
Г. Шилдт САМОУЧИТЕЛЬ e издание переработанное и дополненное Наследование, полиморфизм, инкапсуляция Исключительные ситуации Шаблоны и контейнеры Пространства имен :Динамическая идентификация типа :Библиотека стандартных шаблонов к книге прилагается дискета
Herbert Schildt Teach Yourself C++ Third Edition Osborne McGraw-Hill
Герберт Шилдт Самоучитель C++ 3-е издание Санкт-Петербург "БХВ-Петербург" 2003
УДК 681.3.06 Шилдт Г. Самоучитель C++: Пер. с англ. - 3-е изд. - СПб.: БХВ-Петербург, 2003. - 688 с. ISBN 5-7791-0086-1 Необходимость в переработке и дополнении предыдущего издания книги вызвана в первую очередь выходом в свет долгожданного для программистов всего мира еди-ного международного стандарта по C++. Теперь можно быть уверенным, что уже в ближайшем будущем программы на C++ будут выглядеть и функционировать оди-наково, независимо от того, в какой среде программирования и для какого компи-лятора они написаны. В книге сохранен весь материал двух предыдущих изданий, а также добавлено несколько новых глав и множество новых разделов. Эта книга -наиболее удобное руководство для самостоятельного изучения C++ в соответствии с требованиями нового стандарта и рассчитана на читателей, уже владеющих язы-ком программирования С. Методика подачи материала предполагает строго после-довательное изучение глав, содержащих множество примеров программ, а также упражнений для проверки и повторения пройденного материала. Для программистов и опытных пользователей УДК 681.3.06 Группа подготовки издания: Главный редактор Вадим Сергеев Зав. редакцией Алексеи Жданов Перевод с английского Алексея Жданова Компьютерная верстка: Ольги Сергиенко, Натальи Боговой Корректор Зинаида Дмитриева Дизайн обложки Дмитрия Солнцева, Елены Клыковой Зав. производством Николай Тверских Authorized translation from the English language edition published by Osborne McGraw-Hill. Copyright c (998. All rights reserved. No part of mis book may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording or by any information storage retrieval system, without permission in writing from the Publisher. Russian language edition published by BHV - St. Petersburg. Copyright c 1998. Авторизованный перевод английской редакции, выпушенной Osborne McGraw-Hill. Copyright c 1998. Все права защищены. Никакая часть настоящей книги не может быть воспроизведена или передана в какой бы то пи было форме и какими бы то ни было средствами, будь то электронные или механические, включая фотокопирование и запись на магнитный носитель, если на то нет письменного разрешения издательства. Русская редакция выпушена BHV--Санкт-Петербург. Copyright О 1998. Лицензия ИД NB 02429 от 24.07.00. Подписано в печать 25.06.03. Формат 70*100'/1В. Печать офсетная. Усл. печ. л. 55,5. Доп. тираж 3000 экз. Заказ No 942 "6ХВ-Петербург", 198005, Санкт-Петербург, Измайловский пр., 29. Гигиеническое заключение на продукцию, товар Г* 77.99.02.953.Д.001537.03.02 от 13.03.2002 г. выдано Департаментом ГСЭН Минздрава России. Отпечатано с готовых диапозитивов в Академической типографии "Наука" РАН 199034, Санкт-Петербург, Элиния, 12. ISBN 0-07-882392-7 (англ.) С 1998 by Osborne McGraw-Hill ISBN 5-7791-0086-1 (рус.) О Перевод на русский язык "БХ В-Сан кг-Петербург", 199Й
Введение Если вы уже знаете язык программирования С и хотели бы теперь заняться изучением C++ - эта книга для вас. C++ - это попытка решения разработчиками языка С задач объектно-ориентированного программирования (Object Oriented Programming, OOP). Построенный на твердом фундаменте С, C++ помимо OOP поддерживает множество других полезных инструментов, не жертвуя при этом ни мощью, ни элегантностью, ни гибкостью С. C++ уже стал универсальным языком для программистов всего мира, языком, на котором будет написано следующее поколение высокоэффективного программного обеспечения. Это единствен-ный серьезный язык, который просто обязан знать любой уважающий себя профессиональный программист. C++ был разработан сотрудником научно-исследовательского центра AT&T Bell Laboratories (Нью-Джерси, США) Бьярном Страуструпом в 1979 году. Первоначальное название "С с классами" было изменено на C++ в 1983 году. Начиная с 1980 года C++ претерпел две существенные модернизации: в 1985 и 1990 годах. Последняя, третья модернизация связана с процессом стандарти-зации C++. Несколько лет назад началась работа по созданию единого меж-дународного стандарта по C++. Для этой цели был сформирован объединенный комитет по стандартизации ANSI (American National Standards Institute, Американский национальный институт стандартов) и ISO (International Standards Organization, Международная организация по стандар-там) для языка C++. Первый рабочий проект указанного стандарта был пред-ставлен 25 января 1994 года. Комитет ANSI/ISO по C++ (членом которого являлся автор этой книги Герберт Шилдт) фактически сохранил все основные черты языка, заложенные туда еще Страуструпом и добавил несколько новых инструментов. В своей основе этот первый проект лишь отражал положение, в котором в то время находился язык C++. Вскоре после завершения работы над первым проектом стандарта произошло событие, которое в конечном итоге и привело к его значительному расшире-нию: Александр Степанов создал библиотеку стандартных шаблонов (Standard Template Library, STL). Как вы в дальнейшем узнаете, библиотека стандартных шаблонов устанавливает набор основополагающих процедур, которые можно использовать для обработки данных. Библиотека стандартных шаблонов - это мощный и элегантный инструмент программирования, но одновременно и очень объемный. Сразу после появления первого проекта стандарта комитет ANSI/ISO проголосовал за включение библиотеки стандартных шаблонов в спецификацию C++, что привело к значительному расширению C++ по сравнению с исходным определением этого языка. Несомненно став значи-тельным событием в области программирования, создание библиотеки стан-
Самоучитель C++ дартных шаблонов тем не менее привело к некоторому замедлению процесса стандартизации C++. Справедливости ради надо сказать, что процесс стандартизации C++ отнял значительно больше времени, чем можно было предположить, когда он толь-ко начинался. Тем не менее, он близок к завершению. Комитетом ANSI/ISO разработан и предложен окончательный вариант проекта, который ожидает лишь формального одобрения. С практической точки зрения стандарт для C++-стал наконец реальностью. В появляющихся сейчас компиляторах под-держиваются все новые атрибуты C++. Предлагаемый в книге материал учит языку программирования C++ в соот-ветствии с новым стандартом этого языка (Standard C++). Именно эта версия предложена комитетом ANSI/ISO и именно она в настоящее время принята на вооружение основными производителями компиляторов. Таким образом, можно быть уверенным, что книга, которую вы начали изучать сегодня, завтра окажется столь же полезной. Отличия третьего издания Сейчас вы держите в руках третье издание книги " Самоучитель C++". В ней сохранен весь материал двух предыдущих изданий, а также добавлены две но-вые главы и множество новых разделов. В первой из этих двух глав описыва-ется динамическая идентификация типа (Run-Time Type Identification, RTTI) и новые, недавно разработанные операторы приведения типов. Во второй гла-ве рассказывается о библиотеке стандартных шаблонов. Обе эти темы посвя-щены тем главным инструментам, которые были добавлены в C++ уже после выхода в свет предыдущего издания. В новых разделах других глав вы узнаете о пространствах имен, новом стиле оформления заголовков и современной системе ввода/вывода C++. Таким образом, третье издание книги "Само-учитель C++" оказалось существенно больше предыдущих. Если вы работаете под Windows Если на вашем компьютере установлена операционная система Windows, и вы хотите научиться писать программы для Windows, то C++ --это именно тот язык, который вам нужен. C++ полностью соответствует задачам программи-рования под Windows. Тем не менее ни одна из программ, предлагаемых в книге, не предназначена для работы в этой операционной системе. Наоборот, все эти программы запускаются из командной строки. Причина очевидна: программы для Windows по самой своей сути большие и сложные. По самым скромным подсчетам, для создания даже простейшей программы для Windows требуется от 50 до 70 строк исходного кода. При написании каждой такой программы для демонстрации возможностей языка C++ потребовалось бы написать тысячи строк исходного кода. Проще говоря, Windows - это не са-мая подходящая среда для изучения языка программирования. Тем не менее
Введение 7_ для компиляции предлагаемых в книге программ вполне подходит компиля-тор, работающий в среде Windows, поскольку при выполнении программ он автоматически перейдет в консольный режим. Когда вы в совершенстве овладеете C++, вы несомненно сумеете применить свои знания для программирования под Windows. Действительно, программи-рование на C++ под Windows позволяет пользоваться библиотеками классов, например, библиотекой классов MFC (Microsoft Foundation Classes), что суще-ственно упрощает разработку приложений. Кроме этого, интерфейс любого приложения под Windows достаточно просто создать с помощью таких средств визуального программирования, как Visual C++ 5 или Borland C++ 5. Сердце-виной же любого профессионального приложения является программная реа-лизация его идеи, а отнюдь не пользовательский интерфейс, пусть даже самый что ни на есть дружественный. Другими словами, эта книга учит не созданию пользовательского интерфейса в стиле Windows, а собственно языку программирования C++. Как организована эта книга Эта книга является по-своему уникальной, поскольку учит языку программи-рования C++, опираясь на передовую методику обучения. Эта методика пред-полагает знакомство на каждом занятии с единственной темой, дополненной для лучшего ее усвоения примерами и упражнениями. Такой подход гаранти-рует, что перед тем как перейти к следующей теме, вы полностью освоите предыдущую. Материал книги представлен в определенном порядке. Поэтому изучайте ее последовательно, от главы к главе. В каждой новой главе предполагается, что вы уже освоили материал всех предыдущих. Во всех главах, за исключением главы 1, имеются упражнения для проверки ваших знаний предыдущей главы, упражнения для проверки усвоения материала текущей главы, а также упраж-нения для проверки усвоения всего изученного на данном этапе материала. Ответы на упражнения находятся в приложении В в конце книги. В книге предполагается, что вы уже являетесь состоявшимся программистом на языке С. Проще говоря, гораздо легче учиться программировать на C++, когда уже умеешь это делать на С. Если вы еще не умеете программировать на С, то перед тем как взяться за эту книгу, лучше потратить некоторое время на его изучение. Исходные коды программ Исходные коды представленных в книге программ можно найти либо на при-лагаемой дискете, описание которой находится в приложении D в конце книги, либо в Internet по адресу http://www.osborne.com. Использование этих кодов освободит вас от необходимости набирать их вручную.
Глава 1 Краткий обзор C++ C++ --это расширенная версия языка С. C++ содержит в себе все, что имеется в С, но кроме этого он поддерживает объектно-ориентированное программирование (Object Oriented Programming, OOP). В C++ имеется множество дополнительных возможностей, которые независимо от объект-но-ориентированного программирования делают его просто "лучше, чем С", За небольшими исключениями C++ - это более совершенный С. В то вре-мя как все, что вы знаете о языке С, вполне применимо и к C++, понима-ние его новых свойств все же потребует от вас значительных затрат времени и сил. Однако преимущества программирования на C++ с лихвой окупят ваши усилия. Целью этой главы должно стать знакомство с некоторыми наиболее важны-ми свойствами C++. Как вы знаете, элементы языка программирования не существуют в пустоте, изолированно от других. Они работают вместе в виде полной, законченной конструкции. В C++ эта взаимозависимость еще бо-лее ярко выражена, чем в С. В результате, трудно обсуждать любой аспект C++ без других его аспектов. Поэтому первая глава посвящена предвари-тельному знакомству с теми свойствами C++, без которых сложно понять приводимые здесь примеры программ. Более подробно эти свойства будут изучаться в следующих главах. Эта глава также освещает некоторые отличия между стилями программиро-вания на языках С и C++. В C++ имеется несколько возможностей для написания более гибких, чем в С, программ. Хотя некоторые из этих воз-можностей имеют очень слабую связь с объектно-ориентированным програм-мированием, или вообще ее не имеют, тем не менее, поскольку они содер-жатся в большинстве программ C++, стоит обсудить их в первую очередь. Поскольку C++ был задуман для поддержки объектно-ориентированного программирования, эта глава начинается с описания OOP. Как вы увидите, многие свойства C++ тем или иным образом касаются OOP. Однако важно понимать, что C++ может использоваться для написания не только объект-но-ориентированных программ. То, как вы используете C++, полностью зависит от вас. К моменту написания этой книги процесс стандартизации языка програм-мирования C++ был завершен. По этой причине здесь описываются неко-
10 _ Самоучитель C++ торые важные отличия между обычными для последних нескольких лет вер-сиями C++ и новым стандартом языка (Standard C++). Поскольку настоя-щая книга задумывалась как пособие для обучения языку Standard C++, этот материал особенно важен для тех, кто работает с устаревшим компиля-тором. Помимо знакомства с некоторыми важными свойствами C++, в этой главе описываются существующие отличия между стилями программирования С и C++. Есть несколько аспектов C++, которые позволяют писать программы с большей гибкостью. Некоторые из этих аспектов C++ имеют очень незна-чительную связь с объектно-ориентированным программированием или во-обще ее не имеют, но поскольку они встречаются в большинстве программ на C++, стоит обсудить их в начале книги. Перед тем как начать собственно изложение материала, имеет смысл сде-лать несколько важных замечаний о природе и форме C++. Как правило, программы на C++ внешне напоминают программы на С. Так же, как и на С, программы на C++ начинают выполняться с функции mainQ. Для полу-чения аргументов командной строки C++ использует те же параметры argc, argv, что и С. Хотя C++ определяет их в собственной объектно-ориентированной библиотеке, он также поддерживает все функции стан-дартной библиотеки С. В C++ используются те же управляющие структуры и те же встроенные типы данных, что и в С. Запомните, в этой книге предполагается, что вы уже знаете язык програм-мирования С. Проще говоря, вы уже должны уметь программировать на С перед тем, как начнете изучать программирование на C++. Если вы еще не знаете С, то желательно потратить некоторое время на его изучение. В этой книге предполагается, что вы знаете, как компилировать и выполнять программу, используя компилятор C++. Если это не так, вам следует обра-титься к соответствующему руководству пользователя. (Из-за отличий в ком-пиляторах дать в этой книге инструкцию для работы с любым из них не представляется возможным.) Поскольку программирование лучше изучать в работе, вам настоятельно рекомендуется вводить, компилировать и запус-кать приводимые в книге примеры программ в том порядке, в котором они представлены. 1.1. Что такое объектно-ориентированное программирование? Объектно -ориентире ванное программирование - это новый подход к соз-данию программ. По мере развития вычислительной техники возникали разные методики программирования. На каждом этапе создавался новый подход, который помогал программистам справляться с растущим усложне-
Глава 1. Краткий обзор C++ Г/_ нием программ. Первые программы создавались посредством ключевых пе-реключателей на передней панели компьютера. Очевидно, что такой способ подходит только для очень небольших программ. Затем был изобретен язык ассемблера, который позволял писать более длинные программы. Следую-щий шаг был сделан в 1950 году, когда был создан первый язык высокого уровня Фортран. Используя язык высокого уровня, программисты могли писать программы до нескольких тысяч строк длиной. Для того времени указанный подход к программированию был наиболее перспективным. Однако язык программи-рования, легко понимаемый в коротких программах, когда дело касалось больших программ, становился нечитабельным (и неуправляемым). Избав-ление от таких неструктурированных программ пришло после изобретения в 1960 году языков структурного программирования (structured programming language). К ним относятся языки Алгол, Паскаль и С. Структурное програм-мирование подразумевает точно обозначенные управляющие структуры, программные блоки, отсутствие (или, по крайней мере, минимальное ис-пользование) инструкций GOTO, автономные подпрограммы, в которых поддерживается рекурсия и локальные переменные. Сутью структурного программирования является возможность разбиения программы на состав-ляющие ее элементы. Используя структурное программирование, средний программист может создавать и поддерживать программы свыше 50 000 строк длиной. Хотя структурное программирование, при его использовании для написания умеренно сложных программ, принесло выдающиеся результаты, даже оно оказывалось несостоятельным тогда, когда программа достигала определен-ной длины. Чтобы написать более сложную программу, необходим был но-вый подход к программированию. В итоге были разработаны принципы объектно-ориентированного программирования. OOP аккумулирует лучшие идеи, воплощенные в структурном программировании, и сочетает их с мощными новыми концепциями, которые позволяют оптимально органи-зовывать ваши программы. Объектно-ориентированное программирование позволяет вам разложить проблему на составные части. Каждая составляю-щая становится самостоятельным объектом, содержащим свои собственные коды и данные, которые относятся к этому объекту. В этом случае вся про-цедура в целом упрощается, и программист получает возможность опериро-вать с гораздо большими по объему программами. Все языки OOP, включая C++, основаны на трех основополагающих кон-цепциях, называемых инкапсуляцией, полиморфизмом и наследованием. Рассмотрим эти концепции. Инкапсуляция Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий с этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. В объектно-
12 Самоучитель C++ ориентированном программировании код и данные могут быть объединены вместе; в этом случае говорят, что создается так называемый "черный ящик". Когда коды и данные объединяются таким способом, создается объ-ект (object). Другими словами, объект - это то, что поддерживает инкапсу-ляцию. Внутри объекта коды и данные могут быть закрытыми (private) для этого объекта или открытыми (public). Закрытые коды или данные доступны толь-ко для других частей этого объекта. Таким образом, закрытые коды и данные недоступны для тех частей программы, которые существуют вне объекта. Если коды и данные являются открытыми, то, несмотря на то, что они за-даны внутри объекта, они доступны и для других частей программы. Харак-терной является ситуация, когда открытая часть объекта используется для того, чтобы обеспечить контролируемый интерфейс закрытых элементов объекта. На самом деле объект является переменной определенного пользователем типа. Может показаться странным, что объект, который объединяет коды и данные, можно рассматривать как переменную. Однако применительно к объектно-ориентированному программированию это именно так. Каждый элемент данных такого типа является составной переменной. Полиморфизм Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, ко-торое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно-ориентированному программированию, является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных. Например, для языка С, в котором полиморфизм поддерживается недостаточно, нахожде-ние абсолютной величины числа требует трех различных функций: abs(), labs() и fabs(). Эти функции подсчитывают и возвращают абсолютную вели-чину целых, длинных целых и чисел с плавающей точкой соответственно. В C++ каждая из этих функций может быть названа abs(). (Один из спосо-бов, который позволяет это делать, показан далее в этой главе.) Тип данных, который используется при вызове функции, определяет, какая конкретная версия функции действительно выполняется. Как вы увидите, в C++ можно использовать одно имя функции для множества различных действий. Это называется перегрузкой функций (function overloading). В более общем смысле, концепцией полиморфизма является идея "один ин-терфейс, множество методов". Это означает, что можно создать общий ин-терфейс для группы близких по смыслу действий. Преимуществом поли-морфизма является то, что он помогает снижать сложность программ, раз-решая использование того же интерфейса для задания единого класса действий. Выбор же конкретного действия, в зависимости от ситуации, воз-лагается на компилятор. Вам, как программисту, не нужно делать этот вы-
Глава 1. Краткий обзор C++ 73 бор самому. Нужно только помнить и использовать общий интерфейс. Пример из предыдущего абзаца показывает, как, имея три имени для функ-ции определения абсолютной величины числа вместо одного, обычная зада-ча становится более сложной, чем это действительно необходимо. Полиморфизм может применяться также и к операторам. Фактически во всех языках программирования ограниченно применяется полиморфизм, например, в арифметических операторах. Так, в С, символ + используется для складывания целых, длинных целых, символьных переменных и чисел с плавающей точкой. В этом случае компилятор автоматически определяет, какой тип арифметики требуется. В C++ вы можете применить эту концеп-цию и к другим, заданным вами, типам данных. Такой тип полиморфизма называется перегрузкой операторов (operator overloading), Ключевым в понимании полиморфизма является то, что он позволяет вам манипулировать объектами различной степени сложности путем создания общего для них стандартного интерфейса для реализации похожих действий. Наследование Наследование (inheritance) - это процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать ос-новные свойства другого объекта и добавлять к ним черты, характерные только для него. Наследование является важным, поскольку оно позволяет поддерживать концепцию иерархии классов (hierarchical classification). Приме-нение иерархии классов делает управляемыми большие потоки информа-ции. Например, подумайте об описании жилого дома. Дом - это часть об-щего класса, называемого строением. С другой стороны, строение - это часть более общего класса - конструкции, который является частью еще бо-лее общего класса объектов, который можно назвать созданием рук Челове-ка. В каждом случае порожденный класс наследует все, связанные с родите-лем, качества и добавляет к ним свои собственные определяющие характе-ристики. Без использования иерархии классов, для каждого объекта пришлось бы задать все характеристики, которые бы исчерпывающе его оп-ределяли. Однако при использовании наследования можно описать объект путем определения того общего класса (или классов), к которому он отно-сится, с теми специальными чертами, которые делают объект уникальным. Как вы увидите, наследование играет очень важную роль в OOP. Примерыр 1. Инкапсуляция не является исключительной прерогативой OOP. Некоторая степень инкапсуляция может быть достигнута и в языке С. Например, при применении библиотечной функции, в конечном итоге, имеет место концеп-ция черного ящика, содержимое которого вы не можете изменить (исключая,
14 Самоучитель C++ возможно, злой умысел). Рассмотрим функцию fopen(). Если она использует-ся для открытия файла, то создаются и инициализируются несколько внут-ренних переменных. В той мере, в которой это касается вашей программы, эти переменные скрыты и недоступны. Но, конечно, C++ обеспечивает бо-лее надежную поддержку инкапсуляции. 2. В реальной жизни примеры полиморфизма вполне обычны. Например, рас-смотрим рулевое колесо автомобиля. Оно работает одинаково, независимо от того, используется ли при этом электропривод, механический привод или стандартное ручное управление. Ключевым является то, что интерфейс (рулевое колесо) один и тот же, независимо от того, какой рулевой механизм (метод) применяется на самом деле. 3. Наследование свойств и базовая концепция классов являются основопола-гающими для организации пути познания. Например, сельдерей - член класса овощей, которые являются частью класса растений. В свою очередь, растения являются живыми организмами и так далее. Без иерархии классов систематизация знаний была бы невозможна. Упражнеенниияя] 1. Подумайте о том, какую важную роль в нашей повседневной жизни играют классы и полиморфизм. 1.2. Две версии C++ При написании этой книги C++ находился на перепутье. Как указано в предисловии, в последние годы активно шел процесс стандартизации C++. Целью стандартизации было создание стабильного, ориентированного на будущее языка, которой призван удовлетворить потребности программистов следующего столетия. Результатом стало параллельное существование двух версий C++. Первая, традиционная версия базируется на исходной разра-ботке Бьярна Страуструпа. Это та версия, которая использовалась програм-мистами последние лет десять. Вторая версия, названная Standard C++, соз-дана Бьярном Страуструпом совместно с комитетом по стандартизации (ANSI - American National Standards Institute, Американский национальный институт стандартов; ISO - International Standards Organization, Междуна-родная организация по стандартам). Хотя по сути эти две версии очень по-хожи, Standard C++ содержит несколько усовершенствований, которых нет в традиционном C++. Таким образом Standard C++ по существу является надмножеством традиционного C++. Настоящая книга учит языку Standard C++. Эта версия C++, определенная комитетом по стандартизации ANSI/ISO, должна быть реализована во всех
Глава 1. Краткий обзор C++ 15_ современных компиляторах C++. Примеры программ этой книги отражают современный стиль программирования в соответствии с новыми реалиями языка Standard C++. Это означает актуальность содержания книги не только сегодня, но и в будущем. Проще говоря, Standard C++ - это будущее. А поскольку Standard C++ содержит в себе черты всех ранних версий C++, то, что вы узнаете из этой книги, позволит вам работать в любой программ-ной среде C++. Тем не менее, если вы используете устаревший компилятор, не все приве-денные в книге программы будут вам доступны, поскольку в процессе стан-дартизации комитет ANSI/ISO добавил к языку массу новых черт. По мере определения новых черт, они реализовывались производителями компиля-торов. Естественно, что между добавлением новой возможности языка и ее доступностью в коммерческих компиляторах всегда есть определенный про-межуток времени, а поскольку такие возможности добавлялись в течение нескольких лет, старые компиляторы могут не поддерживать некоторые из них. Это важно, так как два недавних добавления к языку C++ имеют от-ношение ко всем, даже простейшим программам. Если у вас устаревший компилятор, в котором указанные новые возможности недоступны, не рас-страивайтесь, в следующих разделах описано несколько простых способов обойти проблему. Отличия между прежним и современным стилями программирования в чис-ле прочих включают две новые черты: изменился стиль оформления заго-ловков (headers) и появилась инструкция namespace. Чтобы продемонстри-ровать эти отличия, начнем с рассмотрения двух версий простейшей про-граммы на C++. Первая показанная здесь версия написана в прежнем, еще совсем недавно основном стиле программирования. /* Программа на C++ в традиционном стиле */linclude <iostrearn.h> int main() /* программный код */return 0; Поскольку C++ строится на С, этот каркас программы должен быть хорошо вам знаком, тем не менее обратите особое внимание на инструкцию Sinclude Эта инструкция подключает к программе заголовочный файл iostream.li, который обеспечивает поддержку системы ввода/вывода C++. (В C++ этот файл имеет то же самое назначение, что и файл stdio.h в С.) Ниже представлена вторая версия программы, в которой используется со-временный стиль:
16 __ Самоучитель C++ /* Программа на C++ в современном стиле. Здесь используются новое оформление заголовков и ключевое слово namespace * //ttinclude <iostream> using namespace std; int main ( ) { /* программный код */return 0 ; Обратите внимание на две строки в самом начале программы, в которых имеют место изменения. Во-первых, в инструкции ^include после слова iostream отсутствуют символы .h. Во-вторых, в следующей строке задается так называемое пространство имен (namespace). Хотя подробно эти нововве-дения будут рассмотрены позднее, сейчас дадим их краткий обзор. Новые заголовки в программах на C++ Как вам должно быть известно из опыта программирования на С, при ис-пользовании библиотечной функции в программу необходимо включить заголовочный файл. Это делается с помощью инструкции #include. Напри-мер, при написании программ на языке С заголовочным файлом для функ-ций ввода/вывода является файл stdio.h, который включается в программу с помощью следующей инструкции: #include <stdio.h> Здесь stdio.h - это имя файла, который используется функциями вво-да/вывода, и предыдущая инструкция заставляет компилятор включить ука-занный файл в вашу программу. В первые несколько лет после появления C++ в нем использовался тот же стиль оформления заголовков, что и в С. Для совместимости с прежними программами в языке Standard C++ этот стиль по-прежнему поддерживает-ся. Тем не менее при работе с библиотекой Standard C++ в соответствии с новым стилем вместо имен заголовочных файлов указываются стандартные идентификаторы, по которым компилятор находит требуемые файлы. Новые заголовки C++ являются абстракциями, гарантирующими объявление соот-ветствующих прототипов и определений библиотеки языка Standard C++. Поскольку новые заголовки не являются именами файлов, для них не нужно указывать расширение .Ь, а только имя заголовка в угловых скоб-ках. Ниже представлены несколько заголовков, поддерживаемых в языке Standard C++:
Глава 1. Краткий обзор C++ 17_ <iostream> <fstream> <vector> <string> Такие заголовки по-прежнему включаются в программу с помощью инст-рукции ^include. Единственным отличием является то, что новые заголовки совершенно не обязательно являются именами файлов. Поскольку C++ содержит всю библиотеку функций С, по-прежнему под-держивается стандартный стиль оформления заголовочных файлов библио-теки С. Таким образом, такие заголовочные файлы, как stdio.h и ctype.h все еще доступны. Однако Standard C++ также определяет заголовки нового стиля, которые можно указывать вместо этих заголовочных файлов. В соот-ветствии с версией C++ к стандартным заголовкам С просто добавляется префикс с и удаляется расширение .h. Например, заголовок math.h заменя-ется новым заголовком C++ <cmath>, а заголовок string,h - заголовком <cstring>. Хотя в настоящее время при работе с функциями библиотеки С допускается включать в программы заголовочные файлы в соответствии со стилем С, такой подход не одобряется стандартом языка Standard C++. (То есть, он не рекомендуется.) По этой причине во всех имеющихся в книге инструкциях ^include используется новый стиль написания заголовков про-грамм. Если ваш компилятор для функций библиотеки С не поддерживает заголовки нового стиля, просто замените их заголовками в стиле С. Поскольку заголовки нового стиля появились в C++ совсем недавно, во многих и многих прежних программах вы их не найдете. В этих программах в соответствии со стилем С в заголовках указаны имена файлов. Ниже пред-ставлен традиционный способ включения в программу заголовка для функ-ций ввода/вывода: #include <iostream.h> Эта инструкция заставляет компилятор включить в программу заголовочный файл iostream.h. Как правило, в заголовках прежнего стиля вместе с расши-рением .h используется то же имя, что и в соответствующих им новых заго-ловках. Как уже отмечалось, все компиляторы C++ поддерживают заголовки ста-рого стиля. Тем не менее такие заголовки объявлены устаревшими и не ре-комендуются. Именно поэтому в книге вы их больше не встретите. . Несмотря на повсеместное распространение в программах заголовков старо-го стиля, они считаются устаревшими.
Пространства имен Когда вы включаете в программу заголовок нового стиля, содержание этого заголовка оказывается в пространстве имен std. Пространство имен (namespace) - это просто некая объявляемая область, необходимая для то-го, чтобы избежать конфликтов имен идентификаторов. Традиционно имена библиотечных функций и других подобных идентификаторов располагались в глобальном пространстве имен (как, например, в С). Однако содержание заголовков нового стиля помещается в пространстве имен std. Позднее мы рассмотрим пространства имен более подробно. Сейчас же, чтобы простран-ство имен std стало видимым, просто используйте следующую инструкцию: using namespace std; Эта инструкция помещает std в глобальное пространство имен. После того как компилятор обработает эту инструкцию, вы сможете работать с заголов-ками как старого, так и нового стиля. Если вы работаете со старым компилятором Как уже упоминалось, заголовки нового стиля и пространства имен появи-лись в C++ совсем недавно, поэтому эти черты языка могут не поддержи-ваться старыми компиляторами. Если у вас один из таких компиляторов, то при попытке компиляции первых двух строк кода, приводимых в книге примеров программ, вы получите одно или несколько сообщений об ошиб-ках. Обойти эту проблему просто - удалите инструкцию namespace и-ис-пользуйте заголовки старого стиля. То есть замените, например, инструкции #include <iostream> using namespace std; на инструкцию ^include <iostream.h> Это простое действие превратит современную программу в такую же, но в традиционном стиле. Поскольку заголовок старого стиля считывает все свое содержание в глобальное пространство имен, необходимость в инструкции namespace отпадает. И еще одно замечание. Еще в течение нескольких лет вы будете встречать программы, в которых заголовки будут оформлены в старом стиле и не бу-дет инструкций namespace. Ваш компилятор C++ будет прекрасно справ-ляться с такими программами. Тем не менее, что касается новых программ, вам следует использовать современный стиль, поскольку именно он опреде-лен стандартом языка Standard C++. Хотя программы прежнего стиля будут поддерживаться еще многие годы, технически они некорректны.
Глава 1. Краткий обзор C++ 19 Упражнеенниияя] Перед тем как продолжить, попытайтесь откомпилировать представленный выше пример простейшей программы. Хотя эта программа не выполняет ни-каких действий, попытка ее компиляции поможет определить, поддерживает ли ваш компилятор современный синтаксис C++. Если он не принимает заголовки нового стиля и инструкцию namespace, замените их, как только что было описано. Запомните, если ваш компилятор не принимает код но-вого стиля, вам придется сделать изменения в каждой программе этой книги. 1.3. Консольный ввод и вывод в C++ Поскольку C++ - это улучшенный С, все элементы языка С содержатся также и в C++. Это подразумевает, что все программы, написанные на С, по умолчанию являются также и программами на C++. (На самом деле име-ется несколько очень незначительных исключений из этого правила, кото-рые будут рассмотрены позже.) Поэтому можно писать программы на C++, которые будут выглядеть точно так же, как и программы на С. Ошибки не будет, это только будет означать, что вы не смогли использовать все пре-имущества C++. Чтобы по достоинству оценить C++, необходимо писать программы в стиле C++. Вероятно, наиболее своеобразной чертой языка C++, используемой про-граммистами, является подход к вводу и выводу. Хотя такие функции, как printfQ и scanfQ, по-прежнему доступны, C++ обеспечивает иной, лучший способ выполнения этих операций. В C++ ввод/вывод выполняется с ис-пользованием операторов, а не функций ввода/вывода. Оператор вывода -это ", а оператор ввода - ". Как вы знаете, в С эти операторы являются, соответственно, операторами левого и правого сдвига. В C++ они сохраня-ют свое первоначальное значение (левый и правый сдвиг), выполняя при этом еще ввод и вывод. Рассмотрим следующую инструкцию C++: cout " "Эта строка выводится на экран.\п"; Эта инструкция осуществляет вывод строки в заранее определенный поток cout, который автоматически связывается с терминалом, когда программа C++ начинает выполняться. Это напоминает действие функции stdout в языке С. Как и в С, терминал для ввода/вывода в C++ может быть переоп-ределен, но пока будем считать, что используется экран. С помощью оператора вывода " можно вывести данные любого базового типа C++. Например, следующая инструкция осуществляет вывод величины 100.99: cout " 100.99;
20 Самоучитель C++ В общем случае, для вывода на экран терминала используется следующая обычная форма оператора ": cout " выражение; Здесь выражение может быть любым действительным выражением C++, включая другие выражения вывода. Для считывания значения с клавиатуры, используйте оператор ввода ". Например, в этом фрагменте целая величина вводится в num: int num; cin " num; Обратите внимание, что переменной num не предшествует амперсанд &. Как вы знаете, при вводе с использованием функции scanfQ языка С ей должны передаваться адреса переменных. Только тогда они смогут получить значе-ния, вводимые пользователем. В случае использования оператора ввода C++ все происходит иначе. (Смысл этого станет ясен после того, как вы больше узнаете о C++.) В общем случае для ввода значения с клавиатуры, используйте следующую форму оператора ": cin " переменная; Расширенное толкование символов " и " является примером перегрузки операторов. Для правильного использования операторов ввода/вывода в C++ вы должны включить в программу заголовочный файл iostream.h. Он является одним из стандартных заголовочных файлов C++ и поставляется с компилятором. ц Примеры £fr 1. В этой программе выводится строка, два целых числа и одно число с пла-вающей точкой двойной точности: ^include <iostream> using namespace std; int main() int i, j; double d;
Глава 7. Краткий обзор C++ 21 i = 10; j = 20; d = 99.101; cout " "Вот несколько чисел: cout " i; cout " ' '; cout " j; cout " ' '; cout " d; return 0; Ниже представлен результат работы программы: Вот несколько чисел: 10 20 99.101 Если вы работаете с устаревшим компилятором, ему могут оказаться недос-тупными заголовки нового стиля и инструкции namespace, используемые в этой и во всех остальных программах книги. Если это так, замените соответ-ствующие инструкции описанным в предыдущем разделе способом. 2. В одном выражении ввода/вывода можно выводить более одной величины. Например, версия программы, описанной в примере 1, показывает один из эффективных способов программирования инструкций ввода/вывода, ^include <iostream> using namespace std; int main() { int i, j; double d; i = 10; j = 20; d = 99.101; cout " "Вот несколько чисел: "; cout " i " ' ' " j " ' ' " d; return 0;
22 _ Самоучитель C++ Здесь в строке cout " i " ' ' " j " ' ' " d; выводится несколько элементов данных в одном выражении. В общем случае вы можете использовать единственную инструкцию для вывода любого тре-буемого количества элементов данных. Если это кажется неудобным, просто запомните, что оператор вывода " ведет себя так же, как и любой другой оператор С-Н-, и может быть частью произвольно длинного выражения. Обратите внимание, что по мере необходимости следует включать в про-грамму пробелы между элементами данных. Если пробелов не будет, то дан-ные, выводимые на экран, будет неудобно читать. 3. Это программа предлагает пользователю ввести целое число: ^include <iostream> using namespace std; int main{) { int i ; cout " "Введите число : " ; сап " i; cout " "Вот ваше число: " " i " "\n"; return 0; Результат работы программы: Введите число: 100 Вот ваше число: 100 Как видите, введенное пользователем значение действительно оказывается в i. 4. Следующая программа - это программа ввода целого, числа с плавающей точкой и строки символов. В ней для ввода всего перечисленного использу-ется одна инструкция. ^include <iostream> using namespace std; int main(} { int i; float f; char s[80] ; cout " "Введите целое, число с плавающей точкой и строку: cin " i " f " s;
Глава 1. Краткий обзор C++ 23_ cout " "Вот ваши данные: "; cout " i " ' ' " f " ' ' " s; return 0; Как видно из этого примера, можно ввести в одной инструкции ввода столь-ко элементов данных, сколько нужно. Как и в С, различные элементы дан-ных при вводе должны быть отделены друг от друга (пробелами, табуляция-ми или символами новой строки). При считывании строки ввод будет остановлен после считывания первого разделительного символа. Например, если вы введете: 10 100.12 Это проверка то на экран будет выведено: 10 100.12 Это Так происходит потому, что считывание строки прекращается при вводе пробела после слова Это. Остаток строки остается в буфере ввода, в ожида-нии следующей операции ввода. (Это похоже на ввод строки с использова-нием функции scanfQ в формате %s.) 5. По умолчанию при использовании оператора " буферизуется весь ввод строки. Это означает, что до тех пор, пока вы не нажмете клавишу <Enter>, информация не будет передана в вашу программу. (В языке С функция scanf() также буферизует ввод строки, поэтому такой стиль ввода не должен быть для вас чем-то новым.) Для исследования построчно-буферизованного ввода рассмотрим следующую программу: ttinclude <iostream> using namespace std; int main() { char ch; cout " "Вводите символы, для окончания ввода введите х. \п"; do { cout " ":"; с in " ch; } while (ch !='x'); return 0; Когда вы протестируете эту программу, то убедитесь, что для считывания каждого очередного символа необходимо нажимать клавишу <Enter>.
24 Самоучитель C++ 1. Напишите программу для ввода количества отработанных персоналом часов и размера почасовой оплаты каждого. Затем выведите суммарную зарплату персонала. (Удостоверьтесь в правильности ввода.) 2. Напишите программу для преобразования футов в дюймы. Организуйте ввод числа футов и вывод на экран соответствующего числа дюймов. Повторяйте эту процедуру до тех пор, пока пользователь не введет 0 в качестве числа футов. 3. Ниже приведена программа на языке С. Перепишите ее в соответствии со стилем ввода/вывода C++. /* Преобразуйте эту программу на С в соответствии со стилем программирования C++. Эта программа подсчитывает наименьшее общее кратное Vfinclude <stdio.h> int main(void) int a, b, d, min; printf ("Введите два числа:"}; scanf("%d%d", sa, sb); min = a > b ? b: a; for (d=2; d<min; d++) if (((a%d)==0) s& ((b%d)-0)) break; if (d==min) { printf("Нет общего кратного\п"); return 0; printf("Наименьшее общее кратное равно %d\n", d) ; return 0; } 1.4. Комментарии в C++ В C++ комментарии в программу можно включать двумя различными спо-собами. Первый способ - это использование стандартного механизма, та-кого же, как в С, т. е. комментарий начинается с /* и оканчивается */: Как и в С, в C++ этот тип комментария не может быть вложенным. Вторым способом, которым вы можете писать комментарии в программах C++, является однострочный комментарий. Однострочный комментарий на-чинается с символов //и заканчивается концом строки. Другого символа, помимо физического конца строки (такого, как возврат каретки/перевод строки), в однострочном комментарии не используется.
Глава ^Краткий обзор C++ £5_ Обычно программисты C++ используют стиль С для многострочных ком-ментариев, а для коротких замечаний используют однострочные коммента-рии в соответствии со стилем C++. 1. Программа, в которой есть стили комментариев как С, так и C++: /* Этот комментарий в стиле С . Данная программа определяет четность целого */^include <iostream> using namespace std; int main ( } t int num; //это однострочный комментарий C++ //чтение числа cout " "Введите проверяемое число:"; cin " num; //проверка на четность if ( (num%2)==0) cout " "Число четное\п"; else cout " "Число нечетное\п"; return 0 ; 2. Хотя многострочные комментарии не могут быть вложенными, одностроч-ный комментарий в стиле C++ можно вкладывать внутрь многострочного комментария. Например, это совершенно правильный фрагмент: /* Это многострочный комментарий, внутрь которого //вложен однострочный комментарий. Это окончание многострочного комментария. */Тот факт, что однострочный комментарий может быть вложен в многостроч-ный, дает возможность при отладке "помечать" некоторые строки программы. 1. В качестве эксперимента проверьте, имеет ли комментарий, в котором коммен-тарий стиля С вложен внутрь однострочного комментария C++, право на жизнь: //Это странный /*способ делать комментарии'/2. Добавьте комментарии к ответам на упражнения в разделе 1.3.
26 __ _ __ Самоучитель C++ 1.5. Классы. Первое знакомство Вероятно, одним из наиболее важных понятий C++ является класс. Класс - это механизм для создания объектов. В этом смысле класс лежит в основе многих свойств C++. Хотя более детально понятие класса раскрывается в сле-дующих главах, оно столь фундаментально для программирования на C++, что краткий обзор здесь необходим. Класс объявляется с помощью ключевого слова class. Синтаксис объявления класса похож на синтаксис объявления структуры. Здесь показана основная форма: class имя_класса. { закрытие функции л переменные класса public: открытые функции и переменные класса } список объектов; В объявлении класса список_объекпгов не обязателен. Как и в случае со структурой, вы можете объявлять объекты класса позже, по мере необходи-мости. Хотя имя_класса также не обязательно, с точки зрения практики оно необходимо. Доводом в пользу этого является то, что имя_класса становится именем нового типа данных, которое используется для объявления объектов класса. Функции и переменные, объявленные внутри объявления класса, становят-ся, как говорят, членами (members) этого класса. По умолчанию все функции и переменные, объявленные в классе, становятся закрытыми для класса. Это означает, что они доступны только для других членов того же класса. Для объявления открытых членов класса используется ключевое слово public, за которым следует двоеточие. Все функции и переменные, объявленные после слова public, доступны как для других членов класса, так и для любой другой части программы, в которой находится этот класс. Ниже приводится простое объявление класса: class myclass { //закрытый элемент класса int a ; public: void set_a(int num) int get_a ( ) ; Этот класс имеет одну закрытую переменную а, и две открытые функции, set_a() и get_a(). Обратите внимание, что прототипы функций объявляются
Глава 1. Краткий обзор C++ _ 27 внутри класса. Функции, которые объявляются внутри класса, называются функциями-членами (member functions). Поскольку а является закрытой переменной класса, она недоступна для лю-бой функции вне myclass. Однако поскольку set_a() и get_a() являются чле-нами myclass, они имеют доступ к а. Более того, set_a() и get__a(), являясь открытыми членами myclass, могут вызываться из любой части программы, использующей myclass. Хотя функции set_a() и get_a() и объявлены в myclass, они еще не опреде-лены. Для определения функции-члена вы должны связать имя класса, ча-стью которого является функция-член, с именем функции. Это достигается путем написания имени функции вслед за именем класса с двумя двое-точиями. Два двоеточия называются оператором расширения области видимо-сти (scope resolution operator). Например, далее показан способ определения функций-членов set_a() и get_a(): void myclass : : set_a (int num) { a=num; }int myclass: :get_a (} { return a; } Отметим, что и set_a() и get_a() имеют доступ к переменной а, которая для myclass является закрытой. Как уже говорилось, поскольку set_a() и get_a() являются членами myclass, они могут напрямую оперировать с его закрытыми данными. При определении функции-члена пользуйтесь следующей основной формой: Тип возвр значения имя класса: : имя функция (список параметров) { . . .//тело функьщи Здесь имя_класса - это имя того класса, которому принадлежит определяемая функция. Объявление класса myclass не задает ни одного объекта типа myclass, оно определяет только тип объекта, который будет создан при его фактическом объявлении. Чтобы создать объект, используйте имя класса, как специфика-тор типа данных. Например, в этой строке объявляются два объекта типа myclass: myclass obi, ob2; //это объекты типа myclass
28 Самоучитель C++ Объявление класса является логической абстракцией, которая задает новый тип объекта. Объявление же объекта создает физическую сущность объекта такого типа. То есть, объект занимает память, а задание типа нет, После того как объект класса создан, можно обращаться к открытым членам класса, используя оператор точка (.), аналогично тому, как осуществляется доступ к членам структуры. Предположим, что ранее объекты были объявле-ны, тогда следующие инструкции вызывают set_a() для объектов оЫ и оЬ2: obl.set_a(10); //установка версии а объекта оЫ равной 10 оЬ2.set_a(99); //установка версии а объекта оЬ2 равной 99 Как видно из комментариев, эти инструкции устанавливают значение пере-менной а объекта оЫ равной 10 и значение переменной а объекта оЬ2 рав-ной 99. Каждый объект содержит собственную копию всех данных, объяв-ленных в классе. Это значит, что а в obi отлично от а в оЬ2. Каждый объект класса имеет собственную копию всех переменных, объяв-ленных внутри класса. 1. В качестве первого простого примера, рассмотрим программу, в которой ис-пользуется myclass, описанный в тексте, для задания значений а для оЫ и оЬ2 и вывода на экран этих значений для каждого объекта: #include <iostream> using namespace std; class myclass { //закрытая часть myclass int a; public: void set_a{int mini); int get_a ( ) ; void myclass: :set_a(int num} a=num;
Глава 1. Краткий обзор C++ _ 29 int myclass: :get_a О { return a; }int main { } { myclass obi, ob2; obl.set_a(10) ; ob2.set_a(99) ; cout " obl.get_a() " "\n"; cout " ob2.get_a() " "\n"; return 0; }Как и следовало ожидать, программа выводит на экран величины 10 и 99. 2. В предыдущем примере переменная а в myclass является закрытой. Это озна-чает, что она непосредственно доступна только для членов myclass. (Это один из доводов в пользу существования открытой функции get_a().) Если вы по-пытаетесь обратиться к закрытому члену класса из той части вашей програм-мы, которая не является членом этого класса, то результатом будет ошибка при компиляции. Например, предположим, что myclass задан так, как пока-зано в предыдущем примере, тогда компиляция функции mainQ вызовет ошибку: //Этот фрагмент содержит ошибку #include <iostream> using namespace std; int main() { myclass obi, ob2; obi. a = 10; //ОШИБКА! к закрытому члену нет оЬ2.а =99; //доступа для функции - не члена cout " obl.get_a() " "\n"; cout " ob2.get_a() " "\n"; return 0; 3. Точно так же, как открытые функции-члены, могут существовать и открытые переменные-члены. Например, если бы а была объявлена в открытой секции myclass, тогда к ней, как показано ниже, можно было бы обратиться из лю-бой части программы:
30 _ Самоучитель C++ ^include <iostream> using namespace std; class myclass { public: //теперь а открыта int a; //и здесь не нужны функции set__a() и get_a() int main{) { myclass obi, оЬ2; //здесь есть явный доступ к а оЫ.а = 10; оЬ2.а = 99; cout " оЫ.а " "\п"; cout " оЬ2.а " "\п"; return 0; В этом примере, поскольку а объявлена открытым членом myclass, к ней имеется явный доступ из main(). Обратите внимание, как оператор точка (.) используется для доступа к а. Обычно, когда вы вызываете функцию-член, или осуществляете доступ к переменной-члену не из класса, которому они принадлежат, за именем объекта должен следовать оператор точка (.), а за ним имя члена. Это необходимо для исчерпывающего определения того, с членом какого объекта вы имеете дело. 4. Чтобы по достоинству оценить возможности объектов, рассмотрим более практичный пример. В этой программе создается класс stack, реализующий стек, который можно использовать для хранения символов: #include <iostream> using namespace std; ^define SIZE 10 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека public : void init(); //инициализация стека void push(char ch) ; //помещает в стек символ char pop (); //выталкивает из стека символ
Глава 1, Краткий обзор C++ 31_ II Инициализация стека void stack::init() tos=0; \ I/Помещение символа в стек void stack::push(char ch} if (tos=SIZE) { cout " "Стек полон"; return; Jstckftos] = ch; tOS++; '//Выталкивание символа из стека char stack::pop() if (tos==Q) { cout " "Стек пуст"; return 0; //возврат нуля при пустом стеке }tos-; return stck[tos]; int main(} stack si, s2; //создание двух стеков int i; //инициализация стеков si.init (); s2.init () ; si.push ('a'); s2.push f'x'}; si.push('b'); s2.push('y1); si.push ('c'); s2.push ('z1); for(i=0;i<3;i++) cout " "символ из si:" " sl.popO " "\n"; for(i=0;i<3; i++) cout " "символ из s2:" " s2.pop() " "\n"; return 0; 1
32 Самоучитель C++ Эта программа выводит на экран следующее: символ из si символ из si символ из si символ из з2: символ из s2: символ из s2: х Давайте теперь детально проанализируем программу. Класс stack содержит две закрытые переменные: stck и tos. Массив stck содержит символы, факти-чески помещаемые в стек, a tos содержит индекс вершины стека. Открытыми функциями стека являются init(), pushQ и рор(), которые, соответственно, инициализируют стек, помещают символ в стек и выталкивают его из стека. Внутри функции пlain() создаются два стека, si и s2, и по три символа по-мещаются в каждый из них. Важно понимать, что один объект (стек) не за-висит от другого. Поэтому у символов в si нет способа влиять на символы в s2. Каждый объект содержит свою собственную копию stck и tos. Это фунда-ментальная для понимания объектов концепция. Хотя все объекты класса имеют общие функции-члены, каждый объект создает и поддерживает свои собственные данные. 1. Введите и выполните программы, приведенные в этом разделе, если это еще не сделано. 2. Создайте класс card, который поддерживает каталог библиотечных карточек. Этот класс должен хранить заглавие книги, имя автора и выданное на руки число экземпляров книги. Заглавие и имя автора храните в виде строки сим-волов, а количество экземпляров - в виде целого числа. Используйте откры-тую функцию-член store() для запоминания информации о книгах и откры-тую функцию-член show() для вывода информации на экран. В функцию main() включите краткую демонстрацию работы созданного класса. 3. Создайте класс с циклической очередью целых. Сделайте очередь длиной 100 целых. В функцию main() включите краткую демонстрацию ее работы. 1.6. Некоторые отличия языков С и C++ У языка C++ есть ряд небольших отличий от С. Хотя каждое из этих отли-чий само по себе незначительно, вместе они достаточно распространены в программах C++. Поэтому перед тем как двинуться дальше, обсудим эти отличия. а Во-первых, если в С функция не имеет параметров, ее прототип содер-жит слово void в списке параметров функции. Например, если в С функ-
Глава 1. Краткий обзор C++ 33_ ция fl() не имеет параметров (и возвращает char), ее прототип будет вы-глядеть следующим образом: . char fI(void); В C++ слово void не обязательно. Поэтому в C++ прототип обычно пи-шется так: char f1() ; C++ отличается от С способом задания пустого списка параметров. Если бы предыдущий прототип имел место в программе С, то это бы означало, что о параметрах функции сказать ничего нельзя. А в C++ это означает, что у функции нет параметров. Поэтому в предыдущих примерах для ис-черпывающего обозначения пустого списка параметров слово void не ис-пользовалось. (Использование void для обозначения пустого списка па-раметров не ошибочно, скорее, оно излишне. Поскольку большинство программистов C++ гонятся за эффективностью с почти религиозным рвением, вы никогда не увидите void в таких случаях.) Запомните, в C++ следующие два объявления эквивалентны: int f l ( ) ; int f1(void); а Другим небольшим отличием между С и C++ является то, что в про-граммах C++ все функции должны иметь прототипы. Запомните, в С прототипы функций рекомендуются, но технически они не обязательны, а в C++ прототипы необходимы. Как показывают примеры из преды-дущего раздела, содержащийся в классе прототип функции-члена дейст-вует так же, как ее обычный прототип, и никакого иного прототипа не требуется. Q Третьим отличием между С и C++ является то, что если в C++ функция имеет отличный от void тип возвращаемого значения, то инструкция return внутри этой функции должна содержать значение данного типа. В языке С функции с отличным от void типом возвращаемого значения фактически не требуется возвращать что-либо. Если значения нет, то функция возвращает неопределенное значение. В С, если тип возвращаемого функцией значения явно не задан, функция по умолчанию возвращает значение целого типа. В C++ такого правила нет. Следовательно, необходимо явно объявлять тип возвращаемого зна-чения всех функций. а Следующим отличием между С и C++ является то, что в программах C++ вы можете выбирать место для объявления локальных переменных. В С локальные переменные могут объявляться только в начале блока, пе-ред любой инструкцией "действия". В C++ локальные переменные могут
34 Самоучитель C++ объявляться в любом месте программы. Одним из преимуществ такого подхода является то, что локальные переменные для предотвращения не-желательных побочных эффектов можно объявлять рядом с местом их первого использования. а И последнее. Для хранения значений булева типа (истина или ложь) в C++ определен тип данных boot. В C++ также определены ключевые слова true и false - единственные значения, которыми могут быть дан-ные типа boot. В C++ результатом выполнения операторов отношения и логических операторов являются значения типа bool, и направление раз-вития любой условной инструкции должно определяться относительно значения типа bool. Хотя такое отличие от С на первый взгляд кажется значительным, на самом деле это не так. Фактически оно совершенно прозрачно и вот почему: как вы знаете, в С любое ненулевое значение является истинным, а нулевое - ложным. В C++ это положение сохра-няется, поскольку при использовании таких значений в булевом выраже-нии ненулевое значение автоматически преобразуется в true, а нулевое - в false. Правильно и обратное: true преобразуется в 1, a false в 0, если значение типа bool оказывается в целом выражении. Добавление в C++ данных типа bool усиливает контроль типа и дает возможность различать данные булева и целого типов. Естественно, что использование данных булева типа не обязательно, скорее оно просто удобно. ПримерыР 1. В программах С, при отсутствии в командной строке аргументов, функция main() обычно объявляется так: int main(void) Однако в C++ такое использование слова void избыточно и необязательно. 2. Эта короткая программа C++ не будет компилироваться, поскольку у функ-ции sum() нет прототипа: //Эта программа не будет компилироваться ^include <iostream> using namespace std; int main() ( int a,b,c; cout " "Введите два числа: "; cin " a " b; c=sum(a, b); cout " "Сумма равна:" " с;
Глава 1. Краткий обзор C++ _ 35 return 0; //Этой функции необходим прототип sum{int a, int b) { return a+b; 3. Эта короткая программа иллюстрирует тот факт, что локальные переменные можно объявить в любом месте блока: ttinclude <iostrearn> using namespace std; int main ( ) { int i; //локальная переменная, объявленная в начале блока cout " "Введите число:"; cin " i; //расчет факториала int j, fact=l; //переменные, объявленные перед инструкциями //действия for (j=i; j>=l; j - ) fact=fact * j ; cout " "Факториал равен:" " fact; return 0; Хотя объявление переменных j и fact рядом с местом их первого использова-ния в этом коротком примере и не слишком впечатляет, в больших функци-ях такая возможность может обеспечить программе ясность и предотвратить нежелательные побочные эффекты. 4. В следующей Программе создается булева переменная outcome и ей присваи-вается значение false. Затем эта переменная используется в инструкции if. ^include <iostream> using namespace std; int main() bool outcome; outcome = false; if(outcome) cout " "истина"; else cout " "ложь";
36 _ Самоучитель C++ return 0; Как и следовало ожидать, в результате выполнения программы на экране появляется слово ложь. Упражнеенниияя) 1. Следующая программа не будет компилироваться в качестве программы C++. Почему? //В этой программе есть ошибка #include <iostream> using namespace std; int main() f t ) ; return 0; i) void f () cout " "Программа работать не будет"; 2. Попытайтесь объявлять локальные переменные в различных местах програм-мы C++. Попытайтесь проделать то же с программой С, обращая внимание на то, какие объявления вызовут сообщения об ошибках. 1.7. Введение в перегрузку функций После классов, вероятно, следующей важной и необычной возможностью C++ является перегрузка функций (function overloading). Перегрузка функ-ций не только обеспечивает механизм, посредством которого в C++ дос-тигается один из типов полиморфизма, она также формирует то ядро, во-круг которого развивается вся среда программирования на C+ + . Ввиду важности темы в данном разделе предлагается только предварительное знакомство с перегрузкой функций, которой посвящена целая глава этой книги. В C++ две или более функции могут иметь одно и то же имя, отличаясь либо типом, либо числом своих аргументов, либо и тем и другим. Если две или более функции ;::.ао! ,;д™мпковос имя. говорят, что они перегружены.
Глава 7. Краткий обзор C++ _ 37 Перегруженные функции позволяют упростить программы, допуская об-ращение к одному имени для выполнения близких по смыслу действий. Перегрузить функцию очень легко: просто объявите и определите все тре-буемые варианты. Компилятор автоматически выберет правильный вари-ант вызова на основании числа и/или типа используемых в функции аргу-ментов. В C++ можно также перегружать и операторы. Однако для того чтобы понять перегрузку операторов, необходимо больше узнать о C++. Примеры Одно из основных применений перегрузки функций - это достижение по-лиморфизма при компиляции программ, который воплощает в себе филосо-фию - один интерфейс, множество методов. Как вы знаете, при программи-ровании на С необходимо иметь определенное число близких по назначению функций, отличающихся только типом данных, с которыми они работают. Классический пример этой ситуации дает набор библиотечных функций С. Как ранее упоминалось в этой главе, библиотека содержит функции abs(), labs() и fabs(), которые возвращают абсолютное значение, соответственно, целого, длинного целого и числа с плавающей точкой. Однако из-за того, что для трех типов данных требуется три типа функции, ситуация выглядит более сложной, чем это необходимо. Во всех трех случаях возвращается аб-солютная величина числа, отличие только в типе данных. В то же время, программируя на C++, вы можете исправить эту ситуацию путем перегрузки одного имени для трех типов данных так, как показано в следующем примере: #include <iostream> using namespace std; //Перегрузка abs() тремя способами int abs(int n); long abs(long n); double abs(double n); int main() cout " "Абсолютная величина -10:" " abs (-10) " "\n/n"; cout " "Абсолютная величина -10L:" " abs (-10L) " "\n/n"; cout " "Абсолютная величина -10.01:" " abs (-10. 01) " "\n/n"; return 0;
38 _ Самоучитель C++ II abs {) для целых int abs (int n) { cout " "В целом abs()\n"; return n<0 ? -n: n; }//abs() для длинных целых long abs (long n) { cout " "В длинном целом abs()\n"; return n<0 ? -n: n; }//abs() для вещественных двойной точности double abs (double n} { cout " "В вещественном abs() двойной точности \n"; return n<0 ? -n: n; Как можно заметить, в программе задано три функции abs(), своя для каж-дого типа данных. Внутри main() функция abs() вызывается с тремя аргумен-тами разных типов. Компилятор автоматически вызывает правильную версию abs(), основываясь на используемом в аргументе типе данных. В результате работы программы на экран выводится следующее: В целом abs ( ) Абсолютная величина -10: 10 В длинном целом abs ( ) Абсолютная величина -10L: 10 В вещественном abs() двойной точности Абсолютная величина -10.01: 10.01 Хотя этот пример достаточно прост, ценность перегрузки функций он все же демонстрирует. Поскольку одно имя используется для описания основного на-бора действий, искусственная сложность, вызванная тремя слабо различающи-мися именами, в данном случае abs(), labsQ и fabs(), устраняется. Теперь вам необходимо помнить только одно имя - то, которое описывает общее дейст-вие. На компилятор возлагается задача выбора соответствующей конкретной версии вызываемой функции (а значит и метода обработки данных). Это имеет лавинообразный эффект в вопросе снижения сложности программ. В данном случае, благодаря использованию полиморфизма, из трех имен получилось одно. Хотя использование полиморфизма в этом примере довольно тривиально, вы, должно быть, уже поняли, что для очень больших программ подход "один интерфейс, множество методов" может быть очень эффективным.
Глава 1. Краткий обзор C++ 39_ 2. Ниже приведен другой пример перегрузки функций. В этом случае функция date() перегружается для получения даты либо в виде строки, либо в виде трех целых. В обоих этих случаях функция выводит на экран переданные ей данные. ttinclude <iostream> using namespace std; void date(char *date); //дата в виде строки void date(int month, int day, int year); //дата в виде чисел int main{) { date("8/23/99"); date( 8, 23, 99); return 0; //Дата в виде строки void date (char *date) { cout " "Дата:" " date " "\n"; }//Дата в виде целых void date (int month, int day, int year) { cout " "Дата:" " month " "/"; cout " day " "/":" year " "\n"; Этот пример показывает, как перегрузка функций может обеспечить для функции более понятный интерфейс. Поскольку дату очень естественно представлять либо в виде строки, либо в виде трех целых чисел, содержащих месяц, день и год, нужно просто выбрать наиболее подходящую версию в со-ответствии с ситуацией. 3. До сих пор мы рассматривали перегруженные функции, отличающиеся ти-пом своих аргументов. Однако перегруженные функции могут также отли-чаться и числом аргументов, как показано в приведенном ниже примере: ttinclude <iostream> using namespace std; void fl(int a); void fl(int a, int b); int main{) fl(10, 20);
40 return 0; } void fl(int a) cout " "B fl(int a) \n"; void f l f i n t a, int b) cout " "B fl(int a, int b) \n' 4. Важно понимать, что тип возвращаемого значения сам по себе еще не явля-ется достаточным отличием для перегрузки функции. Если две функции от-личаются только типом возвращаемых данных, компилятор не всегда сможет выбрать нужную. Например, следующий фрагмент неправилен, поскольку в нем имеет место избыточность: //Это все неправильно и не будет компилироваться int fl{int a); double fl{int а); f1 (10); //какую функцию выбрать компилятору??? Как написано в комментарии, у компилятора нет способа выяснить, какую версию fl{) вызвать. Упражнения 1. Создайте функцию sroot(), которая возвращает квадратный корень своего аргумента. Перегрузите sroot() тремя способами: чтобы получить квадратный корень целого, длинного целого и числа с плавающей точкой двойной точ-ности. (Для непосредственного подсчета квадратного корня вы можете ис-пользовать стандартную библиотечную функцию sqrt().) 2. Стандартная библиотека C++ содержит три функции: double atof (const char int atoi (const char *s) long atol(const char *s) s) ; Эти функции возвращают численное значение, содержащееся в строке, на которую указывает s. Заметьте, что atof() возвращает double, atoi возвращает int и atoi возвращает long. Почему нельзя перегрузить эти функции? 3. Создайте функцию min(), которая возвращает наименьший из двух числен-ных аргументов, используемых при вызове функции. Перегрузите функцию
Глава 1, Краткий обзор C++ 41 min() так, чтобы она воспринимала в качестве аргументов символы, целые и действительные двойной точности. 4. Создайте функцию sleepQ, приостанавливающую работу компьютера на столько секунд, сколько указано в аргументе функции. Перегрузите sleep() так, чтобы она могла вызываться или с целым, или со строкой, задающей целое. Например, оба этих вызова должны заставить компьютер остановиться на 10 секунд: sleep (10); sleepf'lO") ; Продемонстрируйте работу ваших функций, включив их в короткую про-грамму. (Почувствуйте удобство их применения для задания паузы в работе компьютера.) 1.8. Ключевые слова C++ В C++ поддерживаются все ключевые слова С и кроме этого еще 30 ключе-вых слов, которые относятся только к языку C++. Все определенные для C++ ключевые слова представлены в табл. 1.1. Кроме них в ранних версиях C++ было определено ключевое слово overload, которое сейчас считается устаревшим. Таблица 1.1. Ключевые слова C++ asm auto bool break case catch char class const const_cast continue default delete do double dynamic_cast else enum explicit extern false float torfriend goto if inline int long mutable namespace new operator private protected public register reinterpret_cast return short signed sizeof static static_cast struct switch template this throw true try typedef typeid typename union unsigned using virtual void volatile wchar_t while Проверка усвоения материала главы Попытайтесь выполнить следующие упражнения и ответить на вопросы. 1. Дайте краткие определения полиморфизма, инкапсуляции и наследования. 2. Как включить в программу C++ комментарии?
42 _ Самоучитель C++ 3. Напишите программу, использующую стиль ввода/вывода C++, для вво-да двух целых с клавиатуры и затем вывода на экран результата возведе-ния первого в степень второго. (Например, пользователь вводит 2 и 4, тогда результатом будет 24, или 16.) 4. Создайте функцию rev_str() для изменения порядка следования символов строки на обратный. Перегрузите rev_str() так, чтобы она могла вызы-ваться с одним или двумя символьными строками. Если функция вызы-вается с одной строкой, то операция должна осуществляться с ней. Если она вызывается с двумя строками, то результирующая строка должна ока-заться во втором аргументе. Например: char sl[80], s2[80]; strcpyfsl, "привет") ; rev_str(sl, s2}; //измененная строка оказывается в s2, //si не меняется rev_str{sl); //измененная строка возвращается в si 5. Дана следующая программа, написанная в соответствии с новым стилем программирования на C++. Покажите, как превратить ее в программу старого стиля. ^include <iostream> using namespace std; int f (int a} ; int main{) { cout " f (10) ; return 0; }int f(int a) { return a * 3.1416; 6. Что представляют собой данные типа bool?
Глава 2 Введение в классы В этой главе вводятся понятия классов и объектов. В следующих нескольких важнейших разделах фактически описаны почти все аспекты программиро-вания на C++, поэтому советуем вам читать повнимательнее. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Напишите программу, использующую стиль ввода/вывода C++ для ввода строки и затем вывода на экран ее длины. 2. Создайте класс, который содержит информацию об имени и адресе. Хра-ните всю эту информацию в символьных строках закрытой части класса. Включите в класс открытую функцию для запоминания имени и адреса. Также включите открытую функцию, которая выводит эти имя и адрес на экран. (Назовите эти функции store() и display().) 3. Создайте перегружаемую функцию rotate(), которая циклически сдвигает влево свой аргумент и возвращает результат. Перегрузите ее так, чтобы она работала с целыми (mt) и длинными целыми (long). (Сдвиг по кольцу аналогичен обычному сдвигу, за исключением того, что выдвигаемый с одного конца слова бит появляется на другом его конце.) 4. Что неправильно в следующем фрагменте? ^include <iostream> using namespace std; class myclass { int i; public:
44 Самоучитель C++ int main () { myclass ob; ob.i = 10; -2.1. Конструкторы и деструкторы Если вы писали очень длинные программы, то знаете, что в некоторых час-тях программы обычно требуется инициализация. Необходимость в инициа-лизации еще более часто проявляется при работе с объектами. Действительно, если обратиться к реальным проблемам, то, фактически, для каждого создаваемого вами объекта требуется какого-то вида инициализа-ция. Для разрешения этой проблемы в C++ имеется функция-конструктор (constructor function), включаемая в описание класса. Конструктор класса вы-зывается всякий раз при создании объекта этого класса. Таким образом, лю-бая необходимая объекту инициализация при наличии конструктора выполняется автоматически. Конструктор имеет то же имя, что и класс, частью которого он является, и не имеет возвращаемого значения. Например, ниже представлен небольшой класс с конструктором: ttinclude <iostream> using namespace std; class myclass { int a ; public: myclass (); //конструктор void show() ; myclass : :myclass ( ) { cout " "В конструкторе\п"; a-10; ) void myclass :: show () { cout " a;
Глава 2. Введение в классы _ 45 int main ( ) { myclass ob; ob. show)) ; return 0; В этом простом примере значение а инициализируется конструктором myclass(). Конструктор вызывается тогда, когда создается объект ob. Объект, в свою очередь, создается при выполнении инструкции объявления объекта. Важ-но понимать, что в C++ инструкция объявления переменной янляется "инструкцией действия". При программировании на С инструкции объявления переменных понимаются просто как создание переменных. Однако в C++, по-скольку объект может иметь конструктор, инструкция объявления переменной может вызывать выполнение записанных в конструкторе действий. Обратите внимание, как определяется конструктор myclassQ. Как уже гово-рилось, он не имеет возвращаемого значения. В соответствии с формальны-ми правилами синтаксиса C++ конструктор не должен иметь возвращаемого значения. Для глобальных объектов конструктор объекта вызывается тогда, когда начи-нается выполнение программы. Для локальных объектов конструктор вызыва-ется всякий раз при выполнении инструкции объявления переменной. Функцией, обратной конструктору, является деструктор (destructor). Эта функция вызывается при удалении объекта. Обычно при работе с объектом в момент его удаления должны выполняться некоторые действия. Напри-мер, при создании объекта для него выделяется память, которую необходи-мо освободить при его удалении. Имя деструктора совпадает с именем класса, но с символом ~ (тильда) в начале. Пример класса с деструктором: ^include <iostream> using namespace std; class myclass ( int a; public: myclass (); //конструктор -myclass (); //деструктор void show() ; , .' myclass : :myclass ( ) { cout " "Содержимое конструктора\п"; a = 10;
46 Самоучитель C++ myclass::~myclass ( ) { cout " "Удаление. . Лп"; } void myclass::show() { cout " a " "\n"; } int main() myclass ob; ob.show (); return 0; } Деструктор класса вызывается при удалении объекта. Локальные объекты удаляются тогда, когда они выходят из области видимости. Глобальные объ-екты удаляются при завершении программы. Адреса конструктора и деструктора получить невозможно. Фактически как конструктор, так и деструктор могут выполнить любой тип опе-рации. Тем не менее считается, что код внутри этих функций не должен делать ничего, не имеющего отношения к инициализации или возвращению объектов в исходное состояние. Например, конструктор в предшествующем примере мог бы рассчитать число pi с точностью до 100 знаков после запятой. Однако при-менение конструктора или деструктора для действий, прямо не связанных с инициализацией, является очень плохим стилем программирования и его сле-дует избегать. 1. Вспомните, что в созданном в главе 1 классе stack для установки переменной индекса стека требовалась функция инициализации. Это именно тот тип действия, для выполнения которого и придуман конструктор. Здесь пред-ставлена улучшенная версия класса stack, где для автоматической инициали-зации объекта стека при его создании используется конструктор: ^include <iostream> using namespace std; ^define SIZE 10
Глава 2. Введение в классы 47 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека public: stack(); //конструктор void push(char ch); //помещает в стек символ char pop(); //выталкивает из стека символ //Инициализация стека stack: : stack () { cout " "Работа конструктора стека \п"; tos=0; //Помещение символа в стек void stack: : push (char ch) < if {tos==SIZE} { cout " "Стек полон"; return; }stck[tos]=ch; tos++; 1//Выталкивание символа из стека char stack::pop() { if (tos==0) { cout " "Стек пуст"; return 0; //возврат нуля при пустом стеке }tos - ; return stck[tos]; }int main ( ) ( //образование двух автоматически инициализируемых стеков stack si, s2; int i ; si. push ( 'a' ) ; s2.push( 'x' ) ; sl.push('b') ;
48 Самоучитель C++ s2. push Су') ; si.push('с'); s2.push('z'); for(i=0; i<3; .i++) cout " "символ из si:" " sl.popO " "\n"; for(i=0; i<3; i++} cout " "символ из s2:" " s2.pop() " "\n"; return 0; Обратите внимание, что теперь вместо отдельной, специально вызываемой программой функции задача инициализации выполняется конструктором ав-томатически. Это важное положение. Если инициализация выполняется ав-томатически при создании объекта, то это исключает любую возможность того, что по ошибке инициализация не будет выполнена. Вам, как програм-мисту, не нужно беспокоиться об инициализации - она автоматически вы-полнится при появлении объекта. 2. В следующем примере показана необходимость не только конструктора, но и деструктора. В примере создается простой класс для строк, который содер-жит саму строку и ее длину. Когда создается объект strtype, для хранения строки выделяется память, и начальная длина строки устанавливается равной нулю. Когда объект strtype удаляется, эта память освобождается. ftinclude <iostream> ^include <cstring> ^include <cstdlib> using namespace std; ^define SIZE 255 class strtype { char *p; int len; public: strtype(); //конструктор -strtype(}; //деструктор void set(char *ptr); void show() ; //Инициализация объекта строка strtype::strtype() p=(char *) malloc(SIZE); i f ( ! p ) { cout " "Ошибка выделения памяти\п"; exit (1);
Глава 2. Введение в классы __ __ 49 *р='\0'; 1еп=0; //Освобождение памяти при удалении объекта строка strtype: :~strtype () cout " "Освобождение памяти по адресу р\п"; free (р) ; } void strtype: : set (char *ptr} { if (atrlen(p) > =SIZE) { cout " "Строка слишком великаХп"; return; 1 strcpy(p, ptr) ; len=strlen{p) ; 1 void strtype: : show () { cout " p " " - длина: " " len; cout " "\n"; 1int main () ( strtype sl,s2; sl.set("3TO проверка"); s2. set ("Мне нравится C++"); si. show ( ) ; s2. show() ; return 0; В этой программе для выделения и освобождения памяти используются функции maUoc() и free(). Хотя этот пример совершенно правилен, как вы увидите далее в этой книге, в C++ есть и иной путь управления распределе-нием динамической памяти. V В предыдущей программе заголовочные файлы библиотечных функций языка С оформлены в соответствии с новым стилем оформления заголовков. Как уже упоминалось в главе 1, если ваш компилятор не поддерживает такие за-
50 __ ________ __ Самоучитель C++ головки, просто замените их стандартными заголовочными файлами С. То же самое можно сказать о всех программах этой книги, в которых используются библиотечные функции С. 3. В следующем примере приведен интересный способ использования конст-руктора и деструктора объекта. В программе объект класса timer предназна-чен для измерения временного интервала между его созданием и удалением. При вызове деструктора на экран выводится прошедшее с момента создания объекта время. Вы могли бы воспользоваться подобным объектом для изме-рения времени работы программы или времени работы функции внутри бло-ка. Просто убедитесь, что объект исчезает в момент завершения временного интервала. ^include <iostream> #include <ctime> using namespace std; class timer ( clock_t start; public: timer ( } ; //конструктор ~timer ( ) ; //деструктор >; timer: : timer () { start=clock() ; timer: : -timer () j clock_t end; : end=clock() ; cout " "Затраченное время:" " (end-start) /CLOCKS_PER_SEC <<"\n"; }int main() ( timer ob; char c; //Пауза . . . cout " "Нажмите любую клавишу, затем ENTER: "; cin " с; return 0; 1 В программе используется стандартная библиотечная функция clock(), которая возвращает число временных циклов с момента запуска программы. Если разде-лить это число на CLOCKS_PER_SEC, можно получить значение в секундах.
Глава 2. Введение в классы 51 1. Измените класс queue (см. упражнения гл. 1) так, чтобы провести инициали-зацию с помощью конструктора. 2. Создайте класс stopwatch для имитации секундомера. Используйте конструк-тор для начальной установки секундомера в 0. Образуйте две функции-члена start() и stop() соответственно для запуска и остановки секундомера. Вклю-чите в класс и функцию-член show() для вывода на экран величины истек-шего промежутка времени. Также используйте деструктор для автоматиче-ского вывода на экран времени, прошедшего с момента создания объекта класса stopwatch, до его удаления. (Для простоты время приведите в секундах.) 3. Что неправильно в конструкторе, показанном в следующем фрагменте? class sample { double a, b, с; public: double sample!); //ошибка, почему? 2.2. Конструкторы с параметрами Конструктору можно передавать аргументы. Для этого просто добавьте не-обходимые параметры в объявление и определение конструктора. Затем при объявлении объекта задайте параметры в качестве аргументов. Чтобы по-нять, как это делается, начнем с короткого примера: ^include <iostream> using namespace std; class myclass { int a; public: myclass{int x); //конструктор void show() ; myclass::myclass(int x) { cout " "В конструкторе\п"; a = x; \ void myclass::show() { cout " a " "\n";
52 Самоучитель C++ int main() i myclass ob(4); ob. show()-; return 0; Здесь конструктор класса myclass имеет один параметр. Значение, переда-ваемое в myclass(), используется для инициализации переменной а. Обрати-те особое внимание на то, как в функции main() объявляется объект ob. Число 4, записанное в круглых скобках, является аргументом, передаваемым параметру х конструктора mycIassQ, который используется для инициализа-ции переменной а. Фактически синтаксис передачи аргумента конструктору с параметром явля-ется сокращенной формой записи следующего, более длинного выражения: myclass ob = myclass(4); Однако большинство программистов C++ пользуются сокращенной формой записи. На самом деле, с технической точки зрения между этими двумя формами записи имеется небольшое отличие, связанное с конструктором копий (copy constructor), о котором будет рассказано позже. На данном эта-пе об этом отличии можно не беспокоиться. , В отличие от конструктора деструктор не может иметь параметров. Смысл этого понять достаточно просто: отсутствует механизм передачи аргументов удаленному объекту. Примеры 1. Вполне допустимо передавать конструктору несколько аргументов. В этом примере конструктору myclass() передается два аргумента: #include <iostream> using namespace std; class myclass { int a, b; public: myclass(int x, int y); //конструктор void show (};
Глава 2. Введение^ в классы 53 myclass:imyclass(int х, int у) cout " "В конструкторе\п"; а = х; ь -у; -/oid myclass: :show() cout " a " ' ' " b " "\n"; int main ( } myclass ob(4, 7) ; ob. show() ; return 0; Здесь 4 передается в х, а 7 передается в у. Такой же общий подход использу-ется для передачи любого необходимого числа аргументов (ограниченного, разумеется, возможностями компилятора). 2. Здесь представлена следующая версия класса stack, в котором конструктор с параметром используется для присвоения стеку "имени". Это одно-символьное имя необходимо для идентификации стека в случае возникнове-ния ошибки. ^include <iostream> using namespace std; ^define SIZE 10 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека char who; //идентифицирует стек public: stack(char с ) ; //конструктор void push(char ch) ; //помещает в стек символ char pop ( } ; //выталкивает из стека символ //Инициализация стека stack: :stack(char с) tos = 0; who = с;
54 _ _ Самоучитель C++ cout " "Работа конструктора стека " " who " "\п"; )//Помещение символа в стек void stack: :push(char ch) { if (tos==SIZE) { cout " "Стек " " who " " полон \n"; return; }stck [tos]=ch; tos-н-; ! //Выталкивание символа из стека char stack: :pop() { if (tos==0) { cout " "Стек " " who " " пуст "; return 0; //возврат нуля при пустом стеке tos - ; return stck[tos]; int main{) //образование даух автоматически инициализируемых стеков stack si ('A') , s2('B') ; int i; si. push ( 'a' ) ; s2.push('x') ; sl.push('b') ; s2.push('y') ; si. push ( 'c' ) ; s2 . push ( ' z ' ) ; //Это вызовет сообщения об ошибках for(i=0; i<5; i++) cout " "символ из стека si: " " si. pop {) " "\n"; for(i=0; i<5; i+-t-) cout " "символ из стека s2 : " " s2.pop() " "\n"; return 0; Присвоение "имени" объекту, как показано в примере, является особенно полезным при отладке, когда важно выяснить, какой из объектов вызывает ошибку.
Глава 2. Введение в классы 55_ 3. Здесь показан новый вариант разработанного ранее класса strtype, в котором используется конструктор с параметром: ^include <iostream> #include <cstring> ^include <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype(char *ptr); -strtype ( } ; void show() ; strtype::strtype(char *ptr) len = strlenfptr); p = (char *) malloc(len + 1 ) ; cout " "Ошибка выделения памяти\п"; exit (1) ; strcpy(p, ptr); strtype: : -strtype () cout " "Освобождение памяти по адресу р\п"; free(p); void strtype::show() cout " p " "-длина: " " len; cout " "\n"; >int main() strtype si("Это проверка"), э2("Мне нравится C++"); si.show(); s2. show () ; return 0; В этой версии класса strtype строка получает свое начальное значение с по-мощью конструктора.
56 _ Самоучитель C++ 4. Конструктору объекта можно передать не только константы, но и любые до-пустимые выражения с переменными. Например, в следующей программе для создания объекта используется пользовательский ввод: #include <iostream> using namespace std; class myclass { int i, j; public: myclass (int a, int b) ; void show() ; }; myclass: :myclass (int a, int b) ! i = a; j = b; " void myclass: : show ( ) { cout " i " ' ' " j " "\n"; }int main { ) { int x, y; cout " "Введите два целых: "; cin " x " у; //использование переменных для создания ob myclass ob(x, у) ; ob.showf) ; return 0; Эта программа иллюстрирует важное свойство объектов. Объекты могут соз-даваться по мере необходимости, точно в соответствии с возникающей в мо-мент их создания ситуацией. Когда вы побольше узнаете о C++, вы увидите, какой полезной является возможность создания объектов "на ходу". Упражнеенниияя] 1. Измените класс stack так, чтобы память для стека выделялась динамически. При этом длина стека должна задаваться параметром конструктора. (Не за-будьте освободить эту память с помощью деструктора.)
Глава 2, Введение в классы 57 2. Создайте класс t_and__d, которому при его создании передается текущее сис-темное время и дата в виде параметров конструктора. Этот класс должен включать в себя функцию-член, выводящую время и дату на экран. (Подсказка: Для нахождения и вывода на экран этих данных воспользуйтесь стандартной библиотечной функцией времени и даты.) 3. Создайте класс box, конструктору которого передаются три значения типа double, представляющие собой длины сторон параллелепипеда. Класс box должен подсчитывать его объем и хранить результат также в виде значения типа double. Включите в класс функцию-член vol(), которая будет выводить на экран объем любого объекта типа box. 2.3. Введение в наследование Хотя более полно наследование (inheritance) обсуждается в главе 7, предва-рительно с ним необходимо познакомиться уже сейчас. Применительно к C++ наследование - это механизм, посредством которого один класс может наследовать свойства другого. Наследование позволяет строить иерархию классов, переходя от более общих к более специальным. Для начала необходимо определить два термина, обычно используемые при обсуждении наследования. Когда один класс наследуется другим, класс, ко-торый наследуется, называют базовым классом (base class). Наследующий класс называют производным классом (derived class). Обычно процесс насле-дования начинается с задания базового класса. Базовый класс определяет все те качества, которые будут общими для всех производных от него клас-сов. В сущности, базовый класс представляет собой наиболее общее описа-ние ряда характерных черт. Производный класс наследует эти общие черты и добавляет свойства, характерные только для него. Чтобы понять, как один класс может наследовать другой, давайте начнем с примера, который, несмотря на свою простоту, иллюстрирует несколько ключевых положений наследования. Для начала - объявление базового класса: //Определение базового класса class В { int i; public: void set_i(int n) ; int get_i(); } ; Теперь объявим производный класс, наследующий этот базовый: //Определение производного класса Class D: public В { int j;
58 _ __ Самоучитель C++ public: void set_j (int n) ; int raul () ; Внимательно посмотрите на это объявление. Обратите внимание, что после имени класса D имеется двоеточие, за которым следует ключевое слово public и имя класса В. Для компилятора это указание на то, что класс D бу-дет наследовать все компоненты класса В. Само ключевое слово public ин-формирует компилятор о том, что, поскольку класс В будет наследоваться, значит, все открытые элементы базового класса будут также открытыми элементами производного класса. Однако все закрытые элементы базового класса останутся закрытыми и к ним не будет прямого доступа из произ-водного класса. Ниже приводится законченная программа, в которой используются классы В и D: //Простой пример наследования ^include <iostream> using namespace std; //Определение базового класса class В { int i; public: void set_i(int n) ; int get_i ( ) ; //Определение производного класса class D: public В { int j; public: void set_j {int n) ; int mul ( ) ; //Задание значения i в базовом классе void B::set_i(int n} { i = n; }//Возвращение значения i в базовом классе int В: :get_i () < return i;
Глава 2. Введение в классы _ 59 //Задание значения j в производном классе void D: :set_j (int n) t j = n; //Возвращение значения i базового класса и j - производного int D: :mul (} //производный класс может //вызывать функции-члены базового класса return j * get_i(}; } int main ( ) { D ob; ob.set_i (10) ; //загрузка i в базовый класс ob.set_j(4); //загрузка j в производный класс cout " ob.mul(); //вывод числа 40 return 0; 1 Обратите внимание на определение функции mul(). Отметьте, что функция get_i()j которая является членом базового класса В, а не производного D, вызывается внутри класса D без всякой связи с каким бы то ни было объек-том. Это возможно потому, что открытые члены класса В становятся откры-тыми членами класса D. В функции mu1() вместо прямого доступа к i, необходимо вызывать функцию get_i(), поскольку закрытые члены базового класса (в данном случае i) остаются закрытыми для нее и недоступными из любого производного класса. Причина, по которой закрытые члены класса становятся недоступными для производных классов - поддержка инкапсу-ляции. Если бы закрытые члены класса становились открытыми просто по-средством наследования этого класса, инкапсуляция была бы совершенно несостоятельна. Здесь показана основная форма наследования базового класса: class имя производного класса; с д имя_базового класса { Здесь с_д (спецификатор доступа) - это одно из следующих трех ключевых слов: public (открытый), private (закрытый) или protected (защищенный).
60 Самоучитель С+_+_ В данном случае для наследования класса используется именно public. Пол-ное описание этих спецификаторов доступа будет дано позже. | Примеры ч^____ , , 1. Ниже приведена программа, которая определяет общий базовый класс fruit, описывающий некоторые характеристики фруктов. Этот класс наследуется двумя производными классами Apple и Orange. Эти классы содержат специ-альную информацию о конкретном фрукте (яблоке или апельсине). //Пример наследования классов ^include <iostream> ttinclude <cstring> using namespace std; enum yn (no, yes}; enum color {red, yellow, green, orange}; void out (enum yn x) ; char *c[ ] = { "red", "yellow", "green", "orange"}; //Родовой класс фруктов class fruit { //В этом базовом классе все элементы открыты public: enum yn annual; enum yn perennial; enum yn tree; enum yn tropical; enum color clr; char name [40] ; >; //Производный класс яблок class Apple: public fruit { enurn yn cooking; enum yn crunchy; enum yn eating; public: void seta (char *n, enum color c, enum yn ck, enum yn crchy, enum yn e) ; void showf) ; //Производный класс апельсинов class Orange: public fruit ( enum yn juice;
Глава 2, Введение в классы _ 67 enum yn sour; enum yn eating; public: void seto(char *n, enum color c, enum yn j, enum yn sr, enum yn e) ; void show ( ) ; void Apple: : seta (char *n, enum color c, enum yn ck, enum yn crchy, enum yn e) { strcpy (name, n) ; annual = no; perennial = yes; tree = yes; tropical = no; clr = c; cooking = ck; crunchy = crchy; eating = e; void Orange: :seto (char *n, enum color c, enum yn j, enum yn sr, enum yn e) { strcpy (name, n} ; annual = no; perennial = yes; tree = yes; tropical = yes; clr = c; juice = j; sour = sr; eating = e; void Apple: :show() { cout " name " " яблоко - это: " " "\n"; cout " "Однолетнее растение: "; out{annual}; cout " "Многолетнее растение: "; out (perennial) ; cout " "Дерево: "; out(tree); cout " "Тропическое: "; out (tropical) ; cout " "Цвет: " " c[clr] " "\n"; cout " "Легко приготавливается: "; out (cooking) ; cout " "Хрустит на зубах: "; out (crunchy) ; cout " "Съедобное: "; out (eating); cout " "\n" ;
62 _ Самоучитель C++ void Orange : : show { ) { cout " name " " апельсин - это: " " "\n"; cout " "Однолетнее растение: "; out (annual); cout " "Многолетнее растение: "; out (perennial) ; cout " "Дерево: "; out (tree); cout " "Тропическое: "; out (tropical) ; cout " "Цвет: " " c[clr] " "\n"; cout " "Годится для приготовления сока: "; out(juice); cout " "Кислый: "; out (sour) ; cout " "Съедобный: "; out (eating); cout " "\n"; void out{enum yn x) { if (x==no) cout " "нет\п"; else cout " "да\п"; int main() { Apple al, a2; Orange ol, o2; al . seta ("Красная прелесть", red, no, yes, yes); a2. seta ("Джонатан", red, yes, no, yes) ; ol. setoC'nyn", orange, no, no, yes); o2.seto ("Валенсия", orange, yes, yes, no); al .show( ) ; a2 . show ( ) ; 01 .show{ ) ; 02 . show ( ) ; return 0; Как можно заметить, базовый класс fruit определяет несколько свойств, ха-рактерных для фруктов любого типа, (Конечно, чтобы сократить пример и таким образом приспособить его для книги, класс fruit отчасти упрощен.) Например, все фрукты растут на однолетних или многолетних растениях. Все фрукты растут на деревьях или на растениях другого типа, таких как лоза или куст. Все фрукты имеют цвет и название. Затем такой базовый класс на-следуется классами Apple и Orange. Каждый из этих классов обеспечивает объект информацией, характерной для фруктов конкретного типа. Этот пример иллюстрирует основной смысл наследования. Создаваемый здесь базовый класс определяет основные черты, связанные со всеми фруктами.
Глава 2. Введение в классы 63_ Производным классам предоставляется возможность обеспечения тех характе-ристик, которые являются характерными в каждом конкретном случае. Эта программа раскрывает другой важный аспект наследования: производ-ные классы не "владеют" базовым классом безраздельно. Он может наследо-ваться любым количеством классов. Упражнения) ^ ~^г^ 1. Дан следующий базовый класс: class area_cl { public: double height; double width; создайте два производных класса rectangle и isosceles, которые наследуют ба-зовый класс агеа_с1. Каждый класс должен включать в себя функцию агеа(), которая возвращает площадь соответственно прямоугольника (rectangle) и равнобедренного треугольника (isosceles). Для инициализации переменных height и width (высота и длина основания, соответственно) используйте кон-структор с параметрами. 2.4. Указатели на объекты До сих пор вы осуществляли доступ к членам объекта с помощью оператора точка (.). Если вы работаете с объектом, то это правильно. Однако доступ к члену объекта можно получить также и через указатель на этот объект. В этом случае обычно применяется оператор стрелка (->). (Аналогичным способом оператор стрелка (->) используется при работе с указателем на структуру.) Вы объявляете указатель на объект точно так же, как и указатель на пере-менную любого другого типа. Задайте имя класса этого объекта, а затем имя переменной со звездочкой перед ним. Для получения адреса объекта перед ним необходим оператор &, точно так же, как это делается для получения адреса переменной другого типа. Как и для любого другого указателя, если вы инкрементируете указатель на объект, он будет указывать на следующий объект такого же типа. Примеры 1. Простой пример использования указателя на объект: #include <iostream> using namespace std;
64 Самоучитель C++ class myclass { int a; public: myclass (int x} ; //конструктор int get ( } ; myclass: :myclass (int x) int myclass: : get () f return a; int main() , myclass ob(120); //создание объекта myclass *p; //создание указателя на объект р = sob; //передача адреса ob в р cout " "Значение, получаемое через объект:" " ob.getO; cout " "\n"; cout " "Значение, получаемое через указатель : " " p->get ( } ; return 0 ; . Отметьте, как объявление myclass *p; создает указатель на объект класса myclass. Это важно для понимания сле-дующего положения: создание указателя на объект не создает объекта, оно создает только указатель на него. Для передачи адреса объекта ob в переменную р, использовалась инструкция: р = sob; И последнее, в программе показано, как можно получить доступ к членам объекта с помощью указателя на этот объект. Мы вернемся к обсуждению указателей на объекты в главе 4, когда у вас уже будет более полное представление о C++.
Глава 2. Введение в классы 65 2.5. Классы, структуры и объединения Как вы уже заметили, синтаксически класс похож на структуру. Вас, воз-можно, удивило то, что класс и структура имеют фактически одинаковые свойства. В C++ определение структуры расширили таким образом, что ту-да, как и в определение класса, удалось включить функции-члены, в том числе конструкторы и деструкторы. Таким образом, единственным отличи-ем между структурой и классом является то, что члены класса, по умолча-нию, являются закрытыми, а члены структуры - открытыми. Здесь показан расширенный синтаксис описания структуры: struct имя типа { //открытые функции и данные - "лены класса. private: //закрытие функция и данные - члены класса } список объектов Таким образом, в соответствии с формальным синтаксисом C++ как струк-тура, так и класс создают новые типы данных. Обратите внимание на введе-ние нового ключевого слова. Им является слово private, которое сообщает компилятору, что следующие за ним члены класса являются закрытыми. В том, что структуры и классы обладают фактически одинаковыми свойст-вами, имеется кажущаяся избыточность. Те, кто только знакомится с C++, часто удивляются этому дублированию. При таком взгляде на проблему уже не кажутся необычными рассуждения о том, что ключевое слово class со-вершенно лишнее. Объяснение этому может быть дано в "строгой" и "мягкой" формах. "Строгий" довод состоит в том, что необходимо поддерживать линию на со-вместимость с С. Стиль задания структур С совершенно допустим и для программ C++. Поскольку в С все члены структур по умолчанию открыты, это положение также поддерживается и в C++. Кроме этого, поскольку класс синтаксически отличается от структуры, определение класса открыто для развития в направлении, которое в конечном итоге может привести к несовместимости со взятым из С определением структуры. Если эти два пу-ти разойдутся, то направление, связанное с C++, уже не будет избыточным. "Мягким" доводом в пользу наличия двух сходных конструкций стало отсут-ствие какого-либо ущерба от расширения определения структуры в C++ таким образом, что в нее стало возможным включение функций-членов. Хотя структуры имеют схожие с классами возможности, большинство про-граммистов ограничивают использование структур взятыми из С формами и не применяют их для задания функций-членов. Для задания объекта, содер-жащего данные и код, эти программисты обычно указывают ключевое слово class. Однако все это относится к стилистике и является предметом вашего собственного выбора. (Далее в книге за исключением текущего раздела с
66 Самоучитель C++ помощью ключевого слова struct задаются объекты, которые не имеют функций-членов.) Если вы нашли интересной связь между классами и структурами, вас заин-тересует и следующее необычное свойство C++: объединения и классы в этом языке столь же близки! В C++ объединение также представляет собой тип класса, в котором функции и данные могут содержаться в качестве его членов. Объединение похоже на структуру тем, что в нем по умолчанию все члены открыты до тех пор, пока не указан спецификатор private. Главное же в том, что в C++ все данные, которые являются членами объединения, на-ходятся в одной и той же области памяти (точно так же, как и в С). Объе-динения могут содержать конструкторы и деструкторы. Объединения C++ совместимы с объединениями С. Если в отношениях между структурами и классами существует, на первый взгляд, некоторая избыточность, то об объединениях этого сказать нельзя. В объектно-ориентированном языке важна поддержка инкапсуляции. Поэтому способность объединений связывать воедино программу и данные позволяет создавать такие типы классов, в которых все данные находятся в общей об-ласти памяти. Это именно то, чего нельзя сделать с помощью классов. Применительно к C++ имеется несколько ограничений, накладываемых на использование объединений. Во-первых, они не могут наследовать какой бы то ни было класс и не могут быть базовым классом для любого другого класса. Объединения не могут иметь статических членов. Они также не должны содержать объектов с конструктором или деструктором, хотя сами по себе объединения могут иметь конструкторы и деструкторы. В C++ имеется особый тип объединения --это анонимное объединение (anonymous union). Анонимное объединение не имеет имени типа и следова-тельно нельзя объявить переменную такого типа. Вместо этого анонимное объединение просто сообщает компилятору, что все его члены будут нахо-диться в одной и той же области памяти. Во всех остальных отношениях члены объединения действуют и обрабатываются как самые обычные пере-менные. То есть, доступ к членам анонимного объединения осуществляется непосредственно, без использования оператора точка (.). Например, рас-смотрим следующий фрагмент: union { //анонимное объединение int i; char ch[4]; }; //непосредственный доступ к переменным i и ch i = 10; ch[0] = 'X'; Обратите внимание на то, что, поскольку переменные i и ch не являются частью какого бы то ни было объекта, доступ к ним осуществляется непо-средственно. Тем не менее они находятся в одной и той же области памяти.
Глава 2. Введение в классы 67 Смысл анонимных объединений в том и состоит, что они обеспечивают простой способ сообщить компилятору о необходимости разместить одну или несколько переменных в одной и той же области памяти. Исключая эту особенность, члены анонимного объединения больше ничем не отличаются от других переменных. Все те ограничения, которые накладываются на использование обычных объединений, применимы и к анонимным объединениям. Кроме этого к ним добавлено еще несколько. Глобальное анонимное объединение должно быть объявлено как статическое. Анонимное объединение не может содер-жать закрытых членов. Имена членов анонимного объединения не должны конфликтовать с другими идентификаторами той же области видимости. 1. Ниже представлена короткая программа, в которой для создания класса ис-пользуется ключевое слово struct: # include <iostream> ^include <cstring> using namespace std; //использование структуры для определения типа класса struct st_type { st_type (double b, char *n) ; void show{) ; private: double balance; char name [40] ; st_type: : st_type (double b, char *n) { balance = b; strcpy (name, n) ; } void st_type: :show{) { cout " "Имя:" " name; cout " ":$" " balance; if (balance < 0.0) cout " "***"; cout " "\n"; }int main(} { st_type accl(100.12, "Johnson") ; st type acc2(-12.34, "Hedricks" )
68 _ Самоучитель C++ accl.show() ; acc2.show{) ; return 0; Отметьте, что, как уже говорилось, члены структуры по умолчанию являются открытыми. Для объявления закрытых членов необходимо использовать ключевое слово private. Кроме этого отметьте существенное отличие между структурами С и структурами C++. В C++ имя тега становится также и законченным именем типа данных, которое можно использовать для объявления объектов. В С, чтобы имя тега стаю законченным именем типа данных, перед ним надо указывать ключевое слово struct. Ниже представлена только что рассмотренная программа, но вместо структу-ры здесь используется класс: ^include <iostream> ttinclude <cstring> using namespace std; class cl_type ( double balance; char name[40]; public: cl_type{double b, char *n); void show(); cl_type: :cl_type {double b, char *n) ( balance = b; strcpyfname, n) ; } void cl_type : : show( ) ( cout " "Имя:" " name; cout " ":$" " balance; if (balance < 0 . 0 ) cout " "***"; cout " "\n"; } int rnainf) { cl_type accl(100.12, "Johnson"); cl_type acc2(-12.34, "Hedricks") accl ,show() ; acc2.show() ;
Глава 2. Введение в классы _ 69 return 0; 2. Пример использования объединения для побайтного вывода значения типа double в двоичном представлении: ^include <iostream> using namespace std; union bits ( bits (double n) ; void show_bits ( ) ; double d; unsigned char c[sizeof (double)]; 1; bits: :bits (double n) { d = n; void bits : : show_bits { ) { int i, j; for( j = sizeof (double) - 1; j >= 0; j - ) { cout " "Двоичное представление байта" " j " for( i = 128; i; i "= 1) if(i & c[ j ]) cout " "1"; else cout " "0"; cout " "\n"; int main{ ) { bits оЫЗ.991.829) ; ob.show_bits () ; return 0; Результат работы программы Двоичное представление байта 7: 01000000 Двоичное представление байта 6: 10011111 Двоичное представление байта 5: 00011111 Двоичное представление байта 4: 01010000 Двоичное представление байта 3: 11100101
70 _ Самоучитель C++ Двоичное представление байта 2: 01100000 Двоичное представление байта 1: 01000001 Двоичное представление байта 0: 10001001 3. Структуры и объединения могут иметь конструкторы и деструкторы. В сле-дующем примере класс strtype переделан в структуру. В структуре имеются конструктор и деструктор. # include <iostrearn> , # include <cstring> ^include <cstdlib> using namespace std; struct strtype { strtype (char *ptr) ; ~strtype (} ; void show() ; private : char *p; int len; <! # strtype: :strtype (char *ptr) { len = strlen(ptr); p = (char *) mallocflen + 1) ; i f < ! p > { cout " "Ошибка вьщеления памяти \п"; exit(l) ; strcpy{p, ptr) ; strtype: : -strtype () ( cout " "Освобождение памяти по адресу р\п"; free (p) ; 1 void strtype: : show {} ( cout " p " "-длина: " " len; cout " "\n"; int main () strtype si("Это проверка"}, з2("Мне нравится C++");
Глава 2. Введение в классы _ -71 Sl.showl); s2 . show {) ; return 0; 4. В следующей программе для побайтного вывода на экран значения типа double используется анонимное объединение. (Предполагается, что длина значения типа double равна восьми байтам.) //Использование анонимного объединения ^include <iostream> using namespace std; int main(} union { unsigned char bytes[8]; double value; ); int i; value = 859345.324; //побайтный вывод значения типа double for(i=0; i<8; i++) cout " (int) bytes[ij " " "; return 0; Обратите внимание, что доступ к переменным value и bytes осуществляется так, как если бы они были не частью объединения, а обычными переменны-ми. Несмотря на то, что эти переменные объявлены как часть анонимного объединения, их имена находятся в той же области видимости, что и другие объявленные здесь локальные переменные. Именно по этой причине член анонимного объединения не может иметь то же имя, что и любая перемен-ная в данной области видимости. 1. Перепишите класс stack, представленный в разделе 2.1, чтобы вместо класса использовалась структура. 2. Используйте объединение, чтобы поменять местами старший и младший байты целого (предполагается 16-битное целое; если ваш компьютер исполь-зует 32-битное целое, то меняйте местами байты типа short int). 3. Объясните, что такое анонимное объединение и чем оно отличается от нор-мального объединения.
72 _ Самоучитель C++ 2.6. Встраиваемые функции Перед тем как продолжить исследование классов необходимо краткое отсту-пление. В C++ можно задать функцию, которая на самом деле не вызывает-ся, а ее тело встраивается в программу в месте ее вызова. Она действует почти так же, как макроопределение с параметрами в С. Преимуществом встраиваемых (in-line) функций является то, что они не связаны с механиз-мом вызова функций и возврата ими своего значения. Это значит, что встраиваемые функции могут выполняться гораздо быстрее обычных. (Запомните, что выполнение машинных команд, которые генерируют вызов функции и возвращение функцией своего значения, занимает определенное время. Если функция имеет параметры, то ее вызов занимает еще большее время.) Недостатком встраиваемых функций является то, что если они слишком большие и вызываются слишком часто, объем ваших программ сильно воз-растает. Из-за этого применение встраиваемых функций обычно ограничи-вается короткими функциями. Для объявления встраиваемой функции просто впишите спецификатор inline перед определением функции. Например, в этой короткой программе пока-зано, как объявить встраиваемую функцию: //Пример встраиваемой функции ^include <iostreara> using namespace std; -inline int even (int x) { return ! (x%2); int main () { if (even (10)) cout " "10 является четным\п"; if (even (11)) cout " "11 является четным\п"; return 0; В этом примере функция even(), которая возвращает истину при четном аргументе, объявлена встраиваемой. Это означает, что строка if (even(10)) cout " "10 является четным\п"; функционально идентична строке if (! (10%2)) cout " "10 является четнымХп"; Этот пример указывает также на другую важную особенность использования встраиваемой функции: она должна быть задана до ее первого вызова. Если
Глава 2. Введение в классы 73 это не так, компилятор не будет знать, какой именно код предполагается встроить в программу с помощью встраиваемой функции. Поэтому функция even() была определена перед функцией main(). В пользу использования встраиваемых функций вместо макроопределений с параметрами имеется два довода. Во-первых, они обеспечивают более стройный способ встраивания в программу коротких фрагментов кода. На-пример, при создании макроса с параметрами легко забыть, что для гаран-тии правильности встраивания в каждом случае часто требуются круглые внешние скобки. Встраиваемая функция исключает эту проблему. Во-вторых, компилятор гораздо лучше работает со встраиваемой функцией, чем с макрорасширением. Как правило, программисты C++ для многократ-ных вызовов коротких функций вместо макросов с параметрами практиче-ски всегда используют встраиваемые функции. Здесь важно понимать, что спецификатор inline для компилятора является запросом, а не командой. Если, по разным причинам, компилятор не в со-стоянии выполнить запрос, функция будет компилироваться, как обычная функция, а запрос inline будет проигнорирован. В зависимости от типа вашего компилятора возможны некоторые ограниче-ния на использование встраиваемых функций. Например, некоторые ком-пиляторы не воспринимают функцию как встраиваемую, если функция является рекурсивной или если она содержит либо статическую (static) пе-ременную, либо любую инструкцию выполнения цикла, либо инструкцию switch, либо инструкцию goto. Вам необходимо просмотреть руководство по вашему компилятору, чтобы точно определить ограничения на использова-ние встраиваемых функций. Если какое-либо ограничение на использование встраиваемой функции на-рушено, компилятор генерирует вместо нее обычную функцию. ПримерыР Любая функция может стать встраиваемой, включая функции - члены клас-сов. Например, функция divisible!) для ускорения ее выполнения сделана встраиваемой. (Функция возвращает истину, если ее первый аргумент без ос-татка может делиться на второй.) //Демонстрация встраиваемой функции-члена ^include <iostream> using namespace std; в L
74 _ Самоучитель C++ class samp { int i , j ; public: sampfint a, int b) ; int divisible О; //встраивание происходит в этом определении samp: : samp {int a, int b) ( i = a; j .= b; /* Возврат 1, если i без остатка делится на j. Тело этой функции-члена встраивается в программу */inline int samp: :divisible () { return ! (i%j ) ; int rnainO ii samp obi[10, 2), ob2(10, 3); //это истина if(obi.divisible{)) cout " "10 делится на 2Лп"; //это ложь if(ob2.divisible()} cout " "10 делится на 3\п"; return 0; 2. Допускается перегружать встраиваемую функцию. Например, эта программа перегружает min() тремя способами. В каждом случае функция также объяв-ляется встраиваемой. tfinclude <iostream> using namespace std; //Перегрузка функции min ( ) тремя способами //int inline int min {int a, int b) { return a < b ? a: b; //long inline long min (long a, long b)
Глава 2. Введение в классы 75 return а < b ? а: Ь; }//double inline double rain (double a, double b) { return a < b ? a: b; } int main ( ) { cout " min(-10, 10) " "\n"; cout " min(-10.01, 100.002) " "\n cout " min(-10L, 12L) " "\n"; return 0; 1. В главе 1 вы перегружали функцию abs() так, чтобы она находила абсолют-ные значения типа int, long и double. Модифицируйте программу, чтобы эти функции стали встраиваемыми. 2. Почему следующая функция может не компилироваться как встраиваемая? void f l ( ) { int i; ford = 0; i < 10; i++) cout " i; 2.7. Встраиваемые функции в объявлении класса Если определение функции-члена достаточно короткое, его можно вклю-чить в объявление класса. Поступив таким образом, мы заставляем, если это возможно, функцию стать встраиваемой. Если функция задается внутри объявления класса, ключевое слово inline не требуется. (Однако использова-ние его в такой ситуации не является ошибкой.) Например, как показано ниже, функция divisible() из предыдущего раздела может быть по умолчанию сделана встраиваемой:
76 _ _ __ _ __ Самоучитель #include <iostream> using namespace std; class samp { int i, j; public: samp (int a, int b) ; /* Функция divisible (), которая здесь определяется, по умолчанию становится встраиваемой. V int divisible () { return !(i%j); } samp: : samp (int a, int b) { i = a; j = b; }int main () { samp obi (10, 2), ob2(10, 3); //это истина if (obi .divisible () ) cout " "10 делится на 2\п"; //это ложь if (ob2. divisible () ) cout " "10 делится на 3\п"; return 0; Как видите, код функции divisibleQ находится внутри объявления класса samp. Отметьте, что никакого другого определения функции divisible{) не нужно, это даже запрещено. Определение функции divisible() внутри класса samp автоматически заставляет ее стать встраиваемой функцией. Если функция, заданная внутри объявления класса, не может стать встраи-ваемой функцией (поскольку были нарушены ограничения), она, обычно, преобразуется в обычную функцию. Отметьте, как именно функция divisibleQ задается внутри класса samp, осо-бенно само тело функции. Оно целиком расположено на одной строке. Та-кой формат для программ C++ является совершенно обычным, если функция объявляется внутри объявления класса. Такое объявление стано-вится более компактным. Однако класс samp мог бы быть описан и так: class samp { int i, j;
Глава 2. Введение в классы 77 public: samp(int a, int b); /* Функция divisible(), которая здесь определяется, по умолчанию становится встраиваемой. */int divisible() ' return ! ( i % j ) ; } Здесь в определении функции divisibleQ используется более или менее стан-дартный стиль отступов. С точки зрения компилятора, компактный и стан-дартный стили не отличаются. Однако в программах C++ при задании коротких функций внутри определения класса обычно используется ком-пактный стиль. На применение таких встраиваемых функций накладываются те же ограни-чения, что и на применение обычных встраиваемых функций. Примеры 1. Вероятно наиболее традиционным использованием встраиваемых функций, определяемых внутри класса, является определение конструктора и деструк-тора. Например, класс samp может быть определен более эффективно: ttinclude <iostream> using namespace std; class samp { int i, j; public: //встраиваемый конструктор samptint a, int b) { i = a; j = b; } int divisible() { return ! { i % j ) ; } Определения функции samp() внутри класса samp достаточно, и никакого другого определения не требуется. 2. Иногда короткие функции могут включаться в объявление класса даже тогда, когда преимущества встраивания мало что дают или вовсе не проявляются. Рассмотрим следующее объявление класса: class myclass { int i;
78 Самоучитель C++ public: myclass(int n) ( i = n; } void show(} { cout " i; } i t Здесь функция show() по умолчанию становится встраиваемой. Однако, как вы, наверное, знаете, операции ввода/вывода, по сравнению с операциями процессор/память, являются настолько медленными, что какой бы то ни бы-ло эффект от устранения вызова функции практически отсутствует. Однако в программах на C++, как правило, можно встретить такие короткие функции внутри класса. Делается это просто для удобства, поскольку никакого вреда не приносит. 1. Переделайте класс stack из раздела 2.1, пример 1, так, чтобы в классе, где это возможно, использовались встраиваемые функции. 2. Переделайте класс strtype из раздела 2.2, пример 3, так, чтобы в классе ис-пользовались встраиваемые функции. Проверка усвоения . материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы. 1. Что такое конструктор? Что такое деструктор? Когда они вызываются? 2. Создайте класс line, который рисует на экране линию. Храните длину линии в виде закрытой целой переменной len. Конструктор line должен иметь один параметр - длину линии. Он должен сохранять длину линии и собственно рисовать линию. Если ваша система не поддерживает гра-фику, отобразите линию, используя символ *. Необязательное задание: Для удаления линии используйте деструктор line. 3. Что выведет на экран следующая программа? ^include <iostream> using namespace std; int main() { int i = 10; long 1 = 1000000; double d = -0.0009;
Глава 2. Введение в классы cout " i " ' ' " 1 " ' ' " d; cout " "\n"; return 0; I 4. Добавьте производный класс, который наследует класс агеа_с! из раздела 2.3, упражнение 1. Назовите этот класс cylinder и пусть он вычисляет площадь поверхности цилиндра. Эта площадь задается так: 2 * pi * R2 + pi * D * Н. 5. Что такое встраиваемая функция? В чем ее преимущества и недостатки? 6. Измените следующую программу так, чтобы все функции-члены по умолчанию стали встраиваемыми функциями: #include <iostream> using namespace std; class myclass { int i, j; public: myclass (int x, int y) ; void show() ; }; myclass: :myclass (int x, int y) f i = x; j = Y; } void myclass :: show (} { cout " i " "" "" " j " "\n"; }int main() { myclass count (2, 3); count . show ( ) ; return 0; } 7. В чем отличие между классом и структурой? 8. Правилен ли следующий фрагмент? union { float f; unsigned int bits; 1;
во Самоучитель C++ Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Создайте класс prompt. Для вывода на экран строки-приглашения вклю-чите в класс конструктор. Помимо строки-приглашения конструктор должен выполнить ввод набранного вами целого. Сохраните это значение в'закрытой переменной count. При удалении объекта типа prompt должен быть подан звуковой сигнал, причем столько раз, сколько задано пользо-вателем в переменной count. 2. В главе 1 вы создали программу для преобразования футов в дюймы. Те-перь для этой цели создайте класс. Класс должен хранить число футов и его эквивалент в дюймах. Передайте конструктору класса число футов и при этом он должен вывести на экран число дюймов. 3. Создайте класс dice, который содержит закрытую целую переменную. Создайте функцию го11(), использующую стандартный генератор случай-ных чисел randQ, для получения чисел от 1 до 6. Функция roll() должна вывести это значение на экран.
Глава 3 Подробное изучение классов В этой главе вы продолжите изучение классов. Вы узнаете о том, как присво-ить один объект другому, как объекты передаются функциям в качестве аргу-ментов, как сделать объект возвращаемым значением функций. Вы также узнаете о новом важном типе функций: дружественных (friend) функциях. Повторение пройденного Перед тем как продолжить, вы должны правильно ответить на следующие вопросы и сделать упражнения. 1. Пусть дан следующий класс, каковы имена его конструктора и деструктора? class widgit { int x, у; public: //... впишите конструкторы и деструкторы }; 2. Когда вызывается конструктор? Когда вызывается деструктор? 3. Пусть дан следующий базовый класс, покажите, как он может наследо-ваться производным классом Mars. class planet { int moons; double dist_from_sun; double diameter; double mass; public: //... 1; 4. Имеются два способа сделать функцию встраиваемой. Что это за способы? 5. Приведите, по крайней мере, два ограничения на использование встраи-ваемых функций.
82 Самоучитель C++ 6. Пусть дан следующий класс, покажите, каким образом объявить объект ob, чтобы значение 100 передать переменной а, а значение X переменной с. class sample { int a; char с; public: sample(int x, char ch) { a -x; с = ch; } 3.1. Присваивание объектов Если тип двух объектов одинаков, то один объект можно присвоить другому. По умолчанию, когда один объект присваивается другому, делается пораз-рядная копия всех данных-членов копируемого объекта. Например, когда объект ol присваивается объекту о2, то содержимое всех данных объекта ol копируется в соответствующие члены объекта о2. Это иллюстрируется сле-дующей программой: //Пример присваивания объекта #include <iostream> using namespace std; class myclass { int a, b; public: void set (int i, int j) { a ~ i; b = j; } void show{) { cout " a " ' ' " b " "\n"; } int main ( ) < myclass ol, o2; ol.set(10, 4); //ol присваивается о2 o2 = ol; ol.show( ) ; o2 . show ( ) ; return 0; В этом примере переменным а и b объекта ol присваиваются соответствен-но значения 10 и 4. Далее объект ol присваивается объекту о2. Это приво-
Глава 3. Подробное изучение классов 83_ дит к тому, что текущее значение переменной ol.a присваивается перемен-ной о2.а, а текущее значение переменной ol.b - o2.b. Таким образом, в процессе выполнения программа выведет на экран следующее: 10 4 10 4 Запомните, что присваивание двух объектов просто делает одинаковыми данные этих объектов. Два объекта остаются по-прежнему совершенно неза-висимыми. Например, после выполнения присваивания вызов функции-члена ol.setQ для задания значения ol.a не влияет ни на объект о2, ни на значение его переменной а. Важно понимать, что в инструкции присваивания можно использовать толь-ко объекты одинакового типа. Если тип объектов разный, то при компиля-ции появится сообщение об ошибке. Более того, важно не только чтобы типы объектов были физически одинаковыми, а чтобы одинаковыми были также имена типов. Например, следующая программа неправильна: //Эта программа содержит ошибку #include <iostream> using namespace std; class myclass f int a, b; public: void set(int i, int j) { a = i ; b = j ; } void show() { cout " a " ' ' " b " "\n"; } /* Этот класс похож на класс myclass, но из-за другого имени класса для компилятора он считается другим типом. */class yourclass I int a, b; public: void set(int i, int j) { a = i; b = j; } void show() { cout " a " ' ' " b " "\n"; } }; int main() rayclass ol; yourclass o2; ol.set(10, 4);
_84 Самоучитель C++ о2 = ol; //ОШИБКА, присваивание объектов разных типов ol.show(); о2 . show () ; return 0; }Несмотря на то что классы myclass и yourclass физически одинаковы, они трактуются компилятором как разные, поскольку имеют разные имена типов. 2. Важно понимать, что все данные-члены одного объекта при выполнении присваивания присваиваются данным-членам другого объекта. Это относится и к сложным данным, таким как массивы. Например, в следующей версии уже знакомого нам класса stack символы реально помещаются только в стек si, но после выполнения присваивания массив stck объекта s2 также содер-жит символы a, b и с. ttinclude <iostream> using namespace std; #define SIZE 10 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека public: stack(); //конструктор void push(char ch); //помещает в стек символ char pop(); //выталкивает символ из стека }; //Инициализация стека stack::stack() ( cout " "Работа конструктора стека\л"; tos = 0; }//Помещение символа в стек void stack::push(char ch) { if (tos==SIZE) { cout " "Стек полон \п"; return; )stck[tos] = ch; tos+-(-;
Глава 3. Подробное изучение классов _ В5 //Выталкивание символа из стека char stack: :pop() { if (tos==0) { cout " "Стек пуст \п"; return 0; //возврат нуля при пустом стеке tos - ; return stckftos] ; int main () II Образование двух, автоматически инициализируемых стеков stack si, s2; int i ; si. push ( 'a' ) ; si. push ( 'b* ) ; si .push( 'c' ) ; //копирование si в s 2 s2 = si; //теперь s2 и si идентичны for(i=0; i<3; i++J cout " "символ из si:" " sl.popi) " "\n"; for(i=0; i<3; i++) cout " "символ из s2:" " s2.pop() " "\n"; return 0; 3. При присваивании одного объекта другому необходимо быть очень внима-тельным. Например, рассмотрим несколько измененный класс strtype, кото-рый мы изучали в главе 2. Попытайтесь найти ошибку в этой программе. //Эта программа содержит ошибку ^include <iostream> #include <cstring> ^include <cstdlib> using namespace std; class strtype { char *p; int len; public: \ strtype(char *ptr); ~strtype() ; void showf);
86 __ _ Самоучитель C++ strtype: :strtype (char *ptr) ( len=strlen(ptr) ; p=(char *} malloc (len+1) ; i f ( ! p ) ( cout " "Ошибка выделения памяти\п"; exit(l) ; } strcpy {p, ptr) ; strtype: :~strtype (} { cout " "Освобождение памяти по адресу р\п"; free (p) ; } void strtype: : show () { cout " p " " - длина: " " len; cout " "\n"; }int main () f strtype з!("Это проверка"), з2("Мне нравится C++") si. show () ; s2. show () ; //si присваивается s2 - это ведет к ошибке s2 -si; s 1 . show { ) ; s2 . show ( ) ; return 0; Ошибка в этой программе весьма коварна. Когда создаются объекты si и s2, то для хранения в этих объектах строк выделяется память. Указатель на вы-деленную каждому объекту память хранится в переменной р. Когда объект strtype удаляется, эта память освобождается. Однако когда объект si при-сваивается объекту s2, то указатель р объекта s2 начинает указывать на ту же самую область памяти, что и указатель р объекта si. Таким образом, когда эти объекты удаляются, то память, на которую указывает указатель р объекта si, освобождается дважды, а память, на которую до присваивания указывал указатель р объекта s2, не освобождается вообще. Хотя в данном случае эта ошибка и не опасна, в реальных программах с динамическим распределением памяти она может вызвать крах программы. Как показано в этом примере, при присваивании одного объекта другому вы
Глава 3. Подробное изучение классов 87 должны быть уверены в том, что не удаляете нужную информацию, которая может понадобиться в дальнейшем. Упражнения 1 . Что неправильно в следующем фрагменте? //В этой программе есть ошибка ^include <iostream> using namespace std; class ell { int i, j; public: ell (int a, int b) { i = a; j = b; } class c!2 ( int i, j; public: c!2(int a, int b) { i = a; j = b; } int main ( } { Cll x(10, 20} ; c!2 y(0, 0); x = y; 2. Используя класс queue, который вы создали в главе 2, раздел 2.1, упражнение 1, покажите, как один объект, который мы назвали очередь, можно присво-ить другому. 3. Если класс queue из предыдущего вопроса для хранения очереди требует ди-намического выделения памяти, то почему в такой ситуации одну очередь нельзя присвоить другой? 3.2. Передача объектов функциям Объекты можно передавать функциям в качестве аргументов точно так же, как передаются данные других типов. Просто объявите параметр функции, как имеющий тип класса, и затем используйте объект этого класса в качест-
88 Самоучитель C++ ве аргумента при вызове функции. Как и для данных других типов, по умолчанию объекты передаются в функции по значению. Примеры Р 1. В этом коротком примере объект передается функции: #include <iostream> using namespace std; class samp { int i; public: samp(int n) { i = n; } int get_i{) ( return i; ). //Возвращает квадрат o.i. int sqr_it(samp o) return o.get_i{) * o.get__i(}; int mainf) { samp a(10) , b(2) ; cout " sqr_it(a) " "\n" ; cout " sqr_it(b) " "\n"; return 0; В этой программе создается класс samp, который содержит одну целую пере-менную i. Функция sqr_it() получает аргумент типа samp, а возвращаемым значением является квадрат переменной i этого объекта. Результат работы программы - это значения 100 и 4. 2. Как уже установлено методом передачи параметров в C++, включая объекты, по умолчанию является передача объекта по значению. Это означает, что внут-ри функции создается копия аргумента и эта копия, а не сам объект, использу-ется функцией. Поэтому изменение копии объекта внутри функции не влияет на сам объект. Это иллюстрируется следующим примером: /* Запомните, объекты, как и другие параметры, передаются функции по значению и при этом в функции создается копия объекта. Таким образом, изменение параметра внутри функции не влияет на объект, используемый в вызове. V
Глава 3. Подробное изучение классов 89 #include <iostream> using namespace std; class samp { int i; public: samp(int n) { i = n; } void set_i(int n) { i = n; } int get_i() { return i; } \ . /* Заменяет переменную o.i ее квадратом. Однако это не влияет на объект, используемый для вызова функции sqr_it {} */void sqr_it(samp о) { o.set_i( o.get_i() * o.get_i()); cout " "Для копии объекта а значение i равно: " " o.get_i{); cout." "\n"; int main() samp a (10); sqr_it(a); //передача объекта а по значению cout " "но переменная a.i в функции mainf) не изменилась: "; cout " a.get i(); //выводится 10 return 0; }В результате работы программы на экран выводится следующее: Для копии объекта а значение i равно: 100 но переменная a.i в функции main() не изменилась: 10 3. Как и в случае с переменными других типов, функции может быть передано не значение объекта, а его адрес. В этом случае функция может изменить значение аргумента, используемого в вызове. Например, в рассматриваемом ниже варианте программы из предыдущего примера значение объекта, чей адрес используется при вызове функции sqr_it(), действительно меняется. /* Теперь функции sqr i t ( ) передается адрес объекта и функция может изменить значение аргумента, адрес которого используется при вызове. V^include <iostream> using namespace std;
90 __ Самоучитель C++ class samp { int i ; public : samp (int n) { i = n; } void set_i(int n) { i = n; } int get_i() ( return i; } /* Заменяет переменную o.i ее квадратом. Это влияет на объект, используемый при вызове */void sqr_it (samp *o) { o->set_i {o->get_i ( ) * o->get_i ( ) ) ; cout " "Для объекта а значение i равно: " " o->get_i(); cout " "\n"; int main() { samp a (10) ; sqr_it (fia) ; //функции sqr_it ( } передан адрес объекта а cout " "Теперь значение объекта а в функции main() изменилось:"; cout " а . get_i ( ) ; //выводится 100 return 0; } Теперь результат работы программы следующий: Для объекта а значение i равно: 100 Теперь значение объекта а в функции main(} изменилось: 100 4. Если при передаче объекта в функцию делается его копия, это означает, что появляется новый объект. Когда работа функции, которой был передан объ-ект, завершается, то копия аргумента удаляется. Возникают два вопроса. Во-первых, вызывается ли конструктор объекта, когда создается его копия? Во-вторых, вызывается ли деструктор объекта, когда эта копия удаляется? Ответ на первый вопрос может показаться неожиданным. Когда при вызове функции создается копия объекта, конструктор копии не вы-зывается. Смысл этого понять просто. Поскольку конструктор обычно исполь-зуется для инициализации некоторых составляющих объекта, он не должен вызываться при создании копии уже существующего объекта. Если бы это бы-ло сделано, то изменилось бы содержимое объекта, поскольку при передаче объекта функции необходимо его текущее, а не начальное состояние.
Глава 3. Подробное изучение классов 91 Однако если работа функции завершается и копия удаляется, то деструктор копии вызывается. Это происходит потому, что иначе оказались бы невы-полненными некоторые необходимые операции. Например, для копии может быть выделена память, которую, после завершения работы функции, необхо-димо освободить. Итак, при создании копии объекта, когда он используется в качестве аргумента функции, конструктор копии не вызывается. Однако, когда копия удаляется (обычно это происходит при возвращении функцией своего значения), вызы-вается ее деструктор. Следующая программа иллюстрирует эти положения: ^include <iostreara> using namespace std; class samp { int i ; public: samp(int n) ( i = n; cout " "Работа конструктора\n"; } -samp ( ) { cout " "Работа деструктора\n"; ) int get_i() { return i; } 1; //Возвращает квадрат переменной o.i int sqr it(samp o) return o.get_i() * o.get_i(); int main () { samp a (10); cout " sqr__it(a) " "\n"; return 0; } Эта программа выводит следующее: Работа конструктора 100 Работа деструктора Работа деструктора Обратите внимание, что конструктор вызывается только один раз. Это про-исходит при создании объекта а. Однако деструктор вызывается дважды.
92 Самоучитель C++ Первый раз он вызывается для копии, созданной, когда объект а был передан функции sqr_it(), другой - для самого объекта а. Тот факт, что деструктор объекта, являющегося копией передаваемого функ-ции аргумента, выполняется при завершении работы функции, может стать потенциальным источником проблем. Например, если для объекта, исполь-зуемого в качестве аргумента, выделена динамическая память, которая осво-бождается при его удалении, тогда и для копии объекта при вызове деструктора будет освобождаться та же самая память. Это приведет к повре-ждению исходного объекта. (Для примера см. упражнение 2 данного раз-дела.) Чтобы избежать такого рода ошибок, важно убедиться в том, что дест-руктор копии объекта, используемого в качестве аргумента, не вызывает ни-каких побочных эффектов, которые могли бы повлиять на -исходный аргумент. Как вы, возможно, уже догадались, одним из способов обойти проблему уда-ления деструктором необходимых данных при вызове функции с объектом в качестве аргумента должна стать передача функции не самого объекта, а его адреса. Если функции передается адрес объекта, то нового объекта не созда-ется и поэтому при возвращении функцией своего значения деструктор не вызывается. (Как вы увидите в следующей главе, в C++ имеется и иное, бо-лее элегантное решение этой задачи.) Тем не менее имеется другое, лучшее решение, о котором вы узнаете, изучив особый тип конструктора, а именно конструктор копий (copy constructor). Конструктор копий позволяет точно оп-ределить порядок создания копий объекта. (О конструкторах копий расска-зывается в главе 5.) 1. Используя класс stack из раздела 3.1, пример 2, добавьте в программу функ-цию showstack(), которой в качестве аргумента передается объект типа stack. Эта функция должна выводить содержимое стека на экран. 2. Как вы знаете, если объект передается функции, создается копия этого объ-екта. Далее, когда эта функция возвращает свое значение, вызывается дест-руктор копии. Вспомнив это, ответьте, что неправильно в следующей программе? //В этой v-P'rPa:Mbie есть ошибка #include <iostream> #include <cstdlib> using namespace std; class dyna j int *p; public: dyna fint i ) ; ~dyna() ( free (p); cout " "освобождение памяти\п"; }
Глава 3. Подробное изучение классов int get () { return *p; } dyna : : dyna { int i ) { p = (int *) malloc {sizeof (int) ) ; if(!p) { cout " "Ошибка выделения памяти\п"; exit(l) ; //Возвращает отрицательное значение *ob.p int neg(dyna ob} return -ob.getf); 1 int main() { dyna о (-10) ; cout " o . g e t f } " "\n"; cout " neg(o) " "\n"; dyna o2{20) ; cout " o2.get() " "\n"; cout " neg{o2) " "\n"; cout " o.get() " "\n"; cout " neg(o) " "\n"; return 0; 3.3. Объекты в качестве возвращаемого значения функций Так же как объект может быть передан функции в качестве аргумента, он может быть и возвращаемым значением функций. Для этого, во-первых, объявите функцию так, чтобы ее возвращаемое значение имело тип класса. Во-вторых, объект этого типа возвратите с помощью обычной инструкции return.
94 Самоучитель C++ Имеется одно важное замечание по поводу объектов в качестве возвращае-мого значения функций: если функция возвращает объект, то для хранения возвращаемого значения автоматически создается временный объект. После того как значение возвращено, этот объект удаляется. Удаление этого вре-менного объекта может приводить к неожиданным побочным эффектам, что иллюстрируется в примере 2 этого раздела. ПримерыР 1. Пример функции с объектом в качестве возвращаемого значения: //Возвращение объекта из функции ^include <iostream> ^include <cstring> using namespace std; class samp { char s[BO]; public: void show() { cout " s " "\n"; } void set(char *str) { strcpyts, str); } //Возвращает объект типа samp samp input(} { char s[80]; samp str; cout " "Введите строку: "; cin " s; str.set (s); return str; int main() { samp ob; //присваивание возвращаемого значения объекту ob ob = input(); ob.show(); return 0;
Глава 3. Подробное изучение классов _ 95 В этом примере функция input() создает локальный объект str и считывает строку с клавиатуры. Эта строка копируется в str.s, и затем функция возвра-щает объект str. Внутри функции main() при вызове функции input() возвра-щаемый объект присваивается объекту оЪ. 2. Следует быть внимательными при возвращении объектов из функций, если эти объекты содержат деструктор, поскольку возвращаемый объект выходит из области видимости, как только функция возвращает его значение. Напри-мер, если функция возвращает объект, имеющий деструктор, который осво-бождает динамически выделенную память, то эта память будет освобождена независимо от того, использует ли ее объект, которому присваивается воз-вращаемое значение, или нет. Например, рассмотрим неправильную версию предыдущей программы: //При возвращении объекта генерируется ошибка #include <iostream> #include <cstring> ^include <cstdlib> using namespace std; class samp { char *s; public : samp ( ) { s = ' \ 0 ' ; } ~samp() { i f ( s ) free(s); cout " "Освобождение памяти по адресу sNn"; } void show () { cout " s " "Nn"; } void set (char *str) ; //Загружает строку void samp: : set (char *str) s = (char *} malloc (strlen(str) +1) ; if(!s) { cout " "Ошибка выделения exit(l) ; strcpy (s, str) ; }//Возвращает объект типа samp samp input () ( char s[80] ; samp str; cout " "Введите строку: "; cin " s;
36 _ _ Самоучитель C++ str. set ( s ) ; return str; int mainf) { samp ob; //возвращаемое значение присваивается объекту ob ob = input (); //Это ведет к ошибке ob. show () ; return 0; Здесь показан результат работы программы: Введите строку: Привет Освобождение памяти по адресу s Освобождение памяти по адресу s Привет Освобождение памяти по адресу s Null pointer assignment Обратите внимание, что деструктор класса samp вызывается трижды. Первый раз, когда локальный объект str выходит из области видимости при возвра-щении функцией input() своего значения. Второй раз ~samp() вызывается тогда, когда удаляется временный объект, возвращаемый функцией input(). Запомните, когда объект возвращается функцией, автоматически генерирует-ся невидимый (для вас) временный объект, который и хранит возвращаемое значение. В этом случае временный объект - это просто копия объекта str, являющегося возвращаемым значением функции. Следовательно, после того как функция возвратила свое значение, выполняется деструктор временного объекта. И наконец, при завершении программы вызывается деструктор объ-екта ob в функции таш(). Проблема в этой ситуации в том, что при первом выполнении деструктора память, выделенная для хранения вводимой с помощью функции input() строки, освобождается. Таким образом, при двух других вызовах деструктора класса samp не только делается попытка освободить уже освобожденный блок динамической памяти, но в процессе работы происходит разрушение самой системы динамического распределения памяти и, как доказательство этому, появляется сообщение "Null pointer assignment". (В зависимости от вашего компилятора, модели используемой памяти и тому подобного при попытке выполнить программу это сообщение может и не появиться.) Ключевым моментом в понимании проблемы, описанной в этом примере, является то, что при возвращении функцией объекта для временного объек-та, который и является возвращаемым значением функции, вызывается дест-
Глава 3. Подробное изучение классов 97 руктор. (Как вы узнаете в главе 5, для решения проблемы в такой ситуации можно воспользоваться конструктором копий.) Для внимательного изучения вопроса, когда при возвращении функцией объекта для него вызываются конструктор и деструктор, создайте класс who. Конструктор who должен иметь один символьный аргумент, который будет использоваться для идентификации объекта. При создании объекта конст-руктор должен выводить на экран сообщение: Создание объекта who #x где х - идентифицирующий символ, свой для каждого объекта. При удале-нии объекта на экран должно выводиться примерно такое сообщение: Удаление объекта who #x где х - снова идентифицирующий символ. Наконец, создайте функцию make_who(), которая возвращает объект who. Присвойте каждому объекту уникальное имя. Проанализируйте выводимый на экран результат работы программы. 2. Продумайте ситуацию, в которой, как и при неправильном освобождении дина-мической памяти, возвращать объект из функции было бы также ошибочно. 3.4. Дружественные функции: обзор Возможны ситуации, когда для получения доступа к закрытым членам клас-са вам понадобится функция, не являющаяся членом этого класса. Для дос-тижения этой цели в C++ поддерживаются дружественные функции (friend functions). Дружественные функции не являются членами класса, но тем не менее имеют доступ к его закрытым элементам. В пользу существования дружественных функций имеются два довода, свя-занные с перегрузкой операторов и созданием специальных функций вво-да/вывода. Об этом использовании дружественных функций вы узнаете несколько позднее. Сейчас познакомимся с третьим доводом в пользу суще-ствования таких функций. Вам наверняка когда-нибудь понадобится функ-ция, которая имела бы доступ к закрытым членам двух или более разных классов. Рассмотрим, как создать такую функцию. Дружественная функция задается так же, как обычная, не являющаяся чле-ном класса, функция. Однако в объявление класса, для которого функция будет дружественной, необходимо включить ее прототип, перед которым ставится ключевое слово friend. Чтобы понять, как работает дружественная функция, рассмотрим следующую короткую программу:
gg _ __ Самоучитель C++ H Пример использования дружественной функции #include <iostream> using namespace std; class myclass ( int n, d; public: myclass (int i, int j) { n = i; d = j; } //объявление дружественной функции для класса myclass friend int isfactor (myclass ob) ; }; /* Здесь представлено определение дружественной функции. Она возвращает истину, если n делится без остатка на d. Отметьте, что ключевое слово friend в определении функции isf actor () не используется. */int isfactor (myclass ob) { if(!(ob.n % ob.d)) return 1; else return 0; }int main{) myclass obi (10, 2), ob2(13, 3); if (isfactor (obi) cout " "10 без остатка делится на 2\п"; else cout " "10 без остатка не делится на 2\п"; if (isfactor (ob2) cout " "13 без остатка делится на 3\п"; else cout " "13 без остатка не делится на 3\п"; return 0; В этом примере в объявлении класса myclass объявляются конструктор и дружественная функция isfactorQ. Поскольку функция isfactor() дружест-венна для класса myclass, то функция isfactorQ имеет доступ к его закрытой части. Поэтому внутри функции isfactor() можно непосредственно ссылать-ся на объекты ob.n и ob.d. Важно понимать, что дружественная функция не является членом класса, для которого она дружественна. Поэтому невозможно вызвать дружествен-ную функцию, используя имя объекта и оператор доступа к члену класса (точку или стрелку). Например, по отношению к предыдущему примеру эта инструкция неправильна: obi. is factor () ; //неправильно, isf actor () - это не функция-член
Глава 3. Подробное изучение классов 99 На самом деле дружественная функция должна вызываться точно так же, как и обычная функция. Хотя дружественная функция "знает" о закрытых элементах класса, для ко-торого она является дружественной, доступ к ним она может получить толь-ко через объект этого класса. Таким образом, в отличие от функции-члена myclass, в котором можно непосредственно упоминать переменные п и d, дружественная функция может иметь доступ к этим переменным только че-рез объект, который объявлен внутри функции или передан ей. В предыдущем разделе был рассмотрен важный момент. Когда функция-член использует закрытый элемент класса, то это делается непосредственно, по-скольку функция-член выполняется только с объектами данного класса. Та-ким образом, если в функции-члене класса упоминается закрытый элемент этого класса, то компилятор знает, к какому объекту этот закрытый элемент относится, поскольку знает, с каким объектом при вызове функции-члена связана функция. Однако дружественная функция не связана с каким бы то ни было объектом. Просто ей предоставлен доступ к закрытым элементам класса. Поэтому дружественная функция не может работать с закрытыми членами класса без упоминания конкретного объекта. Поскольку дружественные функции - это не члены класса, им обычно пе-редается один или более объектов класса, для которого они являются друже-ственными. Так было сделано, например, в случае с функцией isfactorQ Ей был передан объект ob класса myclass. Поскольку функция isfactor() друже-ственна для класса myclass, она может иметь доступ к закрытым элементам этого класса через объект ob. Случись так, что функция isfactorQ не была бы дружественной для класса myclass, она не имела бы доступа ни к объекту ob.n, ни к объекту ob.d, поскольку переменные п и d - это закрытые члены класса myclass. Дружественная функция - это не член класса и она не может быть задана через имя объекта. Она должна вызываться точно так же, как и обычная функция. Дружественная функция не наследуется. Поэтому если в базовый класс включается дружественная функция, то эта дружественная функция не явля-ется таковой для производных классов. Другим важным моментом, относящимся к дружественным функциям, явля-ется то, что функция может быть дружественной более чем к одному классу.
100 Самоучитель C++ 1. Обычно дружественная функция бывает полезна тогда, когда у двух разных классов имеется нечто общее, что необходимо сравнить. Например, рассмот-рим следующую программу, в которой создаются классы саг (легковая ма-шина) и truck (грузовик), причем оба содержат в закрытой переменной скорость соответствующего транспортного средства: ^include <iostream> using namespace std; class truck; //предварительное объявление class car { int passengers; int speed; public: car(int p, int s) { passengers = p; speed = s; } friend int sp_greater (car c, truck t) ; class truck { int weight; int speed; public: truck(int w, int s) { weight = w; speed = s; } friend int sp_greater (car c, truck t) ; /* Возвращает положительное число, если легковая машина быстрее грузовика. Возвращает 0 при одинаковых скоростях. Возвращает отрицательное число, если грузовик быстрее легковой машины. */int sp_greater (car c, truck t) { return с. speed - t. speed; iI int main() int t; car cl(6, 55), c2 (2, 120) ; truck tl (10000, 55), t2(2000Q, 72); cout " "Сравнение значений cl и tl:\n"; t = sp_greater (cl, tl); if(t<0) cout " "Грузовик быстрее. \п"; else if (t==0) cout " "Скорости машин одинаковы. \п"; else cout " "Легковая машина быстрее. \п";
Глава 3. Подробное изучение классов Ю1 cout " "ХпСравнение значений с2 и t2:\n"; t -sp_greater(c2, t2); if(t<0) cout " "Грузовик быстрее. \n"; else if(t==Q) cout " "Скорости машин одинаковы. \п"; else cout " "Легковая машина быстрее. \п"; return 0; В этой программе имеется функция sp_greater(), которая дружественна для классов саг и truck. (Как уже установлено, функция может быть дружествен-ной двум и более классам.) Эта функция возвращает положительное число, если объект саг движется быстрее объекта truck, нуль, если их скорости оди-наковы, и отрицательное число, если скорость объекта truck больше, чем скорость объекта саг. Эта программа иллюстрирует один важный элемент синтаксиса C++ - пред-варительное объявление (forward declaration), которое еще называют ссылкой вперед (forward reference). Поскольку функция sp_greater() получает параметры обоих классов саг и truck, то логически невозможно объявить и тот и другой класс перед включением функции sp_greater() в каждый из них. Поэтому не-обходим иной способ сообщить компилятору имя класса без его фактиче-ского объявления. Этот способ и называется предварительным объявлением. В C++, чтобы информировать компилятор о том, что данный идентификатор является именем класса, перед первым использованием имени класса встав-ляют следующую строку: class имя класса.; , Например, в предыдущей программе предварительным объявлением является инструкция class truck; после которой класс truck можно использовать в объявлении дружественной функции sp_greater() без опасения вызвать ошибку компилятора. 2. Функция может быть членом одного класса и дружественной другому. На-пример, если переписать предыдущий пример так, чтобы функция sp_greater() являлась членом класса саг и дружественной классу truck, то по-лучится следующая программа: ftinclude <iostream> using namespace std; class truck; //предварительное объявление class car { int passengers; int speed;
102 Самоучитель public: car(int p, int s) { passengers = p; speed = s; } int sp_greater(truck t); class truck { int weight; int speed; public: truck(int w, int s) ( weight = w; speed = s; } //отметьте новое использование //оператора расширения области видимости friend int car: :sp_greater (truck t); /* Возвращает положительное число, если легковая машина быстрее грузовика . Возвращает 0 при одинаковых скоростях . Возвращает отрицательное число, если грузовик быстрее легковой машины. */int car: :sp_greater (truck t) {/* Поскольку функция sp_greater() - это член класса car, ей должен передаваться только объект truck */return speed - t. speed; int main ( } int t; car cl(6, 55), c2 (2, 120) ; truck tl (10000, 55}, t2{20000, 72); cout " "Сравнение значений cl и tl:\n"; t = cl . sp_greater (tl) ; //вызывается как функция-член класса car if(t<0) cout " "Грузовик быстрее. \п"; else if(t==0) cout " "Скорости машин одинаковы. \п"; else cout " "Легковая машина быстрее . \n" ; cout " "ХпСравнение с2 и t2:\n"; t = c2 .sp_greater (t2) ; //вызывается как функция-член класса car if(t<0) cout " "Грузовик быстрее. \п"; else if{t==0) cout " "Скорости машин одинаковы. \п"; else cout " "Легковая машина быстрее . \n" ; return 0;
Глава 3. Подробное изучение классов юз Обратите внимание на новое использование оператора расширения области видимости, который имеется в объявлении дружественной функции внутри объявления класса truck. В данном случае он информирует компилятор о том, что функция sp_greater() является членом класса саг. Существует простой способ запомнить, где в такой ситуации нужно указы-вать оператор расширения области видимости: сначала идет имя класса, по-том -оператор расширения области видимости и последним -имя функции-члена. Таким образом член класса будет полностью задан. Фактически при упоминании в программе члена класса никогда не помешает полностью (с именем класса и оператором расширения области видимости) задать его имя. Однако при использовании объекта для вызова функции-члена или для доступа к переменной-члену, полное имя обычно излишне и употребляется редко. Например, инструкция t = cl.sp_greater(tl); может быть написана с указанием (избыточным) оператора расширения об-ласти видимости и именем класса саг: t = cl.car::sp_greater(tl); Поскольку объект cl является объектом типа саг, компилятор уже и так зна-ет, что функция sp_greater() - это член класса саг, что делает необязатель-ным полное задание имени класса. Упражнения! ^ -уг* 1. Представьте себе ситуацию, в которой показанные ниже два класса рг! и рг2 используют общий принтер, а для оставшейся части программы необходимо знать, когда принтер занят объектом одного из этих классов. Создайте функ-цию inuse(), которая возвращает true, когда принтер занят объектом одного из классов и false - в противном случае. Сделайте эту функцию дружествен-ной как классу prl, так и классу рг2. class prl { int printing; //... public: prl() { printing = 0; } void set_print (int status) { printing = status; } class pr2 { int printing;
104 Самоучитель C++ public: pr2 () { printing -0; } void set_print(int status) { printing = status; } Проверке усвоения ; материала главы Перед тем как продолжить, вам необходимо ответить на следующие вопросы и выполнить упражнения: 1. Какое условие является обязательным для присвоения одного объекта другому? 2. Пусть дан следующий фрагмент: class samp { double *p; public: samp(double d) { p = (double *) malloc(sizeof{double}); if(!p) exit(l); //ошибка выделения памяти *p -d; ~samp() ( free(p); } samp obi(123.09) , ob2(0.0); //... ob2 = obi; Какую проблему вызовет присваивание объекта obi объекту оЬ2? 3. Дан следующий класс: class planet { int moons; double dist_from_sun; //в милях double diameter; double mass; public: //... double get_miles() { return dist_from_sun; }
Глава 3. Подробное изучение классов 105 создайте функцию Hght(), получающую в качестве аргумента объект типа planet и возвращающую число секунд, за которые свет достигает планеты. (Предположим, что скорость света равна 186000 миль в секунду и что значение dist_from_sun, т. е. расстояние от Солнца, задано в милях.) 4. Можно ли адрес объекта передать функции в качестве аргумента? 5. Используя класс stack, напишите функцию loadstack(), которая бы воз-вращала стек, заполненный буквами алфавита (a-z). В вызывающей про-грамме присвойте этот стек другому объекту и докажите, что и в этом объекте находится алфавит. (Замечание. Удостоверьтесь, что длина стека достаточна для хранения алфавита.) 6. Объясните, почему необходимо быть внимательным при передаче объек-тов функциям или при возвращении объектов из функций. 7. Что такое дружественная функция? Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Функции можно перегружать благодаря отличиям в числе или типе их параметров. Перегрузите функцию loads tack() из вопроса 5 упражнений по проверке усвоения материала данной главы так, чтобы она получала в качестве аргумента целое число upper. В перегруженной версии, если пе-ременная upper будет равной 1, загрузите стек символами алфавита в верхнем регистре. В противном случае загрузите его символами алфавита в нижнем регистре. 2. Используя класс strtype, представленный в разделе 3.1, пример 3, добавь-те дружественную функцию, которая получает в качестве аргумента ука-затель на объект типа strtype и возвращает указатель на строку. (Таким образом, функция должна возвращать указатель р). Назовите эту функ-цию get_string(). 3. Если объект производного класса присваивается другому объекту того же производного класса, будут ли также копироваться данные, связанные с базовым классом? Чтобы ответить, воспользуйтесь следующими двумя классами и напишите программу. class base { int' a;
106 Самоучитель C++ public: void load_a(int n) { a = n; } int get_a() { return a; } class derived: public base { int b; public: void load_b (int n) { b = n; } int get b() { return b; }
Глава 4 Массивы, указатели и ссылки В этой главе исследуется несколько важных аспектов применения массивов объектов и указателей на объекты. Заканчивается глава обсуждением одного из самых важных нововведений C++ - ссылок. Ссылки определяют многие возможности C++, поэтому при чтении нужно быть особенно внимательным. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Что в действительности происходит при присваивании одного объекта другому? 2. Могут ли возникать ошибки или побочные эффекты при присваивании одного объекта другому? (Приведите пример.) 3. Когда объект передается функции в качестве аргумента, создается копия этого объекта. Вызывается ли конструктор копии? Вызывается ли ее де-структор? 4. По умолчанию объект передается функции по значению, это означает, что появляющаяся внутри функции копия объекта не связана с аргумен-том, используемом при вызове, т. е. изменения копии не отражаются на оригинале. Возможно ли нарушение этого принципа? Если да, приведите пример. 5. Дан следующий класс, создайте функцию make_sum(), возвращаемым значением которой является объект типа summation. Пользователь должен ввести число, затем функция должна создать объект, получающий это значение, и возвратить его вызвавшей процедуре. Покажите, что функция работает. class summation { int num; long sum; //суммирование чисел, составляющих num
108 Самоучитель C++ public: void set- sum(int n); void show_sum() ( cout " " сумма чисел, составляющих " " num " " равна " " sum " "\n"; }; void summation::set_sum{int n) int i ; num = n; sum = 0; for(1=1; i<=n; i++) sum += i; 6. В предыдущем вопросе функция set_sum() не была определена как встраиваемая в объявлении класса summation. Объясните, почему это не-обходимо для некоторых компиляторов? 7. Дан следующий класс, покажите, как добавить дружественную функцию isnegQ, которая получает один параметр типа myclass и возвращает true, если значение num отрицательно и false - в противном случае. class myclass { int num; public: myclass(int x} { num = x; } J; 8. Может ли дружественная функция быть дружественной более чем одному классу? 4.1. Массивы объектов Как уже отмечалось ранее, объекты - это переменные, и они имеют те же возможности и признаки, что и переменные любых других типов. Поэтому вполне допустимо упаковывать объекты в массив. Синтаксис объявления массива объектов совершенно аналогичен тому, который используется для объявления массива переменных любого другого типа. Более того, доступ к массивам объектов совершенно аналогичен доступу к массивам переменных любого другого типа.
Глава 4. Массивы, указатели и ссылки 109 Приме!рPыWJ >::" 1. Пример массива объектов: ^include <iostream> using namespace std; class samp { int a; public: void set_a(int n) ( a = n; } int get_a{) { return a; } int mainO ( samp ob[4] ; int i; for(i=0; i<4; i++) ob[ i ].set_a(i); for(i=0; i<4; i++) cout " ob[ i ].get_a(); cout " "\n" ; return 0; В этой программе создается массив из четырех элементов типа samp, кото-рым затем присваиваются значения от 0 до 3. Обратите внимание на то, как вызываются функции-члены для каждого элемента массива. Имя массива, в данном случае ob, индексируется; затем применяется оператор доступа к члену, за которым следует имя вызываемой функции-члена. 2. Если класс содержит конструктор, массив объектов может быть инициализи-рован. Например, здесь объект ob является инициализируемым массивом: //Инициализация массива ^include <iostream> using namespace std; class samp { int a; public : samp (int n) { a = n; } int get_a() { return a; } }; int main ( ) { samp ob[4) = { -1, -2, -3, -4 }; int i;
110 _ Самоучитель C++ for{i=0; i<4; 14+) cout " ob [ i ].get_a() " ' '; cout " "\n"; return 0; Эта программа выводит на экран -1 -2 -3 -4. В этом примере значения от - 1 до -4 передаются объекту ob конструктором. Фактически синтаксис списка инициализации - это сокращение следующей конструкции (впервые показанной в главе 2): samp ob[4] = { samp(-l) , samp (-2} , samp (-3) , samp (-4) } ; Однако при инициализации одномерного массива общепринятой является та форма записи, которая была показана в программе (хотя, как вы дальше уви-дите, такая форма записи будет работать только с теми массивами, конструк-тор которых имеет единственный аргумент). 3. Вы также можете работать с многомерными массивами объектов. Например, эта программа создает двумерный массив объектов и инициализирует его: //Создание двумерного массива объектов ^include <iostream> using namespace std; class samp { int a; public: sampfint n) { a = n; } int get_a() { return a; } int mainO samp ob[4] [2] = { 1, 2, 3, 4, 5, 6, 1, 8 }; int i; for(i=0; i<4; i++) { cout " ob[i] [0],get__a() " ' ' cout " ob[i] [l].get_a() " "\n }cout " "\n"; return 0;
Глава 4. Массивы, указатели и ссылки 111 Эта программа выводит на экран следующее: 1 2 3 4 5 б 7 8 4. Как вы знаете, конструктор может иметь более одного аргумента. При ини-циализации массива объектов с таким конструктором вы должны использо-вать упоминавшуюся ранее альтернативную форму инициализации. Начнем с примера: ^include <iostream> using namespace std; class samp ( int a, b; public: samp (int n, int rn) { a = n; b = m; } int get_a() { return a; } int get_b() { return b; } int main ( ) I samp ob [4] [2] = { sampU, 2), samp(3, 4 ) , sarnp(5, 6), samp(7, 8), samp(9, 10), samp (11, 12), samp(13, 14), sarnp(15, 16) 1; int i.; for(i=0; i<4 cout " ob[i] cout " ob[i] cout " ob[i] cout [0].get_a() " [0].get_b() " [l].get_a(J " ob[i] [l].get_b() " "\n" "\n" Jcout " "\n"; return 0; В этом примере конструктор samp имеет два аргумента. Здесь массив ob объяв-ляется и инициализируется в функции mainQ с помощью прямых вызовов кон-структора samp. Это необходимо, поскольку формальный синтаксис С++ позволяет одновременное использование только одного аргумента в разделяе-
112 Самоучитель С++ мом запятыми списке. При этом невозможно задать, например, два или более аргумента в каждом элементе списка. Поэтому если вы инициализируете массив объектов, имеющих конструктор с более чем одним аргументом, то вам следует пользоваться длинной формой инициализации вместо ее сокращенной формы. Вы всегда можете использовать длинную форму инициализации, даже при наличии у объекта конструктора с одним аргументом. Хотя для этого случая больше подходит сокращенная форма. Предыдущая программа выводит на экран следующее: I 2 3 4 5 6 7 8 9 10 II 12 13 14 15 16 Упражнения 1. Используя следующее объявление класса, создайте массив из 10 элементов и инициализируйте переменную ch значениями от А до J. Покажите, что мас-сив на самом деле содержит эти значения. ^include <iostream> using namespace std; class letters { char ch; public: letters (char c) { ch = c; } char get_ch() { return ch; } 2. Используя следующее объявление класса, создайте массив из 10 элементов, инициализируйте переменную num значениями от 1 до 10, а переменную sqr - квадратом num. ^include <iostream> using namespace std;
Глава 4. Массивы, указатели и ссылки 113 class squares { int num, sqr; public: squares(int a, int b) { num = a; sqr = b; } void show() {cout " num " ' ' " sqr " "\n"; } 3. Измените инициализацию переменной ch из упражнения 1 так, чтобы ис-пользовать ее длинную форму (т. е. чтобы конструктор letters явно вызывался в списке инициализации). 4.2. Использование указателей на объекты Как отмечалось в главе 2, доступ к объекту можно получить через указатель на этот объект. Как вы знаете, при использовании указателя на объект к членам объекта обращаются не с помощью оператора точка (.), а с помощью оператора стрелка (->). Арифметика указателей на объект аналогична арифметике указателей на данные любого другого типа: она выполняется относительно объекта. На-пример, если указатель на объект инкрементируется, то он начинает указы-вать на следующий объект. Если указатель на объект декрементируется, то он начинает указывать на предыдущий объект. Примеры ->г 1. Пример арифметики указателей на объекты; //Указатели на объекты #include <iostream> using namespace std; class samp ( int a, b; public: samp {int n, int m) { a = n; b = m; } int get_a() { return a; } int get_b() { return b; } int main ( ) samp ob[4] samp { 1 , 2 ) ,
114 Самоучитель C++ samp(3, 4), samp(5, 6), samp(7, 8) int i; samp *p; p = ob; //получение адреса начала массива for(i=0; i<4; i++) { cout " p->get_a(} " ' '; cout " p->get_b() " "\n"; P-H-; //переход к следующему объекту cout " "\n"; return 0; Эта программа выводит на экран следующее: 1 2 3 4 5 б : 7 8 Как видно из результата, при каждом инкрементировании указателя р он указывает на следующий объект массива. 1. Перепишите пример 1 так, чтобы на экран выводилось содержимое массива ob в обратном порядке. 2. Измените пример 3 раздела 4.1 так, чтобы получить доступ к двумерному массиву через указатель. Подсказка: в C++, как и в С, все массивы хранятся непрерывно, слева направо, от младшего элемента к старшему. 4.3. Указатель this C++ содержит специальный указатель this. Это указатель, который автоматиче-ски передается любой функции-члену при ее вызове и указывает на объект, ге-нерирующий вызов. Например, рассмотрим следующую инструкцию: ob.fl(); //предположим, что ob - это объект
Глава 4. Массивы, указатели и ссылки П5 Функции fl() автоматически передается указатель на объект ob. Этот указа-тель и называется this. Важно понимать, что указатель this передается только функциям-членам. Дружественным функциям указатель this не передается. 1. Как вы уже видели, если функция-член работает с другим членом того же класса, она делает это без уточнения имени класса или объекта. Например, исследуйте эту короткую программу, в которой создается простой класс inventory: //Демонстрация указателя this #include <j_ostream> ^include <cstring> using namespace std; class inventory { char item[20]; double cost; int on_hand; public: inventory(char *i, double c, int o) { strcpy(item, i); cost = c; on_hand = o; } void show(); }; void inventory::show() { cout " item; cout " ": $" " cost; cout " " On hand: " " on hand " "\n"; int main() inventory ob("wrench", 4.95, 4); ob.show(); return 0; 1
116 _ Самоучитель Обратите внимание, что внутри конструктора inventoryO и функции-члена show() переменные-члены item, cost и onjiand упоминаются явно. Так про-исходит потому, что функция-член может вызываться только в связи с объ-ектом. Следовательно, в данном случае компилятор "знает", данные какого объекта имеются в виду. Однако имеется еще более тонкое объяснение. Если вызывается функция-член, ей автоматически передается указатель this на объект, который являет-ся источником вызова. Таким образом, предыдущую программу можно пе-реписать так: //Демонстрация указателя this #include <iostream> ^include <cstring> using namespace std; class inventory { char item[20] ; double cost; int on_hand; public: inventory (char *i, double c, int o) { strcpy (this->item, i) ; //доступ к члену this->cost = с; //через this->on_hand = о; //указатель this 1 void show {) ; \ . void inventory: : show () { cout " this->item; //использование this для доступа к членам cout " ": $" " this->cost; cout " " On hand: " " this->on_hand " "\n"; int main() { inventory ob( "wrench", 4.95, 4); ob . show ( ) ; return 0; Здесь к переменным-членам объекта ob осуществляется прямой доступ через указатель this. Таким образом, внутри функции show() следующие две инст-рукции равнозначны:
Глава 4. Массивы, указатели и ссылки 117 cost = 123.23; thi3->cost = 123.23; На самом деле первая форма - это сокращенная запись второй. Пока, наверное, еще не родился программист C++, который бы использовал указатель this для доступа к членам класса так, как было показано, поскольку сокращенная форма намного проще, но здесь важно понимать, что под этим сокращением подразумевается. Использовать указатель this можно no-разному. Он особенно полезен при перегрузке операторов. Такое его применение более подробно будет изучать-ся в главе 6. На данный момент важно то, что по умолчанию всем функци-ям-членам автоматически передается указатель на вызывающий объект. Упражнеенниияя] 1. Дана следующая программа, переделайте все соответствующие обращения к членам класса так, чтобы в них явно присутствовал указатель this. ftinclude <iostream> using namespace std; class myclass { int a, b; public: myclass(int n, int m) { a = n; b = m; } int add() { return a + b; } void show(); void myclass::show(); int t; t = add(); //вызов функции-члена cout " t <<"\n"; int main () myclass ob(10, 14); ob.show (); -return 0;
118 Самоучитель C++ 4.4. Операторы new и delete До сих пор при выделении динамической памяти вы использовали функцию mallocQ, а при освобождении памяти - функцию free(). Вместо этих стан-дартных функций в C++ стал применяться более безопасный и удобный способ выделения и освобождения памяти. Выделить память можно с по-мощью оператора new, а освободить ее с помощью оператора delete. Ниже представлена основная форма этих операторов: p-var = new type; delete p-var; Здесь type ~ это спецификатор типа объекта, для которого вы хотите выде-лить память, a p-var - указатель на этот тип. New - это оператор, который возвращает указатель на динамически выделяемую память, достаточную для хранения объекта типа type. Оператор delete освобождает эту память, когда в ней отпадает необходимость. Вызов оператора delete с неправильным указа-телем может привести к разрушению системы динамического выделения памяти и возможному краху программы. Если свободной памяти недостаточно для выполнения запроса, произойдет одно из двух: либо оператор new возвратит нулевой указатель, либо будет сгенерирована исключительная ситуация. (Исключительные ситуации и обработка исключительных ситуаций описываются далее в этой книге. Ко-ротко об исключительной ситуации можно сказать следующее - это дина-мическая ошибка, которую можно обработать определенным образом.) В соответствии с требованиями языка Standart C++ по умолчанию оператор new должен генерировать исключительную ситуацию при невозможности удовлетворить запрос на выделение памяти. Если ваша программа не обра-батывает эту исключительную ситуацию, выполнение программы прекраща-ется. К сожалению, точные требования к тому, какие действия должны выполняться, если оператор new не в состоянии удовлетворить запрос на выделение памяти, за последние годы менялись несколько раз. Поэтому вполне возможно, что в вашем компиляторе реализация оператора new вы-полнена не так, как это предписано стандартом Standart C++. Когда C++ только появился, при невозможности удовлетворить запрос на выделение памяти оператор new возвращал нулевой указатель. В дальней-шем эта ситуация изменилась, и при неудачной попытке выделения памяти оператор new стал генерировать исключительную ситуацию. В конце концов было принято решение, что при неудачной попытке выделения памяти опе-ратор new будет генерировать исключительную ситуацию по умолчанию, а возвращение нулевого указателя останется в качестве возможной опции. Та-ким образом, реализация оператора new оказалась разной у разных произво-дителей компиляторов. К примеру, во время написания этой книги в компиляторе Microsoft Visual C++ при невозможности удовлетворить запрос на выделение памяти оператор new возвращал нулевой указатель, а в компи-ляторе Borland C++ генерировал исключительную ситуацию. Хотя в буду-
Глава 4. Массивы, указатели и ссылки 119 щем во всех компиляторах оператор new будет реализован в соответствии со стандартом Standart C++, в настоящее время единственным способом уз-нать, какие именно действия он выполняет при неудачной попытке выде-лить память, является чтение документации на компилятор. Поскольку имеется два возможных способа, которыми оператор new может сигнализировать об ошибке выделения памяти, и поскольку в разных ком-пиляторах он может быть реализован по-разному, в примерах программ этой книги сделана попытка удовлетворить оба требования. Во всех приме-рах значение возвращаемого оператором new указателя проверяется на равенство нулю. Такое значение указателя обрабатывается теми компилято-рами, в которых при неудачной попытке выделить память оператор new воз-вращает нуль, хотя никак не влияет на те, в которых оператор new генерирует исключительную ситуацию. Если в вашем компиляторе во время выполнения программы при неудачной попытке выделить память оператор new сгенерирует исключительную ситуацию, то такая программа просто за-вершится. В дальнейшем, когда вы ближе познакомитесь с обработкой ис-ключительных ситуаций, мы вернемся к оператору new, и вы узнаете, как лучше обрабатывать неудачные попытки выделения памяти. Вы также уз-наете об альтернативной форме оператора new, который при наличии ошиб-ки всегда возвращает нулевой указатель. И последнее замечание: ни один из примеров программ этой книги не дол-жен вести к ошибке выделения памяти при выполнении оператора new, по-скольку в каждой конкретной программе выделяется лишь считанное число байтов. Хотя операторы new и delete выполняют сходные с функциями malloc() и free() задачи, они имеют несколько преимуществ перед ними. Во-первых, оператор new автоматически выделяет требуемое для хранения объекта за-данного типа количество памяти. Вам теперь не нужно использовать sizeof, например, для подсчета требуемого числа байтов. Это уменьшает вероят-ность ошибки. Во-вторых, оператор new автоматически возвращает указа-тель на заданный тип данных. Вам не нужно выполнять приведение типов, операцию, которую вы делали, когда выделяли память, с помощью функции mallocQ (см. следующее замечание). В-третьих, как оператор new, так и опе-ратор delete можно перегружать, что дает возможность простой реализации вашей собственной, привычной модели распределения памяти. В-четвертых, допускается инициализация объекта, для которого динамически выделена память. Наконец, больше нет необходимости включать в ваши программы заголовок <cstdlib>. В языке С при присваивании указателю возвращаемого функцией mallocf) значения не требуется приведение типов, поскольку тип void *(тип возвра-щаемого функцией mallocf) указателя) автоматически преобразуется в тип.
120 Самоучитель C++ совместимый с типом указателя, стоящего слева от знака равенства. Однако для C++ этот случай не подходит. При использовании функции maflocf) тре-буется полное приведение типов. Смысл этого отличия в том, что оно позво-ляет C++ усилить контроль типа при возвращении функцией значения. Теперь, после введения операторов new и delete, они будут использоваться в программах вместо функций malloc() и free(). Примеры 1. Для начала рассмотрим программу выделения памяти для хранения целого: //Простой пример операторов new и delete ^include <iostream> using namespace std; int main() int *p; p = new int; //выделение памяти для целого !p) (cout " "Ошибка выделения памяти \n"; return 1; ,*р = 1000; cout " "Это целое, на которое указывает р: " " *р " "\п"; delete p; //освобождение памяти return 0; Обратите внимание, что возвращаемое оператором new значение перед использо-ванием проверяется. Как уже упоминалось, эта проверка имеет значение только в том случае, если в вашем компиляторе при неудачной попытке выделения памя-ти оператор new возвращает нулевой указатель. 2. Пример, в котором память объекту выделяется динамически: //Динамическое выделение памяти объектам # include <iostream> using namespace std; class samp { int i , j ; public: void set_ij (int a, int b) { i = a; j = b; }
Глава 4. Массивы, указатели и ссылки 121 int get_product() { return i*j; } int main() f samp *p; p = new samp; //выделение памяти объекту if(!p) 1 cout " "Ошибка выделения памяти\п"; return 1; c->v .-. ; j { 4, 5); "out " "Итог равен:" " p->getjproduct() " "\n"; return 0; Упражнеенниияя] 1. Напишите программу, в которой оператор new используется для динамиче-ского размещения переменных типа float, long и char. Задайте этим динамиче-ским переменным значения и выведите эти значения на экран. В завершение с помощью оператора delete освободите всю динамически выделенную область памяти. 2. Создайте класс для хранения своего имени и номера телефона. Используя оператор new, динамически выделите память для объекта этого класса и вве-дите имя и телефон в соответствующие поля внутри объекта. 3. Какими двумя способами оператор new может известить вас о неудачной по-пытке выделения памяти? 4.5. Дополнительные сведения об операторах new и delete В этом разделе обсуждаются два дополнительных свойства операторов new и delete. Во-первых, динамически размещаемому объекту может быть при-своено начальное значение. Во-вторых, можно создавать динамически раз-мещаемые массивы объектов. Вы можете присвоить динамически размещаемому объекту начальное зна-чение, используя следующую форму оператора new: p-var = new type (начальнов_зна"внив) ;
122_ Самоучитель C++ Для динамически размещаемого одномерного массива используйте такую форму оператора new: p-var = new type [size]; После выполнения этого оператора указатель p-var будет указывать на на-чальный элемент массива из size элементов заданного типа. Из-за разных чисто технических причин невозможно инициализировать массив, память для которого выделена динамически. Для удаления динамически размешенного одномерного массива вам следует использовать следующую форму оператора delete: delete [] p-var; При таком синтаксисе компилятор вызывает деструктор для каждого эле-мента массива. Это не приводит к многократному освобождению памяти по адресу, обозначенному указателем p-var, она освобождается только один раз. Для устаревших компиляторов в операторе delete было необходимо указы-вать в квадратных скобках размер освобождаемого массива. Так требовало исходное определение C++. В современных компиляторах задавать размер массива не нужно. i Примеры J 1. В следующей программе выделяется и инициализируется память для хране-ния целого: //Пример инициализации динамической переменной #include <iostream> using namespace std; int mainO { int *p; p = new int (9); //задание начального значения ргавного 9 cout " "Ошибка выделения памяти\п"; return 1; cout " "Это целое, на которое указывает р: " " *р " "\п";
Глава 4. Массивы, указатели и ссылки 123 delete p; //освобождение памяти return 0; Как и следовало ожидать, программа выводит на экран число 9, являющееся начальным значением переменной, на которую указывает указатель р. 2. Следующая программа инициализирует динамически размещаемый объект: //Динамическое выделение памяти объектам #include <iostream> using namespace std; class samp { int i, j; public: sampfint a, int b) { i = a; j = b; } int get_product(} { return i*j; } : int main(} samp *p; p = new samp(6, 5); //размещение объекта с инициализацией cout " "Ошибка выделения памяти\п"; return 1; cout " "Итог равен:" " p->get_product() " "\п"; delete p; return 0; iПри размещении объекта samp автоматически вызывается его конструктор, и объекту передаются значения 6 и 5, 3. В следующей программе размещается массив целых: //Простой пример использования операторов new и delete #include <iostream> using namespace std; int main ( ) int *p; p = new int [5]; //выделение памяти для 5 целых
124 _ Самоучитель C++ I/Убедитесь, что память выделена i f f ! p ) ! cout " "Ошибка выделения памяти\п" ; return 1; int i ; for(i=0; delete [] p; //освобождение памяти return 0; }Эта программа выводит на экран следующее: Это целое, на которое указывает р[0]: О Это целое, на которое указывает р[1]: 1 Это целое, на которое указывает р[2]: 2 Это целое, на которое указывает р[3]: 3 Это целое, на которое указывает р[4]: 4 4. В следующей программе создается динамический массив объектов: //Динамическое выделение памяти для массива объектов ^include <iostream> using namespace std; class samp ( int i, j; public: void set_ij(int a, int b) f i = a; j = b; } int get_product() { return i*j; } I; int main() i samp *p; int i ; p = new samp [10]; //размещение массива объектов cout " "Ошибка выделения памяти\n"; return 1;
Глава 4. Массивы, указатели и ссылки 125 for (i-0; i<10; p[i] .set_ij (i, for(i=0; cout " "Содержимое [" " i " "] равно: cout " p[i] .get_product ( ) " "\n"; delete [] p; return 0; Эта программа выводит на экран следующее: Содержимое [0] Содержимое [1] Содержимое [2] Содержимое [3] Содержимое [4] Содержимое [5] Содержимое [6] Содержимое [7] Содержимое [8] Содержимое [9] равно: О равно: 1 равно: 4 равно: 9 равно: 16 равно: 25 равно: 36 равно: 49 равно: 64 равно: 81 5. В новой версии предыдущей программы в нее вводится деструктор samp и теперь при освобождении памяти, обозначенной указателем р, для каждого элемента массива вызывается деструктор: //Динамическое выделение памяти для массива объектов ^include <iostream> using namespace std; class samp { int i, j; public: void set_ij (int a, int b) { i = a; j -b; } -sampO { cout " "Удаление объекта ... \n"; } int get_product ( ) { return i*j; } int main ( ) /samp *p; int i; p = new samp [10]; //размещение массива объектов cout " "Ошибка выделения памяти\п"; return 1;
7 26 Самоучитель C++ for(i=0; i cout " "Содержимое [" " i " "] равно:"; cout " p[i] .get_product (} " "\n"; } delete [J p; return 0; Эта программа выводит на экран следующее: Содержимое [0] равно: О Содержимое [ 1 ] равно : 1 Содержимое [2] равно: 4 Содержимое [3] равно: 9 Содержимое [4] равно: 16 Содержимое [5] равно: 25 Содержимое [ 6 ] равно : 3 б Содержимое [7] равно: 49 Содержимое [8] равно: 64 Содержимое [9] равно: 81 Удаление объекта . . . Удаление объекта . . . Удаление объекта... Удаление объекта . . . Удаление объекта. . . Удаление объекта. . . Удаление объекта . . . Удаление объекта. . . Удаление объекта. . . Удаление объекта. . . Как видите, деструктор samp вызывается десять раз - по разу на каждый элемент массива. 1. Переделайте данную программу так, чтобы в ней использовался оператор new. char *p; р -( char *) rnalloc(lOO) ; //... strcpyip, "Это проверка"); Подсказка. Строка - это просто массив символов.
Глава 4. Массивы, указатели и ссылки 127 2. Используя оператор new, покажите, как динамически разместить переменную типа double и передать ей начальное значение -123.0987. 4.6. Ссылки В C++ есть элемент, родственный указателю - это ссылка (reference). Ссыл-ка является скрытым указателем и во всех случаях, и для любых целей ее можно употреблять просто как еще одно имя переменной. Ссылку допусти-мо использовать тремя способами. Во-первых, ссылку можно передать в функцию. Во-вторых, ссылку можно возвратить из функции. Наконец, можно создать независимую ссылку. В книге рассмотрены все эти примене-ния ссылки, начиная со ссылки в качестве параметра функции. Несомненно, наиболее важное применение ссылки -- это передача ее в ка-честве параметра функции. Чтобы помочь вам разобраться в том, что такое параметр -ссылка и как он работает, начнем с программы, в которой пара-метром является указатель (а не ссылка): ^include <iostream> using namespace std; void f(int *n) ; //использование параметра-указателя int main ( ) int i = 0; cout " "Новое значение i: " " i " 'nV; return 0; } void f (int *n) ( *n = 100; //занесение числа 100 в аргумент, //на который указывает указатель п \ Здесь функция f() загружает целое значение 100 по адресу, который обозна-чен указателем п. В данной программе функция f() вызывается из функции main() с адресом переменной i. Таким образом, после выполнения функции f() переменная i будет содержать число 100. В этой программе показано, как использовать указатель для реализации ме-ханизма передачи параметра посредством вызова по ссылке (call by reference). В программах С такой механизм является единственным спосо-
128 _ Самоучитель C++ бом добиться вызова функции по ссылке. Однако в C++ с помощью пара-метра-ссылки можно полностью автоматизировать весь процесс. Чтобы уз-нать, как это сделать, изменим предыдущую программу. В ее новой версии используется параметр -ссылка: ^include <iostream> using namespace std; void f (int &n) ; //объявление параметра -ссылки int main ( ) ( int i = 0; f (i); cout " "Новое значение i: " " i " 'n\'; return 0; //Теперь в функции f ( ) используется параметр-ссылка void f(int &n) ( //отметьте, что в следующей инструкции знак * не требуется п = 100; //занесение числа 100 в аргумент, //используемый при вызове функции f{) Тщательно проанализируйте эту программу. Во-первых, для объявления пара-метра-ссылки перед именем переменной ставится знак амперсанда (&). Таким образом, переменная п объявляется параметром функции f(). Теперь, по-скольку переменная п является ссылкой, больше не нужно и даже неверно указывать оператор *. Вместо него всякий раз, когда переменная п упоминает-ся внутри функции f(), она автоматически трактуется как указатель на аргу-мент, используемый при вызове функции f(). Это значит, что инструкция фактически помещает число 100 в переменную, используемую при вызове функции f(), каковой в данном случае является переменная i. Далее, при вызове функции f() перед аргументом не нужно ставить знак &. Вместо этого, поскольку функция f() объявлена как получающая параметр-ссылку, ей автоматически передается адрес аргумента. Повторим, при использовании параметра-ссылки компилятор автоматиче-ски передает функции адрес переменной, указанной в качестве аргумента. Нет необходимости (а на самом деле и не допускается) получать адрес аргу-мента с помощью знака &. Более того, внутри функции компилятор автома-
Глава 4. Массивы, указатели и ссылки _ 129 тически использует переменную, на которую указывает параметр -ссылка, Нет необходимости (и опять не допускается) ставить знак *. Таким образом, параметр-ссылка полностью автоматизирует механизм передачи параметра посредством вызова функции по ссылке. Важно понимать следующее: адрес, на который указывает ссылка, вы изме-нить не можете. Например, если в предыдущей программе инструкция находилась бы внутри функции f(), ссылка п по-прежнему указывала бы на переменную i в функции main(). Вместо инкрементирования адреса, на ко-торый указывает ссылка п, эта инструкция инкрементирует значение пере-менной (в данном случае это переменная i). Параметры-ссылки имеют несколько преимуществ по сравнению с анало-гичными (более или менее) альтернативными параметрами-указателями. Во-первых, с практической точки зрения нет необходимости получать и передавать в функцию адрес аргумента. При использовании параметра-ссылки адрес передается автоматически. Во-вторых, по мнению многих программистов, параметры-ссылки предлагают более понятный и элегант-ный интерфейс, чем неуклюжий механизм указателей. В-третьих, как вы увидите в следующем разделе, при передаче объекта функции через ссылку копия объекта не создается. Это уменьшает вероятность ошибок, связанных с построением копии аргумента и вызовом ее деструктора. ' Примеры "-^ 1. Классическим примером передачи аргументов по ссылке является функция, меняющая местами значения двух своих аргументов. В данном примере в функции swapargs() ссылки используются для того, чтобы поменять местами два ее целых аргумента: ^include <iostream> using namespace std; void swapargs(int &x, int £y) ; int main() i int i, j; i = 10; j = 19; cout " "i: " " i " ", "; cout " "j: " " j " "\n"; swapargs(i, j) ;
730 Самоучитель C++ cout " "После перестановки: "; cout " "i: " " i " ", "; cout " "j: " " j " "\n"; return 0; void swapargs(int &x, int &y} { int t; t = x; x = y; Если бы при написании функции swapargsQ вместо ссылок использовались указатели, то функция выглядела бы следующим образом: void swapargsfint *x, int *y) | int t; Jс--- *v .л, *х = *у; *у = t; Как видите, благодаря использованию ссылок в функции swapargs(), отпадает необходимость указывать знак *. 2. В следующей программе с помощью функции round() округляется значение типа double. Округляемое значение передается по ссылке. ^include <iostream> ^include <cmath> using namespace std; void round (double &num) ; int main ( ) iouble i = 100.4; :>ut " i " "после округления "; >und ( i ) ; i_ .at " i " "\n"; л = 10.9; cout " i " "после округления "; round ( i ) ; cout " i " "\n";
Глава 4. Массивы, указатели и ссылки _ 131 return 0; } void round (double snum) { double frac; double val; //разложение num на целую и дробную части frac = modf(num, &val); ifffrac < 0.5) num = val; else num = val + 1.0; В функции rou n (1 0 для разложения числа на целую и дробную части указана редко используемая функция modf(). Возвращаемым значением этой функ-ции является дробная часть; целая часть помещается в переменную, на кото-рую указывает второй параметр функции modf(). Упражнения! 1. Напи^ш>ите функцию neg(), которая меняет знак своего целого параметра на противоположный. Напишите функцию двумя способами: первый - исполь-зуя параметр-указатель и второй - параметр-ссылку. Составьте короткую программу для демонстрации обеих функций. 2. Что неправильно в следующей программе? //В этой программе есть ошибка #include <iostream> using namespace std; void triple(double Snum); int main() { double d = 7.0; tripleUd) ; cout " d; return 0; //Утроение значения числа void triple(double Snum}
132 Самоучитель C++ num = 3 * num; 3. Перечислите преимущества параметров-ссылок. 4.7. Передача ссылок на объекты Как вы узнали из главы 3, если объект передается функции по значению, то в функции создается его копия. Хотя конструктор копии не вызывается, при возвращении функцией своего значения вызывается деструктор копии. Повторный вызов деструктора может привести в некоторых случаях к серь-езным проблемам (например, при освобождении деструктором динамиче-ской памяти). Решает эту проблему передача объекта по ссылке. (Другое решение, о кото-ром будет рассказано в главе 5, подразумевает использование конструктора копий.) При этом копия объекта не создается, и поэтому при возвращении функцией своего значения деструктор не вызывается. Тем не менее, запом-ните: изменения объекта внутри функции влияют на исходный объект, ука-занный в качестве аргумента функции. Очень важно понимать, что ссылка не указатель, хотя она и указывает на ад-рес объекта. Поэтому при передаче объекта по ссылке для доступа к его членам используется оператор точка (.), а не стрелка (->}. Примеры 1. В следующем примере на экран выводится значение, передаваемое объекту по ссылке, но сначала рассмотрим версию программы, в которой объект ти-па myclass() передается в функцию f() по значению: ^include <iostream> using namespace std; class myclass { int who; public: myclass(int n) ( who = n; cout " "Работа конструктора " " who " "\n";
Глава 4. Массивы, указатели и ссылки _ 133 ~myclass() { cout " "Работа деструктора " " who " "\n"; } int id(} { return who; } ): i 1 1 о передается по значению void f(myclass о) { cout " "Получено" " o . i d l ) " "\n"; int main() { myclass x(l) ; f Cx); return 0; Эта функция выводит на экран следующее: Работа конструктора 1 Получено 1 Работа деструктора 1 Работа деструктора 1 Как видите, деструктор вызывается дважды: первый раз, когда после выпол-нения функции f() удаляется копия объекта 1, а второй раз - по окончании программы. С другой стороны, если изменить программу так, чтобы использовать параметр-ссылку, то копия объекта не создается и поэтому после выполнения функции f() деструктор не вызывается: #include <iostream> using namespace std; class myclass { int who; public: myclass(int n) { who = n; cout " "Работа конструктора " " who " "\n"; }~myclass() { cout " "Работа деструктора " " who " "\n"; } int id (){ return who; } }; //Теперь о передается по ссылке void f(myclass So)
134 Самоучитель C++ I I отметьте, что по-прежнему используется оператор cout " "Получено" " o.id() " "\п"; int main(} myclass х (1); f i x ) ; return 0; Эта версия предыдущей программы выводит на экран следующее: Работа конструктора 1 Получено 1 Работа деструктора 1 Для доступа к членам объекта по ссылке следует указывать оператор точка (.), а не стрелка (->). Упражневнниияя) 1. Что неправильно в следующей программе? Покажите, как она может быть исправлена с помощью параметра-ссылки. //В этой программе есть ошибка ^include <iostream> ^include <cstring> ^include <cstdlib> using namespace std; class strtype { char *p; public: strtype (char *s) ; -strtype { ) { delete [ ] p; } char *get{) { return p; } strtype: istrtype (char *s) ( int 1;
Глава 4. Массивы, указатели и ссылки _ 735 1 = strlen(s) + 1; р = new char [1] ; i f ( ! p ) ( cout " "Ошибка выделения памяти\п"; exit (1) ; }strcpy{p, s); } void show(strtype x) I char *s; s = x.get () ; cout " s " "\n"; int main() ( strtype а {"Привет") , b( "Здесь") show (a) ; show(b) ; return 0; 4.8. Ссылка в качестве возвращаемого значения функции Функция может возвращать ссылку. Как вы увидите в главе 6, возвращение ссылки может оказаться полезным при перегрузке операторов определенных типов. Кроме этого возвращение ссылки позволяет использовать функцию слева в инструкции присваивания. Это приводит к важному и неожиданно-му результату. 1. Для начала, простая программа с функцией, которая возвращает ссылку: //Простой пример ссылки в качестве возвращаемого значения функции ^include <iostream> using namespace std;
136 _ Самоучитель C++ int sf 0 ; int x; int main ( ) { f ( ) = 100; //присваивание 100 ссылке, возвращаемой функцией f () cout " x " "\n"; return 0; //Возвращение ссылки на целое int &f (} { return x; //возвращает ссылку на х } Здесь функция f() объявляется возвращающей ссылку на целое. Внутри тела функции инструкция return х; не возвращает значение глобальной переменной х, она автоматически воз-вращает адрес переменной х (в виде ссылки). Таким образом, внутри функ-ции main() инструкция f ( ) = 100; заносит значение 100 в переменную х, поскольку функция f() уже возвратила ссылку на нее. Повторим, функция f() возвращает ссылку. Когда функция f() указана слева в инструкции присваивания, то таким образом слева оказывается ссылка на объект, которую возвращает эта функция. Поскольку функция Г() возвращает ссылку на переменную х (в данном примере), то эта переменная х и получает значение 100. 2. Вам следует быть внимательными при возвращении ссылок, чтобы объект, на который вы ссылаетесь, не вышел из области видимости. Например, рас-смотрим эту, слегка переделанную функцию f(): //Возвращение ссылки на целое int &f{) { int x; //х - локальная переменная return х; //возвращение ссылки на х В этом случае х становится локальной переменной функции f() и выходит из области видимости после выполнения функции. Это означает, что ссылку, возвращаемую функцией f(), уже нельзя использовать.
Глава 4 . Массивы, указатели и с с ы л к и 1 3 7 Некоторые компиляторы C++ не позволяют возвращать ссылки на локальные переменные. Тем не менее, эта проблема может проявиться по-другому, на-пример, когда память для объектов выделяется динамически. 3. В качестве возвращаемого значения функции ссылка может оказаться полез-ной при создании массива определенного типа - так называемого защищен-ного массива (bounded array). Как вы знаете, в С и C++ контроль границ массива не производится. Следовательно, имеется вероятность при заполне-нии массива выйти за его границы. Однако в C++ можно создать класс массива с автоматическим контролем границ (automatic bounds checking). Любой класс массива содержит две основные функции - одну для запоми-нания информации в массиве и другую для извлечения информации. Имен-но эти функции в процессе работы могут проверять, не нарушены ли границы массива. Следующая программа реализует контроль границ символьного массива: //Пример защищенного массива #include <iostream> #include <cstdlib> using namespace std; class array { int size; char *p; public: array (int num) ; ~ array () ( delete [] p; } char sput {int i) ; char get (int i) ; array: rarray (int num) { p = new char [num] ; ifUp) ( cout " "Ошибка выделения памяти\п"; exit (1) ; }size = num; I : //Заполнение массива char Sarray: :put (int i)
138 Самоучитель C++ | i>=size) { cout " "Ошибка, нарушены границы массива! ! !\n" exit(l) ; }return p[i]; //возврат ссылки на p[i] //Получение чего-нибудь из массива char array: :get (int i) { if (i<0 ! I i>=size) { cout " "Ошибка, нарушены границы массива! ! !\n" exit (1) ; }return p[i]; //символ возврата int main{) , array a {10} ; a.put(3) = 'X'; a.put(2) = 'R'; cout " a.get{3) " a. get (2); cout " "\n"; /* теперь генерируем динамическую ошибку, связанную с нарушением границ массива */a.put(ll) = '! '; return 0; J Это был пример практического применения ссылок в качестве возвращае-мого значения функций, и вам следует тщательно его изучить. Отметьте, что функция put() возвращает ссылку на элемент массива, заданный параметром i. Если индекс, заданный параметром i, не выходит за границы массива, то чтобы поместить значение в массив, эту ссылку можно использовать слева в инструкции присваивания. Обратной функцией является функция get(), ко-торая возвращает заполненное по заданному индексу значение, если этот ин-декс находится внутри диапазона. При таком подходе к работе с массивом он иногда упоминается как безопасный массив (safe array). Имеется еще одна вещь, которую следует отметить в предыдущей програм-ме, - это использование оператора new для динамического выделения памя-ти. Этот оператор дает возможность объявлять массивы различной длины. Как уже упоминалось, способ контроля границ массива, реализованный в программе, является примером практического применения C++. Если вам
Глава 4, Массивы, указатели и ссылки 139 необходимо во время работы программы проверять границы массива, такой способ позволяет вам легко этого добиться. Тем не менее, запомните: кон-троль границ замедляет доступ к массиву. Поэтому контроль границ лучше включать в программу только в том случае, если имеется высокая степень вероятности нарушения границ массива. Упражнения 1. Напишите программу, которая создает безопасный двумерный (2x3) массив целых. Покажите, как она работает. 2. Правилен ли следующий фрагмент? Если нет, то почему? int fifО; int *x; х = f ( ) ; 4.9. Независимые ссылки и ограничения на применение ссылок Хотя они обычно и не используются, вы можете создавать независимые ссыл-ки (independent reference). Независимая ссылка - это ссылка, которая во всех случаях является просто другим именем переменной. Поскольку ссылкам нельзя присваивать новые значения, независимая ссылка должна быть ини-циализирована при ее объявлении. Поскольку независимые ссылки все-таки иногда используются, важно, чтобы вы имели о них представление. Однако большинство программистов чувству-ет их ненужность, они просто добавляют неразберихи в программу. Более того, независимые ссылки существуют в C++ только потому, что пока не было достаточного повода избавиться от них. Как правило, их следует из-бегать. Имеется несколько ограничений, которые относятся к ссылкам всех типов. Нельзя ссылаться на другую ссылку. Нельзя получить адрес ссылки. Нельзя создавать массивы ссылок и ссылаться на битовое поле. Ссылка должна быть инициализирована до того, как стать членом класса, возвратить значе-ние функции или стать параметром функции.
440 Самоучитель C++ Ссылки похожи на указатели, но это не указатели. 1. Пример программы с независимой ссылкой: ^include <iostream> using namespace std; int main() { int x; : int &ref = x; //создание независимой ссылки x = 10; //эти две инструкции ref = 10; //функционально идентичны ref = 100; //здесь дважды печатается число 100 cout " х " ' ' " ref <<"\n"; return 0; В этой программе независимая ссылка ref служит другим именем перемен-ной х. С практической точки зрения ref и х идентичны. 2. Независимая ссылка может ссылаться на константу. Например, следующая инструкция вполне допустима: const int &ref = 10; В ссылках такого типа выгода невелика, но иногда их можно встретить в программах. Упражнеенниияя] 1. Попытайтесь найти полезное применение для независимой ссылки.
Глава 4. Массивы, указатели и ссылки LПроверка усвоения материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы: 1. Ниже представлен класс a_type. Создайте двумерный, два на пять, массив и дайте каждому элементу массива начальное значение по своему выбору. Затем выведите содержимое массива на экран. class a_type { double a, b; public: a_type(double x, double y) { a = x; b = y; } void show() { cout " a " ' ' " b " "\n"; } ); 2. Модифицируйте решение предыдущей задачи так, чтобы доступ к масси-ву осуществлялся через указатель. 3. Что такое указатель this? 4. Покажите основные формы операторов new и delete. Какие преимущества они дают в сравнении с функциями malloc() и free()? 5. Что такое ссылка? Какое можно получить преимущество от использования ссылки в качестве параметра? 6. Создайте функцию recipQ, которая получает один параметр-ссылку на зна-чение типа double. Эта функция должна изменить значение своего пара-метра на обратное. Напишите программу вывода на экран результатов работы функции. Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Пусть дан указатель на объект. Какой оператор использовать для доступа к члену объекта? 2. В главе 2 была создана программа с классом strtype, в которой память для строки выделялась динамически. Переделайте программу (показан-ную здесь для удобства) так, чтобы в ней использовались операторы new и delete.
142 _ Самоучитель C++ #include <iostream> ^include <cstring> linclude <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype (char *ptr) ; -strtype {) ; void showf) ; ); strtype: : strtype (char *ptr) { len = strlen(ptr) p=(char *} malloc (len+1) ; if(ip) { cout " "Ошибка выделения памяти \п"; exit{l) ; strcpy(p, ptr) ; strtype : : -strtype ( ) { cout " "Освобождение памяти по адресу р\п"; free (p) ; } void strtype: : show () { cout " p " " - длина: " " len; cout " "\n"; }int main { ) ( strtype si {"Это проверка") , з2("Мне нравится C++"); si .show () ; s2 . show ( ) ; return 0; 3. Переделайте любую программу из предьщущей главы так, чтобы в ней использовались ссылки.
Глава 5 Перегрузка функций В этой главе вы более подробно изучите перегрузку функций. Хотя с этой темой вы уже встречались, имеется несколько дополнительных аспектов, с которыми необходимо познакомиться. Здесь вы найдете ответы на следую-щие вопросы: как перегрузить конструктор, как создать конструктор копий, как функции передать аргументы по умолчанию, как можно избежать неод-нозначности при перегрузке функций. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Что такое ссылка? Приведите две важных области применения ссылок? 2. Покажите, как с помощью оператора new выделить память для значений типа float и int. Покажите также, как освободить память с помощью опе-ратора delete. 3. Какова основная форма оператора new, используемая для инициализации динамических переменных? Приведите конкретный пример. 4. Дан следующий класс. Как инициализировать массив из десяти элемен-тов так, чтобы переменная х получила значения от 1 до 10 включительно. Class samp ( int x; public: sump(int i) { x = n; } int getx () [ return x; } 5. Перечислите достоинства и недостатки параметров-ссылок. 6. Может ли быть инициализирован массив, память для которого выделяет-ся динамически?
144 Самоучитель C++ 7. На основе следующего прототипа создайте функцию mag(), повышаю-щую порядок значения переменной mim до того уровня, который задан переменной order: void mag(long Snum, long order); Например, если переменная num равна 4, а переменная order равна 2, то после выполнения функции mag() переменная num должна стать равной 400. Напишите демонстрационную программу, показывающую, что функция работает. 5.1. Перегрузка конструкторов В программах на C++ перегрузка конструктора класса вполне обычна. (Деструктор, однако, перегружать нельзя.) Имеется три основных причины перегрузки конструктора, которая, как правило, выполняется либо для обеспечения гибкости, либо для поддержки массивов, либо для создания конструкторов копий. В этом разделе рассказывается об обеспечении гибко-сти и поддержке массивов, а о конструкторах копий - в следующем. Перед изучением примеров необходимо запомнить одну вещь: каждому спо-собу объявления объекта класса должна соответствовать своя версия конст-руктора класса. Если эта задача не решена, то при компиляции программы обнаружится ошибка. Именно поэтому перегрузка конструктора столь обычна для программ C++. Гу_ . имеры :: Вероятно, наиболее частое использование перегрузки конструктора - это обеспечение возможности выбора способа инициализации объекта. Напри-мер, в следующей программе объекту ol дается начальное значение, а объек-ту о2 - нет. Если вы удалите конструктор с пустым списком аргументов, программа не будет компилироваться, поскольку у неинициализируемого объекта типа samp не будет конструктора. И наоборот, если вы удалите кон-структор с параметром, программа не будет компилироваться, поскольку не будет конструктора у инициализируемого объекта типа samp. Для правильной компиляции программы необходимы оба конструктора. ^include <iostream> using namespace std; class myclass { int x; public: //перегрузка конструктора двумя способами myclass{} { x = 0; J //нет инициализации
Глава 5. Перегрузка функций 745 myclass(int n) { x = n; } //инициализация int getx() { return x; } }; int main() myclass ol(10); //объявление с начальным значением myclass o2; //объявление без начального значения cout " "ol: " " ol.getxO " '\п'; cout " "о2: " " o2,getx() " '\п'; return 0; 2. Другой традиционный довод в пользу перегрузки конструктора состоит в том, что такая перегрузка позволяет сосуществовать в программе как отдель-ным объектам, так и массивам объектов. Как вы, наверное, знаете по своему опыту программирования, вполне обычно инициализировать отдельную пе-ременную, тогда как инициализация массива встречается достаточно редко. (Гораздо чаще элементам массива присваиваются их значения в зависимости от информации, получаемой уже при выполнении программы.) Таким обра-зом, для сосуществования в программе неинициализированных массивов объектов наряду с инициализированными объектами вы должны использо-вать конструктор, который поддерживает инициализацию, и конструктор, который ее не поддерживает. Например, для класса myclass из примера 1 оба этих объявления правильны: myclass ob{10); myclass ob[5]; Обеспечив наличие обоих конструкторов (с параметрами и без параметров), вы в своей программе получаете возможность создавать объекты, которые при необходимости можно либо инициализировать, либо нет. Естественно, что после определения конструктора с параметрами и конст-руктора без параметров, их можно использовать для создания инициализиро-ванных или неинициализированных массивов. Например, в следующей программе объявляются два массива типа myclass; при этом один из них инициализируется, а другой нет: ^include <iostream> using namespace std; class myclass { int x; public: //перегрузка конструктора двумя способами myclass!) { x = 0; } //нет инициализации
146 _ Самоучитель C++ myclass(int n) { x = n; } //инициализация int getx() { return x; } int main () { myclass ol[10]; //объявление массива без инициализации //объявление с инициализацией myclass o2[10] = {1,2,3,4,5,6,7,8,9,10}; int i; for(i=0; i<10; i++} { cout " "ol[ " " i " "]:" " ol [i] . getx ( ) ; cout " ' \n' ; cout " "o2 [ " " i " "]:" " o2 [i] . getx ( ) ; cout " '\n' ; return 0; В этом примере все элементы массива ol конструктор устанавливает в нуль. Элементы массива о2 инициализируются так, как показано в программе. 3. Другой довод в пользу перегрузки конструкторов состоит в том, что такая перегрузка позволяет программисту выбрать наиболее подходящий метод инициализации объекта. Чтобы понять, как это делается, рассмотрим сле-дующий пример, в котором создается класс для хранения календарной даты. Конструктор datcQ перегружается двумя способами. В первом случае данные задаются в виде строки символов, в другом - в виде трех целых. ^include <iostream> #include <cstdio> //заголовок для функции sscanfO using namespace std; class date { int day, month, year; public: date (char *str) ; date (int m, int d, int y) { day = d; month = m; year = y,-} void show() { cout " month " ' /' " day " ' /' ;
Глава 5. Перегрузка функций 14_7_ cout " year " '\n'; ) }; date::date{char *str) { sscanf(str, "%d%*c%d%*c%d", smonth, £day, Syear); } int main (} { //использование конструктора для даты в виде строки date sdate("ll/l/92"); //использование конструктора для даты в виде трех целых date idatefll, I, 92) ; sdate.showO ; idate.show(); return 0; } Преимущество перегрузки конструктора date(), как показано в программе, в том, что вы можете выбрать ту версию инициализации, которая лучше всего подходит к текущей ситуации. Например, если объект типа date создается в ре-зультате пользовательского ввода, то проще использовать строковую версию. Однако если объект типа date строится путем каких-то простых внутренних расчетов, то версия с тремя целыми параметрами становится, вероятно, более привлекательной. Хотя конструктор можно перегружать любое количество раз, лучше этим не злоупотреблять. С точки зрения стилистики, конструктор имеет смысл пе-регружать только тогда, когда такая перегрузка позволяет адаптировать про-грамму к часто встречающимся ситуациям. Например, еще одна перегрузка конструктора date() для ввода трех восьмеричных целых вряд ли будет иметь какой-то смысл. Однако перегрузка конструктора date() для доступа к объек-ту типа time_t (тип данных для хранения системных даты и времени) могла бы оказаться весьма полезной. (См. упражнения для проверки усвоения ма-териала данной главы, где приведен именно такой пример.) 4. Другая ситуация, в которой вам потребуется перегрузить конструктор класса, возникает при выделении динамической памяти массиву объектов этого класса. Как вы должны были узнать из предыдущей главы, динамический массив не может быть инициализирован. Поэтому, если в классе есть ини-циализирующий конструктор, вам необходимо включить туда и его перегру-женную версию без инициализации. Например, ниже приведена программа, в которой массиву объектов динамически выделяется память: ^include <iostream> using namespace std;
148 _ Самоучитель C++ class myclass { int x; public: //перегрузка конструктора двумя способами myclass () { x = 0; } //нет инициализации myclass (int n) { x = n; } //инициализация int getx{) ( return x; } void setx(int n) { x = n; } 1; int mainO myclass *p; myclass ob(10); //инициализация отдельной переменной p = new myclass [10]; //здесь инициализировать нельзя if(!p) { cout " "Ошибка выделения памяти\п"; return 1; int i ; //инициализация всех элементов значением ob for(i=0; i<10; i++) p[i] = ob; for(i=0; cout " "p[ " " i " "]:" " p[i].getx cout " '\n' ; return 0; I Без перегруженной версии конструктора myclass(), в которой отсутствует инициализация, оператор new при компиляции вызвал бы ошибку. Упражнения 1. Дано неполное определение класса: class strtype { char *p; int len; public: char *getstring() { return p; } int getlength{) { return len; }
Глада 5. Перегрузка функций 149 Добавьте в это определение два конструктора. В первом не должно быть па-раметров. Он должен выделять 255 байтов памяти (с помощью оператора new), инициализировать эту память нулевой строкой и устанавливать пере-менную len равной 255. Во втором конструкторе должно быть два параметра. Первый - это строка, используемая при инициализации, второй - число выделяемых байтов. Во второй версии конструктора должно выделяться за-данное количество памяти, в которую должна помещаться копия строки. Не-обходимо реализовать полный контроль границ массива и, разработав короткую программу вывода, показать, что оба конструктора работают так, как это было задумано. 2. В главе 2, раздел 2.1, упражнение 2 вы создали эмулятор секундомера. Мо-дифицируйте ваше решение так, чтобы в классе stopwatch был и конструктор без параметров (как это уже сделано) и его перегруженная версия для досту-па к системному времени через стандартную функцию clockQ. Покажите, что внесенные изменения работают. 3. Подумайте о том, каким образом перегруженный конструктор может быть полезен для ваших собственных программных задач. 5.2. Создание и использование конструкторов копий Одной из важнейших форм перегруженного конструктора является конст-руктор копий (copy constructor). Как показано в многочисленных примерах из предыдущих глав, передача объектов функциям и их возвращение из функ-ций могут привести к разного рода проблемам. В этом разделе вы узнаете, что одним из способов обойти эти проблемы является определение конст-руктора копий. Для начала давайте обозначим проблемы, для решения которых предназна-чен конструктор копий. Когда объект передается в функцию, делается по-разрядная (т. е. точная) копия этого объекта и передается тому параметру функции, который получает объект. Однако бывают ситуации, в которых такая точная копия объекта нежелательна. Например, если объект содержит указатель на выделенную область памяти, то в копии указатель будет ссы-латься на ту же самую область памяти, на которую ссылается исходный указатель. Следовательно, если копия меняет содержимое области памяти, то эти изменения коснутся также и исходного объекта! Кроме того, когда выполнение функции завершается, копия удаляется, что приводит к вызову деструктора этой копии. Вызов деструктора может привести к нежелатель-ным побочным эффектам, которые в дальнейшем повлияют на исходный объект. Сходная ситуация имеет место, когда объект является возвращаемым значе-нием функции. Как правило, компилятор генерирует временный объект для хранения возвращаемого функцией значения. (Это происходит автоматиче-
150 Самоучитель C++ ски и незаметно для вас.) Как только значение возвращается в вызывающую процедуру, временный объект выходит из области видимости, что приводит к вызову деструктора временного объекта. Однако если деструктор удаляет что-то необходимое в вызывающей процедуре (например, если он освобож-дает динамически выделенную область памяти), то это также приводит к проблемам. В основе этих проблем лежит факт создания поразрядной копии объекта. Для решения задачи вам, как программисту, необходимо предварительно определить все то, что будет происходить при образовании копии объекта, и таким образом избежать неожиданных побочных эффектов. Способом до-биться этого является создание конструктора копий. Путем определения такого конструктора вы можете полностью контролировать весь процесс об-разования копии объекта. Важно понимать, что в C++ точно разделяются два типа ситуаций, в кото-рых значение одного объекта передается другому. Первая ситуация - это присваивание. Вторая - инициализация, которая может иметь место в трех случаях: а Когда в инструкции объявления объекта один объект используется для инициализации другого а Когда объект передается в функцию в качестве параметра а Когда в качестве возвращаемого значения функции создается временный объект Конструктор копий употребляется только для инициализации, но не для присваивания. По умолчанию при инициализации компилятор автоматически генерирует код, осуществляющий поразрядное копирование. (То есть C++ автоматиче-ски создает конструктор копий по умолчанию, который просто дублирует инициализируемый объект.) Однако путем определения конструктора копий вполне возможно предварительно задать то, как один объект будет инициа-лизировать другой. После того как конструктор копий определен, он вызы-вается всегда при инициализации одного объекта другим. Конструкторы копий никак не влияют на операции присваивания. Ниже показана основная форма конструктора копий: имя_класса (const нмя_класса Sobj) { //тело конструктора
Глава 5. Перегрузка функций 151 Здесь obj - это ссылка на объект, предназначенный для инициализации другого объекта. Например, пусть имеется класс myclass. а у - это объект типа myclass, тогда следующие инструкции могли бы вызвать конструктор копий myclass: myclass x=y; //у явно инициализирует х fund (у); //у передается в качестве параметра y=func2(); //у получает возвращаемый объект В двух первых случаях конструктору копий можно было бы передать ссылку на объект у. В последнем случае конструктору копий передается ссылка на объект, возвращаемый функцией funcZQ 1. В данном примере показано, почему необходимо явное определение конст-руктора копий. В этой программе создается простейший "безопасный" мас-сив целых, в котором предотвращена возможность нарушения границ массива. Память для массива выделяется с помощью оператора new, а указа-тель на эту память поддерживается внутри каждого объекта-массива. /* В этой программе создается класс "безопасный" массив. Поскольку память для массива выделяется динамически/то, когда один массив используется для инициализации другого, для выделения памяти создается конструктор копий V^include <iostrearn> #include <cstdlib> using namespace std; class array { int *p; int size; publ i с : array (int sz) { //конструктор p=new int [sz] ; if(!p) exitU); size=sz; cout " "Использование обычного конструктора \п" ; ~ array ( ) (delete [] p;} //конструктор копий array{const array &a) ; void put(int i, int j) { if(i>=0 5& i<size) p[i]=j; }
152 _ Самоучитель C++ int get(int i) { return p[i] ; /* Конструктор копий Память выделяется специально для копии, и адрес этой памяти передается в указатель р. Следовательно, указатель р больше не ссылается на ту же самую, где находится исходный объект, динамически выделенную область памяти: */array: :array (const array &a) { int i; size = a. size; p=new int [a. size] ; //выделение памяти для копии if(!p) exit(l); for(i=0; i<a.size; i++) p[i]=a.p[i]; //копирование содержимого cout " "Использование конструктора копий \п"; int ma in () i array num(10); //вызов обычного конструктора int i ; //помещение в массив нескольких значений for(i=0; i<10; i-н-) num. put (i, i) ; //вывод на экран массива пита for (i=9; i>=0; i - ) cout " num.get(i); cout " "\n"; //создание другого массива и инициализация его массивом пшп array x=num; //вызов конструктора копий //вывод на экран массива х for (i=0; i<10; i-н-) cout " x.get(i); return 0; Когда массив пиш используется для инициализации массива х, вызывается конструктор копий и для нового массива по адресу х.р выделяется память, а содержимое массива пшп копируется в массив х. В этом случае в массивах х и num находятся одинаковые значения, но при этом - это совершенно различ-ные массивы. (Другими словами, указатели х.р и num.p теперь не ссылаются на одну и ту же область памяти.) Если бы не был создан конструктор копий, то поразрядная инициализация при выполнении инструкции array x= пшп приве-ла бы к тому, что массивы х и пшп оказались бы в одной и той же области па-мяти! (То есть, указатели х.р и num.p ссылались бы на одну и ту же область памяти.)
Глава 5. Перегрузка функций 153 Конструктор копий вызывается только для инициализации. Например, сле-дующая последовательность инструкций не ведет к вызову определенного в предыдущей программе конструктора копий: array a (10}; array b(10) ; b = а; //конструктор копий не вызывается В данном случае инструкция b = а представляет собой операцию присваивания. 2. Чтобы понять, как конструктор копий помогает предотвратить некоторые проблемы, связанные с передачей функциям объектов определенных типов, рассмотрим следующую, неправильную программу: //В этой программе имеется ошибка #include <iostream> ^include <cstring> ^include <cstdlib> using namespace std; class strtype ( char *p; public: strtype(char *s); -strtype() {delete [] p;} char *get() (return p;} strtype:: strtypefchar *s) int 1; l=strlen(s)+1; p=new char[1]; cout " "Ошибка выделения памяти\п"; exit(1} ; strcpy(p, s); void show(strtype x) char *s; s=x.get() ; cout " s " "\n"; 1
154 _ Самоучитель C++ int main () {strtype a ("Hello"), b("There"); show (a) ; show(b) ; return 0; В этой программе, когда объект типа strtype передается в функцию show(), создается поразрядная копия объекта (поскольку не был определен конст-руктор копий) и передается параметру х. Таким образом, когда функция воз-вращает свое значение, х выходит из области видимости и удаляется. Это, естественно, приводит к вызову деструктора объекта х, который освобождает область памяти по адресу х.р. Однако освобожденная память - это та самая память, которую продолжает занимать объект, используемый при вызове функции. Это приводит к ошибке. Решение предыдущей проблемы лежит в определении конструктора копий для класса strtype, который при создании копии объекта типа strtype выделя-ет для нее память. Такой подход используется в следующей, исправленной версии программы: /* В этой программе используется конструктор копирования, что позволяет передавать функции объекты типа strtype */# include <iostream> # include <cstring> # include <cstdlib> using namespace std; class strtype { char *p; public: strtype(char *s) ; //конструктор strtype (const strtype &o) ; //конструктор копий ~strtype(} {delete [] p; } //деструктор char *get() {return p; } }; //Обычный конструктор strtype: : strtype (char *s) ( int 1; l=strlen(s) +1; p=new char [1] ; if(!p) ( cout " "Ошибка выделения памяти\п";
Глава 5. Перегрузка функций _ 155 exit (1) ; } strcpyfp, з) ; }//Конструктор копий strtype: istrtype (const strtype &o) t int 1; l=strlen(o.p) +1; p=new charfl] ; //выделение памяти для новой копии if(!p) { cout " "Ошибка вьщеления памяти\п"; exit(l) ; }strcpy (р, о.р} ; //копирование строки в копию } void show (strtype x) { char *s; s=x.get () ; cout " s " "\n"; } int mainO {strtype a ("Hello"], b( "There"); show (a) ; show(b) ; return 0; Теперь, когда функция show() завершается и объект х выходит из области ви-димости, память, на которую ссылается указатель х.р (освобождаемая па-мять), - это уже не та память, которая используется переданным в функцию объектом. [Упражнеенниияя] 1. Конструктор копий вызывается и в тех случаях, когда функция генерирует временный объект, используемый в качестве ее возвращаемого значения (для тех функций, которые возвращают объекты). Зная это, рассмотрим следую-щий результат работы программы:
156 _ Самоучитель C++ Работа обычного конструктора Работа обычного конструктора Работа конструктора копий Эти строки появились в результате работы следующей программы. Объясни-те, что именно там происходит и почему. ^include <iostream> using namespace std; class myclass { public: myclass () ; myclass (const myclass &o) ; myclass f ( ) ; //Обычный конструктор myclass : :myclass ( ) { cout " "Работа обычного конструктора\п"; }//Конструктор копий myclass: imyclass (const myclass So) { cout " "Работа конструктора копийХп"; i//Возвращение объекта myclass myclass: :f() { myclass temp; return temp; int main!) { myclass obj; obj=obj.f{); return 0; 2. Объясните, что в следующей программе неправильно, и исправьте ее. //В этой программе имеется ошибка #include <iostream>
Глава 5. Перегрузка функций _ 157 ^include <cstdlib> using namespace std; class rayclass { int *p; public: myclass (int i) ; ~myclass() (delete p; } friend int getval (myclass o) ; myclass: :myclass(int i) { p=new int; if(!p) { cout " "Ошибка выделения памяти\п"; exit(l) ; int getval(myclass o) return *o.p; //получение значения int main() myclass a ( l } , b(2); cout " getval(a) " " " " getval(b); cout " "\n"; cout " getval(a) " " " " getval(b); return 0; J 3. Объясните своими словами, зачем нужен конструктор копий и чем он отли-чается от обычного конструктора. 5.3. Устаревшее ключевое слово overload В ранних версиях C++ для создания перегружаемых функций требовалось ключевое слово overload. Хотя ключевое слово overload в современных компи-ляторах больше не поддерживается, вы все еще можете встретить его в суще-ствующих профаммах, поэтому полезно знать, как оно использовалось.
158 __ Самоучитель C++ Ниже показана основная форма ключевого слова overload: overload имя функции; Здесь имя_функции - это имя перегружаемой функции. Перед этой инструк-цией должно находиться объявление перегружаемой функции. Например, следующая инструкция сообщает компилятору, что вы будете перегружать функцию timer(): overload timer (); Ключевое слово overload является устаревшим и в современных компилято-рах C++ не поддерживается. 5.4. Аргументы по умолчанию В синтаксисе C++ имеется элемент, который имеет непосредственное от-ношение к перегрузке функций и называется аргументом по умолчанию (default argument). Аргумент по умолчанию позволяет вам, если при вызове функции соответствующий аргумент не задан, присвоить параметру значе-ние по умолчанию. Как вы увидите далее, применение аргумента по умол-чанию является скрытой формой перегрузки функций. Чтобы передать параметру аргумент по умолчанию, нужно в инструкции определения функции приравнять параметр тому значению, которое вы хо-тите передать, когда при вызове функции соответствующий аргумент не бу-дет указан. Например, в представленной ниже функции двум параметрам по умолчанию присваивается значение 0: void f l i n t а = О, int Ь = 0); Обратите внимание, что данный синтаксис напоминает инициализацию пе-ременных. Теперь эту функцию можно вызвать тремя различными способа-ми. Во-первых, она может вызываться с двумя заданными аргументами. Во-вторых, она может вызываться только с первым заданным аргументом. В этом случае параметр b по умолчанию станет равным нулю. Наконец, функция f() может вызываться вообще без аргументов, при этом параметры а и b по умолчанию станут равными нулю. Таким образом, все следующие вызовы функции f() правильны: f(); //а и b по умолчанию равны О f(10); //а равно 10, b по умолчанию равно О f(10, 99); //а равно 10, b равно 99
Глава 5. Перегрузка функций J59 Из этого примера должно быть ясно, что невозможно передать по умолча-нию значение а и при этом задать Ь. Когда вы создаете функцию, имеющую один или более передаваемых по умолчанию аргументов, эти аргументы должны задаваться только один раз: либо в прототипе функции, либо в ее определении, если определение пред-шествует первому использованию функции. Аргументы по умолчанию нель-зя задавать одновременно в определении и в прототипе функции. Это правило остается в силе, даже если вы просто дублируете одни и те же аргу-менты по умолчанию. Как вы, вероятно, догадываетесь, все параметры, задаваемые по умолчанию, должны указываться правее параметров, передаваемых обычным путем. Больше того, после того как вы начали определять параметры по умолча-нию, параметры, которые по умолчанию не передаются, уже определять нельзя. Еще несколько слов об аргументах по умолчанию: они должны быть кон-стантами или глобальными переменными. Они не могут быть локальными переменными или другими параметрами. 1. Программа для иллюстрации вышеописанной функции: //Первый простой пример аргументов по умолчанию #include <iostream> using namespace std; void f(int a = 0, int b = 0) { cout " "a: " " a " ", b: " " b; cout " ' \ n r ; int main () f<10); f(10, 99); return 0; }Как и следовало ожидать, на экран выводится следующее: а: О, Ь: О а: 10, Ь: О а: 10, Ь: 99
160 _ _ _ Самоучитель C++ Запомните, если первый аргумент задан по умолчанию, все последующие параметры должны также задаваться по умолчанию. Например, такое не-большое изменение функции f() приведет к ошибке при компиляции про-граммы: void f(int a -0, int b) //Неправильно! Параметр b тоже должен //задаваться по умолчанию { cout " "а: " " а " ", Ь: " " Ь; cout " ' \п' ; 2. Чтобы понять, какое отношение аргументы по умолчанию имеют к перегруз-ке функций, рассмотрим следующую программу, в которой перегружается функция rect_area(). Эта функция возвращает площадь прямоугольника. /* Расчет площади прямоугольника с использованием перегрузки функций */#include <iostream> us ing name space s td ; //Возвращает площадь неравностороннего прямоугольника double rect_area (double length, double width) { return length * width; //Возвращает площадь квадрата double rect_arsa (double 'length) { return length * length; ) int main() { cout " "площадь прямоугольника 10 x 5.8 равна: "; cout " rect_area(10.0, 5.8) " '\n'; cout " "площадь квадрата 10 x 10 равна : " ; cout " rect_area(10.0) " '\n'; return 0; В этой программе функция rect_area() перегружается двумя способами. В пер-вом - функции передаются оба размера фигуры. Эта версия используется для прямоугольника. Однако в случае квадрата необходимо задавать только один аргумент, поэтому вызывается вторая версия функции rect_area().
Глава 5. Перегрузка функций _ 161 Если исследовать этот пример, то становится ясно, что на самом деле в та-кой ситуации нет необходимости в двух функциях. Вместо этого второму па-раметру можно по умолчанию передать некоторое значение, действующее как флаг для функции rect_area(). Когда функция встретит это значение, она дважды использует параметр length. Пример такого подхода: /* Расчет площади прямоугольника с передачей аргументов по умолчанию */^include <iostream> using namespace std; //Возвращает площадь прямоугольника double rect_area (double length, double width = 0) 1 if {! width) width = length; return length * width; int raainO { cout " "площадь прямоугольника 10 x 5.8 равна: "; cout " rect_area(10.0, 5.8) " ' \ n ' ; cout " "площадь квадрата 10 x 10 равна: "; cout " rect_area(10.0) " ' \ n ' ; Теперь параметру width по умолчанию присваивается нуль. Такое значение выбрано потому, что не бывает прямоугольника с нулевой стороной. (Фактически, прямоугольник с нулевой стороной - это линия.) Таким обра-зом, когда в rect_area() встречается такое, переданное по умолчанию значе-ние, для ширины прямоугольника автоматически используется параметр length. Как показано в этом примере, аргументы по умолчанию часто обеспечивают простую альтернативу перегрузке функций. (Конечно, имеется масса ситуа-ций, в которых перегрузка функций необходима по-прежнему.) 3. Передавать конструкторам аргументы по умолчанию не только правильно, но и вполне обычно. Как отмечалось ранее в этой главе, часто конструктор пе-регружается просто для того, чтобы могли создаваться как инициализируе-мые, так и неинициализируемые объекты. Во многих случаях можно избежать перегрузки конструктора путем передачи ему одного или более ар-гументов по умолчанию. Например, рассмотрим следующую программу: ^include <iostrearri> using namespace std;
162 Самоучитель C++ class myclass { int x; public: /* Использование аргумента по умолчанию вместо перегрузки конструктора */myclass(int n = 0) ( x = n; } int getxf) ( return x; } int main() { myclass ol(10); //объявление с начальным значением myclass o2; //объявление без начального значения cout " "ol: " " ol.getxO " '\п'; cout " "о2: " " o2.getx() " '\пт; return 0; Как показано в этом примере, путем передачи по умолчанию параметру n нулевого значения, можно создавать не только объекты, имеющие явно за-данные начальные значения, но и такие, для которых достаточно значений, задаваемых по умолчанию. 4. Другим хорошим применением аргумента по умолчанию является случай, когда с помощью такого параметра происходит выбор нужного варианта раз-вития событий. Можно передать параметру значение по умолчанию так, что-бы использовать его в качестве флага, сообщающего функции о необхо-димости продолжить работу в обычном режиме. Например, в следующей программе функция print() выводит строку на экран. Если параметр how ра-вен значению ignore, текст выводится в том виде, в каком он задан. Если па-раметр how равен значению upper, текст выводится в верхнем регистре. Если параметр how равен значению lower, текст выводится в нижнем регистре. Ес-ли параметр how не задан, его значение по умолчанию равно -1, что говорит функции о необходимости повторно использовать его предыдущее значение. ^include <iostream> tinclude <cctype> using namespace std; const int ignore = 0; const int upper = 1; const int lower = 2; void print(char *s, int how = -1) ; int main() f print ( "Привет \n", ignore) ;
Глава 5, Перегрузка функций _ 1 63 print ("Привет \n", upper); print ("Привет \п") ; //продолжение вывода в верхнем регистре print ("Привет \n", lower) ; print ("Это конец \п") ; //продолжение вывода //в нижнем регистре return 0; /* Печать строки в заданном регистре. Использование заданного последним регистра, если он не задан. */void print (char *s, int how) { static int oldcase = ignore; //повторять работу с прежним регистром, если новый не задан if (how<0) how = oldcase; while (*g) { switch (how) { case upper: cout " (char) toupper(*s); break; case lower: cout " (char) tolower(*s); break; default:-cout " *s; 1 oldcase = how; Эта программа выводит следующее: Привет ПРИВЕТ ПРИВЕТ привет это конец 5. Ранее в этой главе мы рассматривали общую форму конструктора копий. В этой общей форме имелся только один параметр. Однако вполне возможно создавать конструкторы копий, получающие дополнительные аргументы, ес-ли только это аргументы по умолчанию. Например, вполне приемлема сле-дующая форма конструктора копий: myclass(const myclass Sobj, int x=0) ( //тело конструктора
164 Самоучитель C++ Поскольку первый аргумент является ссылкой на копируемый объект, а все остальные - это аргументы по умолчанию, эту функцию можно квалифици-ровать как конструктор копий. Такая гибкость позволяет создавать самые разнообразные конструкторы копий. 6. Хотя аргументы по умолчанию являются мощным и удобным инструментом, ими нельзя злоупотреблять. Несомненно, что 'При правильном применении аргументы по умолчанию позволяют функции выполнять свою работу эф-фективным и простым по реализации образом. Однако так происходит лишь тогда, когда переданное по умолчанию значение имеет смысл. Например, ес-ли аргумент, используемый в девять или десять раз чаще других, передать функции по умолчанию, то, очевидно, это неплохо. Однако в случае, если нет значения, используемого чаще других, или нет выгоды от аргумента по умолчанию в качестве флага, то нет большого смысла передавать что-либо по умолчанию. Фактически, обеспечение передачи аргумента по умолчанию, когда это не вызвано необходимостью, ограничивает возможности вашей программы и вводит в заблуждение всех пользователей такой функции. Как и при перегрузке функций, хороший программист в каждом конкретном случае всегда сумеет определить, стоит или нет пользоваться аргументом по умолчанию. Упражневнниияя) 1. В стандартной библиотеке C++ существует функция strtol(), имеющая сле-дующий прототип: long strtol(const char *start, const **end, int base); Функция преобразует обозначающую число строку, на которую ссылается указатель start, в длинное целое. Число base задает основание системы счис-ления этого числа. При возвращении функцией своего значения указатель end ссылается на символ в строке, следующий сразу за последней цифрой строки. Возвращаемое длинное целое эквивалентно тому числу, которое за-писано в строке. Диапазон значений base от 2 до 38. Однако наиболее часто основание системы счисления равно 10. Создайте функцию mystrtol(), работающую точно так же, как и функция strtolQ, но аргумент 10 должен передаваться параметру base по умолчанию. (Свободно пользуйтесь функцией strtolQ для фактического преобразования. Для этого в программу требуется включить заголовок <cstdlib>.) Покажите, что ваша версия работает правильно. 2. Что неправильно в следующем прототипе функции? char *f(char *p, int x = 0, char *q); 3. В большинстве компиляторов C++ применяются нестандартные функции, управляющие позиционированием курсора и другими аналогичными деист-
Глава 5. Перегрузка функций 165 виями. Если в вашем компиляторе применяются такие функции, создайте функцию myclreolQ, которая стирает строку, начиная от текущей позиции курсора до конца строки. Передайте этой функции параметр, задающий чис-ло стираемых позиций. Если параметр не задавать, то по умолчанию должна стираться вся строка. В противном случае должно стираться число символь-ных позиций, заданное параметром. 4. Что неправильно в следующем прототипе функции с аргументом по умолча-нию? int f(int count, int max = count); 5.5. Перегрузка и неоднозначность При перегрузке возможно внесение неоднозначности в программу. Неодно-значность (ambiguity), вызванная перегрузкой функций, может быть введена в программу при преобразовании типа, а также при использовании парамет-ров-ссылок и аргументов по умолчанию. Некоторые виды неоднозначности вызываются самой перегрузкой функций. Другие виды связаны со способом вызова перегруженных функций. Чтобы программа компилировалась без ошибок, от неоднозначности необходимо избавиться. Примеры J ^^ТР™' Один из наиболее частых видов неоднозначности вызывается правилами преобразования типа в C++. Как вы знаете, при вызове функции с аргумен-том, тип которого совместим (но не аналогичен) с типом параметра, которо-му он передается, тип аргумента по умолчанию преобразуется в тип параметра. Об этой операции иногда говорят как о приведении типа (type promotion). Приведение типа - это такой вид преобразования типа, который позволяет некоторым функциям, например putchar(), вызываться с символь-ным параметром, даже тогда, когда аргумент функции имеет тип int. Однако в некоторых случаях это преобразование типа при перегрузке функций вызо-вет ситуацию неоднозначности. Чтобы понять, как это происходит, исследу-ем следующую программу: //Эта программа содержит ошибку неоднозначности ^include <iostreani> using namespace std; float f (float i) t return i /2.0;
166 __ __ Самоучитель C++ double f (double i) I return i /3.0; \int main ( ) { float x = 10.09; double у = 10.09; cout " f(x); //нет неоднозначности //используется функция f (float) cout " f (y) ; //нет неоднозначности //используется функция f (double) cout " f(10); //неоднозначность //куда преобразовать 10? //в значение типа double или float? return 0; Как указано в комментариях к функции main(), компилятор в состоянии вы-брать правильную версию функции f(), если она вызывается либо с перемен-ными типа double, либо с переменными типа float. Однако что случается, если она вызывается с целым? Какую функцию вызовет компилятор f(float) или f(double)? (Оба преобразования правильны!) И в том, и в другом случае правильно "привести" тип int либо к типу float, либо к типу double. Таким об-разом, возникает ситуация неоднозначности. Этот пример выявляет также то, как неоднозначность может прояштяться при вызове перегруженных функций. Очевидно, что сама по себе неоднознач-ность не присуща перегруженным версиям функции f(), пока каждая вызы-вается с аргументом соответствующего типа. 2. Другой пример перегрузки функции, которая сама по себе не должна приво-дить к неоднозначности. Тем не менее, при вызове с аргументом неправиль-ного типа, правила преобразования типа C++ создают ситуацию неодно-значности. //Эта программа неоднозначна ^include <iostream> using namespace std; void f (unsigned char c) cout " c; } void f (char c) { cout " c;
Глава 5. Перегрузка функций _ 767 int main () ( f Сс1 } ; f{86); //какая версия функции f(} вызывается? return 0; Когда функция f() вызывается с числовой константой 86, компилятор не может понять, какую версию функции вызвать: f(unsigned char) или f(char). Оба преобразования одинаково правильны, что и ведет к неоднозначности. 3. Один из видов неоднозначности проявляется, если вы пытаетесь перегрузить функции, единственным отличием которых является то, что одна использует параметр -ссылку, а другая параметр-значение по умолчанию. В рамках фор-мального синтаксиса C++ у компилятора нет способа узнать, какую функ-цию вызвать. Запомните, что нет синтаксических отличий между вызовом функции по значению и вызовом функции по ссылке. Например: //Эта программа неоднозначна ^include <iostream> using namespace std; int f{int a, int b) { return a + b; //здесь внутренняя неоднозначность int f f i n t a, int &b) { return a - b; Jint main() cout " f ( x , y) ; //какую версию f ( } вызвать? return 0; Здесь вызов функции f(x, у) неоднозначен, поскольку вызвана может быть любая версия функции. При этом компилятор выставит флаг ошибки даже раньше того, как встретится такая инструкция, поскольку сама перегрузка этих двух функций внутренне неоднозначна, и компилятор не будет знать, какую из них предпочесть. 4. Другим видом неоднозначности при перегрузке функций является случай, когда одна или более перегруженных функций используют аргумент по умолчанию. Рассмотрим программу:
168 Самоучитель C++ II Неоднозначность, основанная на аргументах по умолчанию //и перегрузке функций ^include <iostream> using namespace std; int f f i n t a) return a * a; int f{int a, int b = 0) return a * b; int mainO cout " f(10, 2); //вызывается f(int, int) cout " f(10); //неоднозначность, //что вызвать f(int, int) или f(int)??? return 0; Здесь вызов функции f(10, 2) совершенно правилен и не ведет к неодно-значности. Однако у компилятора нет способа выяснить, какую версию функции f() вызывает версия f(10) - первую или вторую, в которой пара-метр Ь передается по умолчанию. 1. Попытайтесь провести компиляцию всех предыдущих программ, в которых име-ет место неоднозначность. Запомните сообщения об ошибках. Это поможет вам сразу распознать ошибки неоднозначности, если они появятся в ваших програм-мах. 5.6. Определение адреса перегруженной функции В заключение этой главы вы узнаете, как найти адрес перегруженной функ-ции. Так же, как и в С, вы можете присвоить адрес функции указателю и получить доступ к функции через этот указатель. Адрес функции можно найти, если поместить имя функции в правой части инструкции присваива-ния без всяких скобок или аргументов. Например, если zap() - это функ-
Глава 5. Перегрузка функций 169 ция, причем правильно объявленная, то корректным способом присвоить переменной р адрес функции zap() является инструкция: р -zap; В языке С любой тип указателя может использоваться как указатель на функцию, поскольку имеется только одна функция, на которую он может ссылаться. Однако в C++ ситуация несколько более сложная, поскольку функция может быть перегружена. Таким образом, должен быть некий ме-ханизм, который позволял бы определять адреса перегруженных версий функции. Решение оказывается не только элегантным, но и эффектным. Способ объяв-ления указателя и определяет то, адрес какой из перегруженных версий функции будет получен. Уточним, объявления указателей соответствуют объявлениям перегруженных функций. Функция, объявлению которой соот-ветствует объявление указателя, и является искомой функцией. Здесь представлена программа, которая содержит две версии функции space(). Первая версия выводит на экран некоторое число пробелов, задан-ное в переменной count. Вторая версия выводит на экран некоторое число каких-то иных символов, вид которых задан в переменной ch. В функции main() объявляются оба указателя на эти функции. Первый задается как ука-затель на функцию, имеющую только один целый параметр. Второй объявля-ется как указатель на функцию, имеющую два параметра. /* Иллюстрация присваивания и получения указателей на перегруженные функции */^include <iostream> using namespace std; //вывод заданного в переменной count числа пробелов void space(int count) { for(; count; count -) cout " ' '; //вывод заданного в переменной count числа символов, //вид которых задан в переменной ch void space(int count, char ch) ( fort; count; count -) cout " ch;
170 _ Самоучитель C++ int main С) f /* Создание указателя на функцию с одним целым параметром. */void (*fpl) (int) ; /* Создание указателя на функцию с одним целым и одним символьным параметром. */void (*fp2) (int, char); fpl = space; //получение адреса функции space (int) fp2 " space; //получение адреса функции space (int, char) fpl (22); //выводит 22 пробела cout " "|\n"; fp2(30, 'x'); //выводит 30 символов х cout " "|\n"; return 0; Как показано в комментариях, на основе того, каким образом объявляются указатели fpl и fp2, компилятор способен определить, какой из них на какую из перегруженных функций будет ссылаться. Повторим, если вы присваиваете адрес перегруженной функции указателю на функцию, то объявление указателя определяет, адрес какой именно функции ему присваивается. Более того, объявление указателя на функцию должно точ-но соответствовать одной и только одной перегруженной функции. Если это не так, будет внесена неоднозначность, что приведет к ошибке при компиляции программы. Упражнеенниияя] 1. Ниже приведены две перегруженные функции. Покажите, как получить ад-рес каждой из них. int d i f f i n t a, int b) { return a - b; float dif (float a, float b) { return a - b; 1
Глава 5. Перегрузка функций 171 Проверка уев материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы: 1. Перегрузите конструктор date() из раздела 5.1, пример 3 так, чтобы он имел параметр типа time_t. (Вспомните, что time_t - это тип данных, определенный стандартными библиотечными функциями времени и да-ты компилятора C++.) 2. Что неправильно в следующем фрагменте? class samp { int а; public: samp (int i) { a = i; } int rnain() ( samp x, у (10) ; 3. Приведите два довода в пользу того, почему вам могло бы потребоваться перегрузить конструктор класса. 4. Какова основная форма конструктора копий? 5. Какой тип операций ведет к вызову конструктора копий? 6. Кратко объясните, зачем нужно ключевое слово overload, и почему оно больше не употребляется. 7. Объясните, что такое аргумент по умолчанию? 8. Создайте функцию reverse() с двумя параметрами. Первый параметр str - это указатель на строку, порядок следования символов в которой, после возвращения функцией своего значения, должен быть заменен на обратный. Второй параметр count задает количество переставляемых в строке str символов. Значение count по умолчанию должно быть таким, чтобы в случае его задания функция reverse() меняла порядок следова-ния символов в целой строке. 9. Что неправильно в следующем прототипе функции? char *wordwrap(char *str, int size = 0, char ch) ;
172 Самоучитель С++ 10. Приведите несколько причин появления неоднозначности при пере-грузке функций. 11. Что неправильно в следующем фрагменте? void compute(double *num, int divisor = 1); void compute(double *num); //... compute(&x); 12. При присваивании указателю адреса перегруженной функции, что опре-деляет конкретную версию используемой фуИкции? Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Создайте функцию orderQ, которая получает два параметра-ссылки на целые. Если первый аргумент больше второго, поменяйте их значения. В противном случае ничего делать не надо. Таким образом, порядок следо-вания двух аргументов, используемых при вызове функции order(), дол-жен быть таким, чтобы всегда после возвращения функцией своего значения первый аргумент был меньше второго. Например, если дано int х = 1, у = 0; order(x, у); то после вызова функции х будет равен 0, а у будет равен 1. 2. Почему следующие две перегруженные функции внутренне неоднозначны? int f(int a) ; int f(int &a) ; 3. Объясните, почему использование аргумента по умолчанию связано с перегрузкой функций. 4. Пусть дано следующее неполное описание класса, добавьте конструк-торы так, чтобы оба объявления в функции main() были правильны. (Подсказка: вам необходимо дважды перегрузить конструктор samp().) class samp { int a;
Глава 5. Перегрузкгпрункций 173 public: //добавьте конструкторы int get_a() { return a; } int ma in samp ob(88); //инициализация объекта а значением 88 samp obarray[10]; //неинициализируемый 10-злементный массив 5. Кратко объясните, зачем нужны конструкторы копий.
Глава 6 Введение в перегрузку операторов В этой главе рассматривается очередное важное свойство C++: перегрузка операторов. Это свойство позволяет определять значение операторов C++ относительно задаваемых вами классов. Путем перегрузки связанных с клас-сами операторов можно легко добавлять в программу новые типы данных. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Покажите, как перегрузить конструктор для следующего класса так, чтобы можно было создавать не только инициализируемые, но и неини-циализируемые объекты. (При создании таких объектов присвойте пере-менным х и у значение 0.) class myclass { int x,y; public: myclass (int i, int j) ( x = i; у = j; } 2. Используя класс из вопроса 1, покажите, как с помощью аргументов по умолчанию можно избежать перегрузки конструктора myclassQ 3. Что неправильно в следующем объявлении? int f {int а = О, double balance) ; 4. Что неправильно в следующих двух перегруженных функциях? void f (int a) ; void f (int &a) ; 5. Когда удобнее использовать аргументы по умолчанию? Когда этого луч-ше не делать?
776 __ ___ _ Самоучитель C++ в. Дано следующее определение класса. Возможно ли динамически выде-лить память для массива объектов такого типа? class test { char *p; int *q; int count ; public: test (char *x, int *y, int c) { p = x; q -y; count = c; 7. Что такое конструктор копий и при каких условиях он вызывается? 6.1. Основы перегрузки операторов Перегрузка операторов напоминает перегрузку функций. Более того, пере-грузка операторов является фактически одним из видов перегрузки функ-ций. Однако при этом вводятся некоторые дополнительные правила. Например, оператор всегда перегружается относительно определенного пользователем типа данных, такого, как класс. Другие отличия будут обсуж-даться ниже по мере необходимости. Когда оператор перегружается, то ничего из его исходного значения не те-ряется. Наоборот, он приобретает дополнительное значение, связанное с классом, для которого оператор был определен. Для перегрузки оператора создается оператор -функция (operator function). Чаще всего, оператор -функция является членом класса или дружественной классу, для которого она определена. Однако есть небольшая разница между оператор -функцией - членом класса и дружественной оператор-функцией. В первой части этой главы обсуждается создание оператор-функций - чле-нов класса. О дружественных оператор -функциях будет рассказано далее в этой главе. Здесь представлена основная форма оператор -функции - члена класса: во-звращаемБш_:гил ш*я_хласса: : opera tor # (список аргументов) { //выполняемая операция Часто типом возвращаемого значения оператор -функции является класс, для которого она определена. (Хотя оператор-функция может возвращать дан-ные любого типа.) В представленной общей форме оператор -функции вме-
Глава 6. Введение в перегрузку операторов 177 сто знака # нужно подставить перегружаемый оператор. Например, если пе-регружается оператор +, то у функции должно быть имя operator*. Содер-жание списка список-аргументов зависит от реализации оператор-функции и от типа перегружаемого оператора. Следует запомнить два важных ограничения на перегрузку операторов. Во-первых, нельзя менять приоритет операторов. Во-вторых, нельзя менять число операндов оператора. Например, нельзя перегрузить оператор /так, чтобы в нем использовался только один операнд. Большинство операторов C++ можно перегружать. Ниже представлены те несколько операторов, которые перегружать нельзя: Кроме того, нельзя перегружать операторы препроцессора. (Оператор .* яв-ляется сугубо специальным и в книге не рассматривается.) Запомните, что в C++ понятие оператора трактуется очень широко: в это понятие входят оператор индексирования [], оператор вызова функции (), операторы new и delete, операторы . (точка) и -> (стрелка). Однако в данной главе мы коснемся более обычных операторов. Оператор-функции, за исключением оператора -, наследуются производным классом. Тем не менее для производного класса тоже можно перегрузить лю-бой выбранный оператор (включая операторы, уже перегруженные в базовом классе). Вы уже пользовались двумя перегруженными операторами: " и ", кото-рые перегружались для реализации ввода/вывода. Как уже упоминалось, пе-регрузка этих операторов для реализации ввода/вывода не мешает им выполнять свои традиционные функции левого и правого сдвига. Хотя допустимо иметь оператор-функцию для реализации любого действия -связанного или нет с традиционным употреблением оператора - лучше, если действия перегружаемых операторов остаются в сфере их традиционного ис-пользования. При создании перегружаемых операторов, для которых этот принцип не поддерживается, имеется риск существенного снижения чита-бельности программ. Например, перегрузка оператора /так, чтобы 300 раз записать в дисковый файл фразу "Мне нравится C++", является явным зло-употреблением перегрузкой операторов. Несмотря на вышесказанное, иногда может потребоваться использовать ка-кой-либо оператор нетрадиционным образом. Типичным примером этого как раз и являются перегруженные для ввода/вывода операторы " и ". Однако даже в этом случае, левые и правые стрелки обеспечивают визуально понят-ный смысл их значения. Поэтому, даже если вам очень хочется перегрузить какой-нибудь оператор нестандартным способом, лучше приложите дополни-тельные усилия и постарайтесь воспользоваться каким-нибудь более подхо-дящим оператором. И последнее, оператор-функции не могут иметь параметров по умолчанию.
178 Самоучитель C++ 6.2. Перегрузка бинарных операторов Когда оператор-функция - член класса перегружает бинарный оператор, у функции будет только один параметр. Этот параметр получит тот объект, который расположен справа от оператора. Объект слева генерирует вызов оператор-функции и передается неявно, с помощью указателя this. Важно понимать, что для написания оператор-функций имеется множество вариантов. Примеры, показанные здесь и в других местах главы, не являют-ся исчерпывающими, хотя они иллюстрируют несколько наиболее общих технических приемов. Примеры 1. В следующей программе перегружается оператор + относительно класса coord. Этот класс используется для поддержания координат X,Y. //Перегрузка оператора 4 относительно класса coord ^include <iostream> using namespace std; class coord { int x,y; //значения координат public: coord () { x = 0; y= 0; } coord{int i, int j) { x = i; у = j; } void get_xy(int &i, int £j ) { i = x; j = y; } coord operator-*-(coord ob2) ; I /Перегрузка оператора + относительно класса coord coord coord: :operator+ (coord ob2) { coord temp; temp.x = x +ob2.x; temp. у = у +оЬ2.у; return temp; int main () coord ol (10, 10), o2(5, 3), o3; int x, y; o3 = ol + o2; //сложение двух объектов //вызов функции operator-*-()
Глава 6. Введение в перегрузку операторов 179 оЗ.get_xy(x, у); cout " "(01 + о2) X: " " х " ", Y: " " у " "\п"; return 0; ) . После выполнения программы на экран выводится следующее: (ol + о2) X: 15, Y: 13 Давайте внимательно рассмотрим программу. Функция operator+() возвраща-ет объект типа coord, в котором сумма координат по оси X находится в пере-менной х, а сумма координат по оси Y - в переменной у. Отметьте, что временный объект temp используется внутри функции operator+() для хране-ния результата и является возвращаемым объектом. Отметьте также, что ни один из операндов не меняется. Назначение переменной temp легко понять. В данной ситуации (как и в большинстве ситуаций) оператор + был пере-гружен способом, аналогичным своему традиционному арифметическому ис-пользованию. Поэтому и было важно, чтобы ни один из операндов не менялся. Например, когда вы складываете 10-И, результат равен 14, но ни 10, ни 4 не меняются. Таким образом, временный объект необходим для хра-нения результата. Смысл того, что функция operator+О возвращает объект типа coord, состоит в том, что это позволяет использовать результат сложения объектов типа coord в сложном выражении. Например, инструкция оЗ = ol + о2; правильна только потому, что результат выполнения операции ol + о2 явля-ется объектом, который можно присвоить объекту оЗ. Если бы возвращае-мым значением был объект другого типа, то эта инструкция была бы неправильна. Более того, возвращая объект типа coord, оператор сложения допускает возможность существования строки, состоящей из нескольких сложений. Например, следующая инструкция вполне корректна: оЗ = ol + о2 + ol + оЗ; Хотя у вас будут ситуации, в которых понадобится оператор-функция, воз-вращающая нечто иное, чем объект класса, для которого она определена, большинство создаваемых вами оператор-функций будут возвращать именно такие объекты. (Основное исключение из этого правила связано с перегруз-кой операторов отношения и логических операторов. Эта ситуация исследу-ется в разделе 6.3 "Перегрузка операторов отношения и логических операторов" далее в этой главе.) Последнее замечание по этому примеру. Поскольку объект типа coord явля-ется возвращаемым значением оператор-функции, то следующая инструкция также совершенно правильна: (ol 4 о2).get xy(x, у);
180 _ Самоучитель C++ Здесь временный объект, возвращаемый функцией operator+(), используется непосредственно. Естественно, что после выполнения этой инструкции вре-менный объект удаляется. 2. В следующей версии предыдущей программы относительно класса coord пе-регружаются операторы - и =. //Перегрузка операторов +, - и = относительно класса coord ^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord () { x = 0; y= 0; } coord (int i, int j) { x = i; у = j ; } void get_xy(int &i, int &j} { i = x; j = y; } coord operator-f (coord ob2) ; coord operator-(coord ob2); coord operator= (coord ob2) ; //Перегрузка оператора + относительно класса coord coord coord: :operator+ (coord ob2) ( coord temp; terap.x = x + ob2.x; temp, у = у -f ob2.y; return temp; }//Перегрузка оператора - относительно класса coord coord coord: : operator-(coord ob2} { coord temp; temp . x = x -ob2 . x ; temp. у = у - ob2.y; return temp; //Перегрузка оператора = относительно класса coord coord coord: :operator=( coord ob2) { x = ob2 . x ; у = ob2.y;
Глава 6. Введение в перегружу операторов _ 181 return *this; //возвращение объекта, //которому присвоено значение > ,, int main{) { coord ol (10, 10), o2(5, 3), оЗ; int x, y; o3 = ol + o2; //сложение двух объектов //вызов функции operator* () o3.get_xy !x, у) ; cout " "(ol + о2) X: " " x " ", Y: " " у " "\n"; : оЗ = ol - о2; //вычитание двух объектов //вызов функции operator-() o3.get_xy (х, у) ; cout " " (ol -о2) X: " " х " ", Y: " " у " "\п"; оЗ = ol; //присваивание объекта-вызов функции operator= ( } o3.get_xy (х, у) ; cout " "(оЗ = ol) X: " " х " ", Y: " " у " "\п"; return 0; Реализация функции operator- () похожа на реализацию функции operator+(). Однако она иллюстрирует ту особенность перегрузки операторов, где важен порядок следования операндов. При создании функции operator+() порядок следования операндов значения не имел. (То есть А+В тождественно В+А.) Однако результат операции вычитания зависит от порядка следования опе-рандов. Поэтому, чтобы правильно перегрузить оператор вычитания, необхо-димо вычесть правый операнд из левого. Поскольку левый операнд генерирует вызов функции operator- (), порядок вычитания должен быть сле-дующим: х - оЬ2 . х ; При перегрузке бинарного оператора левый операнд передается функции неявно, а правый оператор передается функции в качестве аргумента. Теперь рассмотрим оператор-функцию присваивания. В первую очередь не-обходимо отметить, что левый операнд (т. е. объект, которому присваивается значение) после выполнения операции меняется. Здесь сохраняется обычный смысл присваивания. Во-вторых, функция возвращает указатель *this. Это
182 Самоучитель происходит потому, что функция operator=() возвращает тот объект, которо-му присваивается значение. Таким образом удается выстраивать операторы присваивания в цепочки. Как вы уже должны знать, в C++ следующая инст-рукция синтаксически правильна (и на практике вполне обычна): a = b = c = d = 0 ; Возвращая указатель *this, перегруженный оператор присваивания дает воз-можность подобным образом выстраивать объекты типа coord. Например, представленная ниже инструкция вполне корректна: оЗ " о2 = ol; Запомните, нет правила, требующего, чтобы перегруженная оператор-функция присваивания возвращала объект, полученный в результате при-сваивания. Однако если вы хотите перегрузить оператор = относительно класса, то, как и в случае присваивания встроенных типов данных, он дол-жен возвращать указатель *this. 3. Имеется возможность перегрузить оператор относительно класса так, что правый операнд будет объектом встроенного типа, например, целого, а не объектом того класса, членом которого является оператор-функция. Напри-мер, в приведенном ниже примере оператор + перегружается так, что при-бавляет целое значение к объекту типа coord: //Перегрузка оператора + как для операции ob-fob, //так и для операции ob+int #include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord0 { x = 0; у = 0; } coord (int i, int j) { x = i; у = j; } void get_xy(int fii, int &j) { i = x; j = y; } coord operator+(coord ob2); //ob + ob coord operator+(int i); //ob + int //Перегрузка оператора + относительно класса coord coord coord::operators(coord ob2) { coord temp; temp.x = x +ob2.x; temp.у = у +оЬ2.у; return temp;
Глава 6. Введение в перегрузку операторов 183 II Перегрузка оператора + для операции ob-t-int coord coord::operator+(int i) { coord temp; temp.x = x + i; temp.у = у + i; return temp; int main() coord ol (10, 10), o2(5, 3), o3; int x, y; o3 = ol + o2; //сложение двух объектов //вызов функции operator+ (coord) o3.get_xy (x, у) ; cout " "(ol + o2) X: " " x " ", Y: " " у " "\n"; o3 = ol + 100; //сложение объекта и целого //вызов функции operator+(int) o3.get_xy (x, y}; cout " "(ol + 100) X: " " x " ", Y: " " у " "\n"; return 0; Здесь важно запомнить следующее: когда оператор-функция - член класса перегружается так, чтобы объект этого класса можно было использовать в одной операции с переменной встроенного типа данных, встроенный тип данных должен находиться справа от оператора. Смысл этого легко понять: он в том, что объект, который находится слева, генерирует вызов оператор-функции. Однако что произойдет, если компилятор встретит следующую ин-струкцию? оЗ = 19 + ol; //int + ob Для обработки сложения целого с объектом встроенной операции не сущест-вует. Перегруженная функция operator+(int i) работает только в том случае, если объект находится слева от оператора. Поэтому эта инструкция приведет к ошибке при компиляции. (Позже вы узнаете способ обойти это ограничение.) 4. В оператор -функции можно использовать параметр -ссылку. Например, до-пустимым способом перегрузки оператора + относительно класса coord явля-ется следующий: //Перегрузка + относительно класса coord, с использованием ссылки coord coord: :operator-t-(coord &ob2)
184 Самоучитель C++ coord temp; temp.x = x + ob2.x; ь temp. у = у + ob2.y; return temp; Одним из доводов в пользу использования ссылки в качестве параметра опе-ратор-функции является ее эффективность. Передача объекта функции в ка-честве параметра часто требует больших затрат процессорного времени. Передача же адреса объекта всегда быстрее и эффективней. Если оператор многократно используется, параметр-ссылка обычно позволяет значительно повысить производительность. Другой довод в пользу использования параметра-ссылки состоит в том, что ссылка позволяет избежать неприятностей, связанных с удалением копии операнда. Как вы знаете по предыдущим главам, при передаче аргумента по значению создается его копия, Если у такого объекта есть деструктор, то по-сле завершения выполнения функции вызывается деструктор копии. Иногда возможны ситуации, когда деструктор удаляет нечто такое, что необходимо вызывающему объекту. Использование в этом случае в качестве параметра не самого объекта, а ссылки на этот объект - это простой (и эффективный) способ избежать проблем. Тем не менее, запомните, что в общем случае ре-шить эту проблему могло бы определение конструктора копий. Упражнеенниияя] 1. Для класса coord перегрузите операторы * и /. Продемонстрируйте их работу. 2. В приведенном ниже примере некорректно перегружен оператор %. Почему? coord coord::operator%(coord ob) { double i; cout " "Введите число: "; cin " i; cout " "корень " " i " " равен "; cout " sqr(i); i 3 Поэкспериментируйте, меняя тип возвращаемого значения оператор-функ-ций на что-нибудь отличное от coord. Обратите внимание на генерируемые компилятором сообщения об ошибках.
Глава 6. Введение в перегрузку операторов 185 6.3. Перегрузка операторов отношения и логических операторов Существует возможность перегрузки операторов отношения и логических операторов. При перегрузке операторов отношения и логических операторов так, чтобы они вели себя обычным образом, не нужны оператор-функции, возвращающие объект класса, для которого эти оператор-функции опреде-лены. Вместо этого они должны возвращать целое, интерпретируемое как значение true или false. Помимо того, что возвращаемым значением таких оператор-функций должно быть значение true или false, должна быть воз-можность встраивания операторов отношения и логических операторов в большие выражения, включающие также данные других типов. ^Замечание i/' 8 современных компиляторах C++ оператор-функции для перегрузки опера-торов отношения и логических операторов могут возвращать значения буле-ва типа, хотя особого преимущества в этом нет. Как было описано в главе 1, в булевом типе данных определены только два значения - true и false. Эти значения автоматически конвертируются в ненулевое и нулевое значения. И наоборот, целые ненулевое и нулевое значения автоматически конвертиру-ются в значения true и false. Примеры: -х 1. В следующей программе перегружаются операторы == и &&: II Перегрузка операторов == и && относительно класса coord ^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord() { x -0; y= 0; } coord(int i, int j) { x = i; у = j; } void get_xy(int &i, int &j) { i = x; j = y; } int operator^ (coord ob2); int operators &(coord ob2); //Перегрузка оператора == для класса coord int coord::operator==(coord ob2) { return x==ob2.x && y==ob2.y;
186 Самоучитель C++ //Перегрузка оператора && для класса coord int coord::operators&(coord ob2) { return (x && ob2.x) && (у && ob2.y); \int main() t coord ol(10, 10), o2{5, 3}, o3(10, 10), o4 (0, 0); if(ol==o2) cout " "ol равно o2\n"; else cout " "ol не равно o2\n"; if(ol==o3) cout " "ol равно o3\n"; else cout " "ol не равно оЗ\п"; if(ol&&o2) cout " "ol && o2 равно истина\п"; else cout " "ol && o2 равно ложь\п"; if(ol£&o4) cout " "ol && o4 равно истина\п"; else cout " "ol 5& o4 равно ложь\п"; return 0; 1. Относительно класса coord перегрузите операторы отношения < и >. 6.4. Перегрузка унарных операторов Перегрузка унарных операторов аналогична перегрузке бинарных, за исклю-чением того, что мы имеем дело не с двумя, а с одним операндом. При пе-регрузке унарного оператора с использованием функции-члена у функции нет параметров. Поскольку имеется только один операнд, он и генерирует вызов оператор-функции. Другие параметры не нужны. ' ПримерыР 1. В следующей программе относительно класса coord перегружается оператор инкремента (++): //Перегрузка оператора ++ относительно класса coord ^include <iostream> using namespace std;
Глава 6. Введение в перегрузку операторов _ 767 class coord { int x, у; //значения координат public: coord () { х = 0; у = 0; } coord (int i, int j) { x = i; у = j; } void get_xy(int Si, int Sj) { i = x; j = y; } coord operator-n-() ; }; //Перегрузка оператора ++ для класса coord coord coord: :operator++ () return *this; int main { } coord olUO, 10) ; int x, y; -м-ol; //инкремент объекта ol.get_xy(x, у); cout " "(++ol) X: " " x " ", Y: " " у " "\n"; return 0; Поскольку оператор инкремента увеличивает свой операнд на единицу, пе-регрузка этого оператора меняет объект, с которым он работает. Это позво-ляет использовать оператор инкремента в качестве части более сложной инструкции, например, такой: о2 = ++ol; Как и в случае бинарных операторов, нет правила, которое заставляло бы перегружать унарный оператор с сохранением его обычного смысла. Однако в большинстве случаев лучше поступать именно так. 2. В ранних версиях C++ при перегрузке оператора инкремента или декремента положения операторов ++ и - относительно операнда не различались. По-этому по отношению к предыдущей программе следующие две инструкции эквивалентны: -H-ol; Однако в современной спецификации C++ определен способ, по которому компилятор может различить эти две инструкции. В соответствии с этим
188 _ : _ Самоучитель C++ способом задаются две версии функции operator++(). Первая определяется так, как было показано в предыдущем примере. Вторая определяется сле-дующим образом: coord coord: :operator++ (int notused); Если оператор ++ указан перед операндом, вызывается функция operator++(). Если оператор ++ указан после операнда, вызывается функция opera tor++ (int notused). В этом случае переменной notused передается значе-ние 0. Таким образом, если префиксный и постфиксный инкремент или дек-ремент важны для объектов вашего класса, то понадобится реализовать обе оператор -функции. 3. Как вы знаете, знак минус в C++ является как бинарным, так и унарным оператором. Вы, наверное, хотели бы знать, как его можно перегрузить отно-сительно создаваемого вами класса так, чтобы оператор сохранил оба эти ка-чества. Реальное решение достаточно элементарно: просто перегрузите его дважды, один раз как бинарный оператор, а второй - как унарный. Про-грамма, реализующая этот прием, показана ниже: //Перегрузка оператора - относительно класса coord ^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord (J { x = 0; y= 0; } coord(int i, int j) { x = i; у = j; } void get_xy{int &i, int &j ) { i = x; j = y; } coord operator-{coord ob2); //бинарный минус coord operator-(); //унарный минус }t //Перегрузка оператора - относительно класса coord coord coord: : operator-(coord ob2) 1 coord temp; terap.x = x - ob2.x; temp. у = у - ob2.y; return temp; //Перегрузка унарного оператора - для класса coord coord coord: : operator-( )
Глава 6. Введение в перегрузку операторов __ 189 return *this; }int main () { coord ol(10, 10), o2(5, 7); int x, y; ol = ol - o2; //вычитание ol.get_xy {x, y) ; cout " "(Ol-o2) X: " " x " ", Y: " " у " "\n"; ol = -ol; //отрицание ol.get_xy (x, y) ; cout " "(-ol) X: " " x " ", Y: " " у " "\n"; return 0; Как видите, если минус перегружать как бинарный оператор, то у функции будет один параметр. Если его перегружать как унарный оператор, то пара-метров не будет. Это отличие в числе параметров и делает возможным пере-грузку минуса для обоих операторов. Как показано в программе, при использовании минуса в качестве бинарного оператора вызывается функция operator- (coord ob2), а в качестве унарного - функция operator- (): УпраАнеенниия] 1. Перегрузите оператор - относительно класса coord. Создайте его префикс-ную и постфиксную формы. 2. Перегрузите оператор + относительно класса coord так, чтобы он был как бинарным (как было показано ранее), так и унарным оператором. При ис-пользовании в качестве унарного оператор + должен делать положительным значение любой отрицательной координаты. 6.5. Дружественные оператор-функции Как отмечалось в начале этой главы, имеется возможность перегружать опе-ратор относительно класса, используя не только функцию-член, но и дру-жественную функцию. Как вы знаете, дружественной функции указатель this не передается. В случае бинарного оператора это означает, что дружествен-ной оператор-функции явно передаются оба операнда, а в случае унарно-го - один. Все остальное в обоих случаях одинаково, и нет особого смысла вместо оператор-функции - члена класса использовать дружественную
190 Самоучитель C++ оператор-функцию, за одним важным исключением, которое будет рассмот-рено в примерах. Нельзя использовать дружественную функцию для перегрузки оператора присваивания. Оператор присваивания можно перегружать только как опера-тор-функцию - член класса. 1. Здесь функция operator+() перегружается для класса coord с использованием дружественной функции: //Перегрузка оператора + относительно класса coord //с использованием дружественной функции #include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord() { x = 0; y= 0; } coord (int i, int j) 1 x = i; у = j; } void get_xy(int si, int & j) { i = x; j = y; } friend coord operator*(coord obi, coord ob2); ); //Перегрузка оператора + с использованием дружественной функции coord operator+(coord obi, coord ob2) { coord temp; temp.x = obl.x + ob2.x; temp.у = obi.у + ob2.y; return temp; int main() { coord ol(10, 10), o2(5, 3), o3; int x, y; o3 = ol + o2; //сложение двух объектов //вызов функции operator+{)
Глава 6. Введение в перегрузку операторов 191 o3.get_xy(х, у); cout " "(ol + о2) X: " " х " ", Y: " " у " "\п"; return 0; Обратите внимание, что левый операнд передается первому параметру, а правый - второму. 2. Перегрузка оператора посредством дружественной функции дает одну очень важную возможность, которой нет у функции - члена класса. Используя дружественную оператор-функцию, в операциях с объектами можно исполь-зовать встроенные типы данных, и при этом встроенный тип может распо-лагаться слева от оператора. Как отмечалось ранее в этой главе, можно перегрузить оператор-функцию, являющуюся членом класса, так, что левый операнд становится объектом, а правый - значением встроенного типа. Но нельзя для функции - члена класса располагать значение встроенного типа слева от оператора. Например, пусть перегружается оператор-функция -член класса, тогда первая показанная здесь инструкция правильна, а вторая нет: оЫ = оЬ2 + 10; //правильно оЫ = 10 + оЬ2; //неправильно Несмотря на то, что допустимо строить выражения так, как показано в первом примере, необходимость постоянно думать о том, чтобы объект находился слева от оператора, а значение встроенного типа - справа, может быть обременитель-ной. Решение проблемы состоит в том, чтобы сделать перегруженную оператор-функцию дружественной и задать обе возможные ситуации. Как вы знаете, дружественной оператор-функции передаются явно оба опе-ранда. Таким образом, можно задать перегружаемую дружественную функ-цию так, чтобы левый операнд был объектом, а правый - операндом другого типа. Затем можно снова перегрузить оператор, чтобы левый операнд был значением встроенного типа, а правый - объектом. Следующая программа иллюстрирует такой подход: //Дружественные оператор-функции придают гибкость программе ^include <iostream> using namespace std; class coord { int х, у; //значения координат public: coord() { x = 0; y= 0; } coord(int i, int j) { x = i ; y = j ; } void get_xy(int Si, int &j) { i = x; j = y; } friend coord operator+(coord obi, int i); friend coord operator+(int i, coord obi);
192 Самоучитель C++ II Перегрузка оператора + для операции, ob + int coord operator-*-(coord obi, int i) coord temp; temp.x -obl.x + i; temp. у = obi. у + i; return temp; }//Перегрузка оператора + для операции int :+: ob coord operator-Hint i, coord obi) { coord temp; temp.x = obl.x + i; temp. у = obi. у + i; return temp; int main!) { coord ol (10, 10) ; int x, y; ol = ol + 1 0 ; //объект + целое ol .get_xy (x, y) ; cout " "(ol + 10) X: " " x " ", Y: " " у " "\n"; ol = 99 + ol; //целое + объект ol.get_xy (x, y) ; cout " "(99 + ol) X: " " x " ", Y: " " у " "\n"; return 0; В результате перегрузки дружественных оператор-функций становятся пра-вильными обе инструкции: ol = ol +: 10; ol = 99 + ol; 3. При использовании дружественной оператор-функции для перегрузки унар-ного оператора ++ или - необходимо передавать операнд в функцию в каче-стве параметра-ссылки, поскольку дружественной функции не передается указатель this. Запомните, что в операторах инкремента и декремента подразу-мевается, что операнд будет изменен. Однако при перегрузке этих операторов посредством дружественных функций операнд передается по значению. Таким образом, любое изменение параметра внутри дружественной оператор-функ-ции не влияет на объект, являющийся источником вызова. Поскольку при ис-
Глава 6. Введение в перегрузку операторов _ /93 пользовании дружественной функции отсутствует явно передаваемый указа-тель на объект (т. е. указатель this), инкремент и декремент не влияют на операнд. Однако при передаче операнда дружественной функции в качестве парамет-ра-ссылки, изменения, которые имеют место внутри дружественной функции, влияют на объект, являющийся источником вызова. Например, в следующей программе посредством дружественной функции перегружается оператор ++. //Перегрузка оператора ++ с использованием дружественной функции ^include <iostrearn> using namespace std; class coord { int x, у; //значения координат public: coord () ( x = 0; y= 0; } coord (int i, int j) { x = i; у = j; } void get_xy(int Si, int &j) { i = x; j = y; } friend coord operator++ (coord &ob) ; //Перегрузка оператора ++ с использованием дружественной функции coord operator+-f (coord Sob) //использование ссылки //в качестве параметра ob,x++; оЬ.у+-ь; return ob; //возвращение объекта, //ставшего источником вызова int ma in () coord ol(10, 10) ; int x, y; ++ol; //объект ol передается по ссылке ol.get_xy (x, y) ; cout " "(++ol) X: " " x " ", У: " " у " "\n"; return 0; Если вы используете современный компилятор, то с помощью дружествен-ной оператор-функции можно определить разницу между префиксной и постфиксной формами операторов инкремента и декремента точно так же, как это делалось с помощью функций-членов. Просто добавьте целый пара-метр при задании постфиксной версии. Например, здесь приводятся пре-
194 Самоучитель C++ фиксная и постфиксная версии оператора инкремента относительно класса coord: : coord operator*-*-(coord Sob}; //префиксная версия coord operator++(coord Sob, int notused); //постфиксная версия Если оператор +4-находится перед операндом, то вызывается функция coord operatoH-+(coord &ob). Однако, если оператор ++ находится после операнда, вызывается функция coord operator++(coord &ob, int notused). В этом случае переменной notused будет передано значение 0. !УпраЖнlеeHниUяfl|j 1. Перегрузите операторы - и /для класса coord посредством дружественных функций. 2. Перепишите класс coord так, чтобы можно было использовать объекты типа coord для умножения каждой из координат на целое. Должны быть коррект-ными обе следующие инструкции: ob * int и int * ob. 3. Объясните, почему решение упражнения 2 требует использования дружест-венных оператор-функций. Покажите, как с помощью дружественной оператор-функции перегрузить опе-ратор- относительно класса coord. Определите как префиксную, так и пост-фиксную формы. 6.6. Особенности использования оператора присваивания Как уже отмечалось, относительно класса можно перегрузить оператор при-сваивания. По умолчанию, если оператор присваивания применяется к объ-екту, то происходит поразрядное копирование объекта, стоящего справа от оператора, в объект, стоящий слева от оператора. Если это то, что вам нуж-но, нет смысла создавать собственную функцию operator=(). Однако бывают случаи, когда точное поразрядное копирование нежелательно. В главе 3 при выделении памяти объекту вам было представлено несколько примеров по-добного рода. В таких случаях требуется особая операция присваивания. I Примеры ] 1. Здесь приведена новая версия класса strtype, различные формы которого изучались в предыдущих главах. В этой версии оператор = перегружается так, что указатель р при присваивании не перезаписывается.
Глава 6. Введение в перегрузку операторов 195 ^include <iostream> #include <cstring> #include <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype (char *s) ; -strtype () { cout " "Освобождение памяти по адресу " " (unsigned) p " ' \ n ' ; delete []p; )char *get() { return p; } strtype &operator= (strtype &ob) ; }; strtype: : strtype (char *s) { int 1; 1 = strlen(s) + 1; p = new char [1] ; if(!p) { cout " "Ошибка выделения памяти\п"; exit(l) ; }len = 1; strcpy (p, s) ; }//Присваивание. объекта strtype fistrtype: :operator= (strtype &ob) { //выяснение необходимости дополнительной памяти if {len < ob.len) { //требуется выделение дополнительной памяти delete!] p; p = new char [ob.len]; if(!p) { cout " "Ошибка выделения памяти\п"; exit ( 1 ) ; len = ob.len; strcpy (p, ob.p); return *this;
/96 _ __ _ Самоучитель C++ int ma in () ( strtype а ("Привет") , b ("Здесь") ; cout " a.getO " '\n'; cout " b.getO " '\n'; a = b; //теперь указатель р не перезаписывается cout " a.getO " '\n'; cout " b.getO " ' \ n ' ; return 0; Как видите, перегрузка оператора присваивания предотвращает перезапись указателя р. При первом контроле выясняется, достаточно ли в объекте слева от оператора присваивания выделено памяти для хранения присваиваемой ему строки. Если это не так, то память освобождается и выделяется новый фрагмент. Затем строка копируется в эту память, а длина строки копируется в переменную 1еп. Отметьте два важных свойства функции operator=(). Во-первых, в ней ис-пользуется пара метр-ссылка. Это необходимо для предотвращения создания копии объекта, стоящего справа от оператора присваивания. Как известно по предыдущим главам, при передаче в функцию объекта создается его копия, и эта копия удаляется при завершении работы функции. В этом случае для удаления копии должен вызываться деструктор, который освобождает па-мять, обозначенную указателем р. Однако память по адресу р все еще необ-ходима объекту, который является аргументом. Параметр -ссылка помогает решить проблему. Вторым важным свойством функции operator=() является то, что она возвра-щает не объект, а ссылку на него. Смысл этого тот же, что и при обычном ис-пользовании параметра-ссылки. Функция возвращает временный объект, который удаляется после полного завершения ее работы. Это означает, что для временного объекта будет вызван деструктор, который вызовет освобождение памяти по адресу р, но указатель р (и память на которую он ссылается) все еще необходимы для присваивания значения объекту. Поэтому, чтобы избежать создания временного объекта, в качестве возвращаемого значения используется ссылка. Как вы узнали из главы 5, создание конструктора копий - это другой путь решения проблем, описанных в двух предыдущих разделах. Но конструктор копий может оказаться не столь эффективным решением, как ссылка в каче-стве параметра и ссылка в качестве возвращаемого значения функции. Это происходит потому, что использование ссылки исключает затраты ресурсов,
Глава 6. Введение в перегрузку операторов 197 связанные с копированием объекта в каждом из двух указанных случаев. Как видите, в C++ часто имеется несколько способов достижения одной и той же цели. Понимание их преимуществ и недостатков ~ это часть процесса ваше-го становления как профессионального программиста C++. Пусть дано следующее объявление класса, добавьте все необходимое для соз-дания типа динамический массив. То есть выделите память для массива и со-храните указатель на эту память по адресу р. Размер массива в байтах сохраните в переменной size. Создайте функцию put(), возвращающую ссыл-ку на заданный элемент массива и функцию get(), возвращающую значение заданного элемента. Обеспечьте контроль границ массива. Кроме этого пе-регрузите оператор присваивания так, чтобы выделенная каждому массиву такого типа память не была случайно повреждена при присваивании одного массива другому. (В следующем разделе будет показан более совершенный способ решения этого упражнения.) class dynarray { int *p; int size; public: dynarray(int s); //передача размера массива в переменной s int Sput(int i); //возвращение ссылки на элемент i int get(int i}; //возвращение значения переменной i //создайте функцию operator={) 6.7. Перегрузка оператора индекса массива [] Последним оператором, который мы научимся перегружать, будет оператор индекса массива []. В C++ при перегрузке оператор [] рассматривается как бинарный. Оператор [] можно перегружать только как функцию-член. Ниже представлена основная форма оператор -функции - члена класса operator!] (): тип иыя__класса: : opera tor [] (int индекс) II ... С технической точки зрения тип параметра не обязательно должен быть це-лым, но поскольку оператор-функция operator[](), как правило, использует-ся для получения индекса массива, то ее параметр обычно имеет тип int.
198 Самоучитель C++ Чтобы понять, как работает оператор [], представим, что объект О индекси-руется следующим образом: 0[9] Этот индекс транслируется в вызов функции operator[](): О.operator[](9) Таким образом, значение выражения внутри оператора индексирования яв-но передается функции operator[]() в качестве параметра. При этом указа-тель this будет ссылаться на объект О, являющийся источником вызова. I Примеры ^i/" 1. В следующей программе объявляется состоящий из пяти целых массив arraytype. Каждый элемент массива инициализируется конструктором. Пере-груженная функция operator[]() возвращает элемент, заданный ее параметром. # include <iostream> using namespace std; const int SIZE = 5; class arraytype { int a [SIZE] ; public: arraytype ( ) ( int i ; for (i=o; i<SIZE; i-H-) a[i] = i; }int operator [] {int i) { return a[i]; } int main ( ) { arraytype ob; int i; for{i=0; i<SIZE; i cout " ob[i] " return 0; В результате работы программы на экран выводится следующее: 0 1 2 3 4
Глава 6. Введение в перегрузку операторов _ 199 В этом и остальных примерах инициализация массива а с помощью конст-руктора выполнена исключительно в иллюстративных целях и на самом деле не требуется. 2. Имеется возможность перегрузить функцию operator[]() так, чтобы в инст-рукции присваивания оператор [] можно было располагать как слева, так и справа от оператора =. Для этого возвратите ссылку на индексируемый эле-мент. Следующая программа иллюстрирует такой подход. ttinclude <iostream> using namespace std; const int SIZE = 5; , class arraytype { int a [SIZE]; public: arraytype (} { int i ; for {i=o; i<SIZE; i++) a[i] = i; int Separator [] (int i) { return a[i]; } int main ( ) arraytype ob; int i; for(i=0; i<SIZE; i cout " o b f i j " " "; cout " "\n"; //добавление значения 10 к каждому элементу массива for{i=0; i<SIZE; i-H-} ob[i] = ob[i]+10; //оператор [] слева от оператора = for(i=0; i<SIZE; i+-t-) cout " ob[i] " " "; return 0; В результате работы программы на экран выводится следующее: 0 1 2 3 4 10 11 12 13 14 Поскольку теперь функция operator[]() возвращает ссылку на элемент мас-сива с индексом i, то для изменения этого элемента оператор [] можно рас-
200 _ Самоучитель C++ положить слева в инструкции присваивания. (Естественно, что как и прежде его можно располагать справа.) Таким образом, с объектами типа arraytype можно обращаться так же, как и с обычными массивами. 3. Перегрузка оператора [] дает возможность по-новому взглянуть на задачу индексирования безопасного массива. Ранее в этой книге мы рассматривали простейший способ реализации безопасного массива, в котором для доступа к элементам массива использовались функции get() и put(). Перегрузка опе-ратора [] позволит нам теперь создать такой массив гораздо проще. Вспом-ните, что безопасный массив - это массив, который инкапсулирован в классе, и при этом класс обеспечивает контроль границ массива. Такой под-ход предотвращает нарушение границ массива. Благодаря перегрузке опера-тора [], работать с безопасным массивом можно так же, как с обычным. Для создания безопасного массива просто реализуйте в функции operator[]() контроль границ. Кроме этого, функция operator[]() должна возвращать ссылку на индексируемый элемент. Например, в представленном ниже при-мере в предыдущую программу добавлен контроль границ массива, что по-зволяет при нарушении границ генерировать соответствующую ошибку. //Пример безопасного массива #include <iostream> finclude <cstdlib> using namespace std; const int SIZE = 5; class arraytype { int a[SIZE]; public: arraytype () { int i ; for (i=o; i<SIZE; i++) a[i] = i; int &operator[] (int i) ; //Обеспечение контроля границ для массива типа arraytype int fiarraytype: : operator [] (int i) cout " "ХпЗначение индекса "; cout " i " " находится за пределами границ массива. \п exit (1) ; }return a [i] ;
Глава 6. Введение в перегрузку операторов 201 int main () arraytype ob; int i; //Здесь проблем нет for{i=0; i<S!ZE; i++) cout " ob[i] " " "; /* А здесь при выполнении программы генерируется ошибка, поскольку значение SIZE+100 не входит в заданный диапазон */ob[SIZE+100] = 99; //Ошибка!!! return 0; Благодаря контролю границ, реализованному в функции operator[](), при выполнении инструкции ob[SIZE+100] = 99; программа завершится еще до того, как будет повреждена какая-либо ячейка памяти. Поскольку перегрузка оператора [] позволяет создавать безопасные массивы, которые выглядят и функционируют так же, как самые обычные массивы, их можно безболезненно добавить в вашу программную среду. Однако будьте внимательны. Безопасный массив увеличивает расход ресурсов, что не во всех ситуациях может оказаться приемлемым. Фактически, именно из-за не-производительного расхода ресурсов в C++ отсутствует встроенный контроль границ массивов. Тем не менее, в тех приложениях, в которых желательно обеспечить целостность границ, реализация безопасного массива будет луч-шим решением. 1. Переделайте пример 1 из раздела 6.6 так, чтобы относительно класса strtype перегрузить оператор []. Этот оператор должен возвращать символ по задан-ному индексу. Кроме этого, необходима возможность задавать оператор [] в левой части инструкции присваивания. Покажите, что ваша программа работает. 2. Измените ваше решение упражнения 1 из раздела 6.6 так, чтобы оператор [] использовать для индексирования динамического массива. То есть замените функции get() и put() оператором [].
202 Самоучитель C++ \ Проверка усвоении , материала главы ~~2^ Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы: 1. Перегрузите операторы сдвига " и " относительно класса coord так, чтобы стали возможными следующие типы операций: ob " integer ob " integer Удостоверьтесь, что ваши операторы действительно сдвигают значения х и у на заданное количество разрядов. 2. Пусть дан класс class three_d ( int х, у, z; public: three_d(int i, int j, int 3t) { x = i; у = j ; z = k; } three_d() { x = 0; у -0; z = 0; } void get (int &i, int sj, int &k) { i = x; j = y; k = z; Перегрузите для этого класса операторы +, - , ++ и - . (Для операторов инкремента и декремента перегрузите только префиксную форму.) 3. Измените ваше решение вопроса 2 так, чтобы в оператор-функциях вме-сто параметров-значений использовать параметры -ссылки. (Подсказка. Для операторов инкремента и декремента вам потребуются дружествен-ные функции.) 4. Чем действие дружественной оператор-функции отличается от действия оператор -функции - члена класса? 5. Объясните, почему может потребоваться перегрузка оператора присваи-вания. 6. Может ли функция operator=() быть дружественной? 7. Перегрузите оператор + для класса three_d из вопроса 2 так, чтобы иметь возможность выполнять следующие типы операций:
Глава 6. Введение в перегрузку операторов 203 ob + int; int + ob; 8. Перегрузите операторы ==, != и || относительно класса three_d из вопроса 2. 9. Приведите главный довод в пользу перегрузки оператора []. Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Создайте класс strtype, который допускает следующие типы операций: : Конкатенацию строк с помощью оператора + : Присваивание строк с помощью оператора = : Сравнение строк с помощью операторов <, > и == Можете пользоваться строками фиксированной длины. На первый взгляд это может показаться непростой задачей, но, немного подумав (и поэкспе-риментировав), вы должны справиться.
Глава 7 Наследование Ранее в этой книге вы познакомились с концепцией наследования. Сейчас пришло время осветить эту тему более детально. Наследование - это один из трех базовых принципов OOP, и потому является одним из важнейших инструментов C++. В C++ наследование используется не только для под-держки иерархии классов, но, как вы узнаете из главы 10, и для поддержки другого важнейшего инструмента OOP - полиморфизма. Материал, который приведен в этой главе, включает в себя следующие темы: управление доступом к базовому классу, спецификатор доступа protected, множественное наследование, передача аргументов конструкторам базового класса, виртуальные базовые классы. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. -1. Теряет ли оператор при перегрузке что-либо из своей исходной функ-циональности? 2. Нужно ли перегружать оператор относительно определенного пользова-телем типа данных, например, класса? 3. Можно ли изменить приоритет перегруженного оператора? Можно ли изменить количество операндов? 4. Дана следующая, почти законченная программа, добавьте недостающие оператор-функции: ^include <iostrearn> using namespace std; class array { int nums[10]; public: array (} ;
206 Самоучитель C++ void set(int n[10]); void show(); -array operator+(array ob2) ; array operator-(array ob2} ; int operator==(array ob2); }; array::array() { int i ; for{i = 0; i < 10; i++) nums[i] -0; 1 void array::set(int *n) { int i ; for(i = 0 ; i < 10; i++) nums[i] = n[i]; } void array::show() { int i; for(i = 0; i < 10; i++) cout " numsfi] " ' ' ; cout " "\n"; }//Впишите оператор-функции int main() { array ol, o2, o3; J int i[10] -{1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; ol.set (i); o2.set(i); o3 = ol + o2; o3.show(); o3 = ol -o3; o3.show() ; if{ol==o2) cout " "ol равно o2\n"; else cout " "ol не равно о2\п"; if(ol==o3} cout " "ol равно o3\n"; else cout " "ol не равно оЗ\п"; return 0;
Глава 7. Наследование 207 Перегруженный оператор + должен поэлементно складывать оба операн-да. Перегруженный оператор - должен вычитать все элементы правого операнда из элементов левого. Перегруженный оператор == должен воз-вращать значение true, если все элементы обоих операндов равны, в про-тивном случае он должен возвращать значение false. 5. Переработайте решение упражнения 4 так, чтобы перегрузить операторы с использованием дружественных функций. 6. Используя класс и функции из вопроса 4, перегрузите оператор ++ с помощью функции - члена класса, а оператор - с помощью дружест-венной функции. (Перегрузите только префиксные формы операторов ++ и -:.) 7. Можно ли, используя дружественную функцию, перегрузить оператор присваивания? 7.1. Управление доступом к базовому классу Когда один класс наследуется другим, используется следующая основная форма записи: class имл производного класса: ел доступа имя_базового_хласса ( //. . . J Здесь cn_docmyna - это одно из трех ключевых слов: public, private или protected. Обсуждение спецификатора доступа protected отложим до сле-дующего раздела этой главы. Здесь рассмотрим спецификаторы public и private. Спецификатор доступа (access specifier) определяет то, как элементы базо-вого класса (base class) наследуются производным классом (derived class). Если спецификатором доступа наследуемого базового класса является ключевое слово public, то все открытые члены базового класса остаются от-крытыми и в производном. Если спецификатором доступа наследуемого ба-зового класса является ключевое слово private, то все открытые члены базового класса в производном классе становятся закрытыми. В обоих слу-чаях все закрытые члены базового класса в производном классе остаются закрытыми и недоступными. Важно понимать, что если спецификатором доступа является ключевое сло-во private, то хотя открытые члены базового класса становятся закрытыми в производном, они остаются доступными для функций - членов производ-ного класса.
208 Самоучитель C++ Технически спецификатор доступа не обязателен. Если спецификатор дос-тупа не указан и производный класс определен с ключевым словом class, то базовый класс по умолчанию наследуется как закрытый. Если спецификатор доступа не указан и производный класс определен с ключевым словом struct, то базовый класс по умолчанию наследуется как открытый. Тем не менее, для ясности большинство программистов предпочитают явное зада-ние спецификатора доступа. ПримерыР 1. Здесь представлены базовый и наследующий его производный классы (наследование со спецификатором public): ^include <iostream> using namespace std; class base { int x; public: void setx{int n) { x = n; } void showx() ( cout " x " '\n'; } //Класс наследуется как открытый class derived: public base { int y; public: void setyfint n) { у = n; } void showy () { cout " у " '\n'; } }; int main() { derived ob; ob.setx(lO); //доступ к члену базового класса ob.sety(20); //доступ к члену производного класса ob.showx(); //доступ к члену базового класса ob.showyO; //доступ к члену производного класса return 0; Как показано в программе, поскольку класс base наследуется как открытый, открытые члены класса base - функции setx() и showx() - становятся от-крытыми производного класса derived и поэтому доступны из любой части
Глава 7. Наследование _ 209 программы. Следовательно, совершенно правильно вызывать эти функции из функции main О 2. Важно понимать, что наследование производным классом базового как от-крытого совсем не означает, что для производного класса станут доступными закрытые члены базового. Например, это небольшое изменение в классе derived из предыдущего примера неправильно: class base { int х; public : void setx(int n) { x = n; } void ghowxf) { cout " x " '\n'; } //Класс наследуется как открытый class derived: public base { int y; public: void sety(int n) { у = n; } /* Закрытые члены базового класса недоступны, х - это закрытый член базового класса и поэтому внутри производного класса он недоступен */void show_sum(} { cout " х+у " '\nr; } //Ошибка! ! ! void showy {) { cout " у " '\n'; } Здесь в производном классе derived сделана попытка доступа к переменной х, которая является закрытым членом базового класса base. Это неверно, по-скольку закрытые члены базового класса остаются закрытыми, независимо от того, как он наследуется. 3. Ниже представлена слегка измененная версия программы из примера 1. Ба-зовый класс base наследуется как закрытый, т. е. с ключевым словом private. Такое изменение, как показано в комментариях, при компиляции ведет к ошибке. //В этой программе есть ошибка tinclude <iostream> using namespace std; class base { int x; public: void setxfint n} ( x = n; } void showx{) { cout " x " '\n'; }
210 _ Самоучитель_С+ + /! Класс наследуется как закрытый class derived: private base { int у; public: void setyfint n) { у = n; } void showy () { cout " у " r\n'; } int raain() ( derived ob; ob.setx(lO); //ОШИБКА - теперь закрыто для производного класса ob.sety(20); //правильный доступ к члену производного класса ob.showxi); //ОШИБКА - теперь закрыто для производного класса ob. showy (); //правильный доступ к члену производного класса return 0; Как отражено в комментариях к этой (неправильной) программе, функции showx() и setx() становятся закрытыми в производном классе и недоступны-ми вне его. Запомните, что функции showxQ и setx() в базовом классе base по-прежнему остаются открытыми независимо от того, как они наследуются производным классом. Это означает, что объект типа base мог бы получить доступ к этим функциям в любом месте программы. Однако для объектов типа derived они становятся закрытыми. Например, в данном фрагменте: base base_ob; base_ob.setx (1) ; //правильно, поскольку объект base_ob //имеет тип base вызов функции setx() правилен, поскольку функция setx() - это открытый член класса base, 4. Как мы уже узнали, хотя открытые члены базового класса при наследовании с использованием спецификатора private в производном классе становятся закрытыми, внутри производного класса они остаются доступными. Напри-мер, ниже представлена исправленная версия предыдущей программы: //Исправленная версия программы ^include <iostream> using namespace std; class base ( int x; public : void setx(int n) { x = n; }
Глава 7. Наследование 211 void showxO { cout " x " '\n'; } }; //Класс наследуется как закрытый class derived: private base { int y; public: //переменная setx доступна внутри класса derived void setxy(int n, int m) { setx(n); у = га; } //переменная showx доступна внутри класса derived void showxyO { showxf); cout " у " '\n'; } }; int main () { derived ob; ob.setxyUO, 20) ; ob.showxy(); return 0; } . В данном случае функции showx() и setx() доступны внутри производного класса, что совершенно правильно, поскольку они являются закрытыми чле-нами этого класса. : 1. Исследуйте следующую конструкцию: ttinclude <iostream> using namespace std; class mybase { int a, b; public: int c; void setab{int i, int j ) ( a = i; b = j ; } void getab(int Si, int &j ) { i = a; j = b; } class derivedl: pablic mybase {
212 Самоучитель C++ class derived2: private mybase ( int rnainO derivedl ol; derived2 o2; int i, j; //... Какая из следующих инструкций правильна внутри функции mainQ? A. ol.getab(i, j ) ; B. о2.getab(i, j ) ; C. ol.c = 10; D. o2.c = 10; 2. Что происходит, когда открытые члены базового класса наследуются как от-крытые? Что происходит, когда они наследуются как закрытые? 3. Если вы этого еще не сделали, попытайтесь выполнить все примеры, пред-ставленные в этом разделе. Поэкспериментируйте со спецификаторами дос-тупа и изучите результаты. 7.2. Защищенные члены класса Как вы узнали из предыдущего раздела, у производного класса нет доступа к закрытым членам базового. Это означает, что если производному классу необходим доступ к некоторым членам базового, то эти члены должны быть открытыми. Однако возможна ситуация, когда необходимо, чтобы члены базового класса, оставаясь закрытыми, были доступны для производного класса. Для реализации этой идеи в C++ включен спецификатор доступа protected (защищенный). Спецификатор доступа protected эквивалентен спецификатору private с единственным исключением: защищенные члены базового класса доступны для членов всех производных классов этого базового класса. Вне базового или производных классов защищенные члены недоступны. Спецификатор доступа protected может находиться в любом месте объявле-ния класса, хотя обычно его располагают после объявления закрытых чле-нов (задаваемых по умолчанию) и перед объявлением открытых членов. Ниже показана полная основная форма объявления класса:
Глава 7. Наследование _ 213 class имя класса { //закрытые члени protected: //необязательный //защищенные public: //открытые "лени Когда базовый класс наследуется производным классом как открытый (public), защищенный член базового класса становится защищенным членом производного класса. Когда базовый класс наследуется как закрытый (private), то защищенный член базового класса становится закрытым членом производного класса. Базовый класс может также наследоваться производным классом как защи-щенный (protected). В этом случае открытые и защищенные члены базового класса становятся защищенными членами производного класса. (Естественно, что закрытые члены базового класса остаются закрытыми, и они не доступны для производного класса.) Спецификатор доступа protected можно также использовать со структурами. 1. В этой программе проиллюстрирован доступ к открытым, закрытым и защи щенным членам класса: finclude <iostream> using namespace std; class samp ( //члены класса, закрытые по умолчанию int а; protected: //тоже закрытые члены класса samp int b; public: int с; samp(int n, int m) { a = n; b = m; } int geta(} { return a; } int getb() { return b; } }; int main{) { samp ob(10, 20);
214 _ _ __ _ __ Самоучитель C++ //ob.b = 99; Ошибка! Переменная Ь защищена и поэтому закрыта ob.c = 30; //Правильно! Переменная с //является открытым членом класса samp cout " ob.geta() " ' '; cout " ob.getbO " ' ' " ob.c " r\n'; return 0; Как вы могли заметить, выделенная в комментарий строка содержит инст-рукцию, недопустимую в функции main(), поскольку переменная b является защищенной и таким образом по-прежнему закрытой для класса samp. 2. В следующей программе показано, что происходит, если защищенные члены класса наследуются как открытые: ^include <iostream> using namespace std; class base { protected: //закрытые члены класса base, int a,b; //но для производного класса они доступны public: void setab(int n, int m) { a = n; b = m; } class derived: public base { int c; public : void setc(int n) ( с = n; } //эта функция имеет доступ к переменным а и b класса base void showabc 0 { cout " а " ' ' " b " ' ' " с " '\n'; int main ( ) ( derived ob; /* Переменные а и b здесь недоступны, поскольку являются закрытыми членами классов base и derived Ч ob.setab(l, 2) ; ob.setc (3) ; ob. showabc () ; return 0;
Глава 7. Наследование _ 215 Поскольку переменные а и Ь в классе base защищены и наследуются произ-водным классом derived как открытые члены, они доступны для использова-ния функциями - членами класса derived. Однако вне двух этих классов они в полной мере закрыты и недоступны. 3. Как упоминалось ранее, если базовый класс наследуется как защищенный, открытые и защищенные члены базового класса становятся защищенными членами производного класса. Например, в слегка измененной версии про-граммы из предыдущего примера класс base наследуется не как открытый, а как защищенный: //Эта программа компилироваться не будет ^include <iostream> using namespace std; class base { protected: //закрытые члены класса base, int a,b; //но для производного класса они доступны public: void setab(int n, int m) { a = n; b = m; } }; class derived: protected base ( II класс base наследуется //как защищенный int с; public: void setcfint n} { с = n; } //эта функция имеет доступ к переменным а и b класса base void showabc () { cout " a " ' ' " b " ' ' " с " '\n'; \ : int main() derived ob; //ОШИБКА: теперь функция setab{) //является защищенным членом класса base ob.setab(l, 2); //функция setab() здесь недоступна ob.setc (3) ; ob . showabc ( ) ; return 0; Как указано в комментариях, поскольку класс base наследуется как защи-щенный, его открытые и защищенные элементы становятся защищенными членами производного класса derived и следовательно внутри функции main() они недоступны.
216 Самоучитель C++ 1. Что происходит с защищенным членом класса, когда класс наследуется как открытый? Что происходит, когда он наследуется как закрытый? 2. Объясните, зачем нужна категория защищенности protected? 3. В вопросе 1 из раздела 7.1, если бы переменные а и b внутри класса myclass стали не закрытыми (по умолчанию), а защищенными членами, изменился бы какой-нибудь из ваших ответов на вопросы этого упражнения? Если да, то почему? 7.3. Конструкторы, деструкторы и наследование Базовый класс, производный класс или оба класса вместе могут иметь кон-структоры и/или деструкторы. В этой главе исследуется несколько следст-вий такого положения. Если у базового и у производного классов имеются конструкторы и деструк-торы, то конструкторы выполняются в порядке наследования, а деструкто-ры-в обратном порядке. Таким образом, конструктор базового класса выполняется раньше конструктора производного класса. Для деструкторов правилен обратный порядок: деструктор производного класса выполняется раньше деструктора базового класса. Последовательность выполнения конструкторов и деструкторов достаточно очевидна. Поскольку базовый класс "не знает" о существовании производ-ного, любая инициализация выполняется в нем независимо от производного класса и возможно становится основой для любой инициализации, выпол-няемой в производном классе. Поэтому инициализация в базовом классе должна выполняться первой. С другой стороны, деструктор производного класса должен выполняться раньше деструктора базового класса потому, что базовый класс лежит в ос-нове производного. Если бы деструктор базового класса выполнялся пер-вым, это бы разрушило производный класс. Таким образом, деструктор производного класса должен вызываться до того, как объект прекратит свое существование. Пока что ни в одном из предыдущих примеров мы не передавали аргументы для конструктора производного или базового класса. Однако это вполне возможно. Когда инициализация проводится только в производном классе, аргументы передаются обычным образом. Однако при необходимости пере-дать аргумент конструктору базового класса ситуация несколько усложня-ется. Во-первых, все необходимые аргументы базового и производного классов передаются конструктору производного класса. Затем, используя
Глава 7. Наследование _ 217 расширенную форму объявления конструктора производного класса, соот-ветствующие аргументы передаются дальше в базовый класс. Синтаксис пе-редачи аргументов из производного в базовый класс показан ниже: конструктор_произв_класса(список-арг) : базов_класс (список_арг) { //тело конструктора производного класса Для базового и производного классов допустимо использовать одни и те же аргументы. Кроме этого, для производного класса допустимо игнорирование всех аргументов и передача их напрямую в базовый класс. 1. В этой очень короткой программе показано, в каком порядке выполняются конструкторы и деструкторы базового и производного классов: ^include <iostream> using namespace std; . class base { public: base() { cout " "Работа конструктора базового класса \п"; } ~base ( ) { cout " "Работа деструктора базового класса \п"; } class derived: public base ( public: derived() ( cout " "Работа конструктора производного класса\п"; } -derived () ( cout " "Работа деструктора производного классаХп"; } int main () { derived о; return 0; После выполнения программы на экран выводится следующее: Работа конструктора базового класса Работа конструктора производного класса Работа деструктора производного класса Работа деструктора базового класса Как видите, конструкторы выполняются в порядке наследования, а деструк-торы - в обратном порядке.
218 _ __ _ __ Самоучитель 2. В этой программе показана передача аргумента конструктору производного класса: linclude <:iostream> using namespace std; class base { public: base() { cout " "Работа конструктора базового класса\п"; } -base () { cout " "Работа деструктора базового класса\п"; } class derived: public base { int j; public: derived(int n) { cout " "Работа конструктора производного класса \п"; j = n; } ~derived{) { cout " "Работа деструктора производного класса\п"; } void showj() { cout " j " '\n'; } }; int main() /derived о (10) ; о . showj ( ) ; return 0; Обратите внимание, что аргумент передается конструктору производного класса обычным образом. 3. В следующем примере у конструкторов производного и базового классов имеются аргументы. В этом особом случае оба конструктора используют один и тот же аргумент, и производный класс просто передает этот аргумент в базовый класс. #include <iostream> using namespace std; class base { int i; public: base {int n) { cout " "Работа конструктора базового класса\п"; i -n;
Глава 7. Наследование 2)9 -base () { cout " "Работа деструктора базового класса\п"; } void show!() ( cout " i " ' \ n ' ; } class derived: public base { int j ; public: derived{int n} : base (n) { //передача аргумента //в базовый класс cout " "Работа конструктора производного классаЧп"; j = n; }~derived() { cout " "Работа деструктора производного класса\п ) void showj() { cout " j " '\n'; } ); int main () t derived о (10) ; o.showi ( ) ; o.showj () ; return 0; Обратите особое внимание на объявление конструктора производного класса. Отметьте, как параметр n (который получает аргумент при инициализации) используется в конструкторе derived() и передается конструктору base(). 4. Обычно конструкторы базового и производного классов не используют один и тот же аргумент. В этом случае, при необходимости передать каждому кон-структору класса один или несколько аргументов, вы должны передать кон-структору производного класса все аргументы, необходимые конструкторам обоих классов. Затем конструктор производного класса просто передает кон-структору базового класса те аргументы, которые ему требуются. Например, в представленной ниже программе показано, как передать один аргумент конструктору производного класса, а другой - -конструктору базового класса: #include <iostream> using namespace std; class base { int-i; public : base (int n) { cout " "Работа конструктора базового класса\п" ; i = n; \
220 Самоучитель C++ -base() { cout " "Работа деструктора базового класса\п"; ) void showi() { cout " i " '\n'; } class derived: public base { int j ; public: derivedfint n, int m) : base (m) { //передача аргумента //в базовый класс cout " "Работа конструктора производного класса\п"; j = п; }~derived() { cout " "Работа деструктора производного класса\п } void showj() { cout " j " '\n'; } }; int main() { derived о (10, 20) ; о. showi () ; o.showj () ; return 0; 5. Конструктору производного класса совершенно нет необходимости как-то обрабатывать аргумент, предназначенный для передачи в базовый класс. Ес-ли производному классу этот аргумент не нужен, он его просто игнорирует и передает в базовый класс. Например, в этом фрагменте параметр п конструк-тором derived() не используется. Вместо этого он просто передается конст-руктору base(): class base { int i; public: base (int n) { cout " "Работа конструктора базового класса\п"; i = п; } -base () { cout " "Работа деструктора базового класса\п"; } void showi () ( cout " i " *\n'; } class derived: public base { int j ; public: derived(int n) : base(n) { //передача аргумента в базовый класс
Глава 7. Наследование 221 cout " "Работа конструктора производного класса\п"; j = 0; //аргумент п здесь не используется )-derived() { cout " "Работа деструктора производного класса\п"; } void showj(} { cout " j " '\n'; } [Упражнения] &^ 1. В приведенном ниже фрагменте добавьте конструктор для класса myderived. Он должен передать указатель на инициализируемую строку конструктору класса mybase. Кроме того, конструктор myderived() должен инициализиро-вать переменную len длиной строки. ttinclude <iostream> # include <cstring> using namespace std; class rnybase { char str[80] ; public : mybasefchar *s) { strcpy(str, s) ; } char *get() { return str; } class myderived: public mybase { int len; public: //добавьте здесь конструктор myderived () int getlenf) ( return len; } void showf) ( cout " get() " '\n'; } }; int main () { myderived ob ("привет") ; ob . show ( ) ; cout " ob.getlen() " '\n'; return 0; 2. Используя следующий фрагмент, создайте соответствующие конструкторы саг() и truck(). Они должны передавать необходимые аргументы объектам класса vehicle. Кроме этого конструктор саг() должен при создании объекта
222 Самоучитель C++ инициализировать переменную passengers, а конструктор truck() - перемен-ную loadlimit. ^include <iostream> using namespace std; //Базовый класс автомобилей для разных типов class vehicle { int num_wheels; int range; public: vehicle(int w, int r) num_wheels = w; range = r; void showv() , cout " "Число колес" " num_wheels " '\n'; cout " "Грузоподъемность" " range " '\n'; J; class car: public vehicle { int passengers; public: //вставьте здесь конструктор саг() void show() showv(); cout " "Пассажироемкость" " passengers " '\n'; class truck: public vehicle { int loadlimit; public: //вставьте здесь конструктор truck {) void ahow() { showv {) ; cout " "Пробег" " loadlimit " ' \n ' ; int main () ( car c(5, 4, 500) ; truck t (30000, 12, 1200);
Глава\7._ Наследование 223 cout " "легковая машина:\п"; с.show(); cout " "Хпгрузовик:\п"; t. show () ; return 0; Для конструкторов саг() и truck() объекты должны объявляться следующим образом: car ob(passengers, wheels, range); truck ob(loadlimit, wheels, range); 7.4. Множественное наследование Имеются два способа, посредством которых производный класс может на-следовать более одного базового класса. Во-первых, производный класс мо-жет использоваться в качестве базового для другого производного класса, создавая многоуровневую иерархию классов. В этом случае говорят, что ис-ходный базовый класс является косвенным (indirect) базовым классом для второго производного класса. (Отметьте, что любой класс - независимо от того, как он создан - может использоваться в качестве базового класса.) Во-вторых, производный класс может прямо наследовать более одного базо-вого класса. В такой ситуации созданию производного класса помогает ком-бинация двух или более базовых классов. Ниже исследуются результаты, к которым приводит наследование нескольких базовых классов. Когда класс используется как базовый для производного, который, в свою очередь, является базовым для другого производного класса, конструкторы всех трех классов вызываются в порядке наследования. (Это положение яв-ляется обобщением ранее исследованного принципа.) Деструкторы вызыва-ются в обратном порядке. Таким образом, если класс В1 наследуется классом Dl, a D1 - классом D2, то конструктор класса В1 вызывается пер-вым, за ним конструктор класса D1, за которым, в свою очередь, конструк-тор класса D2. Деструкторы вызываются в обратном порядке. Если производный класс напрямую наследует несколько базовых классов, используется такое расширенное объявление: class имя_проязводного_кла.сса: сп_доступа кмя_базового_класса1, сп доступа лмя_баэовог^> класса.2, . . . , сп доступа иия_базовосо-классам { I I . . . тело класса
224 _ Самоучитель C++ Здесь цмя_базового_класса1 ... UMR_6a3oeozo_tuiaccaN- имена базовых клас-сов, сп_доступа - спецификатор доступа, который может быть разным у разных базовых классов. Когда наследуется несколько базовых классов, конструкторы выполняются слева направо в том порядке, который задан в объявлении производного класса. Деструкторы выполняются в обратном порядке. Когда класс наследует несколько базовых классов, конструкторам которых необходимы аргументы, производный класс передает эти аргументы, исполь-зуя расширенную форму объявления конструктора производного класса: констр произв_класса (список_арг) : имя базового класса! (список арг) , имя_базового_хласса2 (список_арг) , . . . , имя базового_классаК( список { //... тело конструктора производного класса Здесь имя_бозового_класса! ... uMR_6o3oeoto_KnaccaN - имена базовых клас-сов. Если производный класс наследует иерархию классов, каждый производный класс должен передавать предшествующему в цепочке базовому классу все необходимые аргументы. Примеры 1. В этом примере производный класс наследует класс, производный от другого класса. Обратите внимание, как аргументы передаются по цепочке от класса D2 к классу В1. //Множественное наследование ^include <iostream> using namespace std; class Bl { int a; public: Bl(int x) { a = x; } int geta!) { return a; } //Прямое наследование базового класса class Dl: public Bl { int b; public: Dl(int x, int y): Bl(у) //передача переменной у классу Bl
Глава 7, Наследование 225 ( Ь = х; 11int getbO t return b; } //Прямое наследование производного класса //и косвенное наследование базового класса class D2: public Dl { int с; public: D2 (int x, int y, int z) : Dl{y, z) //передача аргументов //классу Dl { с = x; /* Поскольку базовые классы наследуются как открытые, класс D2 имеет доступ к открытым элементам классов В1 и Dl */void show ( ) { cout " geta() " ' ' " getb() " ' '; cout " с " ' \n ' ; int main ( ) { D2 ob(l, 2, 3); ob.showf) ; //функции geta() и getb ( ) здесь тоже открыты cout " ob.geta{) " ' ' " ob.getb{) " '\n'; return 0; Вызов функции ob.showQ выводит на экран значения 3 2 1. В этом примере класс В1 является косвенным базовым классом для класса D2. Отметьте, что класс D2 имеет доступ к открытым членам классов D1 и В1. Как вы уже должны знать, при наследовании открытых членов базового класса они ста-новятся открытыми членами производного класса. Поэтому, если класс D1 наследует класс В1, то функция geta() становится открытым членом класса D1 и затем открытым членом класса D2. Как показано в программе, каждый класс иерархии классов должен переда-вать все аргументы, необходимые каждому предшествующему базовому клас-су. Невыполнение этого правила приведет к ошибке при компиляции программы.
226 Самоучитель C++ Здесь показана иерархия классов предыдущей программы: В1 D1 D2 Перед тем как двигаться дальше, необходимо небольшое замечание о стиле изображения графов наследования в C++. Обратите внимание на то, что в предыдущем графе стрелки направлены не вниз, а вверх. Традиционно программисты C++ изображают отношения наследования в виде прямых графов, стрелки которых направлены от производного к базо-вому классу. Хотя новички могут посчитать такой подход излишне схематич-ным, именно он обычно практикуется в C++. 2. Здесь представлена переработанная версия предыдущей программы, в кото-рой производный класс прямо наследует два базовых класса: ^include <iostream> using namespace std; //Создание первого базового класса class Bl { int a; public: Bl(int x) { a = x; } int geta() { return a; } //Создание второго базового класса class B2 { int b; public: B2 (int x} f b = x; }int getbO { return b; } //Прямое наследование двух базовых классов class D: public Bl, public B2 { int c;
Глава 'Л Наследование _ 227 public: //здесь переменные z и у //напрямую передаются классам В1 и В2 D{int x, int у/int z) : Bl(z), B2(y) { с = х; /* Поскольку базовые классы наследуются как открытые, класс D имеет доступ к открытым элементам классов В1 и В2 */void show ( ) { cout " getaO " ' ' " getb() " ' '; cout " с " ' \ n ' ; int main() D ob(l, 2, 3) ; ob.show() ; return 0; В этой версии программы класс D передает аргументы по отдельности клас-сам В1 и В2. Теперь иерархия классов выглядит таким образом: Bl B2 D 3. В следующей программе показан порядок, в котором вызываются конструк-торы и деструкторы, когда производный класс прямо наследует несколько базовых классов: #include <iostream> using namespace std; class Bl { public: Bl{} { cout " "Работа конструктора класса В1\п"; } -Bl() { cout " "Работа деструктора класса В1\п"; } 1;
228 _ _ _ Самоучитель C++ class B2 { int b; public: B2 ( ) ( cout " "Работа конструктора класса В2\п"; } ~В2 ( ) { cout " "Работа деструктора класса В2\п"; ) //Наследование двух базовых классов class D: public Bl, public B2 { public: D() { cout " "Работа конструктора класса D\n"; } ~D() { cout " "Работа деструктора класса D\n"; } }; int main () { D ob; return 0; , Эта программа выводит на экран следующее: Работа конструктора класса В1 Работа конструктора класса В2 Работа конструктора класса D Работа деструктора класса D Работа деструктора класса В2 Работа деструктора класса В1 Как уже установлено, когда прямо наследуются несколько базовых классов, конструкторы вызываются слева направо в порядке, задаваемом списком. Деструкторы вызываются в обратном порядке. ! Упражнения ч ^ 1. Что выводит на экран следующая программа? (Попытайтесь определить это, не запуская программу.) ^include <iostream> using namespace std; class A { public: A() { cout " "Работа конструктора класса А\п"; } ~-A{) { cout " "Работа деструктора класса А\п"; }
Глава 7. Наследование _ 229 class В { public: В() { cout " "Работа конструктора класса В\п"; } ~В() { cout " "Работа деструктора класса В\п"; } }; class С: public A, public В ( public: С(} ( cout " "Работа конструктора класса С\п"; } ~С() { cout " "Работа деструктора класса С\п"; } }; int main ( ) { С ob; return 0; 2. Используя следующую иерархию классов, создайте конструктор класса С так, чтобы он инициализировал переменную k и передавал аргументы конструк-торам А() и В(). ^include <iostreani> using namespace std; class A { int i; public: A{int a) { i = a; } class В { int j; public: В {int a) { j = a; } class C: public A, public В { int k; public: /* Создайте такой конструктор C(), чтобы он инициализировал переменную k и передавал аргументы конструкторам А() и ВО */7.5. Виртуальные базовые классы При многократном прямом наследовании производным классом одного и того же базового класса может возникнуть проблема. Чтобы понять, что это за проблема, рассмотрим следующую иерархию классов:
230 Самоучитель C++ Базовый Производный! Базовый Производный! ПрошводныйЗ Здесь базовый класс Базовый наследуется производными классами Произ-водный! и Производный2. Производный класс ПроизводныйЗ прямо наследует производные классы Производный! и Производный2. Однако это подразуме-вает, что класс Базовый фактически наследуется классом ПроизводныйЗ два-жды - первый раз через класс Производный!, а второй через класс Производный2. Однако, если член класса Базовый будет использоваться в классе ПроизводныйЗ, это вызовет неоднозначность. Поскольку в классе ПроизводныйЗ имеется две копии класса Базовый, то будет ли ссылка на элемент класса Базовый относиться к классу Базовый, наследуемому через класс Производный!, или к классу Базовый, наследуемому через класс Произ-водный2? Для преодоления этой неоднозначности в C++ включен меха-низм, благодаря которому в классе ПроизводныйЗ будет включена только одна копия класса Базовый. Класс, поддерживающий этот механизм, назы-вается виртуальным базовым классом (virtual base class). В таких ситуациях, когда производный класс более одного раза косвенно наследует один и тот же базовый класс, появление двух копий базового класса в объекте производного класса можно предотвратить, если базовый класс наследуется как виртуальный для всех производных классов. Такое наследование не дает появиться двум (или более) копиям базового класса в любом следующем производном классе, косвенно наследующем базовый класс. В этом случае перед спецификатором доступа базового класса необ-ходимо поставить ключевое слово virtual. и ' " : : Примеры ' $г \, В этом примере для предотвращения появления в классе derived3 двух копий класса base используется виртуальный базовый класс. //В этой программе используется виртуальный базовый класс ^include <iostreara> using namespace std;
Глава 7. Наследование _ 231 class base ( public: int i ; 1; //Наследование класса base как виртуального class derivedl: virtual public base { public: int j ; //Здесь класс base тоже наследуется как виртуальный class derived2: virtual public base { public: int k; /* Здесь класс derivedS наследует как класс derivedl, так и класс derived2. Однако в классе derived3 создается только одна копия класса base */class derived3: public derivedl, public derived2 { public: int product (} { return i * j * k; } int mainf) { derivedS ob; //Здесь нет неоднозначности, поскольку //представлена только одна копия класса base ob.i - 10; ob . j = 3 ; ob.k = 5; cout " "Результат равен " " ob.productf) " '\n'; return 0; Если бы классы derivedl и derived! наследовали класс base не как виртуаль-ный, тогда инструкция ob.i -10; вызывала бы неоднозначность и при компиляции возникла бы ошибка. (См. представленное ниже упражнение 1.) 2. Важно понимать, что даже если базовый класс наследуется производным как виртуальный, то копия этого базового класса все равно существует внутри
232 Самоучитель C++ производного. Например, по отношению к предыдущей программе этот фрагмент совершенно правилен: derivecil ob; ob.i = 100; Отличие между обычным и виртуальным базовыми классами проявляется только тогда, когда объект наследует базовый класс более одного раза. Если используются виртуальные базовые классы, то в каждом конкретном объекте присутствует копия только одного из них. В противном случае (при обычном наследовании) там было бы несколько копий. 1. В программе из примера 1 удалите ключевое слово virtual и попытайтесь отком-пилировать программу. Обратите внимание на виды ошибок. 2. Объясните, зачем может понадобиться виртуальный базовый класс. Проверка усвоения материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы: 1. Создайте исходный базовый класс building для хранения числа этажей и комнат в здании, а также общую площадь комнат. Создайте производный класс house, который наследует класс building и хранит число ванных комнат и число спален. Кроме этого создайте производный класс office, который наследует класс building и хранит число огнетушителей и теле-фонов. (Замечание. Ваше решение может отличаться от приведенного в конце книги. Однако, если функционально оно такое же, считайте его правильным.) 2. Когда базовый класс наследуется производным классом как открытый, что происходит с его открытыми членами? Что происходит с его закры-тыми членами? Когда базовый класс наследуется производным классом как закрытый, что происходит с его закрытыми и открытыми членами? 3. Объясните, что означает ключевое слово protected. (Рассмотрите два слу-чая: когда оно используется для задания элементов класса и когда оно используется в качестве спецификатора доступа.) 4. При наследовании одного класса другим, когда вызываются конструкто-ры классов? Когда вызываются их деструкторы?
Глава 7. Наследование _ 233 5. Дан следующий фрагмент программы, впишите детали, как указано в комментариях: ^include <iostream> using namespace std; class planet { protected: double distance; //расстояние в милях от Солнца int revolve; //полный оборот Б днях public: planet (double d, int r) { distance = d; revolve = r; } class earth: public planet { double circumference; //окружность орбиты public: /* Создайте конструктор earth (double d, int r) . Он должен передавать классу planet расстояние и число оборотов, а также рассчитывать окружность орбиты {Подсказка: окружность = 2г * 3.1416.) V/* Создайте функцию show() для вывода информации на экран */int main () г earth оЬОЗОООООО, 365); ob.show( ) ; return 0; 6. Исправьте следующую программу: /* Вариация иерархии классов из примера с классом vehicle. В программе имеется ошибка. Найдите ее. Подсказка: попытайтесь провести компиляции и изучите сообщения об ошибках */^include <iostream> using namespace std; //Базовый класс для автомобилей разных типов Class vehicle { int num_wheels; int range; public: vehicle(int w, int r} num wheels = w; range = r;
234 ________ Самоучитель C++ void showvO { cout " "Число колес" " nuin_wheels " ' \ n ' ; cout " "Грузоподъемность" " range " r\n'; enum motor {gas, electric, diesel}; class motorized: public vehicle { enum motor mtr; public: motorized {enum motor m, int w, int r) : vehicle (w, r) { mtr = m; } void showmO { cout " "Мотор:"; switch (mtr) { case gas: cout " "На газе\п"; break; case electric: cout " "На электроэнергии\п"; break; case diesel: cout " "ДизельныйХп"; break; class road_use: public vehicle { int passengers; public: road__use (int p, int w, int r} : vehicle(w, r) t passengers -p; 1 void showr() ( cout " "Пассажироемкость" " passengers " '\n'; enum steering {power, rack_pinion, manual}; class car: public motorized, public road_use { enum steering strng; public: car(enum steering s, enum motor m, int w, int r, int p}:
Глава 7, Наследование 235 road_use(p, w, r), motorized(m, w, r), vehicle(w, r) { strng = s; void show() { s h o w v f ) ; showr(); showm(); cout " "Управление:"; switch(strng) ( case power: cout " "Силовой привод\п"; break; case rack_pinion: cout " "Механический привод\п"; break; case manual: cout " "Ручной приводХп"; break; I }; int main() car c(power, gas, 4, 500, 5); с.show(); return 0; }Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. При компиляции программы из вопроса 6 только что приведенных уп-ражнений по проверке усвоения материала главы 7, вы могли увидеть предупреждающее сообщение (или, возможно, сообщение об ошибке), связанное с использованием инструкции switch внутри классов саг и motorised. Почему? 2. Как вы знаете из предыдущей главы, большинство операторов, перегру-женных в базовом классе, доступны для использования в производном. Для какого или для каких операторов это не так? Объясните, почему. 3. Следующей представлена переработанная версия класса coord из преды-дущей главы. Теперь он используется в качестве базового для класса
236 __ Самоучитель C++ quad, в котором помимо координат хранится номер квадранта, к которо-му принадлежит точка с этими координатами. Запустите программу и попытайтесь понять полученный результат. /* Перегрузите операторы +, - и = относительно класса coord. Затем используйте класс coord в качестве базового для класса quad */^include <iostream> using namespace std; class coord { public: int x, у; //значения координат coord {) { x = 0; у-0; } coord { int i, int j) { x = i; у = j; } void get_xy(int fii, int fij) { i = x; j = y; } coord operator+ (coord ob2); coord operator-{coord ob2); coord operator=( coord ob2}; //Перегрузка оператора + для класса coord coord coord: :operator+ (coord ob2) { coord temp; cout " "Использование функции operator+ {) \n"; temp . x = x + ob2 . x ; temp. у = у + ob2.y; return temp; //Перегрузка оператора - относительно класса coord coord coord: : operator-(coord ob2) { coord temp; cout " "Использование функции operator-() \n"; temp.x = x - ob2.x; temp. у = у - ob2.y; return temp; //Перегрузка оператора = относительно класса coord coord coord: :operator= (coord ob2)
Глава 7. Наследование 237 { cout " "Использование функции operator^ ()\п"; х = оЬ2.х; у = оЬ2 . у; return *this; //возвращение присваиваемого объекта 1class quad: public coord { int quadrant; public: quad() { x = 0; у = 0; quadrant =0; } quad(int x; int y): coord(x, y) if(x>=0 && y>=0) quadrant = 1; else if(x<0 && y>=0) quadrant = 2; else if(x<0 && y<0} quadrant = 3; else quadrant = 4; void showq() cout " "Точка в квадранте: " " quadrant " '\n'; quad operator=(coord ob2); : quad quad::operator=(coord ob2) cout " "Использование функции operator=()\n"; x = ob2,x; у = ob2.у; if(x>=0 && y>=0} quadrant = 1; else if(x<0 && y>=0) quadrant = 2; else if(x<0 Sfi y<0) quadrant = 3; else quadrant = 4; return *this; int main() quad ol(10, 10), o2(15, 3), o3; int x, y; o3 = ol 4 o2; //сложение двух объектов //вызов функции operator-f() o3.get_xy(x, y); o3.showq(); cout " "(ol + o2) X: " " x " ", Y: " " у " "\n";
238_ Самоучитель оЗ = ol - о2; //вычитание двух объектов o3.get_xy(x, у); оЗ.showq(); cout " "(ol -о2) X: " " х " ", Y: " " у " "\n"; оЗ = ol; //присваивание объектов оЗ.get_xy(х, у); o3.Showq(); cout " "(оЗ = ol) X: " " х " ", Y: " " у " "\n"; return 0; 4. Переработайте программу из вопроса 3 так, чтобы в ней использовались дружественные оператор-функции.
Глава 8 Введение в систему ввода/вывода C++ Начиная с первой главы этой книги, создавая свои программы, мы пользо-вались стилем ввода/вывода C++. Теперь настало время изучить его более подробно. Как и в языке С, в C++ имеется развитая, гибкая и достаточно полная система ввода/вывода. Важно понимать, что в C++ по-прежнему поддерживается вся система ввода/вывода С. Кроме этого в C++ включен дополнительный набор объектно-ориентированных подпрограмм вво-да/вывода. Главным преимуществом системы ввода/вывода C++ является то, что она может перегружаться для создаваемых вами классов. Это отличие позволяет легко встраивать в систему ввода/вывода C++ новые создаваемые вами типы данных. Как и в С, в системе объектно-ориентированного ввода/вывода C++ имеет-ся незначительная разница между консольным и файловым вводом/выводом. На самом деле, консольный и файловый ввод/вывод - это просто разный взгляд на один и тот же механизм. В этой главе в примерах используется ввод/вывод на консоль (в данном случае на экран монитора), но представ-ленная информация вполне применима и для ввода/вывода в файл (ввод/вывод в файл более детально исследуется в главе 9). К моменту написания этой книги использовались две версии библиотеки ввода/вывода C++: старая, основанная на изначальной спецификации C++, и новая, определенная единым международным стандартом Standard C++. С точки зрения программиста для решения подавляющего большинства за-дач обе эти библиотеки идентичны. Так происходит потому, что новая биб-лиотека ввода/вывода - это по существу просто обновленная и усовер-шенствованная версия старой библиотеки. Фактически, почти все отличия двух версий скрыты от вас, поскольку касаются не способа использования библиотек, а способа их реализации. Для программиста главное отличие за-ключается в том, что новая библиотека ввода/вывода C++ имеет несколько дополнительных возможностей и определяет несколько новых типов данных. Таким образом, новая библиотека ввода/вывода - это по существу просто несколько улучшенная старая. Почти все уже написанные для старой библио-теки программы при использовании новой будут компилироваться без каких бы то ни было существенных изменений. Поскольку прежняя библиотека ввода/вывода ныне считается устаревшей, данная книга описывает только
240 Самоучитель C++ новую библиотеку, как это определено стандартом Standard C++. Тем не менее, большая часть информации вполне применима и к старой библиоте-ке ввода/вывода. Эта глава охватывает несколько аспектов системы ввода/вывода C++, вклю-чая форматируемый ввод/вывод, манипуляторы ввода/вывода и создание пользовательских функций ввода/вывода. Как вы увидите в дальнейшем, в системе ввода/вывода C++ имеется множество черт, характерных для сис-темы ввода/вывода С. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Создайте иерархию классов для хранения информации о летательных ап-паратах. Начните с общего базового класса airship, предназначенного для хранения количества перевозимых пассажиров и количества перевози-мого груза (в фунтах). Затем создайте два производных от airship класса airplane и balloon. Класс airplane должен хранить тип самолетного двига-теля (винтовой или реактивный) и дальность полета в милях. Класс balloon должен хранить информацию о типе газа, используемого для подъема дирижабля (водород или гелий), и его максимальный потолок (в футах). Создайте короткую программу для демонстрации работы этой ие-рархии классов. (Ваше решение несомненно будет несколько отличаться от ответа, приведенного в конце книги. Однако, если функционально оно будет соответствовать ответу, считайте его правильным.) 2. Для чего используется ключевое слово protected? 3. Дана следующая иерархия классов. В каком порядке вызываются конст-рукторы? В каком порядке вызываются деструкторы? ^include <iostream> using namespace std; class A { public: A{} { cout " "Работа конструктора класса A\n"; } ~A(} ( cout " "Работа деструктора класса А\п"; } ); class В: public A { public: B() { cout " "Работа конструктора класса В\п"; } ~B() { cout " "Работа деструктора класса В\п"; }
Глава 8. Введение в систему ввода/вывода C++ _ 241 class С: public В { public : С() { cout " "Работа конструктора класса С\п"; } ~С О { cout " "Работа деструктора класса С\п"; } 1; . int main ( ) < С ob; return 0; ) 4. Дан следующий фрагмент кода. В каком порядке вызываются конструкторы и деструкторы? class myclass: public A, public В, public С { ... 5. Добавьте отсутствующие конструкторы в данную программу: ^include <iostream> using namespace std; class base { int i , j ; public : //требуется конструктор void showij (} { cout " i " ' ' " j " '\n'; } class derived: public base { int k; public: //требуется конструктор void show ( ) { cout " k " ' ' ; showij ( ) ; } int main() derived ob(l, 2, 3); ob.show(); return 0; J 6. Обычно, если вы задаете иерархию классов, вы начинаете с более класса и продолжаете более классом. (Впишите пропущенные слова.)
242 Самоучитель C++ 8.1. Некоторые базовые положения системы ввода/вывода C++ Перед тем как начать обсуждение системы ввода/вывода C++, несколько общих комментариев. Система ввода/вывода C++, так же, как система вво-да/вывода С, действует через потоки (streams). Поскольку вы программирова-ли на С, вы уже должны знать, что такое поток ввода/вывода, однако несколько дополнительных замечаний обобщат ваши знания. Поток вво-да/вывода -: это логическое устройство, которое выдает и принимает пользо-вательскую информацию. Поток связан с физическим устройством с помощью системы ввода/вывода C++. Поскольку все потоки ввода/вывода действуют одинаково, то, несмотря на то, что программисту приходится рабо-тать с совершенно разными по характеристикам устройствами, система вво-да/вывода предоставляет для этого единый удобный интерфейс. Например, функция, которая используется для записи информации на экран монитора, вполне подойдет как для записи в файл, так и для вывода на принтер. Как вы знаете, если программа на С начинает выполняться, открываются три потока: stdin, stdout и stderr. Нечто похожее имеет место при запуске программ на C++. Когда запускается программа на C++, автоматически открываются четыре потока: Поток cin cout сегг clog Значение Стандартный ввод Стандартный вывод Стандартная ошибка Буферизуемая версия сегг Устройство Клавиатура Экран Экран Экран по умолчанию Как вы, наверное, уже догадались, потоки cin, cout и сегг соответствуют пото-кам stdin, stdout и stderr языка С. Потоками cin и cout вы уже пользовались. Поток clog - это просто буферизуемая версия потока сегг. В языке Standard C++ также открываются дополнительные потоки wcin, wcout, wcerr и wclog, предназначенные для широких (16-разрядных) символов, которые в данной книге не рассматриваются. Эти потоки обеспечивают передачу расширенных наборов символов (large character sets), что обеспечивает возможность работы с некоторыми экзотическими языками, такими как, например, китайский. По умолчанию, стандартные потоки используются для связи с клавиатурой и экраном. Однако в среде, в которой поддерживается переопределение вво-да/вывода, эти потоки могут быть перенаправлены на другие устройства. Как отмечалось в главе 1, в C++ ввод/вывод обеспечивается подключением к программе заголовочного файла <iostream>. В этом файле определены слож-ные наборы иерархий классов, поддерживающие операции ввода/вывода. Классы ввода/вывода начинаются с системы классов-шаблонов (template classes).
Глава 8. Введение в систему ввода/вывода C++ 243 Подробно о классах-шаблонах, называемых также родовыми классами (generic classes), будет рассказано в главе 11, сейчас же ограничимся кратким коммен-тарием. В классе-шаблоне определяется только форма класса без полного за-дания данных, с которыми он работает. После того как класс-шаблон определен, появляется возможность создавать отдельные экземпляры этого класса. Что касается библиотеки ввода/вывода, то Standard C++ создает две разные версии классов-шаблонов ввода/вывода: одну для 8-разрядных симво-лов, а другую для широких (16-разрядных) символов. В данной книге расска-зывается только о классах для 8-разрядных символов, поскольку именно они используются чаще всего. Система ввода/вывода C++ строится на двух связанных, но различных иерар-хиях классов-шаблонов. Первая является производной от класса нижнего уровня bastcjstreambuf. Этот класс предоставляет базу для операций нижнего уровня по вводу и выводу, а также обеспечивает надлежащую поддержку всей системы ввода/вывода C++. До тех пор, пока вы не погрузитесь в самые ос-новы программирования ввода/вывода, непосредственно использовать класс basie_streambuf вам не понадобиться. Иерархия классов, с которой вам чаще всего придется иметь дело, является производной от класса basic_ios. Это класс ввода/вывода верхнего уровня, который обеспечивает форматирование, контроль ошибок и информацию о состоянии потока ввода/вывода. Класс basic_ios является базовым для нескольких производных классов, среди кото-рых классы basic_istream, basic_ostream и basic_iostream. Эти классы исполь-зуются соответственно для создания потоков ввода, вывода и ввода/вывода. Как уже говорилось, библиотека ввода/вывода создает две отдельные версии иерархий классов: одну для 8-разрядных символов и другую для широких символов. В представленной ниже таблице показано соответствие имен клас-сов-шаблонов их версиям для 8-разрядных символов (включая и те, о которых будет рассказано в главе 9). Класс-шаблон basic_streambuf basicjos basicjstream basic ostream basicjostream basic_fstream basicjf stream basic_ofstream Класс для 8-разрядных символов streambuf ios istream " ostream ,iostream fstream ifstream ofstream Имена классов для 8-разрядных символов будут употребляться далее на всем протяжении книги, поскольку как раз эти имена и следует указывать в
244 Самоучитель C++ программах. Это именно те имена, которые использовались в прежней биб-лиотеке ввода/вывода, и именно по этой причине на уровне исходного кода совместимы старая и новая библиотеки ввода/вывода. И последнее замечание: в классе ios содержится множество функций и пе-ременных - членов класса, которые контролируют или отображают основ-ные операции потока ввода/вывода. Вы еще часто будете сталкиваться с классом ios. Запомните: чтобы получить доступ к этому важному классу, не-обходимо включить в программу заголовок <iostream>. 8.2. Форматируемый ввод/вывод До сих пор во всех примерах этой книги для вывода информации на экран использовались форматы, заданные в C++ по умолчанию. Однако инфор-мацию можно выводить в широком диапазоне форм. При этом с помощью системы ввода/вывода C++ можно форматировать данные так же, как это делала в С функция printfQ. Кроме того, можно изменять определенные па-раметры ввода информации. Каждый поток ввода/вывода связан с набором флагов формата (format flags), которые управляют способом форматирования информации и представляют собой битовые маски (bitmasks). Эти маски объявлены в классе ios как данные перечислимого типа fmtflags, в котором определены следующие значения: adjustfield basefield boolalpha dec fixed floatfield hex internal left oct right scientific showbase showpoint showpos skipws unitbuf uppercase Эти значения определены в классе ios и необходимы для установки или сброса флагов формата. Если вы пользуетесь устаревшим, нестандартным компилятором, может оказаться, что перечислимый тип данных fmtflags в нем не определен. В таких компиляторах для хранения флагов формата отводится длинное целое. Когда при вводе информации в поток установлен флаг skipws, начальные невидимые символы (пробелы, табуляции и символы новой строки) отбра-сываются. Когда флаг skipws сброшен, невидимые символы не отбрасываются. Когда установлен флаг left, происходит выравнивание вывода по левому краю, Когда установлен флаг right, происходит выравнивание вывода по правому краю. Когда установлен флаг internal, для заполнения поля вывода происходит вставка пробелов между всеми цифрами и знаками числа. Если все эти флаги не установлены, то по умолчанию используется выравнивание по правому краю.
Глава 8. Введение в систему ввода/вывода C++ 245 По умолчанию числовые значения выводятся в десятичной системе счисле-ния. Однако основание системы счисления можно поменять. Установка флага oct ведет к тому, что вывод будет осуществляться в восьмеричной системе счисления, а установка флага hex - в шестнадцатеричной. Чтобы вернуться к десятичной системе счисления, установите флаг dec. Установка флага showbase ведет к выводу основания системы счисления. Например, шестнадцатеричное значение IF с этим флагом будет выводиться как Ox IF. По умолчанию при выводе значений в научной нотации символ "е" выво-дится в нижнем регистре. Кроме этого, при выводе шестнадцатеричного значения символ "х" тоже выводится в нижнем регистре. При установке флага uppercase, эти символы выводятся в верхнем регистре. Установка флага showpos приводит к выводу знака + перед положительными значениями. Установка флага showpoint ведет к появлению десятичной точки и после-дующих нулей при выводе любых значений с плавающей точкой. При установке флага scientific числа с плавающей точкой выводятся в науч-ной нотации. При установке флага fixed числа с плавающей точкой выво-дятся в обычной нотации. Если ни один из этих флагов не установлен, компилятор сам выбирает подходящий способ вывода. Если установлен флаг umtbuf, то буфер очищается (flush) после каждой опе-рации вставки (insertion operation). При установленном флаге boolalpha значения булева типа выводятся в виде ключевых слов true и false. Одновременно на все поля, определенные с флагами oct, dec и hex, можно сослаться с помощью флага basefield. Аналогично на поля, определенные с флагами left, right и internal, можно сослаться с помощью флага adjust field И наконец, на поля с флагами scientific и fixed можно сослаться с помощью флага floatfield. Для установки флага формата пользуйтесь функцией setf(). Эта функция является членом класса ios. Здесь показана ее основная форма: fratflags setf(fmtflags флаги); Эта функция возвращает предыдущие установки флагов формата и устанав-ливает новые, заданные значением флаги. (Значения всех остальных флагов не изменяются.) Например, для установки флага showpos можно воспользо-ваться следующей инструкцией: лотох_ввода/вывода.setf{ios::showpos); Здесь поток ввода/вывода ~ это тот поток, на который вы хотите повлиять. Обратите внимание на использование оператора расширения области види-
246 Самоучитель мости. Запомните, флаг showpos - это перечислимая константа внутри класса ios. Следовательно, чтобы сообщить компилятору об этом, необходи-мо поставить перед флагом showpos имя класса и оператор расширения об-ласти видимости. Если этого не сделать, константа showpos просто не будет распознана компилятором. Важно понимать, что функция setf() является членом класса ios и влияет на созданные этим классом потоки ввода/вывода. Поэтому любой вызов функ-ции setfQ делается относительно конкретного потока. Нельзя вызвать функ-цию setf() саму по себе. Другими словами, в C++ нет понятия глобального состояния формата. Каждый поток ввода/вывода поддерживает собственную информацию о состоянии формата. Вместо повторных вызовов функции setfQ в одном вызове можно устано-вить сразу несколько флагов. Для объединения необходимых флагов исполь-зуйте оператор OR. Например, в следующем вызове функции setf() для потока cout устанавливаются флаги showbase и hex; cout,setf(ios::showbase I ios::hex); Поскольку флаги формата определяются внутри класса ios, доступ к ним должен осуществляться через класс ios и оператор расширения области ви-димости. Например, сам по себе флаг showbase задать нельзя, необходимо написать ios::showbase. Дополнением setfQ является функция unsetfQ. Эта функция-член класса ios сбрасывает один или несколько флагов формата. Здесь показана ее основная форма: void unsetf(fmtflags флаги); Флаги, заданные параметром флаги, сбрасываются. (Все остальные флаги остаются без изменений.) Когда-нибудь вам понадобится только узнать текущее состояние флагов и при этом ничего не менять. Поскольку функции setf() и unsetf() меняют со-стояние одного или более флагов, в класс ios включена функция-член flags(), которая просто возвращает текущее состояние флагов формата. Здесь показан прототип этой функции: fmtflags flags(); Функция flags() имеет и вторую форму, которая позволяет установить все, связанные с потоком ввода/вывода, флаги формата. Флаги задаются в аргу-менте функции flags(). Здесь показан прототип этой версии функции: fmtflags flags(fmtflags t) ;
Глава 8. Введение в систему ввода/вывода C++ 247 При использовании этой версии функции flags() битовый шаблон/копиру-ется в переменную для хранения связанных с потоком флагов формата; при этом перезаписывается весь предшествующий набор флагов. Функция воз-вращает предыдущие установки флагов формата. 1. В этом примере показано, как установить несколько флагов формата. ^include <iostream> using namespace std; int mainf) I //вывод с использованием установок по умолчанию cout " 123.23 " " привет " " 100 " '\п' ; cout " 10 "' ' " -10 " '\п'; cout " 100.0 " '\п'; //теперь меняем формат cout.unsetf(ios::dec); //требуется не для всех компиляторов cout,setf{ios::hex \ ios::scientific); cout " 123.23 " " привет " " 100 " '\n'; cout.setf(ios::showpos); cout " 10 "' ' " -10 " '\n'; cout.setf(ios::showpoint \ ios::fixed); cout " 100.0; return 0; }После выполнения программы на экран выводится следующее: 123.23 привет 100 10 -10 100 1.232300е+02 привет 64 a fffffff6 +100.000000 Обратите внимание, что флаг showpos влияет только на вывод десятичных значений. Он не влияет на число 10, когда оно выводится в шестнадцатерич-ной системе счисления. Кроме того, отметьте, что вызов функции unsetfQ приводит к сбросу установленного по умолчанию флага dec. Этот вызов ну-жен не для всех компиляторов, а только для некоторых, для которых уста-
248 _ Самоучитель C++ новка флага dec автоматически приводит к сбросу остальных флагов. Поэто-му после сброса флага dec необходимо заново установить флаг hex или oct. Как правило, для лучшей переносимости программ лучше установить только то основание системы счисления, которое вы будете использовать и стереть остальные. 2. В следующей программе показано действие флага uppercase. В первую оче-редь устанавливаются флаги uppercase, showbase и hex. Затем выводится чис-ло 88 в шестнадцатеричной системе счисления. В этом случае символ шестнадцатеричной системы счисления "X" выводится в верхнем регистре. Далее с помощью функции imsetf() сбрасывается флаг uppercase и снова вы-водится шестнадцатеричное число 88. Теперь символ "х" оказывается в ниж-нем регистре. ^include <iostream> using namespace std; int main ( ) rt cout .unset f (ios: :dec) ; cout .setffios: : uppercase | ios: ishowbase | ios::hex); cout " 88 " r\n'; cout. unsetf (ios: : uppercase) ; cout " B8 " '\n'; return 0; 3. В следующей программе для вывода состояния флагов формата потока cout используется функция flagsQ. Обратите особое внимание на функцию showflags(). Она может вам пригодиться при разработке собственных про-грамм. ^include <iostream> using namespace std; void showf lags ( ) ; int main { ) { //отображение состояния флагов формата по умолчанию showf lags () ; cout. setf (ios: :oct I ios: : showbase I ios: : fixed) ; showf lags () ; return 0;
Глава_В. Введение в систему ввода/вывода C++ 249 //Эта функция выводит состояние флагов формата void showflags() { ios::fmtflags f; f = cout.flags(); //получение установок флагов формата if(f & ios::skipws) cout " "skipws установленХп"; else cout " "skipws сброшен\n"; if(f & ios::left} cout " "left установленХп"; else cout " "left сброшен\п"; if(f & ios::right) cout " "right установленХп"; else cout " "right сброшенХп"; if(f & ios::internal) cout " "internal установленХп"; else cout " "internal сброшенХп"; if(f & ios::dec) cout " "dec установленХп"; else cout " "dec сброшенХп"; if(f & ios::oct) cout " "oct установленХп"; else cout " "oct сброшенХп"; if(f & ios::hex) cout " "hex установленХп"; else cout " "hex сброшен\п"; if(f & ios::showbase) cout " "showbase установленХп"; else cout " "showbase сброшенХп"; if(f & ios::showpoint) cout " "showpoint установленХп"; else cout " "showpoint сброшенХп"; if (f & ios::showpos) cout " "showpos установленХп"; else cout " "showpos сброшенХп"; if(f £ ios::uppercase) cout " "uppercase установленХп"; else cout " "uppercase сброшенХп"; if(f & ios:scientific) cout " "scientific установленХп"; else cout " "scientific сброшенХп"; if(f & ios::fixed) cout " "fixed установленХп"; else cout " "fixed сброшенХп"; if (f & ios::unitbuf) cout " "unitbuf установленХп"; else cout " "unitbuf сброшенХп"; if(f & ios:iboolalpha) cout " "boolalpha установленХп"; else cout " "boolalpha сброшенХп"; cout " "Xn";
250 Самоучитель C++ В функции showflagsQ объявляется локальная переменная f типа fmtflags. Ес-ли в вашем компиляторе тип данных fmtflags не определен, объявите пере-менную f типа long. Ниже показан результат выполнения программы: skipws установлен left сброшен right сброшен internal сброшен dec установлен oct сброшен hex сброшен showbase сброшен showpoint сброшен showpos сброшен uppercase сброшен scientific сброшен fixed сброшен unitbuf сброшен boolalpha сброшен skipws установлен left сброшен right сброшен internal сброшен dec установлен oct установлен hex сброшен showbase установлен showpoint сброшен showpos сброшен uppercase сброшен scientific сброшен fixed установлен unitbuf сброшен boolalpha сброшен 4. В следующей программе проиллюстрирована работа второй версии функции flags()-Сначала, устанавливая флаги showpos, showbase, oct и right, мы строим маску флагов. Затем с помощью функции flags() для потока cout маска свя-зывается с переменной флагов. С помощью функции showflagsQ проверяется правильность установки флагов. (Это та же функция, которая использовалась в предыдущей программе.) ^include <iostream> using namespace std; void showflagsf);
Глава 8. Введение в систему ввода/вывода C++ 2_5_1_ int mainf) { //отображение состояния флагов формата по умолчанию showf lags () ; //устанавливаются флаги showpos, showbase, cct и right; //остальные сбрасываются ios:ifmtflags f -ios::showpos | ios::showbase | ios:: oct I ios::right; cout.flags(f); //установка флагов showflags(); return 0; УпражнIеfiнHиUfяl]! 1. Напишите программу, которая бы устанавливала флаги для потока cout так, чтобы целые, если они положительны, выводились со знаком +. Покажите, что ваш набор флагов формата правилен. 2. Напишите программу, которая бы устанавливала флаги для потока cout так, чтобы всегда при выводе дробных значений были показаны десятичные точ-ки. Кроме этого, значения с плавающей точкой должны выводиться в науч-ной нотации с символом "Е" в верхнем регистре. 3. Напишите программу, которая сохраняет текущее состояние флагов формата, устанавливает флаги showbase и hex, выводит на экран значение 100, а затем возвращает флаги в исходное состояние. 8.3. Функции width(), precision() и fill() Кроме флагов формата в классе ios определены три функции-члена. Эти функции устанавливают следующие параметры формата: ширину поля, точ-ность и символ заполнения. Этими функциями являются соответственно функции width(), precision() и fill(). По умолчанию при выводе любого значения оно занимает столько позиций, сколько символов выводится. Однако с помощью функции width() можно задать минимальную ширину поля. Ниже показан прототип этой функции: streamsize width(strearasize w) ; Ширина поля задается параметром и>, а функция возвращает предыдущую ширину поля. Тип данных streamsize определен в заголовочном файле
252 Самоучитель C++ <iostream> как одна из форм целого. В некоторых компиляторах при вы-полнении каждой операции вывода значение ширины поля возвращается к своему состоянию по умолчанию, поэтому перед каждой инструкцией выво-да может понадобиться устанавливать минимальную ширину поля. После установки минимальной ширины поля, если выводимое значение требует поле, меньшее заданной ширины, остаток поля заполняется теку-щим символом заполнения (по умолчанию пробелом) так, чтобы была заня-та вся ширина поля. Однако запомните, если размер выводимого значения превосходит минимальную ширину поля, будет занято столько символов, сколько нужно. Выводимое значение не усекается. По умолчанию при выводе значений с плавающей точкой точность равна шести цифрам. Однако с помощью функции precisionQ это число можно изменить. Ниже показан прототип функции precisionQ: streamsize precision(streamsize p); Точность (число выводимых цифр после запятой) задается параметром р, а возвращает функция прежнее значение точности. По умолчанию, если требуется заполнить свободные поля, используются пробелы. Однако с помощью функции Ш1() можно изменить символ запол-нения. Ниже показан прототип функции fill(): char fill(char ch); После вызова функции fjllQ символ ch становится новым символом запол-нения, а функция возвращает прежнее значение символа заполнения. 1. В этом примере показана программа, которая иллюстрирует работу функций формата: #include <iostream> using namespace std; int main() { cout.width(10); //установка минимальной ширины поля cout " "Привет" " '\n'; //по умолчанию выравнивание вправо cout.fill('%'); //установка символа заполнения cout.width(10); //установка ширины поля cout " "Привет" " '\п'; //по умолчанию выравнивание вправо cout.setf(ios::left); //выравнивание влево cout.width(10); //установка ширины поля cout " "Привет" " '\п'; //выравнивание влево
Глава 8. Введение в систему ввода/вывода C++ 253 cout.width(10); //установка ширины поля cout.precision(lO); //установка точности в 10 цифр cout " 123.234567 " т\п'; cout.width(lO); //установка ширины поля cout.precision(6); //установка точности в 6 цифр cout " 123.234567 " '\п'; return 0; После выполнения программы на экран выводится следующее: Привет Привет%%%% 123.234567 123.235%%% Обратите внимание, что ширина поля устанавливается перед каждой инст-рукцией вывода. 2. В следующей программе показано, как с помощью функций установки фла-гов формата ввода/вывода C++ создать выровненную таблицу чисел: //Создание таблицы квадратных корней и квадратов ^include <iostream> ftinclude <cmath> using namespace std; int main() double x; cout.precision(4); cout " "x sqrt(x) xA2\n\n"; for(x = 2.0; x <= 20.0; x++) { cout.width(7); COUt " X " " "; cout.width(7); cout " sqrt(x) " " "; cout.width(7); cout " x*x " "\n"; 1return 0; ,После выполнения программы на экран выводится следующее: x sqrt(x) x2 2 1.414 4 3 1Л32 9
254 Самоучитель C++ 456789 10 11 12 13 14 15 16 17 18 19 20 2. 2. 2. 2. 3. 3. 3. 3. 3. 3. 4. 4 . 4. 4. 2 236 449 646 8283 162 317 464 606 742 8734 123 243 359 472 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 .УпраАнеенниия) 1. Разработайте программу для печати таблицы натуральных и десятичных ло-гарифмов чисел от 2 до 100. Формат таблицы следующий: правое выравнива-ние, ширина поля - 10 символов, точность - 5 десятичных позиций. 2. Создайте функцию center() со следующим прототипом: void center (char *s) ; Эта функция должна устанавливать заданную строку в центр экрана. Для реализации этой задачи воспользуйтесь функцией width(). Предполагается, что ширина экрана равна 80 символам. (Для простоты считайте, что длина строки не превышает 80 символов.) Напишите программу, иллюстрирующую работу этой функции. 3. Поэкспериментируйте с флагами и функциями формата. После того как вы ближе познакомитесь с системой ввода/вывода C++, вы никогда не ошибе-тесь в выборе нужного формата вывода. 8.4. Манипуляторы ввода/вывода В системе ввода/вывода C++ имеется еще один способ форматирования информации. Этот способ подразумевает использование специальных функ-ций - манипуляторов ввода/вывода (I/O manipulators). Как вы увидите далее, манипуляторы ввода/вывода являются, в некоторых ситуациях, более удоб-ными, чем флаги и функции формата класса ios.
Глава 8. Введение в систему ввода/вывода C++ 255 Манипуляторы ввода/вывода являются специальными функциями формата ввода/вывода, которые, в отличие от функций - членов класса ios, могут располагаться внутри инструкций ввода/вывода. Стандартные манипуляторы показаны в табл. 8.1. Как можно заметить при изучении таблицы, значи-тельная часть манипуляторов ввода/вывода по своим действиям аналогична соответствующим функциям - членам класса ios. Многие манипуляторы, представленные в табл. 8.1, стали частью языка совсем недавно, после появ-ления стандарта Standard C++, и поддерживаются только современными компиляторами. Для доступа к манипуляторам с параметрами (таким, как функция setw()), необходимо включить в программу заголовок <iomanip>. В этом заголовке нет необходимости при использовании манипуляторов без параметров. Как уже установлено, манипуляторы можно задавать внутри цепочки опера-ций ввода/вывода. Например: cout " oct " 100 " hex " 100; cout " setw(10) " 100; Первая инструкция сообщает потоку cout о необходимости вывода целых в восьмеричной системе счисления и выводит число 100 в восьмеричной системе счисления. Затем она сообщает потоку ввода/вывода о необходимости вывода целых в шестнадцатеричной системе счисления и далее осуществляется вывод числа 100 уже в шестнадцатеричном формате. Во второй инструкции устанавли-вается ширина поля равная 10, и затем снова выводится 100 в шестнадцатерич-ном формате. Обратите внимание, если используется манипулятор без аргументов (в данном примере им является манипулятор oct), скобки за ним не ставятся, поскольку это на самом деле адрес манипулятора, передаваемый пе-регруженному оператору ". Таблица 8.1. Манипуляторы ввода/вывода языка Standard C++ Манипулятор boolalpha dec endl ends fixed flush hex internal left noboolalpha Назначение Установка флага boolalpha Установка флага dec Вывод символа новой строки и очистка потока Вывод значения NULL Установка флага fixed Очистка потока Установка флага hex Установка флага internal Установка флага left Сброс флага boolalpha Ввод/Вывод Ввод/Вывод Ввод/Вывод Вывод Вывод Вывод Вывод В вод/Вы вод Вывод Вывод Ввод/Вывод
256 Манипулятор noshowbase noshowpoint noshowpos noskipws nounitbuf nouppercase oct resetiosflagsffmtflags f) right scientific setbase (int основание) setfill(int с/т) setiosf lag s(fmtf lags f) setprecision(int p) setw(int w) showbase showpoint showpos skipws unitbuf uppercase ws Таблица Назначение Сброс флага showbase Сброс флага showpoint Сброс флага showpos Сброс флага skipws Сброс флага unitbuf Сброс флага uppercase Установка флага oct Сброс флагов, заданных параметром f Установка флага right Установка флага scientific Задание основания системы счисления Задание символа заполнения с/т Установка флагов, заданных параметром f Задание числа цифр точности равным р Задание ширины поля равным w позиций Установка флага showbase Установка флага showpoint Установка флага showpos Установка флага skipws Установка флага unitbuf Установка флага uppercase Пропуск начальных пробелов Самоучитель C++ 8. 1 (продолжение) Ввод/Вывод Вывод Вывод Вывод Ввод Вывод Вывод Ввод/Вы вод Ввод/Вывод Вывод Вывод Ввод/Вывод Вывод Ввод/Вывод Вывод Вывод Вывод Вывод Вывод Ввод Вывод Вывод Ввод Запомните, что манипулятор ввода/вывода влияет только на поток, частью которого является выражение ввода/вывода, содержащего манипулятор. Ма-нипуляторы ввода/вывода не влияют на все, открытые в данный момент, потоки. Как отмечалось в предыдущем примере, главным преимуществом манипуля-торов по сравнению с функциями - членами класса ios является то, что ма-нипуляторы обычно удобнее, так как позволяют писать более компактные программы. Если вы с помощью манипулятора хотите установить конкретные флаги формата, используйте функцию setiosflagsQ. Этот манипулятор реализует ту же функцию, что и функция-член setf(). Для сброса флагов формата исполь-зуйте манипулятор resetiosflags(). Этот манипулятор эквивалентен функции unsetfQ.
Глава 8. Введение в систему ввода/вывода C++ 257 Примеры __-^ \. В этой программе представлено несколько манипуляторов ввода/вывода: #include <iostream> ^include <iomanip> using namespace std; int main() ! cout " hex " 100 " endl; cout " oct " 10 " endl; cout " setfill('X') " setw(lO); cout " 100 " " привет " " endl; return 0; После выполнения программы на экран выводится следующее: 64 12 ХХХХХХХ144 привет 2. Здесь представлена другая версия программы, в которой на экран выводится таблица квадратов и квадратных корней чисел от 2 до 20. В этой версии вме-сто функций-членов и флагов формата используются манипуляторы вво-да/вывода. /* В этой версии для вывода таблицы квадратов и квадратных корней используются манипуляторы */^include <iostream> ^include <iomanip> ^include <cmath> using namespace std; int main() double x; cout " setprecision(4); cout " "x sqrt(x) xA2\n\n"; for(x = 2.0; x <= 20.0; x++) { cout " setw("7) " x " " "; cout " setw(7) " sqrt(x) " " "; cout " setw(7) " x*x " '\n';
258 _ Самоучитель^ C++ return 0; 3. Одним из самых интересных флагов формата новой библиотеки ввода/вы-вода является флаг boolalpha. Этот флаг можно установить либо непосредст-венно, либо с помощью манипулятора boolalpha. Интересным этот флаг дела-ет то, что он позволяет реализовать ввод и вывод значений булева типа, т. е. ключевых слов true и false, вместо которых раньше обычно приходилось ис-пользовать соответственно 1 для истинного значения и 0 для ложного. //Использование флага формата boolalpha ^include <iostream> using namespace std; int main ( ) I bool b; cout " "Перед установкой флага формата boolalpha: "; b = true; cout " b " " "; b = false; cout " b " endl; cout " "После установки флага формата boolalpha: "; b = true; cout " boolalpha " b " " "; b = false; cout " b " endl; cout " "Введите значение булева типа: "; cin " boolalpha " b; //здесь можно ввести true или false cout " "Введенное значение: " " b; return 0; Примерный результат работы программы: Перед установкой флага формата boolalpha: 1 О После установки флага формата boolalpha: true false Введите значение булева типа: true Введенное значение: true Как видите, после установки флага формата boolalpha, для обозначения вво-димых и выводимых значений булева типа используются ключевые слова true и false. Отметьте, что флаг формата boolalpha необходимо устанавливать от-дельно для потока cin и отдельно для потока cout. Как и в случае с другими флагами формата, установка флага boolalpha для одного потока вовсе не под-разумевает его автоматической установки для другого потока.
Глава 8. Введение в систему ввода/вывода C++ 259 1. Выполните еще раз упражнения 1 и 2 из раздела 8.3, только теперь, вместо функций-членов и флагов формата, используйте манипуляторы вво-да/вывода. 2. Составьте инструкцию для вывода числа 100 в шестнадцатеричной системе счисления с отображением основания системы счисления (Ох). Для выполне-ния задания воспользуйтесь манипулятором setiosflagsQ 3. Объясните, что дает установка флага boolalpha. 8.5. Пользовательские функции вывода Как уже отмечалось в этой книге, одним из доводов в пользу использования операторов ввода/вывода C++, вместо аналогичных им функций вво-да/вывода С, является возможность перегрузки операторов ввода/вывода для создаваемых вами классов. В этом разделе вы узнаете, как перегрузить опе-ратор вывода ". В языке C++ вывод иногда называется вставкой (insertion), а оператор " - оператором вставки (insertion operator). Когда вы для вывода информации перегружаете оператор ", вы создаете функцию вставки (inserterfunction или inserter). Рациональность этим терминам дает то, что оператор вывода встав-ляет (inserts) информацию в поток. Во избежание путаницы мы будем назы-вать функцию вставки пользовательской функцией вывода. У всех пользовательских функций вывода следующая основная форма: ostream &operator" (ostream ustream, имя_класса объект; { //тело пользовательской функции вывода return stream,-i Первый параметр является ссылкой на объект типа ostream. Это означает, что поток stream должен быть потоком вывода. (Запомните, класс ostream является производным от класса ios.) Второй параметр получает выводимый объект. (Он, если для вашего приложения это нужно, тоже может быть па-раметром-ссылкой). Обратите внимание, что пользовательская функция вы-вода возвращает ссылку на поток stream, который имеет тип ostream. Это необходимо, если перегруженный оператор " должен использоваться в ря-де последовательных выражений ввода/вывода: cout " оЫ " оЬ2 " оЬЗ; Внутри пользовательской функции вывода можно выполнить любую про-цедуру. То, что будет делать эта функция, полностью зависит от вас. Однако
260 Самоучитель С++ в соответствии с хорошим стилем программирования, следует ограничить задачи пользовательской функции вывода только вставкой информации в поток. Хотя это на первый взгляд может показаться странным, но пользовательская функция вывода не может быть членом класса, для работы с которым она создана. И вот почему. Если оператор-функция любого типа является чле-ном класса, то левый операнд, который неявно передается через указатель this, является объектом, генерирующим вызов оператор-функции. Это под-разумевает, что левый операнд является объектом этого класса. Поэтому, если перегруженная оператор-функция является членом класса, тогда левый операнд должен быть объектом этого класса. Однако, когда вы создаете пользовательскую функцию вывода, левый операнд становится потоком, а не объектом класса, а правый операнд - объектом, который нужно вывести. Именно поэтому пользовательская функция вывода не может быть функци-ей-членом. То, что пользовательская функция вывода не может быть функцией-членом на первый взгляд кажется серьезным изъяном C++, поскольку подразумева-ет, что все данные класса, выводимые в поток через эту функцию, должны быть открытыми, нарушая тем самым ключевой принцип инкапсуляции. Однако это не так. Несмотря на то, что пользовательские функции вывода не могут быть членами класса, для работы с которым они разработаны, они могут быть дружественными классу. В подавляющем большинстве реальных ситуаций, с которыми вам придется столкнуться при программировании ввода/вывода, перегружаемая пользовательская функция вывода будет дру-жественной классу, для которого она создана. Примеры 1.^ Д-ля н^ачала рассмотрим простой пример, в котором для класса coord, разра-ботанного в предыдущей главе, создается пользовательская функция вывода: //Использование дружественной функции вывода //для объектов типа coord #include <iostream> using namespace std; class coord { int x, y; public: coordO ( x = 0; у = 0; } coord(int i, int j) { x = i; у = j; } friend ostream &operator"(ostream sstreara, coord obj;
Глава 8. Введение в систему ввода/вывода C++ 261 ostream &operator" (ostream Sstream, coord ob) stream " ob.x " ", " " ob.y " '\np ; return stream; int main() 1 coord a(l, 1) , b(10, 23) ; cout " a " b; return 0; В результате выполнения программы на экран выводится следующее: 1, 1 10, 23 Пользовательская функция вывода этой программы иллюстрирует одну очень важную для создания ваших собственных функций особенность: их нужно разрабатывать, возможно, более обобщенными. В данном конкретном случае инструкция ввода/вывода внутри функции вставляет значения х и у в поток stream, который и является передаваемым в функцию потоком. Как вы уви-дите в следующей главе, та же самая пользовательская функция вывода, ко-торая в нашем примере используется для вывода информации на экран, может использоваться и для ее вывода в любой поток. Тем не менее, начи-нающие программисты иногда пишут пользовательскую функцию вывода для класса coord следующим образом:" ostream &operator"(ostream sstream, coord ob) ' cout " ob.x " ", " " ob.y " ' \ n ' ; return stream; В этом случае выражение жестко запрограммировано на вывод информации на стандартное устройство вывода, связанное с классом cout. Это ведет к то-му, что другие потоки не могут воспользоваться вашей функцией. Вывод очевиден, следует делать свои функции, возможно, более обобщенными, по-скольку это никогда не повредит, а иногда может оказаться полезным. 2. В следующей версии предыдущей программы, пользовательская функция вывода не является дружественной классу coord. Поскольку у пользователь-ской функции вывода нет доступа к закрытой части класса coord, перемен-ные х и у приходиться делать открытыми. //Создание не дружественной функции вывода для объектов типа coord #include <iostream> using namespace std;
262 _ Самоучитель C++ class coord { public: int x, у; //должны быть открытыми coord{) { x = 0; у = 0; } coord (int i, int j) { x = i; у = j; } //Пользовательская функция вывода для объектов класса coord ostream &operator" (ostream sstream, coord ob) { stream " ob.x " ", " " ob.y " '\n'; return stream; int main{) { coord ail, 1) , b(10, 23) ; cout " a " b; return 0; 3. Возможности пользовательских функций вывода не ограничиваются выводом текстовой информации. Они могут выполнить любое действие или преобра-зование, необходимое для вывода информации в том виде, который требует-ся из-за особенностей устройства или ситуации. Например, совершенно разумно создать пользовательскую функцию вывода для отправки информа-ции на плоттер. В этом случае, кроме собственно информации, функция пе-редаст предназначенные для управления плоттером коды. Чтобы вы могли почувствовать вкус к такого рода функциям, в следующей программе созда-ется класс triangle, в котором хранится ширина и высота прямоугольного треугольника. Пользовательская функция вывода этого класса выводит тре-угольник на экран. //Эта программа рисует прямоугольные треугольники finclude <iostream> using namespace std; class triangle { int height, base; public: triangle (int h, int b) { height = h; base= b; } friend ostream &operator" (ostream &stream, triangle ob) ; J; //рисование треугольника ostream soperator" (ostream sstream, triangle ob) i int i, j, h, k;
Глава 8_._Введение а систему ввода/вывода C++ 263 i = j = ob.base - 1; for(h=ob.height -1; h; h -) { for(k=i; k; k -) stream " ' '; stream " ' * ' ; for(k=j -i -1; k; k - ) stream " ' ' ; stream " ' * ' ; i --; stream " ' \n' ; for(k=0; k <ob.base; k++) stream " '*:; stream " '\n' ; return stream; int mainf) triangle tl (5, 5), t2 (10, 10), t3(12, 12) cout " tl; cout " endl " t2 " endl " t3; return 0; Отметьте, что должным образом разработанная пользовательская функция вывода может быть целиком вставлена в "обычное" выражение ввода/вывода. После выполнения программы на экран выводится следующее: * * * * * * * * * * * * ***** * * * * * * * * * * * * ********** * * * * * * * * * * * * * * * * * * * * * ************
264 Самоучитель С++_ УпраЖнеж >> 1. В незавершенной программе имеется класс strtype. Для вывода строки на экран создайте пользовательскую функцию вывода: ftinclude <iostream> ^include <cstring> ^include <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype(char *ptr); -strtype () (delete [] p; } friend ostream &operator" (ostream &stream, strtype Sob); strtype;:strtype(char *ptr) len = strlen(ptr) + 1; p = new char [len]; cout " "Ошибка выделения памяти\п"; exit(l) ; strcpy (p, ptr) ; .//Здесь добавьте собственную функцию вывода int main () strtype si ("Это проверка"), з2("Мне нравится C++"); coat " si " '\n' " s2; return 0; 2. Замените в следующей программе функцию show() пользовательской функ-цией вывода: ^include <iostream> using namespace std; class planet { protected: double distance; //расстояние в милях от Солнца
Глава 8. Введение в систему ввода/вывода C++ 265^ int revolve; //полный оборот в днях public: planet(double d, int r) { distance = d; revolve = r; ) }; : class earth: public planet { double circumference; //окружность орбиты public: earth{double d, int r): planet(d, r) ( circumference = 2 * distance * 3.1416; /*Перепишите функцию show() так, чтобы информация выводилась с помощью пользовательской функции вывода */void show () { cout " "Расстояние от Солнца: " " distance " '\п'; cout " "Оборот вокруг Солнца: " " revolve " '\п'; cout " "Окружность орбиты: " " circumference " '\п'; }; int main() earth ob(93000000, 365); cout " ob; return 0; 3. Вспомните, почему пользовательская функция вывода не может быть функ-цией-членом. 8.6. Пользовательские функции ввода Точно так же, как мы перегружали оператор вывода ", можно перегрузить и оператор ввода ". В C++ оператор ввода " иногда называют операто-ром извлечения (extraction operator), а функцию, перегружающую этот опера-тор, - функцией извлечения (extractor). Смысл этих терминов в том, что при вводе информации мы извлекаем данные из потока. Во избежание пу-таницы мы будем называть функцию извлечения пользовательской функци-ей ввода. Здесь показана основная форма пользовательской функции ввода: istream Separator" (istream fistream, имя_класса &об-ъект) //тело пользовательской функции ввода
266 _ Самоучитель C++ return stream; Пользовательские функции ввода возвращают ссылку на поток istream, ко-торый является потоком ввода. Первый параметр тоже является ссылкой на поток ввода. Второй параметр - это ссылка на объект, получающий вводи-мую информацию. Так же, как и пользовательская функция вывода, пользовательская функция ввода не может быть функцией-членом. Хотя внутри такой функции может быть выполнена любая операция, лучше ограничить ее работу вводом ин-формации. Примеры ' Ъ*-1. В этой программе к классу coord добавлена пользовательская функция ввода: //Добавление дружественной функции ввода для объектов типа coord ^include <iostream> using namespace std; class coord { int x, y; public: coord() { x = 0; у = 0; } coord(int i, int j) { x = i; у = j; } friend ostream soperator" (ostream Sstream, coord ob) ; friend istream separator"{istream Sstream, coord Sob); ostream &operator" (ostream sstream, coord ob) stream " ob.x " ", " " ob.y " '\n'; return stream; istream ^operator" f istream sstream, coord &ob) { cout " "Введите координаты: " ; stream " ob.x " ob.y; return stream; int main() { coord a(l, 1) , b(10, 23) ; cout " a " b;
. Введение в систему ввода/вывода C++ _ 267 cin " a; cout " a; return 0; Обратите внимание, как пользовательская функция ввода формирует строку-приглашение для ввода данных. Хотя во многих случаях этого не требуется (или даже это нежелательно), пользовательская функция ввода показывает, как в случае необходимости почти без усложнения программы можно выдать приглашающее сообщение. 2. Здесь создается класс inventory (инвентарь), в котором хранится название какого-то предмета, количество выданных на руки штук и стоимость одной штуки. В программу для этого класса включены пользовательские функции ввода и вывода. #include <iostream> #include <cstring> using namespace std; class inventory { char item[40]; //название предмета int onhand; //количество предметов на руках double cost; //цена предмета public: inventory (char *i, int o, double c) { strcpy (item, i) ; onhand = o; cost = c; }friend ostreara &operator" (ostream &stream, inventory obi; friend istream &operator" (istream ^stream, inventory &ob) ; 1; ostream 5operator" (ostream sstream, inventory ob) { stream " ob.item " ": " " ob. onhand; stream " " на руках по цене $" " ob.cost " г\п'; return stream; istream soperator" (istream sstream, inventory &ob) { cout " "Введите название предмета: "; stream " ob.item; cout " "Введите число выданных на руки экземпляров: stream " ob. onhand;
268 __ Самоучитель C++ cout " "Введите стоимость экземпляра : " ; stream " ob.cost; return stream; int main ( ) inventory ob{ "hammer", 4, 12.55); cout " ob; cin " ob; cout " ob; return 0; Упражнеенниияя] 1. Добавьте пользовательскую функцию ввода в класс strtype из упражнения I предыдущего раздела. 2. Создайте класс для хранения целого и его наименьшего делителя. Создайте для этого класса пользовательские функции ввода и вывода. Проверка усвоения материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы: 1. Напишите программу для вывода числа 100 в десятичной, шестнадцатерич-ной и восьмеричной системе счисления. (Используйте флаги формата класса ios.) 2. Напишите программу для вывода значения 1000.5364 в 20-символьном поле, с выравниванием влево, с двумя позициями после запятой и сим-волом * в качестве символа заполнения. (Используйте флаги формата класса ios.) 3. Перепишите ваши ответы на упражнения 1 и 2 так, чтобы использова-лись манипуляторы ввода/вывода. 4. Покажите, как записать и как отобразить для класса cout флаги формата. Используйте функции-члены либо манипуляторы.
Глава 8. Введение в систему ввода/вывода C++ 269 5. Создайте для следующего класса пользовательские функции ввода и вывода: class pwr ( int base; int exponent; double result; //результат возведения в степень public: pwr(int b, int e) }; pwr::pwr(int b, int e) f base = b; exponent = e; result = 1; for{; e; e -) result = result * base; } 6. Создайте класс box для хранения размеров квадрата. Для вывода изобра-жения квадрата на экран создайте пользовательскую функцию вывода. (Способ изображения выберите любой.) Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Используя показанный здесь класс stack, создайте пользовательскую функцию вывода для вставки в поток содержимого стека. Покажите, что функция работает. ttinclude <iostream> using namespace std; ^define SI2E 10 //Объявление класса stack для хранения символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины -стека public: stack 0; void pushfchar ch); //помещение символа в стек char pop0; //выталкивание символа из стека 1;
270 Самоучитель C++ I/Инициализация стека stack::stack() { tos=0; //Помещение символа в стек void stack::push(char ch} /if (tos=SIZE) { cout " "Стек полон"; return; }stck[tos]=ch; tos-f-+; }//Выталкивание символа из стека char stack::pop() ( if (tos=~0) { cout " "Стек пуст"; return 0; //возврат нуля при пустом стеке } tos - ; return stckftos]; } 2. Напишите программу с классом watch, который бы играл роль обычных часов. Используя стандартные функции времени, создайте конструктор класса, который должен считывать и запоминать системное время. Для вывода этого времени на экран создайте пользовательскую функцию вывода. 3. На основе класса, созданного для преобразования футов в дюймы, напи-шите пользовательскую функцию ввода, формирующую строку-пригла-шение для записи числа футов. Кроме этого, напишите пользовательскую функцию вывода для отображения на экране как числа футов, так и чис-ла дюймов. Включите указанные функции в программу и продемонстри-руйте их работоспособность. class ft__to inches { double feet; double inches; public: void set (double f); { feet -f; inches = f * 12; i
Глава 9 Дополнительные возможности ввода/вывода в C++ В этой главе продолжается изучение системы ввода/вывода C++. Здесь вы узнаете, как создать пользовательские манипуляторы ввода/вывода и как реализовать ввод/вывод в файл. Запомните, система ввода/вывода C++ очень богата, гибка и многофункциональна. Рассмотрение всех ее возмож-ностей выходит за рамки данной книги, мы коснемся только наиболее важ-ных из них. Зам ^*-^"^--т-Замечание Представленная в этой главе система ввода/вывода C++ определена в стан-дарте Standard C++ и совместима с подавляющим большинством современ-ных компиляторов C++. Если у вас устаревший или несовместимый с современной системой ввода/вывода компилятор, то не все описанные здесь возможности будут вам доступны. ПоБТОрение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Напишите программу для вывода предложения: "C++ прекрасен" в поле шириной 40 символов с использованием двоеточия (:) в качестве символа заполнения. 2. Напишите программу для вывода результата деления 10/3 с четырьмя знаками после десятичной точки. Для этого используйте функции-члены класса ios. 3. Перепишите предыдущую программу, используя манипуляторы вво-да/вывода. 4. Что такое пользовательская функция вывода? Что такое пользовательская функция ввода?
jTg ____ _ ____ Самоучитель C++ 5. Дан следующий класс. Создайте для него пользовательские функции вво-да и вывода. class date { char date [9]; //дата хранится в виде строки: mm/dd/yy public: //добавьте пользовательские функции ввода и вывода 6. Какой заголовок должен быть включен в программу для использования манипуляторов ввода/вывода с параметрами? 7. Какие создаются встроенные потоки, когда начинается выполнение про-граммы на C++? 9.1. Создание пользовательских манипуляторов В дополнение к перегрузке операторов ввода и вывода вы можете создать свою подсистему ввода/вывода C++, определив для этого собственные ма-нипуляторы. Использование пользовательских манипуляторов важно по двум причинам. Во-первых, можно объединить последовательность несколь-ких отдельных операций по вводу/выводу в один манипулятор. Например, нередки ситуации, в которых в программе встречаются одинаковые последо-вательности операций ввода/вывода. Для выполнения такой последователь-ности можно создать пользовательский манипулятор. Этим вы упрощаете исходную программу и исключаете случайные ошибки. Во-вторых, пользо-вательский манипулятор может понадобиться, когда необходимо выполнить ввод/вывод на нестандартном оборудовании. Например, вы могли бы вос-пользоваться манипулятором для посылки управляющих кодов на специаль-ный принтер или в систему оптического распознавания. Пользовательские манипуляторы - это те элементы языка, которые обеспе-чивают поддержку в C++ объектно-ориентированного программирования, но они также удобны и для обычных, не объектно-ориентированных про-грамм. Как вы увидите, пользовательские манипуляторы могут помочь сде-лать любую программу ввода/вывода понятней и эффективней. Как вы знаете, имеется два базовых типа манипуляторов: те, которые рабо-тают с потоками ввода, и те, которые работают с потоками вывода. Однако кроме этих двух категорий имеются еще две: манипуляторы с аргументами и без них. Есть несколько важных отличий в способе создания манипуляторов с параметрами и без. Более того, создание манипуляторов с параметрами является существенно более трудной задачей, чем создание манипуляторов без параметров, и в этой книге не рассматривается. С другой стороны, соз-дать пользовательский манипулятор без параметров достаточно просто, и вы скоро узнаете, как это сделать.
Глава 9. Дополнительные возможности ввода/вывода в C++ 273 Все манипуляторы без параметров для вывода имеют следующую конструкцию: ostream бимя^манилулятора (ostream &поток) ( (I Код программы манипулятора return поток; } Здесь имя_манипулятора - это имя создаваемого вами пользовательского манипулятора, а поток ~ ссылка на вызывающий поток. Возвращаемым значением функции является ссылка на поток. Это необходимо в случае, когда манипулятор является частью большого выражения ввода/вывода. Важно понимать, что хотя у манипулятора и имеется в качестве единствен-ного аргумента ссылка на поток, с которым он работает, но, когда манипу-лятор используется в операции вывода, его аргумент не используется. Все манипуляторы без параметров для ввода имеют следующую конструкцию: istream &кмя манипулятора, (istream йлоток) { //Код программы манипулятора return поток; I Манипулятор ввода получает в качестве параметра ссылку на поток, для ко-торого он вызывается. Манипулятор должен возвращать этот поток. То, что манипулятор возвращает ссылку на вызывающий поток весьма важно. Если этого не сделать, то ваши манипуляторы нельзя будет использовать в по-следовательностях операций ввода или вывода. 1. Рассмотрим первый простой пример. В следующей программе создается ма-нипулятор setup(), который устанавливает ширину поля вывода, равную 10, точность, равную 4, и символ заполнения *. #include <iostream> using namespace std;
274 Само учитель ostream fisetup (ostrearn fistream) f stream.width(10); stream.precision{4) ; stream.filK1*'} ; return stream; int main() cout " setup " 123.1234^6: return 0; Как можно заметить, созданный вами манипулятор setup используется в ка-честве части выражения ввода/вывода точно так же, как это делается с лю-бым встраиваемым манипулятором. 2. Пользовательские манипуляторы не обязательно должны быть сложными. Например, простые манипуляторы atn() и note() обеспечивают простой и удобный способ вывода часто встречающихся слов и фраз. ^include <iostream> using namespace std; //Внимание: ostream Satn (ostream sstream) i stream " "Внимание: "; return stream; }//Пожалуйста, не забудьте: ostream Snote (ostream ^stream) { stream " "Пожалуйста, не забудьте: "; return stream; }int main ( ) { cout " atn " "Высокое напряжениеХп"; cout " note " "Выключить свет\п"; return 0; Несмотря на простоту, такие манипуляторы оградят вас от необходимости частого набора одних и тех же слов и фраз.
Глава_9. Дополнительные возможности ввода/вывода в C++ _ 275 3. В следующей программе создается манипулятор getpass(), который вызывает гудок динамика и затем предлагает ввести пароль: #include ,<io3tream> ^include <cstring> using namespace std; //Простой манипулятор ввода istream bgetpass (istream Sstream) { cout " ' \ a ' ; //гудок динамика cout " "Введите пароль : " ; -return stream; int main ( ) { char pw[80] ; do {cin " getpass " pw; } while (strcmp(pw, "пароль")); cout " "Пароль введен верноХп"; return 0; 1. Создайте манипулятор вывода для отображения текущего системного време-ни и даты. Назовите манипулятор td(). 2. Создайте манипулятор вывода sethex(), который осуществляет вывод в шест-надцатиричной системе счисления и устанавливает флаги uppercase и showbase. Кроме того, создайте манипулятор вывода resetQ, который отменя-ет изменения, сделанные манипулятором sethex(). 3. Создайте манипулятор ввода skipchar(), который поочередно то считывает, то пропускает каждые десять символов потока ввода. 9.2. Основы файлового ввода/вывода Как было отмечено в предыдущей главе, файловый и консольный ввод/вывод очень близко связаны. Фактически файловый ввод/вывод под-держивается той же иерархией классов, что и консольный ввод/вывод.
276 Самоучитель C++ Таким образом, все, что вы уже узнали о вводе/выводе, вполне применимо и к файлам. Естественно, что обработка файлов предполагает и кое-что новое. Для реализации файлового ввода/вывода, необходимо включить в программу заголовок <fstream>. В нем определено несколько классов, включая классы ifstream, ofstream и fstream. Эти классы являются производными от классов istream и ostream. Вспомните, что классы istream и ostream, в свою очередь, являются производными от класса ios, поэтому классы ifstream,. ofstream и fstream также имеют доступ ко всем операциям, определяемым классом ios (это обсуждалось в предыдущей главе). В C++ файл открывается посредством его связывания с потоком. Имеется три типа потоков: ввода, вывода и ввода/вывода. Перед тем как открыть файл, нужно, во-первых, создать поток. Для создания потока ввода необхо-димо объявить объект типа ifstream. Для создания потока вывода - объект типа ofstream. Потоки, которые реализуют одновременно ввод и вывод, должны объявляться как объекты типа fstream. Например, в следующем фрагменте создается один поток для ввода, один поток для вывода и еще один поток одновременно для ввода и для вывода: ifstream in; //ввод ofstream out; //вывод fstream io; //ввод и вывод После создания потока, одним из способов связать его с файлом является функция ореп(). Эта функция является членом каждого из трех потоковых классов. Здесь показаны ее прототипы для каждого класса: void ifstream::open(const char *#мя_файла, openmode режим = ios: : in) ; void ofstream::open(const char *имя файла, openmode режим = ios: :out I ios: : trunc) ; void fstream::open(const char *имя_фаяла, Openmode режим = ios: : in | ios: : out) ; Здесь UMxjpaUAa - имя файла, в которое может входить и спецификатор пути. Значение режим задает режим открытия файла. Оно должно быть зна-чением типа openmode, которое является перечислением, определенным в классе ios. Значение режим может быть одним из следующих: юз ios ios ios ios ios :app :ate : binary : in :out : trunc Вы можете объединить два или более этих значения с помощью оператора OR. Рассмотрим, что означает каждое из этих значений.
Глава 9. Дополнительные возможности ввода/вывода в C++ 277 Значение ios::app вызывает открытие файла в режиме добавления в конец файла? Это значение может применяться только к файлам, открываемым для вывода. Значение ios::ate задает режим поиска конца файла при его открытии. Хотя значение ios::ate вызывает поиск конца файла, тем не менее, операции ввода/вывода могут быть выполнены в любом месте файла. Значение ios::in задает режим открытия файла для ввода. Значение ios::out задает режим открытия файла для вывода. Значение ios::binary вызывает открытие файла в двоичном режиме. По умол-чанию все файлы открываются в текстовом режиме. В текстовом режиме имеет место преобразование некоторых символов, например, последова-тельность символов "возврат каретки/перевод строки" превращается в сим-вол новой строки. Если же файл открывается в двоичном режиме, такого преобразования не выполняется. Запомните, что любой файл, независимо от того, что в нем содержится - отформатированный текст или необработан-ные данные - может быть открыт как в текстовом, так и в двоичном режи-ме. Отличие между ними только в отсутствии или наличии упомянутого символьного преобразования. Значение ios::trunc приводит к удалению содержимого ранее существовав-шего файла с тем же названием и усечению его до нулевой длины. При соз-дании потока вывода с помощью ключевого слова ofstream любой ранее существовавший файл с тем же именем автоматически усекается до нулевой длины. В следующем фрагменте для вывода открывается файл test: . ofstream mystream; mystream.open("test"); В этом примере параметр режим функции ореп() по умолчанию устанавлива-ется в значение, соответствующее типу открываемого потока, поэтому нет не-обходимости указывать его явно. Если выполнение функции ореп() завершилось с ошибкой, в булевом выра-жении поток будет равен значению false. Этот факт можно использовать для проверки правильности открытия файла с помощью, например, такой инст-рукции: if(!mystream) { cout " "Файл открыть невозможно\п"; //программа обработки ошибки открытия файла ) Как правило, перед тем как пытаться получить доступ к файлу, следует про-верить результат выполнения функции ореп(). Проверить правильность открытия файла можно также с помощью функции is_open(), являющейся членом классов ifstream, ofstream и fstream. Ниже по-казан прототип этой функции: bool is open{);
278 _ __ Самдучитель_С+ + Функция возвращает истину, если поток удалось связать с открытым фай-лом, в противном случае функция возвращает ложь. Например, в следую-щем фрагменте проверяется, открыт ли файл, связанный с потоком mystream: iff !mystream.is_open() ) { cout " "Файл не открытЛп"; Хотя использовать функцию openQ для открытия файла в целом правильно, часто вы этого делать не будете, поскольку у классов ifstream, ofstream и fstream есть конструкторы, которые открывают файл автоматически. Конст-рукторы имеют те же параметры, в том числе и задаваемые по умолчанию, что и функция орел(). Поэтому чаще вы будете пользоваться таким спосо-бом открытия файла: ifstream mystream ("rnyfile") ; //открытие файла для ввода Как уже установлено, если по каким-то причинам файл не открывается, пе-ременная, соответствующая потоку, в условной инструкции будет равна зна-чению false. Поэтому, независимо от того, используете ли вы конструктор или явно вызываете функцию ореп(), вам потребуется убедиться в успешном открытии файла путем проверки значения потока. Для закрытия файла используйте функцию-член close(). Например, чтобы закрыть файл, связанный с потоком mystream, необходима следующая инст-рукция: mystream. close ( ) ; Функция close() не имеет параметров и возвращаемого значения. С помощью функции eof(), являющейся членом класса ios, можно опреде-лить, был ли достигнут конец файла ввода. Ниже показан прототип этой функции: bool eof () ; Функция возвращает истину, если был достигнут конец файла; в противном случае функция возвращает ложь. После того как файл открыт, очень легко считать из него или записать в него текстовые данные. Просто используйте операторы " и " так же, как это делалось для консольного ввода/вывода, только замените поток cm или cout тем потоком, который связан с файлом. Так же, как и операторы " и " для чтения из файла и записи в файл годятся функции С - fprintfQ и fscanfQ. Вся информация в файле хранится в том же формате, как если бы она находилась на экране. Следовательно, файл, созданный с помощью оператора ", представляет из себя файл с отформатированным текстом, и
Глава 9. Дополнительные возможности ввода/вывода в C++ 279 наоборот, любой файл, содержимое которого считывается с помощью опе-ратора ", должен быть файлом с отформатированным текстом. То есть, как правило, файлы с отформатированным текстом, которые вы будете об-рабатывать, используя операторы " и ", следует открывать в текстовом, а не в двоичном режиме. Двоичный режим больше подходит для неотформа-тированных файлов, о которых в этой главе будет рассказано позже. Примеры 1. В представленной ниже программе создается файл для вывода, туда записыва-ется информация, и файл закрывается. Затем файл снова открывается уже в качестве файла для ввода, и записанная ранее информация оттуда считывается: tfinclude <iostream> #include <fstream> using namespace std; int main() ofstream fout("test"); //создание файла для вывода if{!font) { cout " "Файл открыть невозможно\п"; return 1; fout " "Привет !\п"; fout " 100 " ' ' " hex " 100 " endl; fout .close () ; if stream fin ("test"); //открытие файла для ввода if П fin) { cout " "Файл открыть невозможно\п"; return 1; char str[80] ; int i; fin " str " i; cout " str " ' ' " i " endl; fin. close () ; return 0; .
280 __ ___ __ Самоучитель C++ После того как программа завершится, проанализируйте содержимое файла test. Оно будет следующим: Привет ! 100 64 Как уже установлено, при использовании операторов " и " для реализа-ции файлового ввода/вывода, информация форматируется так же, как если бы она находилась на экране. 2. Рассмотрим другой пример файлового ввода/вывода. В этой программе вве-денные с клавиатуры строки считываются и записываются в файл. Програм-ма завершается при вводе знака доллара $ в качестве первого символа строки. Для использования программы в командной строке задайте имя фай-ла для вывода. ftinclude <iostream> ^include <fstream> using namespace std; int main{int argc, char *argv[]) { if(argc!=2) { cout " "Введите <имя_файла>\п" ; return 1; ofstream out (argv[l] ) ; //файл для. вывода if (lout) { cout " "Файл открыть невозможной"; return 1 ; char str[80] ; cout " "Вводите строки; для окончания ввода введите S\n"; do {cout " ": "; cin " str; out " str " endl; } while (*str != 'S1) ; out. close () ; return 0; 3. В следующей программе копируется текстовый файл и при этом пробелы превращаются в символы [. Обратите внимание, как для контроля конца файла для ввода используется функция eof(). Также обратите внимание, как
Глава 9. Дополнительные возможности ввода/вывода в C++ 28? поток ввода fin воспринимает сброс флага skipws. Это предотвращает пропуск пробелов в начале строк. //Превращение пробелов в вертикальные линии | ftinclude <iostrearn> ttinclude <fstream> using namespace std; int main(int argc, char *argv[]) if (argc!=3) { cout " "Преобразование <файл_ввода> <файл_вывода>\п"; return 1 ; }ifstream fin(argv[l] ) ; //открытие файла для ввода ofstream fout (argv[2] ) ; //создание файла для вывода if (lout) { cout " "Файл открыть невозможной"; return 1; }if(!fin) { cout " "Файл открыть невозможно\п" ; return 1; }char ch; f in. unsetf (ios: : skipws) ; //не пропускать пробелы while ( ! fin, eof ( ) ) { fin " ch; if (ch==' ') ch = ' | '; if ( ! fin. eof () ) fout " ch; fin. close () ; fout. close () ; return 0; 4. Между исходной библиотекой ввода/вывода C++ и библиотекой вво-да/вывода современного стандарта Standard C++ имеются некоторые отли-чия, которые необходимо учитывать при модернизации старых программ. Во-первых, в исходной библиотеке ввода/вывода C++ у функции ореп(') име-ется третий параметр, задающий режим защиты файла. По умолчанию это режим обычного файла. В современной библиотеке C++ указанный пара-метр не поддерживается. Во-вторых, при работе со старой библиотекой для открытия потока вво-да/вывода fstream необходимо явно указать значения режима открытия файла
282 Самоучитель C++ ios::in и ios::out. Значения режима открытия файла по умолчанию не поддер-живаются. Это относится как к конструктору класса fstream, так и к функции орел(). Например, при работе со старой библиотекой ввода/вывода C++, чтобы открыть файл для ввода и вывода с помощью функции ореп(), необхо-димо использовать следующую конструкцию: fstream mystream; mystream.openC'test", ios::in j ios::out); В современной библиотеке ввода/вывода C++, если режим открытия файла не указан, любой объект типа fstream автоматически открывает файл для ввода и вывода. И последнее. При работе со старой библиотекой ввода/вывода к ошибке вы-полнения функции openQ ведет значение режима открытия файла, равное ios::noncreate, если указанный файл не существует, или равное ios::noreplace, если, наоборот, указанный файл уже существует. В стандарте Standard C++ данные значения режима открытия файла не поддерживаются. 1. Напишите программу для копирования текстового файла. Эта программа должна подсчитывать число копируемых символов и выводить на экран по-лученный результат. Почему это число отличается от того, которое выводит-ся при просмотре списка файлов каталога? 2. Напишите программу для заполнения информацией следующей таблицы в файле phone. Исаак Ньютон, 415 555-3423 Роберт Годдард, 213 555-2312 Энрико Ферми, 202 555-1111 3. Напишите программу для подсчета числа слов в файле. Для простоты счи-тайте, что словом является все, имеющее с двух сторон пробелы. 4. Какие действия выполняет функция is_open? 9.3. Неформатируемый двоичный ввод/вывод Хотя текстовые файлы (т. е. файлы, информация в которых представлена в кодах ASCII, - примеч. пер.) полезны во многих ситуациях, у них нет гиб-кости неформатированных двоичных файлов. Неформатированные файлы содержат те самые исходные или "сырые" двоичные данные, которые непо-средственно используются вашей программой, а не удобный для восприятия
Глава 9. Дополнительные возможности ввода/вывода в C++ 283 человека текст, данные для которого транслируются операторами " и ". Поэтому о неформатируемом вводе/выводе иногда говорят как о "сыром" (raw) вводе/выводе. В C++ для двоичных файлов поддерживается широкий диапазон функций ввода/вывода. Эти функции дают возможность точно контролировать процессы считывания из файлов и записи в файлы. На нижнем уровне двоичного ввода/вывода находятся функции get() и put(). С помощью функции-члена put() можно записать байт; а с помощью функ-ции-члена get() - считать. Эти функции являются членами всех потоковых классов соответственно для ввода и для вывода. Функции get() и put() име-ют множество форм. Ниже приведены их наиболее часто встречающиеся версии: istream figet(char £ символ) ; ostream &put(char символ); Функция get() считывает один символ из связанного с ней потока и переда-ет его значение аргументу символ. Ее возвращаемым значением является ссылка на поток. При считывании символа конца файла функция возвратит вызывающему потоку значение false. Функция put() записывает символ в поток и возвращает ссылку на поток. Для считывания и записи блоков двоичных данных используются функции read() и writeQ, которые также являются членами потоковых классов соот-ветственно для ввода и для вывода. Здесь показаны их прототипы: istream firead(char * буфер, streamsize число_байгг) ; ostream fiwrite(const char * буфер, streamsize чксло_байт); Функция readQ считывает из вызывающего потока столько байтов, сколько задано в аргументе число_6айт и передает их в буфер, определенный указа-телем буфер. Функция write() записывает в соответствующий поток из буфе-ра, который определен указателем буфер, заданное в аргументе число_байт число байтов. Значения типа streamsize представляют собой некоторую форму целого. Если конец файла достигнут до того, как было считано число_байт симво-лов, выполнение функции read() просто прекращается, а в буфере оказыва-ется столько символов, сколько их было в файле. Узнать, сколько символов было считано, можно с помощью другой функции-члена gcount(), прототип которой приведен ниже: streamsize gcountO ; Функция возвращает количество символов, считанных во время последней операции двоичного ввода. Естественно, что при использовании функций, предназначенных для работы с двоичными файлами, файлы обычно открывают в двоичном, а не в тек-
284 Самоучитель C++ стовом режиме. Смысл этого понять легко, значение режима открытия фай-ла ios::binary предотвращает какое бы то ни было преобразование символов. Это важно, когда в файле хранятся двоичные данные, например, целые, ве-щественные или указатели. Тем не менее, для файла, открытого в текстовом режиме, хотя в нем содержится только текст, двоичные функции также вполне доступны, но при этом помните о возможности нежелательного пре-образования символов. 1. В следующей программе на экран выводится содержимое файла. Использует-ся функция get(). ^include <iostream> ttinclude <fstream> using namespace std; int main(int argc, char *argv[]) * char ch; if(argc!=2) { cout " "Содержимое: <имя_файла>\п"; return 1; ifstream in(argv[lj, ios::in | ios : :binary) ; i£(!in) { cout " "Файл открыть невозможно\п"; return 1 ; while ( ! in,eof () ) in. get (ch) ; cout " ch; in. close (} ; return 0; 2. В данной программе для записи в файл вводимых пользователем символов используется функция put(). Программа завершается при вводе знака доллара $. #include <iostream> #include <fstream> using namespace std;
Глава 9. Дополнительные возможности ввода/вывода в C++ 285 in.t main(int argc, char *argv[]} char ch; if(argc!=2) { cout " "Запись: <имя файла>\п"; return 1; ofstream out[argv[l], ios::out I ios:ibinary); if (lout) { cout " "Файл открыть невозможноХп"; return 1; cout " "Для остановки введите символ $\п"; do {cout " ": "; cin.get(ch); out.put(ch); } while (ch!='$') ; out.close (); return 0; Обратите внимание, что для считывания символов из потока cin в программе используется функция get(). Это предотвращает игнорирование начальных пробелов. 3. В следующей программе для записи строки и числа типа double в файл test используется функция wtite(): ^include <iostreain> #include <fstream> #include <cstring> using namespace std; int main () { ofstream out{"test", ios:rout I ios:ibinary}; if(lout) { cout " "Файл открыть невозможноХп"; return 1; } double num = 100.45; char str[] = "Это проверка";
286 Самоучитель C++ out.write((char *) &num, sizeof(double)); out.write(str, strlen(str)); out.close{): return 0; Приведение типа к (char*) при вызове функции write() необходимо, если буфер вывода не определен как символьный массив. Поскольку в C++ осу-ществляется строгий контроль типов, указатель на один тип не преобразует-ся автоматически в указатель на другой тип. 4. В следующей программе для считывания из файла, созданного в программе примера 3, используется функция read(): ^include <iostream> ^include <fstreairt> using namespace std; \ int main ( ) { ifstream in("test", ios::in | ios : :binary) ; cout " "Файл открыть невозможно \п"; return 1; double num; char str[80]; in.read( {char *) &num, sizeof (double) ); in. read(str, 15) ; str[14] = '\0',-cout " num " ' ' " str; in. close () ; return 0; Как и в программе из предыдущего примера, приведение типов внутри функции read() необходимо, поскольку в C++ указатель одного типа автома-тически не преобразуется в указатель другого типа.
Глава 9. Дополнительные возможности ввода/вывода в C++ 287 5. В следующей программе сначала массив double записывается в файл, а затем считывается обратно. Кроме того, отображается число считанных символов. //Демонстрация работы функции gcountO ^include <iostream> ttinclude <fstrearn> using namespace std; int main() ofstream out ("test", ios::out | ios: :binary) ; if (lout) { cout " "Файл открыть невозможно\п"; return 1 ; double nums[4] = {1.1, 2.2, 3.3, 4.4}; out.write((char *) nums, sizeof(nums)); out. close (} ; ifstream in("test", ios::in | ios::binary); if(!in) { cout " "Файл открыть невозможной"; return 1; 'in.read((char *) snums, sizeof(nums)); int i; for (i=0; i<4; i++) cout " numsfi] " ' '; cout " '\n'; cout " in.gcount() " " символов считано\n"; in.close (); return 0; } УпраЖненш ^':"::::--S^p 1. Измените ответы на упражнения 1 и 3 раздела 9.2 так, чтобы в них использо-вались функции get(), put(), read() и/или write(). (Используйте эти функции там, где они, по вашему мнению, принесут наибольшую отдачу.)
288 Самоучитель C++ 2. Дан следующий класс. Напишите программу для вывода содержимого класса в файл. Для этой цели создайте пользовательскую функцию вывода. class account { int custnum; char name[80]; double balance; public: account(int c, char *n, double b} custnum = c; strcpyiname, n); balance = b; //здесь нужна пользовательская функция вывода }; 9.4. Дополнительная информация о функциях двоичного ввода/вывода Кроме представленной ранее формы, функцию get() можно перегрузить еще несколькими способами. Здесь показаны прототипы трех наиболее часто перегружаемых форм: iatream figet(char *буфвр, strearasize чксло_байт); istream figet (char *буфер, strearasize число__баит, char ограничитель) ; int get(); Первая функция get() считывает символы в массив, определенный указате-лем буфер, до тех пор, пока либо не считано столько символов, сколько за-дано параметром число_байт - I, либо не встретился символ конца файла. В конце массива, заданного указателем буфер, функция get() помещает ноль. Если в потоке ввода встретится символ новой строки, он не извлекается, а остается в потоке до следующей операции ввода. Вторая функция get() считывает символы в массив, определенный указате-лем буфер, до тех пор, пока либо не считано столько символов, сколько за-дано параметром число_байт - 1, либо не встретился символ, заданный параметром ограничитель, либо не встретился символ конца файла. В конце массива, заданного указателем буфер, функция get() помешает ноль. Если в потоке ввода встретится символ ограничитель, он не извлекается, а остается в потоке до следующей операции ввода. Третья функция get() возвращает из потока следующий символ. Она воз-вращает символ EOF, если достигнут конец файла. Эта форма функции get() напоминает функцию getc() языка С.
Глава 9. Дополнительные возможности ввода/вывода в C++ 289 Другой функцией для реализации ввода является функция getline(). Эта функция - член всех потоковых классов ввода. Ниже показаны ее прототипы: istream figetline(char *буфер, streamsize число_байт); istream ugetline(char * буфер, streamsize число байт, char ограничитель) ; Первая функция считывает символы в массив, обозначенный указателем буфер, до тех пор, пока либо не считано столько символов, сколько задано параметром число_байт - 1, либо не встретился символ новой строки, либо не встретился символ конца файла. В конце массива, заданного указателем буфер, функция getline() помещает ноль. Если в потоке ввода встретится символ новой строки, он извлекается, но не помещается в массив. Вторая функция считывает символы в массив, обозначенный указателем бу-фер, до тех пор, пока либо не считано столько символов, сколько задано параметром число_байт - 1, либо не встретился символ ограничитель, либо не встретился символ конца файла. В конце массива, заданного указателем буфер, функция getline() помещает ноль. Если в потоке ввода встретится символ ограничитель, он извлекается, но не помещается в массив. Как можно заметить, обе версии функции getlineQ фактически тождествен-ны версиям get(5y$ep, число_байт) и %еЬ(буфер9 число_байт, ограничитель) функции get(). Обе считывают символы из потока ввода и помещают их в массив, обозначенный указателем буфер до тех пор, пока либо не считано число_байт - 1 символов, либо не встретился символ ограничитель или символ конца файла. Отличие между функциями get() и getline() в том, что функция gellineQ считывает и удаляет из потока ввода символ ограничитель, а функция get() - нет. Используя функцию peek(), можно получить следующий символ из потока ввода без его удаления из потока. Функция является членом потоковых классов ввода и имеет следующий прототип: int peek(); Функция возвращает следующий символ из потока или, если достигнут ко-нец файла, символ EOF. С помощью функции putbackQ, являющейся членом потоковых классов ввода, можно возвратить последний считанный из потока символ обратно в поток. Ниже показан прототип этой функции: istream fiputback (char с); Здесь с - это последний считанный из потока символ. При выполнении вывода данные не сразу записываются на связанное с потоком физическое устройство, а информация временно сохраняется во внутреннем буфере. Только после заполнения буфера его содержимое пере-писывается на диск. Однако вызов функции flush () вызывает физическую
290 Самоучитель C++ запись информации на диск до заполнения буфера. Ниже показан прототип функции flush(), являющейся членом потоковых классов вывода: ostream fiflushO ; Вызовы функции flush() оправданы при работе в неблагоприятной обста-новке (например, в ситуациях, когда часто случаются сбои по питанию). I. Как вы знаете, при использовании для считывания строки оператора ", считывание прекращается при встрече первого разделительного символа. При наличии в строке пробелов такое считывание становится невозможным. Однако, как показано в программе, с помощью функции gctlinc() можно ре-шить эту проблему: //Использование функции getlineO для считывания строки с пробелами # include <iostream> ftinclude <fstream> using namespace std; int main() char str [80]; cout " "Введите ваше имя: "; cin.getline (str, 79} ; cout " str " '\n' ; return 0; В данном случае ограничителем для функции getline() является символ новой строки. Это делает выполнение функции getline() очень похожей на выпол-нение стандартной функции gets(). 2. В реальном программировании особенно полезны функции peek() и putback() Они позволяют упростить управление, когда неизвестен тип вво-димой в каждый конкретный момент времени информации. Следующая программа иллюстрирует это. В ней из файла считываются строки либо це-лые. Строки и целые могут следовать в любом порядке. //Демонстрация работы функции peek() ^include <iostream> ttinclude <fstream> #include <cctype> using namespace std; int main ()
Глава 9. Дополнительные возможности ввода/вывода в C++ 291 ( char ch; ofstream out("test", ios::out | ios::binary); . if(lout) { cout " "Файл открыть невоэможно\п"; return 1; } char str[80], *p; out " 123 " "this is a test" " 23; out " "Hello there!" " 99 " "sdf" " endl; out.close{); ifstream inC'test", ios::in | ios: :binary); if(!in) { cout " "Файл открыть невозможнсЛп"; return 1; } do {p = str; ch = in.peekj); //выяснение типа следующего символа if(isdigit(ch)) { while(isdigit{*p=in.get())} p++; //считывание целого in.putback(*p); //возврат символа в поток *р = '\0'; //заканчиваем строку нулем cout " "Целое: " " atoi(str); } else if(isalpha(ch)} { //считывание строки while(isalpha(*p=in.get())) p++; in.putback(*p); //возврат символа в поток *р -'\0'; //заканчиваем строку нулем cout " "Строка: " " str; } else in.getO; //пропуск cout " '\n'; } while(lin.eof()); in.close(); return 0; 1. Перепишите программу из примера I так, чтобы вместо функции getlineQ использовать функцию get(). Будет ли отличаться работа программы?
292 Самоучитель C++ 2. Напишите программу для построчного считывания текстового файла и выво-да каждой считанной строки на экран. Используйте функцию getlineQ. 3. Подумайте о ситуациях, в которых может оказаться полезным вызов функ-ции flush(). 9.5. Произвольный доступ В системе ввода/вывода C++ произвольный доступ (random access) реализуется с помощью функций seekg() и seekp(), являющихся соответственно потоковыми функциями ввода и вывода. Здесь показаны их основные формы: istream fiseekg(off_type смещение, seekdir задание); ostream Sseekp(off_type смещение, seekdir задание); Здесь off_type --это целый тип данных, определенный в классе ios и со-вместимый с максимальным правильным значением, которое способен хра-нить параметр смещение. Тип seekdir - это перечисление, определенное в классе ios и содержащее следующие значения: Значение Смысл ios:: beg Поиск с начала файла ios: :cur Поиск от текущей позиции в файле ios: :end Поиск с конца файла Система ввода/вывода C++ управляет двумя указателями, связанными с файлом. Первый - это указатель считывания (get pointer), который задает следующее место в файле, откуда будет вводиться информация. Второй -это указатель записи (put pointer), который задает следующее место в файле, куда будет выводиться информация. При каждом вводе или выводе соответ-ствующий указатель последовательно продвигается дальше. Однако с помо-щью функций seekg() и seekpQ возможен непоследовательный доступ к файлу. Функция seekgQ устанавливает указатель считывания соответствующего файла в позицию, отстоящую на величину смещение от заданного места задание. Функция seekp() устанавливает указатель записи соответствующего файла в позицию, отстоящую на величину смещение от заданного места задание. Как правило, файлы, доступные для функций seekg() и seekp(), должны от-крываться в режиме операций для двоичных файлов. Таким образом предот-вращается возможное неожиданное преобразование символов внутри файла. Определить текущую позицию каждого из двух указателей можно с помо-щью функций:
Глава 9. Дополнительные возможности ввода/вывода в C++ 293 pos_type tellgO; pos_type tellpO; Здесь pos_type - это целый тип данных, определенный в классе ios и спо-собный хранить наибольшее возможное значение указателя. Для перемещения файловых указателей считывания и записи на позицию, заданную возвращаемыми значениями функций tellgQ и tellp(), используют-ся перегруженные версии функций seekgQ и seekpQ. Прототипы этих функ-ций представлены ниже: istream Sseekg{pos_type позиция) ; ostream fiseekp(pos type позиция) ; Примеры J В следующей программе показана работа функции seekpQ. Она позволяет заме-нить в файле заданный символ. Укажите в командной строке имя файла, затем номер байта в файле, который вы хотите изменить, и, наконец, новый символ для замены. Обратите внимание: файл открывается для операций чтения и записи. ^include <iostream> ^include <fstream> ^include <cstdlib> using namespace std; int mainlint argc, char *argv[]) { if{argc!=4} { cout " "Замена: <файл> <байт> <символ>\п"; return 1; fstream out(argv[l], ios::in | ios::out | ios : : binary ) ; if (lout) { cout " "Файл открыть невозможно \п"; return 1; out .seekp (atoi (arqv[2] ) , ios: :beg) ; out .put (*argv[3] ) ; out, close () ; return 0;
294 _ __ Самоучитель С++_ 1, В следующей программе функция seekgQ используется для установки указа-теля считывания в заданную позицию внутри файла и для вывода содержи-мого файла, начиная с этой позиции. Имя файла и позиция начала считывания задаются в командной строке. //Демонстрация работы функции seekg() ^include <iostream> ^include <fstream> # include <cstdlib> using namespace std; int main(int argc, char *argv[]} char ch; if(argc!=3) { cout " "Поиск: <файл> <позиция>\п"; return 1; if stream in(argv[l] , ios: :in I ios: : binary) ; if(!in) { cout " "Файл открыть невозможно \п"; return 1; in.seekgfatoi (argv[2] ) , ios: :beg) ; while (lin.eofO) { in. get (ch) ; cout " ch; in. close () ; return 0; Упражнеенниияя] 1. Напишите программу для вывода на экран содержимого текстового файла в обратном порядке. (Подсказка: Обдумайте задание перед началом програм-мирования. Решение проще, чем может показаться на первый взгляд.) 2. Напишите программу, которая попарно меняет местами символы в тексто-вом файле. Например, если в файле содержится "1234", то после выполнения программы там должно содержаться "2143". (Для простоты считайте, что в файле содержится четное число символов.)
Глава 9. Дополнительные возможности ввода/вывода в C++ 295 9.6. Контроль состояния ввода/вывода В системе ввода/вывода C++ поддерживается информация о состоянии по-сле каждой операции ввода/вывода. Текущее состояние потока вво-да/вывода, которое хранится в объекте типа iostate, является перечислением, определенным в классе ios и содержащим следующие члены: Название Значение goodbit Ошибок нет eofbit Достигнут конец файла failbit Имеет место нефатальная ошибка badbit Имеет место фатальная ошибка В устаревших компиляторах флаги состояния ввода/вывода хранятся как целые, а не как объекты типа iostate. Имеются два способа получения информации о состоянии ввода/вывода. Во-первых, можно вызвать функцию rdstate(), являющуюся членом класса ios. Прототип этой функции: iostate rdstateO; Функция возвращает текущее состояние флагов ошибки. Как вы, вероятно, догадываетесь, глядя на приведенный выше список флагов, функция rdstate() возвращает флаг goodbit при отсутствии какой бы то ни было ошибки. В противном случае она возвращает флаг ошибки. Другим способом определения того, имела ли место ошибка, является ис-пользование одной или нескольких следующих функций - членов класса ios: bool bad () ; bool eof () ; bool fail () ; bool goodО; Функция eof() уже обсуждалась. Функция bad() возвращает истину, если установлен флаг badbit. Функция fail() возвращает истину, если установлен флаг failbit. Функция good() возвращает истину при отсутствии ошибок. В противном случае функции возвращают ложь. После появления ошибки может возникнуть необходимость сбросить это состояние перед тем, как продолжить выполнение программы. Для этого используется функция с!еаг(), являющаяся членом класса ios. Ниже приве-ден прототип этой функции: void clear(iostate фляга = ios::goodbit);
296 Самоучитель C++ Если параметр флаги равен goodbit (значение по умолчанию), то сбрасыва-ются флаги всех ошибок. В противном случае переменной флаги присваи-ваются значения тех флагов, которые вы хотите сбросить. Примеры ""' " '' :%j/J 1. В следующей программе иллюстрируется выполнение функции rdstateQ. Программа выводит на экран содержимое текстового файла. При наличии ошибки функция сообщает об этом с помощью функции checkstatus(). ^include <iostream> finclude <fstream> using namespace std; void checkstatus(ifstream Sin); int mainfint argc, char *argv[]) if(argc!=2) { cout " "Содержимое: <имя_файла>\п"; return 1; ifstream in(argv[l]); if(!in) I cout " "Файл открыть невозможной"; return 1; char с; while(in.get(c)) { cout " c; checkstatus(in); checkstatus (in); //контроль финального состояния in.close () ; : return 0; void checkstatus(ifstream sin) ios::iostate i; i = in.rdstate(); if(i & ios::eofbit) cout " "Достигнут EOF\n"; else if(i & ios::failbit) cout " "Нефатальная ошибка ввода/вывода\п";
Глава 9. Дополнительные возможности ввода/вывода в C++ 297 else i f ( i S ios::badbit) cout " "Фатальная ошибка ввода/вывода\n"; Эта программа всегда будет выводить сообщение по крайней мере об одной ошибке. После окончания цикла while последний вызов функции checkstatus(), как и ожидается, выдаст сообщение о достижении конца файла (символа EOF). 2. В следующей программе с помощью функции good() файл проверяется на наличие ошибки: : tinclude <iostream> #include <fstream> using namespace std; int main(int argc, char *argv[]) ' char ch; if(argc!=2) { cout " "Содержимое: <имя_файла>\п"; return 1; } -ifstream in(argv[l]); if (!in) { cout " "Файл открыть невозможной"; return 1; while(lin.eof0} { in.get(ch); //контроль ошибки if(!in.good() && lin.eof()) { cout " "Ошибка ввода/вывода ... прерывание работы\п" return 1; }cout " ch; }in.close(); return 0; Упражнения 1. Добавьте контроль ошибок в ваши ответы на вопросы предыдущего раздела.
298 Самоучитель C++ 9.7. Пользовательский ввод/вывод и файлы В предыдущей главе вы изучили перегрузку операторов ввода и вывода для создаваемых вами классов. При этом рассматривался только консольный ввод/вывод. Однако поскольку все потоки C++ одинаковы, то одинаково перегруженная, например, функция вывода, может использоваться без ка-ких-либо изменений для вывода как на экран, так и в файл. Это одна из наиболее важных и полезных возможностей ввода/вывода в C++. Как установлено в предыдущей главе, перегруженные функции вво-да/вывода так же, как и манипуляторы ввода/вывода могут использоваться с любым потоком. Если вы "жестко" зададите конкретный поток в функции ввода/вывода, область ее применения, несомненно, будет ограничена только этим потоком. Следует, по возможности, разрабатывать такие функции вво-да/вывода, чтобы они могли одинаково работать с любыми потоками. Примеры В следующей программе относительно класса coord перегружаются операто-ры " и ". Обратите внимание, что одни и те же оператор-функции можно использовать для вывода как на экран, так и в файл. tinclude <iostream> ttinclude <fstream> using namespace std; class coord { int x, y; public: coordfint i, int j) { x = i; у = j; } friend ostream £operator"(ostream &stream, coord ob); friend istream &operator"(istream &stream, coord Sob); i; ostream &operator" (ostream Sstream, coord ob) stream " ob.x " ' ' " ob.y " ' \ n ' ; return stream; istream soperator" (istream Sstream, coord Sob) { stream " ob.x " ob.y; return stream;
Глава 9. Дополнительные возможности ввода/вывода в C++ _ 299 int ma in () . coord ol(l, 2), o2(3, 4); of stream out ("test"); if (lout) { cout " "Файл открыть невозможной"; return 1; out " ol " o2; out. close (} ; ifstream in ("test"); if(!in) { cout " "Файл открыть невозможно \п" return 1; 1 coord o3(0, 0), o4(0, 0) ; in " o3 " o4; cout " o3 " o4; in. close () ; return 0; 2. Все манипуляторы ввода/вывода подходят и для файлового ввода/вывода. Например, в представленной ниже переработанной версии одной из про-грамм этой главы, тот манипулятор, который выводит информацию на эк-ран, используется и для ее записи в файл. ^include <iostream> ttinclude <fstream> ttinclude <iomanip> using namespace std; //Внимание: ostream &atn(ostream Sstream) { stream " "Внимание: "; return stream; }//Пожалуйста, не забудьте: ostream &note (ostream Sstream) stream " "Пожалуйста, не забудьте: ";
300 Самоучитель C++ return stream; }int main() { ofstream out("test"}; if(lout) { cout " "Файл открыть невозможной"; return 1; }//вывод на экран cout " atn " "Высокое напряжение \п"; cout " note " "Выключить свет\п"; //вывод в файл out " atn " "Высокое напряжение\п"; out " note " "Выключить свет\п"; out.close(); return 0; Упражнения 1. Попытайтесь адаптировать программы предыдущей главы для работы с фай-лами. Проверка усвоения материала главы ;-:- """l [ ^ N j Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы. 1. Создайте манипулятор для вывода трех символов табуляции и установки ширины поля равной 20. Продемонстрируйте работу манипулятора. 2. Создайте манипулятор для ввода, который должен считывать и отбрасы-вать все неалфавитные символы. При считывании первого алфавитного символа, манипулятор должен возвратить его во входной поток и закон-чить работу. Назовите манипулятор findalpha. 3. Напишите программу копирования текстового файла. При копировании измените регистр всех букв.
Глава 9. Дополнительные возможности ввода/вывода в C++ 301 4. Напишите программу, которая считывает текстовый файл, а затем сооб-щает, сколько раз каждая буква алфавита появляется в файле. 5. Если вы еще этого не сделали, добавьте в ваши решения упражнений 3 и 4 полный контроль ошибок. 6. Какая функция перемещает указатель считывания? Какая функция пере-мещает указатель записи? Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Ниже приведена переработанная версия класса inventory из предыдущей главы. Добавьте функции storeQ и retrieveQ. Затем создайте небольшой файл, содержащий несколько инвентарных записей. Далее, используя произвольный доступ, по номеру записи отобразите на экране информа-цию об одном из элементов. ttinclude <fstream> ttinclude <iostream> ttinclude <cstring> using namespace std; ttdefine SIZE 40 class inventory { char itemfSIZE]; //название предмета int onhand; //количество выданных на руки экземпляров double cost; //цена предмета public: inventory(char *i, int o, double c); strcpy(item, i); onhand = o; cost = c; void store(fstream sstream); void retrieve(fstream sstream); friend ostream &operator" (ostream sstream, inventory oV friend istream &operator"(istream sstream, inventory &ob) ; } ; ostream &operator" (ostream &stream, inventory ob) stream " ob.item " ": " " ob.onhand; stream " "на руках по цене ." " ob.cost " '\n';
302 Самоучитель C++ return stream; )istream "operator"{istreara &stream, inventory sob) { cout " "Введите название предмета: "; stream " ob.item; cout " "Введите число выданных экземпляров: "; stream " ob.onhand; cout " "Введите стоимость экземпляра: "; stream " ob.cost; return stream; ' 2. Необязательное задание. Создайте класс stack для хранения символов в файле, а не в массиве.
Глава 10 Виртуальные функции В этой главе рассматривается следующий важный аспект C++: виртуальные функции (virtual functions). Виртуальные функции важны потому, что они используются для поддержки динамического полиморфизма (run-time polymorphism). Как вы знаете, в C++ полиморфизм поддерживается двумя спо-собами. Во-первых, при компиляции он поддерживается посредством перегрузки операторов и функций. Во-вторых, во время выполнения про-граммы он поддерживается посредством виртуальных функций. Здесь вы узнаете, как с помощью динамического полиморфизма можно повысить гибкость программ. Основой виртуальных функций и динамического полиморфизма являются указатели на производные классы. Поэтому эта глава начинается с обсужде-ния указателей на производные классы. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Создайте манипулятор для вывода чисел в научной нотации с символом Е в верхнем регистре. 2. Напишите программу для копирования текстового файла. В процессе ко-пирования преобразуйте каждый символ табуляции в соответствующее число пробелов. 3. Напишите программу для поиска в текстовом файле слова, заданного в командной строке. После выполнения программы на экране должно поя-виться число, обозначающее, сколько раз данное слово найдено в файле. Для простоты считаем следующее: все, что с обеих сторон окружено про-белами, есть слово. 4. Напишите инструкцию, которая устанавливает указатель записи на 234-й байт в файле, связанном с потоком out. 5. Какие функции выдают информацию о состоянии системы ввода/вывода C++?
304 Самоучитель C++ 6. Приведите хотя бы одно преимущество от использования функций вво-да/вывода C++ по 'сравнению с соответствующими функциями системы ввода/вывода языка С. 10.1. Указатели на производные классы Хотя в главе 4 довольно обстоятельно обсуждались указатели C++, одна их специфическая особенность до сих пор опускалась, поскольку она тесно связана с виртуальными функциями. Этой особенностью является следую-щее: указатель, объявленный в качестве указателя на базовый класс, также может использоваться, как указатель на любой класс, производный от этого базового. В такой ситуации представленные ниже инструкции являются правильными: base *p; //указатель базового класса base base_ob; //объект базового класса derived derived_ob; //объект производного класса , //Естественно, что указатель р может указывать //на объект базового класса р = &base_ob; //указатель р для объекта базового класса //Кроме базового класса указатель р может указывать //на объект производного класса р = &derived_ob; //указатель р для объекта производного класса Как отмечено в комментариях, указатель базового класса может указывать на объект любого класса, производного от этого базового и при этом ошиб-ка несоответствия типов генерироваться не будет. Для указания на объект производного класса можно воспользоваться указа-телем базового класса, при этом доступ может быть обеспечен только к тем объектам производного класса, которые были унаследованы от базового. Объясняется это тем, что базовый указатель "знает" только о базовом классе и ничего не знает о новых членах, добавленных в производном классе. Указатель базового класса можно использовать для указания на объект про-изводного класса, но обратный порядок недействителен. Указатель произ-водного класса нельзя использовать для доступа к объектам базового класса. (Чтобы обойти это ограничение, можно использовать приведение типов, но на практике так действовать не рекомендуется.) И последнее: запомните, что арифметика указателей связана с типом дан-ных (т. е. классом), который задан при объявлении указателя. Таким обра-зом, если указатель базового класса указывает на объект производного класса, а затем инкрементируется, то он уже не будет указывать на следую-щий объект производного класса. Этот указатель будет указывать на сле-дующий объект базового класса. Помните об этом.
Глава 10. Виртуальные функции 305 Примеры 1. В этой короткой программе показано, как указатель базового класса может использоваться для доступа к объекту производного класса: //Демонстрация указателя на объект производного класса #include <iostreara> using namespace std; class base { int x; public: void setx(int i) { x = i; } int getx0 { return x; } class derived: public base { int y; public : void sety(int i) { у = i; } int getyf) (return y; } int mam base *p; //указатель базового класса base b_ob; //объект базового класса derived d_ob; //объект производного класса //использование указателя р //для доступа к объекту базового класса р = &b_ob; p->setx(10); //доступ к объекту базового класса cout " "Объект базового класса х: " " p->getx() " '\п'; //использование указателя р //для доступа к объекту производного класса р = &d_ob; //указывает на объект производного класса p->setx(99); //доступ к объекту производного класса //т. к. р нельзя использовать для установки у, //делаем это напрямую d_ob.sety (88) ; cout " "Объект производного класса х: " " p->getx ( ) " ' '; cout " "Объект производного класса у: " " d_ob,gety() " '\п' return 0;
306 Самоучитель C++ Нет смысла использовать указатели на объекты базового класса так, как показа-но в этом примере. Однако в следующем разделе вы увидите, почему для объек-тов производного класса столь важны указатели на объекты базового класса. 1. Попытайтесь запустить рассмотренную выше программу и поэксперименти-руйте с ней. Например, попробуйте, объявив указатель на производный класс, получить доступ к объекту базового класса. 10.2. Знакомство с виртуальными функциями Виртуальная функция (virtual function) является членом класса. Она объявля-ется внутри базового класса и переопределяется в производном классе. Для того, чтобы функция стала виртуальной, перед объявлением функции ста-вится ключевое слово virtual. Если класс, содержащий виртуальную функ-цию, наследуется, то в производном классе виртуальная функция переопределяется. По существу, виртуальная функция реализует идею "один интерфейс, множество методов", которая лежит в основе полиморфизма. Виртуальная функция внутри базового класса определяет вид интерфейса этой функции. Каждое переопределение виртуальной функции в производ-ном классе определяет ее реализацию, связанную со спецификой производ-ного класса. Таким образом, переопределение создает конкретный метод. При переопределении виртуальной функции в производном классе, ключе-вое слово virtual не требуется. Виртуальная функция может вызываться так же, как и любая другая функ-ция-член. Однако наиболее интересен вызов виртуальной функции через указатель, благодаря чему поддерживается динамический полиморфизм. Из предыдущего раздела вы знаете, что указатель базового класса можно ис-пользовать в качестве указателя на объект производного класса. Если указа-тель базового класса ссылается на объект производного класса, который содержит виртуальную функцию и для которого виртуальная функция вы-зывается через этот указатель, то компилятор определяет, какую версию виртуальной функции вызвать, основываясь при этом на типе объекта, на который ссылается указатель. При этом определение конкретной версии виртуальной функции имеет место не в процессе компиляции, а в процессе выполнения программы. Другими словами, тип объекта, на который ссыла-ется указатель, и определяет ту версию виртуальной функции, которая будет выполняться. Поэтому, если два или более различных класса являются производными от базового, содержащего виртуальную функцию, то, если указатель базового класса ссылается на разные объекты этих производных
Глава 10, Виртуальные функции 307 классов, выполняются различные версии виртуальной функции. Этот процесс является реализацией принципа динамического полиморфизма. Фактически, о классе, содержащем виртуальную функцию, говорят как о полиморфном классе (polymorphic class). 1. Рассмотрим короткий пример использования виртуальной функции: //Простой пример использования виртуальной функции #include <iostream> using namespace std; class base { public : int i; base {int x} { i = x; } virtual void func() { cout " "Выполнение функции func() базового класса: "; cout " i " '\n'; class derivedl : public base ( public : derivedKint x) : base(x) ( } void f unc ( ) { cout " "Выполнение функции func() класса derivedl: cout " i * i " '\n' ; } ь-class derived2: public base { public: derived2 (int x) : base(x) { } void f unc { } { cout " "Выполнение функции f unc ( ) класса derived2 : " cout " i + i " '\n' ; int main(} { base *p;
308 __ Самоучитель C++ base ob (10) ; derivedl d_obl(10); derived2 d_ob2(10); p = sob; p->func ( ) ; //функция f unc ( ) класса base p = &d_obl; p->func(); //функция func{) производного класса derivedl p = &d_ob2; p->func(); //функция f unc ( ) производного класса derived2 return 0; После выполнения программы на экране появится следующее: Выполнение функции func ( ) базового класса: 10 Выполнение функции f unc ( ) класса derivedl: 100 Выполнение функции func() класса derived2: 20 Переопределение виртуальной функции внутри производного класса может показаться похожим на перегрузку функций. Однако эти два процесса со-вершенно различны. Во-первых, перегружаемая функция должна отличаться типом и/или числом параметров, а переопределяемая виртуальная функция должна иметь точно такой же тип параметров, то же их число, и такой же тип возвращаемого значения. (На самом деле, если при переопределении виртуальной функции вы изменяете число или тип параметров, она просто становится перегружаемой функцией и ее виртуальная природа теряется.) Далее, виртуальная функция должна быть членом класса. Это не относится к перегружаемым функциям. Кроме этого, если деструкторы могут быть вирту-альными, то конструкторы нет. Чтобы подчеркнуть разницу между перегру-жаемыми функциями и переопределяемыми виртуальными функциями, для описания переопределения виртуальной функции используется термин под-мена (overriding). В рассмотренном примере создается три класса. В классе base определяется виртуальная функция func(). Затем этот класс наследуется двумя производ-ными классами: derivedl и derived!. Каждый из этих классов переопределяет функцию func() по-своему. Внутри функции main() указатель базового класса р поочередно ссылается на объекты типа base, derivedl и derived!. Первым указателю р присваивается адрес объекта ob (объекта типа base). При вызове функции func () через указатель р используется ее версия из класса base. Сле-дующим указателю р присваивается адрес объекта d_obl и функция func() вызывается снова. Поскольку версия вызываемой виртуальной функции оп-ределяется типом объекта, на который ссылается указатель, то вызывается та версия функции, которая переопределяется в классе derivedl. Наконец, ука-зателю р присваивается адрес объекта d_ob2, и снова вызывается функция func(). При этом выполняется та версия функции func(), которая определена внутри класса derived!.
Главами. Виртуальные функции _ 309 Ключевым для понимания предьщущего примера является тот факт, что, во-первых, тип адресуемого через указатель объекта определяет вызов той или иной версии подменяемой виртуальной функции, во-вторых, выбор конкрет-ной версии происходит уже в процессе выполнения программы. 2. Виртуальные функции имеют иерархический порядок наследования. Кроме того, если виртуальная функция не подменяется в производном классе, то используется версия функции, определенная в базовом классе. Например, ниже приведена слегка измененная версия предыдущей программы: //Иерархический порядок виртуальных функций #include <iostream> using namespace std; class base { public: i:n t*. i:; base (int x) { i = x; } virtual void £unc{) { cout " "Выполнение функции f u n c f ) базового класса: "; cout " i " '\n'; } } /* -class derivedl: public base { public: derivedl (int x) : base(x) { } void f unc ( ) { cout " "Выполнение функции func() класса derivedl: "; cout " i * i " *\n'; class derived2: public base { public : derived2(int x) : base(x) { } //в классе derived2 функция f unc ( ) не подменяется } /int rnainO { base *p; base ob(10) ; derivedl d_obl(10) ; derived2 d_ob2(10); p = sob; p->func(); //функция func ( ) базового класса
310 Самоучитель C++ р = &d_obl; p->func(); //функция func{) производного класса derivedl р = &d_ob2; p->func{); //функция func() базового класса return 0; После выполнения программы на экран выводится следующее: Выполнение функции func() базового класса: 10 Выполнение функции f unc ( ) класса derivedl: 100 Выполнение функции f unc { ) базового класса: 10 В этой программе в классе derivedl функция func() не подменяется. Когда указателю р присваивается адрес объекта d_ob2 и вызывается функция func(), используется версия функции из класса base, поскольку она следующая в ие-рархии классов. Обычно, если виртуальная функция не переопределена в производном классе, используется ее версия из базового класса. 3. В следующем примере показано, как случайные события во время работы программы влияют на вызываемую версию виртуальной функции. Программа выбирает между объектами d_obl и d_ob2 на основе значений, возвращаемых стандартным генератором случайных чисел rand(). Запомните, выбор кон-кретной версии функции func() происходит во время работы программы. (Действительно, при компиляции этот выбор сделать невозможно, поскольку он основан на значениях, которые можно получить только во время работы программы.) /* В этом примере показана работа виртуальной функции при наличии случайных событий во время выполнения программы. V# include <iostream> ^include <cstdlib> using namespace std; class base { public: int i ; base (int x} { i = x; } virtual void func() { cout " "Выполнение функции func() базового класса: "; cout " i " '\n' ; class derivedl: public base { public: derivedl (int x) : base(x) { )
Глава 10. Виртуальные функции 311 void fume ( ) cout " "Выполнение функции func() класса derivedl: "; cout " i * i " '\n'; class derived2: public base { public: derived2(int x) : base(x) { } void func ( ) cout " "Вьшолнение функции func() класса derived2: "; cout " i + i " '\n' ; int main() base *p; derivedl d_obl(10); derived2 d_ob2(10); int i, j; for(i=0; j = rand(); if ( ( j % 2 )> p = &d_obl; else p = &d_ob2; p->func {) ; return 0; //если число нечетное //использовать объект d_obl //если число четное //использовать объект d_ob2 //вызов подходящей версии функции 4. Теперь более реальный пример использования виртуальной функции. В этой программе создается исходный базовый класс area, в котором сохраняются две размерности фигуры. В нем также объявляется виртуальная функция getareaQ, которая, при ее подмене в производном классе, возвращает пло-щадь фигуры, вид которой задается в производном классе. В этом случае оп-ределение функции getarea() внутри базового класса задает интерфейс. Конкретная реализация остается тем классам, которые наследуют класс area. В этом примере рассчитывается площадь треугольника и прямоугольника. //Использование виртуальной функции для определения интерфейса ^include <iostream> using namespace std;
312 Самоучитель C++ class area { double diml, dim2; //размеры фигуры public: void setarea(double dl, double d2) diml = dl; dim2 = d2; void getdim(double sdl, double &d2) dl = diml; d2 = dim2; virtual double getareaO cout " "Вам необходимо подменить эту функцикЛп"; return 0.0; Ь-class rectangle: public area { public: double getareaO double dl, d2; getdim{dl, d2); return dl * d2; } }; class triangle: public area { public: double getarea() double dl, d2; getdim(dl, d2); return 0.5 * dl * d2; int mainf) ( area *p; rectangle r; triangle t; r.setarea{3.3, 4.5) t.setarea(4.0, 5.0)
Глава 10. Виртуальные функции 313 Р - & г ; cout " "Площадь прямоугольника: " " p->getarea() " '\п'; р = fit; cout " "Площадь треугольника: " " p->getarea() " '\п'; return 0; Обратите внимание, что определение getarea() внутри класса area является только "заглушкой" и, в действительности, не выполняет никаких действий. Поскольку класс area не связан с фигурой конкретного типа, то нет значи-мого определения, которое можно дать функции getarea() внутри класса area. При этом, для того чтобы нести полезную нагрузку, функция getarea() долж-на быть переопределена в производном классе. В следующем разделе вы уз-наете об этом подробнее. Напишите программу создания базового класса num. В этом классе должно храниться целое и определяться виртуальная функция shownum(). Создайте два производных класса outhex и outoct, которые наследуют класс num. Функция shownum() должна быть переопределена в производных классах так, чтобы осуществлять вывод на экран значений, в шестнадцатеричной и вось-меричной системах счисления соответственно. 2. Напишите программу, в которой базовый класс dist используется для хране-ния в переменной типа double расстояния между двумя точками. В классе dist создайте виртуальную функцию trav_time(), которая выводит на экран время, необходимое для прохождения этого расстояния с учетом того, что расстоя-ние задано в милях, а скорость равна 60 миль в час. В производном классе metric переопределите функцию trav_time() так, чтобы она выводила на эк-ран время, необходимое для прохождения этого расстояния, считая теперь, что расстояние задано в километрах, а скорость равна 100 километров в час. 10.3. Дополнительные сведения о виртуальных функциях Как показано в примере 4 предыдущего раздела, иногда, когда виртуальная функция объявляется в базовом классе, она не выполняет никаких значи-мых действий. Это вполне обычная ситуация, поскольку часто в базовом классе законченный тип данных не определяется. Вместо этого в нем просто содержится базовый набор функций-членов и переменных, для которых в производном классе определяется все недостающее. Когда в виртуальной
314 Самоучитель C++ функции базового класса отсутствует значимое действие, в любом классе, производном от этого базового, такая функция обязательно должна быть пе-реопределена. Для реализации этого положения в C++ поддерживаются так называемые чистые виртуальные функции (pure virtual function). Чистые виртуальные функции не определяются в базовом классе. Туда включаются только прототипы этих функций. Для чистой виртуальной функции используется такая основная форма: virtual тип ямя^функцкя(списох_параметров) = 0; Ключевой частью этого объявления является приравнивание функции нулю. Это сообщает компилятору, что в базовом классе не существует тела функ-ции. Если функция задается как чистая виртуальная, это предполагает, что она обязательно должна подменяться в каждом производном классе. Если этого нет, то при компиляции возникнет ошибка. Таким образом, создание чистых виртуальных функций - это путь, гарантирующий, что производные классы обеспечат их переопределение. Если класс содержит хотя бы одну чистую виртуальную функцию, то о нем говорят как об абстрактном классе (abstract class). Поскольку в абстрактном классе содержится, по крайней мере, одна функция, у которой отсутствует тело функции, технически такой класс неполон, и ни одного объекта этого класса создать нельзя. Таким образом, абстрактные классы могут быть толь-ко наследуемыми. Они никогда не бывают изолированными. Важно пони-мать, однако, что по-прежнему можно создавать указатели абстрактного класса, благодаря которым достигается динамический полиморфизм. (Также допускаются и ссылки на абстрактный класс.) Если виртуальная функция наследуется, то это соответствует ее виртуальной природе. Это означает, что если производный класс используется в качестве базового для другого производного класса, то виртуальная функция может подменяться в последнем производном классе (так же, как и в первом про-изводном классе). Например, если базовый класс В содержит виртуальную функцию f(), и класс D1 наследует класс В, а класс D2 наследует класс D1, тогда функция f() может подменяться как в классе D1, так и в классе D2. Примеры 1. Здесь представлена несколько усовершенствованная версия программы, по-казанной в примере 4 предыдущего раздела. В этой версии программы в ба-зовом классе area функция getarea() объявляется как чистая виртуальная функция. //Создание абстрактного класса ^include <iostream> using namespace std;
Глава 10. Виртуальные функции 375 class area ( double diml, dim2; //размеры фигуры public: void setarea(double dl, double d2) diml = dl; dim2 = d2; void getdim(double &dl, double &d2) f dl = diml; d2 = dim2; virtual double getareaO = 0; /V чистая виртуальная функция class rectangle: public area { public: double getareaO double dl, d2; getdim(dl, d2); return dl * d2; ) }; class triangle: public area ( public: double getareaO { double dl, d2; -getdim (dl, d2); return 0.5 * dl * d2; int main{) ( area *p; rectangle r; triangle t; r. setarea (3.3, 4.5) ; t. setarea (4.0, 5.0); p = &r; cout " "Площадь прямоугольника: " " p->getarea() " '\n';
31f> _ Самоучитель C++ p = &t; cout " "Площадь треугольника: " " p->getarea() " '\n'; return 0; Теперь то, что функция getareaQ является чистой виртуальной, гарантирует ее обязательную подмену в каждом производном классе. 2. В следующей программе показано, как при наследовании сохраняется вирту-альная природа функции: /* Виртуальная функция при наследовании сохраняет свою виртуальную природу */^include <iostreara> using namespace std; class base { public: virtual void func(} { cout " "Выполнение функции f unc { ) базового класса \п"; class derivedl: public base { public: void f unc ( ) { cout " "Выполнение функции func() класса derivedl \n"; //Класс derivedl наследуется классом derived2 class derived2: public derivedl { public: void f unc ( ) { cout " " Выполнение функции func() класса derived2\n"; int main ( } I base *p; base ob; derivedl d_obl; derived2 d_ob2;
Глава 10. Виртуальные функции 317 р = sob; p->func(); //функция func() базового класса р = &d_obl; p->func(); //функция func() производного класса derivedl р = &d_ob2; p->func(); //функция func() производного класса derived2 return 0; В этой программе виртуальная функция func() сначала наследуется классом derivedl, в котором она подменяется. Далее класс derivedl наследуется классом derived2. В классе derived! функция funcQ снова подменяется. Поскольку виртуальные функции являются иерархическими, то если бы в классе derivedl функция funcQ не подменялась, при доступе к объекту d_ob2 использовалась бы переопределенная в классе derivedl версия функции func(). Если бы функция func() не подменялась ни в классе derivedl, ни в классе derivedl, то все ссылки на функцию func() относились бы к ее опреде-лению в классе base. 'правлеeнmиifяlj 1. Проведите эксперимент с двумя программами из предыдущих примеров. По-пытайтесь создать объект, используя класс area из примера 1, и проанализи-руйте сообщение об ошибке. В примере 2 попытайтесь удалить переопреде-ление функции funcQ внутри класса derivedl. Убедитесь, что тогда действи-тельно будет использоваться та версия функции func(), переопределение ко-торой находится в классе derivedl. 2. Почему нельзя создать объект абстрактного класса? 3. Что произойдет в примере 2 при удалении переопределения функции func() из класса derivedl? Будет ли при этом программа компилироваться и запус-каться? Если да, то почему? 10.4. Применение полиморфизма Теперь, когда вы знаете, как использовать виртуальные функции для реали-зации динамического полиморфизма, самое время рассмотреть, зачем это нужно. Как уже много раз в этой книге отмечалось, полиморфизм является процессом, благодаря которому общий интерфейс применяется к двум или более схожим (но технически разным) ситуациям, т. е. реализуется филосо-фия "один интерфейс, множество методов". Полиморфизм важен потому,
318 Самоучитель C++ что может сильно упростить сложные системы. Один хорошо определенный интерфейс годится для доступа к некоторому числу разных, но связанных по смыслу действий, и таким образом устраняется искусственная сложность. Уточним: полиморфизм позволяет сделать очевидной логическую близость схожих действий; поэтому программа становится легче для понимания и сопровождения. Если связанные действия реализуются через общий интер-фейс, вам нужно гораздо меньше помнить. Имеются два термина, которые часто ассоциируются с объектно-ориентиро-ванным программированием вообще и с C++ в частности. Этими терминами являются раннее связывание (early binding) и позднее связывание (late binding). Важно понимать, что означают указанные термины. Раннее связывание отно-сится к событиям, о которых можно узнать в процессе компиляции. Особенно это касается вызовов функций, которые настраиваются при компиляции. Функции раннего связывания - это "нормальные" функции, перегружаемые функции, невиртуальные функции-члены и дружественные функции. При компиляции функций этих типов известна вся необходимая для их вызова адресная информация. Главным преимуществом раннего связывания (и дово-дом в пользу его широкого использования) является то, что оно обеспечивает высокое быстродействие программ. Определение нужной версии вызываемой функции во время компиляции программы - это самый быстрый метод вы-зова функций. Главный недостаток - потеря гибкости. Позднее связывание относится к событиям, которые происходят в процессе выполнения программы. Вызов функции позднего связывания - это вызов, при котором адрес вызываемой функции до запуска программы неизвестен. В C++ виртуальная функция является объектом позднего связывания. Если доступ к виртуальной функции осуществляется через указатель базового класса, то в процессе работы программа должна определить, на какой тип объекта он ссылается, а затем выбрать, какую версию подменяемой функ-ции выполнить. Главным преимуществом позднего связывания является гибкость во время работы программы. Ваша программа может легко реаги-ровать на случайные события. Его основным недостатком является то, что требуется больше действий для вызова функции. Это обычно делает такие вызовы медленнее, чем вызовы функций раннего связывания. В зависимости от нужной эффективности, следует принимать решение, ко-гда лучше использовать раннее связывание, а когда - позднее. Ниже представлена программа, которая иллюстрирует принцип "один ин-терфейс, множество методов". В ней определен исходный базовый класс для связанного списка целых. Интерфейс списка определяется с помощью чис-тых виртуальных функций storeQ и retrieve(). Для хранения значения в списке вызывается функция store(). Для выборки значения из списка вызы-
Глава 10. Виртуальные функции _ 319 вается функция retrieve(). В базовом классе list для выполнения этих дейст-вий никакого встроенного метода не задается. Вместо этого в каждом произ-водном классе явно определяется, какой тип списка " будет поддерживаться. В программе реализованы списки двух типов; очередь и стек. Хотя способы работы с этими двумя списками совершенно различны, для доступа к каж-дому из них применяется один и тот же интерфейс. Вам следует тщательно изучить эту программу. //Демонстрация виртуальных функций ^include <iostream> ^include <cstdlib> #include <cctype> using namespace std; class list ( public : list *head; //указатель на начало списка list *tail; //указатель на конец списка list *next; //указатель на следующий элемент списка int num; //число для хранения list () { head = tail = next = NULL; } virtual void store (int i) = 0; virtual int retrieve () = 0; //Создание списка типа очередь class queue: public list { public: void store (int i) ; int retrieve ( ) ; >; void queue: : store (int i) { list *item; item = new queue; if (! item) { cout " "Ошибка выделения памяти\п exit(l) ; 1item->num = i; //добавление элемента в конец списка if (tail) tail->next = item; tail = item; item->next = NULL; if(!head) head = tail;
320 _ __ _ Самоучитель C++ int queue: : retrieve () ) int i; list *p; if {! head) { cout " "Список пуст\п"; return 0; //удаление элемента из начала списка i = head->num; р = head; head = head->next; delete p; return i; //Создание списка типа стек class stack: public list { public: void store (int i); int retrieve () ; void stack: :store (int i) list *item; item = new stack; if ( ! item) i cout " "Ошибка выделения памяти\п"; exit (1) ; }item->num = i; //добавление элемента в начало списка if (head) item->next = head; head = item; if (Itail) tail = head; int stack : : retrieve ( ) { int i ; list *p; if (! head) { cout " "Список пустХп";
Глава 10. Виртуальные функции 321 return 0; 1//удаление элемента из начала списка i = head->num; р = head; head = head->next; delete p; return i; } int main() { list *p; //демонстрация очереди queue q_ob; p = &q_ob; //указывает на очередь p->store(1); p->store(2); p->store(3); coot " "Очередь: "; cout " p->retrieve(); cout " p->retrieve(); cout " p->retrieve(); cout " '\nr; //демонстрация стека stack s_ob; p = Ss_ob; //указывает на стек p->store(l); p~>store{2); p->store (3); cout " "Стек: "; cout " p->retrieve(); cout " p->retrieve(); cout " p->retrieve (); cout " '\n'; return 0; 2. Функция main() в программе со списками только иллюстрирует работу клас-сов. Однако для изучения динамического полиморфизма попробуйте исполь-зовать в предыдущей программе следующую функцию main():
322 _ Самоучитель C++ int main () { list *p; stack s_ob; queue q_ob; char ch; int i; for(i=0; i cout " "Стек или Очередь? (С/О): "; cin " ch; ch = tolower(ch); if(ch=='o') p = &q_ob; else p = ss_ob; p->store (i) ; cout " "Введите К для завершения работы\п"; for(;;) { cout " "Извлечь элемент из Стека или Очереди9 fr-/ry : " cin " ch; ch = tolower (ch) ; if (ch=='Kp ) break; if{ch=='o') p = &q_ob; else p = &s_ob; cout " p->reteieve ( ) " '\n'; } cout " '\n'; return 0; Функция main() показывает, как случайные события, возникающие при выполнении программы, могут быть легко обработаны, если использовать виртуальные функции и динамический полиморфизм. В программе выполня-ется цикл for от 0 до 9. В течение каждой итерации предлагается выбор типа списка - стек или очередь. В соответствии с ответом, базовый указатель р устанавливается на выбранный объект (очередь или стек), и это значение запоминается. После завершения цикла начинается другой цикл, в кото-ром предлагается выбрать список для извлечения запомненного значения. В соответствии с ответом пользователя выбирается число из указанного списка. Несмотря на то, что этот пример достаточно прост, он позволяет понять, как полиморфизм может упростить программу, которой необходимо реагировать на случайные события. Например, операционная система Windows взаимо-действует с программой посредством сообщений. Эти сообщения генериру-ются как случайные, и ваша программа должна как-то реагировать на каждое
Глава 10. Виртуальные функции 323 получаемое сообщение. Одним из возможных способов обработки этих со-общений и является использование чистых виртуальных функций. Упражнеенниияя] 1. Добавьте список другого типа к программе из примера 1. Эта версия должна поддерживать отсортированный (в порядке возрастания) список. Назовите список sorted. 2. Обдумайте случаи, в которых следует использовать динамический полимор-физм, чтобы упростить решение разного рода проблем. Проверка усвоения материала главк Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы. 1. Что такое виртуальная функция? 2. Какие функции не могут быть виртуальными? 3. Как виртуальные функции помогают реализовывать динамический поли-морфизм? Ответьте подробно. 4. Что такое чистая виртуальная функция? 5. Что такое абстрактный класс? Что такое полиморфный класс? 6. Правилен ли следующий фрагмент? Если нет, то почему? class base { public: virtual int f(int a) = 0; class derived: public base { public: int f (int a, int b) ( return a*b; } 7. Наследуется ли виртуальность? 8. Поэкспериментируйте с виртуальными функциями. Это важное понятие и необходимо освоить технические приемы, связанные с ним.
324 Самоучитель C++ Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Расширьте пример со списком, пример 1 из раздела 4 так, чтобы в нем перегружались операторы + и -. Используйте оператор + для внесения элемента в список, а оператор - для выборки элемента из списка. 2. Что отличает виртуальные функции от перегружаемых функций? 3. Вернитесь к представленным ранее в книге примерам перегрузки функ-ций. Определите, какие из этих функций можно превратить в виртуаль-ные. Кроме этого, подумайте, как с помощью виртуальных функций решить ваши собственные программные задачи.
Глава 11 Шаблоны и обработка исключительных ситуаций В этой главе вы познакомитесь с двумя важнейшими характеристиками C++ верхнего уровня: шаблонами (templates) и обработкой исключительных ситуа-ций (exception handling). Ни та, ни другая характеристики не входили в изна-чальную спецификацию C++, а были добавлены туда несколько лет назад и определены в стандарте Standard C++. Эти характеристики поддерживаются всеми современными компиляторами и позволяют достичь двух наиболее заманчивых целей программирования: создания многократно используемых и отказоустойчивых программ. С помощью шаблонов можно создавать родовые функции (generic functions) и родовые классы (generic classes). В родовой функции или классе тип дан-ных, с которыми функция или класс работают, задается в качестве парамет-ра. Это позволяет одну и ту же функцию или класс использовать с несколь-кими различными типами данных без необходимости программировать но-вую версию функции или класса для каждого конкретного типа данных. Таким образом шаблоны дают возможность создавать многократно исполь-зуемые программы. В данной главе рассказывается как о родовых функциях, так и о родовых классах. Система обработки исключительных ситуаций встроена в C++ и позволяет работать с ошибками, которые возникают во время работы программы, зара-нее предусмотренным и управляемым образом. С помощью системы обработ-ки исключительных ситуаций C++ ваша программа при возникновении ошибки может автоматически вызвать процедуру ее обработки. Принципи-альное преимущество обработки исключительных ситуаций состоит в том, что она автоматически в зависимости от ситуации запускает одну из множества подпрограмм обработки ошибок, которые предварительно "вручную" встраи-ваются в основную программу. Должным образом запрограммированная об-работка исключительных ситуаций помогает создавать действительно отка-зоустойчивые программы. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения.
326 Самоучитель C++ 1. Что такое виртуальная функция? 2. Что такое чистая виртуальная функция? Если в объявлении класса имеет-ся чистая виртуальная функция, как называется такой класс и какие ог-раничения налагаются на его использование? 3. Динамический полиморфизм достигается посредством использования функций и указателей класса. (Вставьте про-пущенные слова.) 4. Если при наличии иерархии классов в производном классе опущена пе-регрузка (не чистой) виртуальной функции, что происходит, когда объект этого производного класса вызывает такую функцию? 5. В чем основное преимущество динамического полиморфизма? Каков его потенциальный недостаток? 11.1. Родовые функции Родовая функция определяет базовый набор операций, которые будут при-меняться к разным типам данных. Родовая функция оперирует с тем типом данных, который она получает в качестве параметра. С помощью этого ме-ханизма одна и та же процедура может применяться к самым разным дан-ным. Как известно, многие алгоритмы логически одинаковы, независимо от того, для обработки каких типов данных они предназначены. Например, алгоритм быстрой сортировки одинаков как для массивов целых, так и для массивов действительных чисел. Это именно тот случай, когда сортируемые данные отличаются только по типам. Благодаря созданию родовой функции вы можете независимо от типа данных определить суть алгоритма. После того как это сделано, компилятор автоматически генерирует правильный код для фактически используемого при выполнении функции типа данных. По существу, при создании родовой функции вы создаете функцию, которая может автоматически перегружаться сама. Родовая функция создается с помощью ключевого слова template. Обычное значение этого слова (т. е. шаблон) точно отражает его назначение в C++. Оно предназначено для создания шаблона (или каркаса), который описыва-ет то, что будет делать функция, при этом компилятору остается дополнить каркас необходимыми деталями. Ниже представлена типовая форма опреде-ления функции-шаблона: template <class Фтип> возвр__значвние имя_функции(слисок_парамвтров) { II тело функции Здесь вместо Фтип указывается тип используемых функцией данных. Это имя можно указывать внутри определения функции. Однако это всего лишь фиктивное имя, которое компилятор автоматически заменит именем реаль-ного типа данных при создании конкретной версии функции.
Глава 1 /. Шаблоны и обработка исключительных ситуаций 327 Хотя традиционно для задания родового типа данных в объявлении шаблона указывается ключевое слово class, вы также можете использовать ключевое слово typename. Примеры ^_ 1. В следующей программе создается родовая функция, которая меняет местами значения двух переменных, передаваемых ей в качестве параметров. По-скольку в своей основе процесс обмена двух значений не зависит от типа пе-ременных, этот процесс удачно реализуется с помощью родовой функции. //Пример родовой функции или шаблона ^include <iostream> using namespace std; //Это функция-шаблон template <class X> void swapargs(X &a, X &b) { X temp; temp = a; a = b; b = temp; I int main() { int i = 10, j = 20; float x = 10.1, у = 23.3; cout " "Исходные значения i, j равны: " " i " ' ' " j " endl; cout " "Исходные значения x, у равны: " " x " ' ' " у " endl; swapargs (i, j); //обмен целых swapargs (x, y) ; //обмен действительных cout " "Новые значения i, j равны: " " i " ' ' " j " endl; cout " "Новые значения x, у равны: " " x " ' ' " у " endl; return 0; 1 ' Ключевое слово template используется для определения родовой функции. Строка: template <class X> void swapargs(X &а, X &b) сообщает компилятору две вещи: во-первых, создается шаблон, и, во-вторых, начинается определение родовой функции. Здесь X - это родовой тип дан-ных, используемый в качестве фиктивного имени. После строки с ключевым
328 _ ; _ _ Самоучитель C++ словом template функция swapargs() объявляется с именем X в качестве типа данных обмениваемых значений. В функции mainO функция swapargs() вы-зывается с двумя разными типами данных: целыми и действительными. По-скольку функция swapargs() - это родовая функция, компилятор автомати-чески создает две ее версии: одну - для обмена целых значений, другую для обмена действительных значений. Теперь попытайтесь скомпилировать про-грамму. Имеются и другие термины, которые можно встретить при описании шабло-нов в литературе по C++. Во-первых, родовая функция (то есть функция, в определении которой имеется ключевое слово template) также называется функция-шаблон (template function). Когда компилятор создает конкретную версию этой функции, говорят, что он создал порожденную функцию (generated function). Процесс генерации порожденной функции называют соз-данием экземпляра (instantiating) функции. Другими словами, порожденная функция - это конкретный экземпляр функции -шаблона. 2. Ключевое слово template в определении родовой функции не обязательно должно быть в той же строке, что и имя функции. Например, ниже приведен еще один вполне обычный формат определения функции swapargs(): template <class X> void swapargs (X &a, X &b) { X temp; temp = a; a = b; b = temp; При использовании такого формата важно понимать, что никаких других ин-струкций между инструкцией template и началом определения родовой функ-ции быть не может. Например, следующий фрагмент программы компилиро-ваться не будет: //Этот фрагмент компилироваться не будет template <class X> int i; //это неправильно void swapargs (X &а, X &Ь) { X temp; temp = а; а = b; b = temp; Как указано в комментариях, инструкция с ключевым словом template долж-на находиться сразу перед определением функции.
Глава 1 1. Шаблоны и обработка исключительных ситуаций _ 329 3. Как уже упоминалось, для задания родового типа данных в определении шаблона вместо ключевого слова class можно указывать ключевое слово typename. Например, ниже приведено еще одно объявление функции swapargsQ: //Использование ключевого слова typename template <typename X> void swapargs (X &a, X Sb) I X temp; temp = a; a = b; b = temp; Ключевое слово typename можно также указывать для задания неизвестного типа данных внутри шаблона, но такое его использование выходит за рамки данной книги, 4. С помощью инструкции template можно определить более одного родового типа данных, отделяя их друг от друга запятыми. Например, в данной про-грамме создается родовая функция, в которой имеются два родовых типа данных: #include <iostream> using namespace std; template <class typel, class type2> void myfunc (typel x, type2 y) cout " x " ' ' " у " endl; int main() { myfunc (10, "hi") ; myfunc(0.23, 10L) ; return 0; }В данном примере при генерации конкретных экземпляров функции myfunc(), фиктивные имена типов typel и type2 заменяются компилятором на типы данных int и char* или double и long соответственно. Когда вы создаете родовую функцию, то по существу предписываете компи-лятору генерировать столько разных версий этой функции, сколько нужно для обработки всех способов вызова этой функции в вашей программе.
330 Самоучитель C++ 5. Родовые функции похожи на перегруженные функции за исключением того, что они более ограничены по своим возможностям. При перегрузке функции внутри ее тела можно выполнять совершенно разные действия. С другой сто-роны, родовая функция должка выполнять одни и те же базовые действия для всех своих версий. Например, следующие перегруженные функции нельзя заменить на родовую функцию, поскольку они делают не одно и то же. void outdataCint i) j cout " i; } void outdata(double d) { cout " setprecision(lO) " setfill ('#'); cout " d; cout " setprecision(6) " setfill (' '); } 6. Несмотря на то, что функция-шаблон при необходимости перегружается са-ма, ее также можно перегрузить явно. Если вы сами перегружаете родовую функцию, то перегруженная функция подменяет (или "скрывает") родовую функцию, которую бы создал компилятор для этой конкретной версии. Рас-смотрим такой вариант примера 1: //Подмена функции-шаблона ttinclude <iostream> using namespace std; template <class X> void swapargs(X &a, X &b) { X temp; temp = a; a = b; b = temp; }//Здесь переопределяется родовая версия функции swapargs() void swapargs(int a, int b) { cout " "это печатается внутри функции swapargs(int, int)\n"; } int main() { int i = 10, j = 20; float x = ЮЛ, у = 23.3; cout " "Исходные значения i, j равны: " " i " ' ' " j " endl; cout " "Исходные значения х, у равны: " " x " ' ' " у " endl;
Глава 11. Шаблоны и обработка исключительных ситуаций 337 swapargs(i, j ) ; //вызов явно перегруженной функции swapargs() swapargs(х, у) ; //обмен действительными числами cout " "Новые значения i, j равны: " " i " ' ' " j " endl; cout " "Новые значения х, у равны: " " х " ' ' " у " endl; return 0; Как отмечено в комментариях, при вызове функции swapargs(i, j) вызывается определенная в программе явно перегруженная версия функции swapargs() Таким образом, компилятор не генерирует этой версии родовой функции swapargs(), поскольку родовая функция подменяется явно перегруженной функцией. Ручная перегрузка шаблона, как показано в данном примере, позволяет из-менить версию родовой функции так, чтобы приспособить ее к конкретной ситуации. Однако в большинстве случаев, если вам нужно несколько разных версий функции для разных типов данных, вместо шаблонов лучше исполь-зовать перегруженные функции. УпраЛнеенния] 1. Если этого еще не сделано, попытайтесь откомпилировать каждый из преды-дущих примеров. 2. Напишите родовую функцию min(), возвращающую меньший из двух своих аргументов. Например, версия функции min(3, 4) должна возвратить 3, а вер-сия min('c', 'a') - а. Продемонстрируйте работу функции с помощью про-граммы. 3. Прекрасным кандидатом на функцию -шаблон является функция fmd(). Эта функция ищет объект в массиве. Она возвращает либо индекс найденного объекта (если его удалось найти), либо - 1, если заданный объект не найден. Ниже представлен прототип конкретной версии функции flndQ. Переделайте функцию find() в родовую функцию и проверьте ваше решение в программе. (Параметр size задает количество элементов массива.) int find(int object, int *list, int size) 4. Объясните своими словами, зачем нужны родовые функции и как они могут упростить исходный код ваших программ.
332 __ Самоучитель C++ 11.2. Родовые классы В дополнение к родовым функциям можно определить и родовые классы. При этом создается класс, в котором определены все необходимые алгорит-мы, а фактические типы обрабатываемых данных задаются в качестве пара-метров позже, при создании объектов этого класса. Родовые классы полезны, когда класс содержит общую логику работы. На-пример, алгоритм, который реализует очередь целых, будет также работать и с очередью символов. Кроме того, механизм, который реализует связанный список почтовых адресов, будет также поддерживать связанный список за-пасных частей к автомобилям. С помощью родового класса можно создать класс, реализующий очередь, связанный список и т. д. для любых типов данных. Компилятор будет автоматически генерировать правильный тип объекта на основе типа, заданного при создании объекта. Ниже представлена основная форма объявления родового класса: template <class ФУИП> class имя класса { Здесь Фтип - это фиктивное имя типа, который будет задан при создании экземпляра класса. При необходимости можно определить более одного ро-дового типа данных, разделяя их запятыми. После создания родового класса с помощью представленной ниже формы можно создать конкретный экземпляр этого класса: хмя_класса <тяп> объект; Здесь тип - это имя типа данных, с которым будет оперировать класс. Функции-члены родового класса сами автоматически становятся родовыми. Для них не обязательно явно задавать ключевое слово template. Как вы увидите в главе 14, в C++ имеется встроенная библиотека классов-шаблонов, которая называется библиотекой стандартных шаблонов (Standard Template Library, STL). Эта библиотека предоставляет родовые версии клас-сов для наиболее часто используемых алгоритмов и структур данных. Чтобы научиться пользоваться библиотекой" стандартных шаблонов с максимальной эффективностью, вам необходимо иметь твердые знания по классам-шаблонам и их синтаксису. Примеры 1. В следующей программе создается очень простой родовой класс, реализую-щий односвязный список. Затем демонстрируются возможности такого клас-са путем создания связанного списка для хранения символов.
Глава 1 1. Шаблоны и обработка исключительных ситуаций _ 333 //Простой родовой связанный список # include <iostream> using namespace std; template <class data_t> class list { data_t data; list *next; public: list (data_t d) ; void add (list *node) { node->next = this; next = 0; } list *getnext() { return next; } data_t getdataf) { return data; } template <class data_t> list<data_t>: : list (data_t d) i data = d; next = 0; ) int main() { list<char> start { 'a' ) ; list<char> *p, *last; int i; //создание списка last = sstart; for(i=l; i<26; i++} { p = new list<char> ('a1 + i) ; p->add(last) ; last = p; }//вывод списка p = Sstart; while (p) { cout " p->getdata {) ; p = p->getnext () ; }return 0; Как видите, объявление родового класса похоже на объявление родовой функ-ции. Тип данных, хранящихся в списке, становится родовым в объявлении класса. Но он не проявляется, пока не объявлен объект, который и задает реальный тип данных. В данном примере объекты и указатели создаются внутри функции main (), где указывается, что типом хранящихся в списке дан-ных является тип char. Обратите особое внимание на следующее объявление: list<char> start ( ' a ' } ;
334 _ Самоучитель C++ Отметьте, что необходимый тип данных задается между угловыми скобками. Наберите и выполните эту программу. В ней создается связанный список с символами алфавита, который затем выводится на экран. Путем простого изменения типа данных, который указывается при создании объектов, можно изменить тип данных, хранящихся в списке. Например, с помощью следую-щего объявления можно создать другой объект, где можно было бы хранить целые: list<int> int_start (1) ; Можно также использовать список list для хранения создаваемых вами типов данных. Например, для хранения адресной информации можно воспользо-ваться следующей структурой: struct addr { char name [40] ; char street [40] ; char city [30]; char state[3] ; char zip[12] ; Теперь, чтобы с помощью списка list хранить объекты типа addr, используйте такое объявление (предположим, что объект structvar содержит правильную структуру addr): list<addr> obj (structvar) ; 2. Ниже представлен другой пример родового класса. Это переработанный класс stack, впервые приведенный в главе 1. Однако в данном случае класс stack реализован как шаблон. Следовательно, в нем можно хранить объекты любого типа. В представленном ниже примере создаются стек символов и стек действительных чисел: //Здесь показан родовой стек ^include <iostream> using namespace std; #define SIZE 10 //Создание родового класса stack template <class StackType> class stack { StackType stckfSIZE]; //содержит стек int tos; //индекс вершины стека public: void init() { tos = 0 ; } //инициализация стека void push (StackType ch) ; //помещает объект в стек StackType рор(); //выталкивает объект из стека
Глава 7 1. Шаблоны и обработка исключительных ситуаций _ 335 //Помещение объекта в стек template <class StackType> void stack<StackType>: :push(StackType ob) { if (toa- SIZE) { cout " "Стек полон"; return; } stck[tos] = ob; tos++; //Выталкивание объекта из стека template <class StackType> StackType stack<StackType>: :pop () { if (tos==0) { cout " "Стек пуст"; return 0; //возврат нуля при пустом стеке tos - ; return stckftos] ; int main ( ) < //Демонстрация символьных стеков stack<char> si, s2; //создание двух стеков int i ; //инициализация стеков s2.init(); si.push ('a') s2,push{'x') si.push Cb') s2.push('y1) si.push{'c') s2.push('z'} for(i=0; i<3 for(i=0; i<3 //Демонстрация стеков со значениями типа double stack<double> dsl, ds2; //создание двух стеков //инициализация стеков dsl.init() ; ds2.init() ; i++) cout " "Из стека 1:" " sl.popO " "\n cout " "Из стека 2:" " s2.pop() " "\n
336 _ Самоучитель C++ dsl.push(l.l) ds2.push(2.2) dsl.push{3.3) ds2.push(4.4} dsi.push(5.5) ds2.push(6.6) for(i=0; i<3; i++) cout " " Из стека 1:" " dsl.pop{) " "\n for(i=0; i<3; i++) cout " " Из стека 2:" " ds2.pop() " "\n return 0; Как показано на примере класса stack (и предыдущего класса list), родовые функции и классы обеспечивают мощный инструмент экономии времени при программировании, поскольку они позволяют определить общую форму алгоритма, который затем можно использовать с данными любого типа. Та-ким образом, вы избегаете однообразных операций по созданию отдельных процедур для каждого типа данных, с которыми должен работать ваш алго-ритм. Класс-шаблон может иметь более одного родового типа данных. Просто объ-явите все необходимые для класса типы данных внутри спецификации template, перечислив их через запятую. Например, в следующем коротком при-мере создается класс с двумя родовыми типами данных: //Здесь в определении класса используется два родовых типа данных ^include <iostream> using namespace std; template <class Typel, class Type2> class myclass Typel i; Type2 j; public: myclass(Typel a, Type2 b) ( i = a; j = b; } void show() { cout " i " ' ' " j " '\n'; } 1i1. int main () myclass<int, double> obl(10, 0.23); myclass<char, char *> ob2('X'f "Это проверка"); obl.showf); //вывод значений типа int и double ob2.show(); //вывод значений типа char и char * }После выполнения программы на экран выводится следующая информация: 10 0.23 X Это проверка
Глава 11. Шаблоны и обработка исключительных ситуаций 337 В программе объявлено два типа объектов. В объекте obi используются целое и значение двойной точности. В объекте оЬ2 - символ и указатель на сим-вол. В обоих случаях компилятор автоматически генерирует необходимые данные и функции в соответствии со способом создания объектов. Упражнения! 1. Если ^э^т*ого еще не сделано, откомпилируйте и выполните два примера про-грамм с родовыми классами. Попытайтесь объявлять списки и/или стеки для разных типов данных. 2. Создайте и продемонстрируйте родовой класс, реализующий очередь. 3. Создайте родовой класс input, который при вызове конструктора делает сле-дующее: : выводит на экран строку-приглашение, : получает данные от пользователя, : повторно выводит на экран строку-приглашение, если вводимые данные не соответствуют заданному диапазону. Объекты типа input должны объявляться следующим образом: input ob ("сгрока^риглашение" , мин_ана"анив, иакс_знаиеяие) Здесь строка ^приглашение ~ это сообщение, появляющееся на экране в ка-честве приглашения для ввода. Минимальное и максимальное допустимые значения задаются с помощью параметров мин_значение и макс_значение со-ответственно. (Тип данных, вводимых пользователем, будет тем же самым, что и тип значений мин_значение и макс_значение.) 11.3. Обработка исключительных ситуаций C++ обеспечивает встроенный механизм обработки ошибок, называемый обработкой исключительных ситуаций (exception handling). Благодаря обработ-ке исключительных ситуаций можно упростить управление и реакцию на ошибки во время выполнения программ. Обработка исключительных ситуа-ций в C++ организуется с помощью трех ключевых слов; try, catch и throw. В самых общих словах, инструкции программы, во время выполнения кото-рых вы хотите обеспечить обработку исключительных ситуаций, располага-ются в блоке try. Если исключительная ситуация (т. е. ошибка) имеет место внутри блока try, она возбуждается (ключевое слово throw), перехватывается (ключевое слово catch) и обрабатывается. Ниже поясняется приведенное здесь общее описание.
335 Самоучитель C++ Как уже отмечалось, любая инструкция, которая возбуждает исключительную ситуацию, должна выполняться внутри блока try. (Функции, которые вызы-ваются из блока try также могут возбуждать исключительную ситуацию.) Лю-бая исключительная ситуация должна перехватываться инструкцией catch, которая располагается непосредственно за блоком try, возбуждающем исклю-чительную ситуацию. Далее представлена основная форма инструкций try и catch: try {//блок возбуждения исключительной ситуации } catch (typel arg-) { //блох перехвата исключительной ситуация }catch (type-2 arg) { //блох перехвата исключительной ситуации }catch (type3 arg) {' If блох перехвата исключительной ситуации catch (typeW arg) { //блок перехвата исключительной ситуации Блок try должен содержать ту часть вашей программы, в который вы хотите отслеживать ошибки. Это могут быть как несколько инструкций внутри од-ной функции, так и все инструкции внутри функции inainO (что естествен-но ведет к отслеживанию ошибок во всей программе). После того как исключительная ситуация возбуждена, она перехватывается соответствующей этой конкретной исключительной ситуации инструкцией catch, которая ее обрабатывает. С блоком try может быть связано более од-ной инструкции catch. To, какая именно инструкция catch используется, зависит от типа исключительной ситуации. То есть, если тип данных, ука-занный в инструкции catch, соответствует типу исключительной ситуации, выполняется данная инструкция catch. При этом все оставшиеся инструк-ции блока try игнорируются (т. е. сразу после того, как какая-то инструкция в блоке try вызвала появление исключительной ситуации, управление пере-дается соответствующей инструкции catch, минуя оставшиеся инструкции блока try, - примеч. пер.). Если исключительная ситуация перехвачена, ар-гумент arg получает ее значение. Если вам не нужен доступ к самой исключительной ситуации, можно в инструкции catch указать только ее тип type, аргумент arg указывать не обязательно. Можно перехватывать
Глава 11. Шаблоны и обработка исключительных ситуаций 339 любые типы данных, включая и типы создаваемых вами классов. Факти-чески в качестве исключительных ситуаций часто используются именно ти-пы классов. Далее представлена основная форма инструкции throw: throw исклю"ительная_си!гуация; Инструкция throw должна выполняться либо внутри блока try, либо в любой функции, которую этот блок вызывает (прямо или косвенно). Здесь исключмпельная^ситпуация - это возбуждаемая инструкцией throw исключи-тельная ситуация. Если вы возбуждаете исключительную ситуацию, для которой нет соответст-вующей инструкции catch, может произойти ненормальное завершение про-граммы. Если ваш компилятор функционирует в соответствии со стандартом Standard C++, то возбуждение необрабатываемой исключительной ситуации приводит к вызову стандартной библиотечной функции terminate(). По умол-чанию для завершения программы функция terminate() вызывает функцию abort(), однако при желании можно задать собственную процедуру заверше-ния программы. За подробностями обращайтесь к справочной документации вашего компилятора. 1. В следующем очень простом примере показано, как в C++ функционирует система обработки исключительных ситуаций: //Простой пример обработки исключительной ситуации ttinclude <iostream> using namespace std; int mainO cout " "начало \n"; try { //начало блока try cout " "Внутри блока try\n"; throw 10; //возбуждение ошибки cout " "Эта инструкция выполнена не будет" }catch (int i) { //перехват ошибки cout " "перехвачена ошибка номер: "; cout " i " "\n"; cout " "конец"; return 0;
340 _ Самоучитель C++ После выполнения программы на экран будет выведено следующее: начало Внутри блока try Перехвачена ошибка номер: 10 конец Внимательно изучите программу. Как видите, здесь имеется блок try, содер-жащий три инструкции, и инструкция catch (int i), обрабатывающая исклю-чительную ситуацию целого типа. Внутри блока try будут выполнены только две из трех инструкций - инструкции cout и throw. После того как исключи-тельная ситуация возбуждена, управление передается выражению catch и выполнение блока try завершается. Таким образом, инструкция catch вызы-вается не явно, управление выполнением программы просто передается этой инструкции. (Для этого стек автоматически сбрасывается.) Следовательно, следующая за инструкцией throw инструкция cout не будет выполнена никогда. После выполнения инструкции catch, управление программы передается сле-дующей за ней инструкции. Тем не менее, обычно блок catch заканчивают вызо-вом функции exit(), abort() или какой-либо другой функции, принудительно за-вершающей программу, поскольку, как правило, система обработки исключи-тельных ситуаций предназначена для обработки катастрофических ошибок. 2. Как уже упоминалось, тип исключительной ситуации должен соответствовать типу, заданному в инструкции catch. Например, в предыдущем примере, если изменить тип данных в инструкции catch на double, то исключительная си-туация не будет перехвачена и будет иметь место ненормальное завершение программы. Это продемонстрировано в следующем фрагменте: //Этот пример работать не будет ^include <iostream> using namespace std; int main ( ) { cout " "начало\п"; try { //начало блока try cout " "Внутри блока try\n"; throw 10; //возбуждение ошибки cout " "Эта инструкция выполнена не будет"; }catch (double i) { //Эта инструкция не будет работать //с исключительной ситуацией целого типа cout " "перехвачена ошибка номер: "; cout " i " "\n"; cout " "конец"; return 0;
Глава 11. Шаблоны и обработка исключительных ситуаций 341 Поскольку исключительная ситуация целого типа не будет перехвачена инст-рукцией catch типа double, на экран программа выведет следующее: начало Внутри блока try Abnormal program termination 3. Исключительная ситуация может быть возбуждена не входящей в блок try инструкцией, если сама эта инструкция входит в функцию, которая вызыва-ется из блока try-Например, ниже представлена совершенно правильная программа: /* Возбуждение исключительной ситуации из функции, находящейся вне блока try */ttinclude <iostream> using namespace std; void Xtest(int test) t cout " "Внутри функции Xtest, test равно: " " test " "\n"; if (test) throw test; int main() I cout " "начало\п"; try { //начало блока try cout " "Внутри блока try\n"; Xtest (0); Xtest (1); Xtest (2); catch (int i) { //перехват ошибки cout " "перехвачена ошибка номер: "; cout " i " "\n"; cout " "конец"; return 0; 1На экран программа выводит следующее: начало Внутри блока try Внутри функции Xtest, test равно: О Внутри функции Xtest, test равно: 1
342 __ Самоучитель C++ Перехвачена ошибка номер: 1 конец 4. Блок try можно располагать внутри функции. В этом случае при каждом вхо-де в функцию обработчик исключительной ситуации устанавливается снова. Например, рассмотрим следующую программу: ^include <iostream> using namespace std; //Блоки try и catch могут находиться не только в функции main ( ) void Xhandler (int test) ( try fif (test) throw test; }catch(int i) { cout " "перехвачена ошибка номер : " " i " ' \n ' ; int main ( } { cout " "началоХп"; Xhandler (1) ; Xhandler (2} ; Xhandler (0) ; Xhandler (3) ; cout " "конец"; return 0; На экран программа выводит следующее: начало Перехвачена ошибка номер: 1 Перехвачена ошибка номер: 2 Перехвачена ошибка номер: 3 конец Как видите, обработаны три исключительные ситуации. После вызова каж-дой исключительной ситуации функция возвращает свое значение. При по-вторном вызове функции обработчик исключительной ситуации устанавлива-ется вновь. 5. Как упоминалось ранее, с блоком try можно связать более одной инструкции catch. Как правило, так и делается. При этом каждая инструкция catch пред-
Глава 11. Шаблоны и обработка исключительных ситуаций 343 назначена для перехвата своего типа исключительной ситуации. Например, в следующей программе перехватываются две исключительных ситуации, одна для целых и одна для строки: tinclude <iostream> using namespace std; : //Можно перехватывать разные типы исключительных ситуаций void Xhandler(int test} try {if(test) throw test; else throw "Значение равно нулю"; . catch (int i} { cout " "Перехвачена ошибка номер: " " i " '\n'; catch(char *str) ( cout " "Перехвачена строка: "; cout " str " p \ n ' ; int main () { cout " "начало\п"; Xhandler(l); Xhandler(2); Xhandler(O); Xhandler(3); cout " "конец"; return 0; На экран программа выводит следующее: начало Перехвачена ошибка номер: 1 Перехвачена ошибка номер: 2 Перехвачена строка: Значение равно нулю Перехвачена ошибка номер: 3 конец Как видите, каждая инструкция catch перехватывает только исключительные ситуации соответствующего ей типа. Обычно выражения инструкций catch проверяются в том порядке, в котором они появляются в программе. Выполняется только та инструкция, которая
344 Самоучитель C++ совпадает по типу данных с исключительной ситуацией. Все остальные бло-ки catch игнорируются. [Упражнеенниияя] 1. Лучший способ понять, как функционирует система обработки исключи-тельных ситуаций в C++ - это поработать с ней. Введите, откомпилируйте и запустите предыдущие примеры программ. Затем поэкспериментируйте с ними, меняя фрагменты и исследуя результаты. 2. Что неправильно в данном фрагменте? int main () { throw 12.23; 3. Что неправильно в данном фрагменте? try {//. .. throw ' а ' ; catch (char *) { 4. Что может произойти при возбуждении исключительной ситуации, для кото рой не задано соответствующей инструкции catch? 11.4. Дополнительная информация об обработке исключительных ситуаций В системе обработки исключительных ситуаций имеется несколько допол-нительных аспектов и нюансов, которые могут сделать ее понятнее и удоб-ней для применения. В некоторых случаях необходимо настроить систему так, чтобы перехваты-вать все исключительные ситуации, независимо от их типа. Сделать это дос-таточно просто. Для этого используйте следующую форму инструкции catch: catch (...) { //обработка всех исключияелышх ситуаций
Глава 1 1. Шаблоны и обработка исключительных ситуаций _ 345 Здесь многоточие соответствует любому типу данных. Для функции, вызываемой из блока try, вы можете ограничить число типов исключительных ситуаций, которые способна возбудить такая функция. Фактически можно даже запретить функции вообще возбуждать какую бы то ни было исключительную ситуацию. Для этого необходимо добавить в определение функции ключевое слово throw. Здесь представлена основная форма такого определения: возвраща&мый_тип имя_функции (список_аргумекч>ов) throw ( списох_ типов) I Здесь в поле список_типов перечисляются через запятые только те типы данных исключительных ситуаций, которые могут быть возбуждены функ-цией. Возбуждение любого другого типа исключительной ситуации приведет к аварийному завершению программы. Если вы хотите, чтобы функция не возбуждала никаких исключительных ситуаций, то оставьте поле список_ типов пустым. Если ваш компилятор работает в соответствии с современным стандартом Standard C++, то попытка возбуждения неподдерживаемой исключительной ситуации приведет к вызову стандартной библиотечной функции unexpected(). По умолчанию функция unexpectedQ вызывает функцию abort(), что ведет к аварийному завершению программы. Однако при желании вы можете задать собственную процедуру завершения программы. За подробностями обра-щайтесь к справочной документации вашего компилятора. Если вы хотите в процедуре обработки исключительной ситуации возбудить по-вторную исключительную ситуацию, можно просто использовать инструкцию throw без параметров. Это приводит к тому, что текущая исключительная ситуа-ция передается внешней последовательности инструкций try/catch. Примеры 1. В следующей программе иллюстрируется использование инструкции catch(...): //В этой программе перехватываются все типы исключительных ситуаций ^include <iostream> using namespace std; void Xhandler(int test) try {//возбуждение исключительной ситуации типа int if(test==0) throw test;
346 Самоучитель C++ //возбуждение исключительной ситуации типа char if(test==l) throw 'a'; //возбуждение исключительной ситуации типа double if (test-2) throw 123.23; } catch (...) { //перехват исключительных ситуаций всех типов cout " "Перехвачена ошибка!\п"; }int main () cout " "начало\п"; Xhandler(O); Xhandler(l); Xhandler(2); cout " "конец return 0; " На экран программа выводит следующее: начало Перехвачена ошибка ! Перехвачена ошибка ! Перехвачена ошибка ! конец Как видите, во всех трех случаях возбуждения исключительной ситуации в инструкции throw, она перехватывается с помощью единственной инструк-ции catch. 2. Очень удобно инструкцию catch(...) использовать в качестве последней в группе инструкций catch. В этом случае инструкция catch(...) по умолчанию становится инструкцией, которая "перехватывает все". Например, далее пред-ставлена слегка измененная версия предыдущей программы, где исключи-тельные ситуации целого типа перехватываются явно, а все другие - с по-мощью инструкции catch(...): /* В этом примере инструкция catch (...) по умолчанию перехватывает все типы исключительных ситуаций */^include <io5tream> using namespace std; void Xhandler(int test)
Глава 1 1. Шаблоны и обработка исключительных ситуаций _ 347 t су { //возбуждение исключительной ситуации типа int if(test=0) throw test; //возбуждение исключительной ситуации типа char if (test- 1} throw 'a'; //возбуждение исключительной ситуации типа double if (test- 2) throw 123.23; }catch(int i) { //перехват исключительной ситуации типа int cout " "Перехвачен " " i " '\n'; } catch (...) { //перехват исключительных ситуаций остальных типов cout " "Перехвачена ошибка ! \п" ; int main {) { cout " "начало\п " ; Xhandler(O) ; Xhandler(l) ; Xhandler(2) ; cout " "конец"; return 0; На экран программа выводит следующее: начало Перехвачен О Перехвачена ошибка! Перехвачена ошибка! конец Как показано в этом примере, использование инструкции catch(...) таким образом - это хороший способ перехватывать те исключительные ситуации, которые вы не хотите обрабатывать явно. Кроме этого, путем перехвата всех исключительных ситуаций вы предотвращаете аварийное завершение про-граммы из-за случайно необработанной исключительной ситуации. 3. В следующей программе показано, как ограничить число типов исключи-тельных ситуаций, которые возбуждаются функцией: /* Ограничение числа возбуждаемых функцией типов исключительных ситуаций */ttinclude <iostreara> using namespace std;
348 _ _ _ Самоучитель C++ II Этой функцией могут возбуждаться только //исключительные ситуации типов int, char и double void Xhandler (int test) throw(int, char, double) { //возбуждение исключительной ситуации типа int if (test-0) throw test; //возбуждение исключительной ситуации типа char if(test=l) throw rar; //возбуждение исключительной ситуации типа double ifttest- 2) throw 123.23; int main () ( cout " "начало\п"; try {Xhandler(O); //попробуйте также передать в //функцию Xhandler () значения 1 и 2 catch (int i) { cout " "Перехват int\n"; Jcatch (char c) j cout " "Перехват char\n"; }catch (double d) { cout " "Перехват double\n" ; } cout " "конец" ; return 0; В этой программе функция Xhandler() может возбуждать только исключи-тельные ситуации типа int, char и double. При попытке возбудить исключи-тельную ситуацию другого типа произойдет аварийное завершение програм-мы. (То есть будет вызвана функция unexpected<>.) Чтобы убедиться в этом, удалите из списка допустимых исключительных ситуаций тип int и повторите запуск программы. Важно понимать, что ограничить типы возбуждаемых исключительных си-туаций можно только после того, как функция вызвана из блока try-To есть внутри функции блок try может возбудить любой тип исключительной си-туации, коль скоро она перехватывается внутри этой функции. Ограничения вступают в силу только тогда, когда исключительная ситуация не перехваче-на функцией.
Глава 1 1. Шаблоны и обработка исключительных ситуаций _ 349 4. Следующее небольшое изменение в функции Xhandler() запрещает возбужде-ние любой исключительной ситуации: //Эта функция НЕ может вызывать никаких исключительных ситуаций void Xhandler (int test) throw ( ) /*Следующие инструкции больше не работают. Наоборот, попытка их выполнения ведет к ненормальному завершению программы *///возбуждение исключительной ситуации типа int if (test==0) throw test; //возбуждение исключительной ситуации типа char if(test==l) throw 'a'; //возбуждение исключительной ситуации типа double if(test=2J throw 123.23; Вы уже знаете, что можно повторно возбудить исключительную ситуацию. Смысл этого в том, чтобы предоставить возможность обработки исключи-тельной ситуации нескольким процедурам. Например, предположим, что од-на процедура обрабатывает один аспект исключительной ситуации, а вто-рая - другой. Повторно исключительная ситуация может быть возбуждена только внутри блока catch (или любой функцией, которая вызывается из этого блока). Когда вы повторно возбуждаете исключительную ситуацию, она перехватывается не той же инструкцией catch, а переходит к другой, внеш-ней к данной инструкции. В следующей программе иллюстрируется повтор-ное возбуждение исключительной ситуации: возбуждается исключительная ситуация типа char *. /* Пример повторного возбуждения исключительной ситуации одного и того же типа */^include <iostream> using namespace std; void Xhandler () { try {//возбуждение исключительной ситуации типа char * throw "привет"; j//перехват исключительной ситуации типа char * catch (char *) { cout " "Перехват char * внутри функции Xhandler () \n"; //повторное возбуждение исключительной ситуации //типа char *, но теперь уже не в функции Xhandler () throw;
350 Самоучитель C++ int main() cout " "началсЛп"; try {XhandlerO ; } catch(char *) { cout " " Перехват char * внутри функции main()\n"; }cout " "конец"; return 0; На экран программа выводит следующее: начало Перехват char * внутри функции XhandlerO Перехват char * внутри функции main() конец \. Перед тем как двинуться дальше, откомпилируйте и запустите все примеры текущего раздела. Убедитесь, что вы понимаете, почему каждая программа выводит на экран ту или иную информацию. 2. Что неправильно в данном фрагменте? try {//... throw 10; }catch (int *p) { 3. Предложите способ исправления предыдущего фрагмента. 4. Какая инструкция catch перехватывает все типы исключительных ситуаций? 5. Далее представлен каркас функции dividcQ double divide (double a, double b) { //добавьте обработку ошибок return a/b;
Глава 11. Шаблоны и обработка исключительных ситуаций 35? Эта функция возвращает результат деления а на Ь. Добавьте в функцию про-цедуру обработки исключительных ситуаций, а конкретно предусмотрите об-работку ошибки деления на ноль. Покажите, что ваша процедура работает. 11.5. Обработка : v исключительных ситуации, возбуждаемых оператором new В главе 4 вы получили представление о том, что в соответствии с современ-ной спецификацией оператора new, он возбуждает исключительную ситуа-цию при неудачной попытке выделения памяти. Поскольку в главе 4 об ис-ключительных ситуациях мы еще не знали, описание того, как они обраба-тываются было отложено. Теперь настало время подробно исследовать ситуацию неудачной попытки выделения памяти с помощью оператора new. В материале этого раздела атрибуты оператора new описаны так, как это оп-ределено в современном едином международном стандарте Standard C++. Как уже упоминалось в главе 4, с момента появления языка C++ точное определение действий, которые должны выполняться при неудачной попыт-ке выделения памяти с помощью оператора new, менялось несколько раз. Сразу после разработки языка при неудачной попытке выделения памяти оператор new возвращал нуль, несколькими годами позднее - возбуждал исключительную ситуацию. Кроме того, неоднократно менялось имя этой исключительной ситуации. В конце концов было решено, что неудачная по-пытка выделения памяти с помощью оператора new по умолчанию будет возбуждать исключительную ситуацию, но по желанию в качестве опции можно возвращать нулевой указатель. Таким образом, оператор new реали-зовывался по-разному в разное время разными производителями компиля-торов. Хотя в будущем все компиляторы должны быть выполнены в точном соответствии с требованиями стандарта Standard C++, сегодня это не так. Если представленные здесь примеры программ у вас не работают, проверьте по документации вашего компилятора то, как именно в нем реализован оператор new. В соответствии со стандартом Standard C++, когда требование на выделение памяти не может быть выполнено, оператор new возбуждает исключитель-ную ситуацию bad_alloc. При невозможности перехватить эту исключитель-ную ситуацию программа завершается. Хотя для коротких программ такой алгоритм кажется вполне очевидным и понятным, в реальных приложениях вы должны не только перехватить, но и каким-то разумным образом обра-ботать эту исключительную ситуацию. Для доступа к указанной исключи-тельной ситуации в программу необходимо включить заголовок <new>.
352 Самоучитель C++ Изначально описанная выше исключительная ситуация называлась xalloc и во время написания данной книги это имя продолжало использоваться на многих компиляторах. Тем не менее в дальнейшем оно, несомненно, будет вытеснено определенным в стандарте Standard C++ именем bad_alloc. Как уже упоминалось, в соответствии с требованиями стандарта Standard C++ при неудачной попытке выделения памяти допускается, чтобы опера-тор new возвращал нуль, а не возбуждал исключительную ситуацию. Такая форма оператора new может оказаться полезной при компиляции устарев-ших программ на современном компиляторе, а также при замене функций malloc() операторами new. Ниже представлена именно эта форма оператора new: указатель = new(nothrow) TIOI; Здесь указатель - это указатель на переменную типа тип. Форма оператора new с ключевым словом nothrow (без вызова исключительной ситуации) функционирует аналогично его прежней, изначальной версии. Поскольку в этом случае при неудачной попытке выделения памяти возвращается нуль, оператор new может быть легко "встроен" в старые программы и вам не нужно заботиться о формировании процедуры обработки какой бы то ни было исключительной ситуации. Тем не менее, в новых программах меха-низм исключительных ситуаций предоставляет вам гораздо более широкие возможности. ПримерыР I. В представленном ниже примере с оператором new использование блока try/catch дает возможность проконтролировать неудачную попытку выделе-ния памяти. ^include <iostream> tfinclude <new> using namespace std; int main() { int *p; try {p = new int; //выделение памяти для целого } catch (taad_alloc xa) { cout " "Ошибка выделения памяти\п";
Глава 1 1. Шаблоны и обработка исключительных ситуаций _ 353 return 1; for(*p = 0; *р < 10; (*р}-НО cout " *р " " "; delete p; //освобождение памяти return 0; В данном примере, если при выделении памяти случается ошибка, она пере-хватывается инструкцией catch. 2. Поскольку в предыдущей программе при работе в нормальных условиях ошибка выделения памяти чрезвычайно маловероятна, в представленном ниже примере для демонстрации возможности возбуждения исключительной ситуации оператором new ошибка выделения памяти достигается принуди-тельно. Процесс выделения памяти длится до тех пор, пока не произойдет ошибка. ^include <iostream> ^include <new> using namespace std; int raainO , double *p; //цикл будет продолжаться вплоть до исчерпания ресурса памяти do {try {p = new double [100000]; } catch (bad_alloc xa) ( cout " "Ошибка выделения памяти\п"; return 1; }cout " "Выделение памяти идет нормально\п"; } while (p) ; return 0; 3, В следующей программе показано, как использовать альтернативную форму оператора new - оператор new(nothrow). Это переработанная версия преды-дущей программы с принудительным возбуждением исключительной ситуа-ции. //Демонстрация работы оператора new(nothrow) ^include <iostream> ^include <new>
354 Самоучитель C++ using namespace std; int main() { double *p; //цикл будет продолжаться вплоть до исчерпания ресурса памяти do { р = new(nothrow) double[100000]; i f ( p ) cout " "Выделение памяти идет нормально\п"; else cout " "Ошибка вьщеления памяти\п"; } while(р); return 0; }Как показано в этой программе, при использовании оператора new с ключе-вым словом nothrow, после каждого запроса на выделение памяти следует проверять возвращаемое оператором значение указателя. 1. Объясните, в чем разница между функционированием операторов new и new(nothrow), если при выделении памяти происходит ошибка. 2. Дан следующий фрагмент программы. Приведите два переделанных варианта этого фрагмента с учетом современных требований к программам на C++. р = malloc(sizeof(int)); ifUp) { cout " "Ошибка выделения памяти\п"; exit(l); роверка усвоения материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы. 1. Создайте родовую функцию, возвращающую значение элемента, который чаще всего встречается в массиве.
Глава 11. Шаблоны и обработка исключительных ситуаций 355 2. Создайте родовую функцию, возвращающую сумму значений элементов массива. 3. Создайте родовой класс для "пузырьковой" сортировки (или используйте любой другой известный вам алгоритм сортировки). 4. Измените класс stack так, чтобы в стеке можно было хранить пары объ-ектов разных типов. 5. Напишите обычные формы инструкций try, catch и throw. Опишите своими словами их функции. 6. Еще раз измените класс stack так, чтобы переполнение и, наоборот, опустошение стека обрабатывались как исключительные ситуации. 7. Просмотрите документацию на ваш компилятор, Проверьте, поддержива-ет ли он функции terminate() и unexpected(). Как правило, эти функции можно конфигурировать так, чтобы из них вы могли вызвать любую не-обходимую вам функцию. Если в случае с вашим компилятором это так, постарайтесь создать собственный набор функций завершения програм-мы, который обеспечил бы возможность обработки необрабатываемых до этого исключительных ситуаций. 8. Философский вопрос: в чем, по вашему мнению, при неудачной попытке выделения памяти преимущество возбуждения исключительной ситуации оператором new по сравнению с возвращением нуля? Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущей глав. 1. В главе 6, раздел 6.7, пример 3 был представлен класс с безопасным мас-сивом. Переделайте его в родовой класс с безопасным массивом. 2. В главе 1 были созданы перегруженные версии функции abs(). Усовер-шенствуйте решение, создав родовую функцию abs(), которая возвращала бы абсолютную величину любого численного объекта.
Глава 12 Динамическая идентификация и приведение типов В этой главе рассказывается о двух сравнительно новых инструментах C++: динамической идентификации типа (Run-Time Type Identification, RTTI) и новых, более совершенных операторах приведения типов (casting operators). Динамическая идентификация типа дает возможность определить тип объ-екта во время выполнения программы. Новые операторы приведения типов предоставляют более безопасные и управляемые способы выполнения опе-раций приведения типов, по сравнению с существовавшими ранее. Как вы увидите в дальнейшем, один из операторов приведения типов, а именно оператор dynamic_cast, относится непосредственно к RTTI, поэтому имело смысл объединить эти две темы в одной главе. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Что такое родовая функция и какова ее основная форма? 2. Что такое родовой класс и какова его основная форма? 3. Напишите родовую функцию gexpQ, возвращающую значение одного из своих аргументов, возведенного в степень другого. 4. В главе 9, раздел 9.7, пример 1 был создан класс coord для хранения це-лочисленных координат. Создайте родовую версию этого класса, чтобы можно было хранить координаты любого типа. Продемонстрируйте про-грамму решения этой задачи. 5. Кратко объясните, как совместная работа инструкций try, catch и throw обеспечивает в C++ обработку исключительных ситуаций. 6. Можно ли использовать инструкцию throw, если ход выполнения про-граммы не затрагивает инструкции, расположенные в блоке try? 7. Для чего служат функции terminate!) и unexpectedQ? 8. Какая форма инструкции catch будет обрабатывать все типы исключи-тельных ситуаций?
358 Самоучитель C++ 12.1. Понятие о динамической идентификации типа Поскольку динамическая идентификация типа не характерна для языков программирования, в которых не поддерживается полиморфизм (например, С), это понятие может оказаться для вас неизвестным. В языках, в которых не поддерживается полиморфизм, информация о типе объекта во время вы-полнения программы просто не нужна, так как тип каждого объекта извес-тен уже на этапе компиляции программы (вернее даже тогда, когда программа еще пишется). С другой стороны, в языках, поддерживающих полиморфизм (таких, как C++), возможны ситуации, в которых тип объекта на этапе компиляции неизвестен, поскольку до выполнения программы не определена точная природа объекта. Как вы знаете, в C++ полиморфизм реализуется через иерархии классов, виртуальные функции и указатели ба-зовых классов. При таком подходе указатель базового класса может исполь-зоваться либо для указания на объект базового класса, либо для указания на объект любого класса, производного от этого базового. Следовательно, не всегда есть возможность заранее узнать тип объекта, на который будет ука-зывать указатель базового класса в каждый данный момент времени. В таких случаях определение типа объекта должно происходить во время выполне-ния программы, а для этого служит механизм динамической идентификации типа. Информацию о типе объекта получают с помощью оператора lypeid. Для использования оператора typeid в программу следует включить заголовок <typemfo>. Ниже представлена основная форма оператора typeid: typeid(объект) Здесь объект - этот тот объект, информацию о типе которого необходимо получить. Оператор typeid возвращает ссылку на объект типа type_info, кото-рый и описывает тип объекта объект. В классе type_info определены сле-дующие открытые члены: bool operator= (const type_info йобъвкт) ; bool operator!=(const type_info &объект); bool before(const type_info ^объект); const char *name(); Сравнение типов обеспечивают перегруженные операторы == и !=. Функ-ция before() возвращает истину, если вызывающий объект в порядке сорти-ровки расположен раньше объекта, заданного в качестве параметра. (Эта функция обычно предназначена только для внутреннего использования. Ее возвращаемое значение вряд ли может пригодиться при операциях с насле-дованием или иерархиями классов.) Функция пате() возвращает указатель на имя типа.
Глава 12. Динамическая идентификация и приведение типов 359 Хотя оператор typeid позволяет получать типы разных объектов, наиболее полезен он будет, если в качестве его аргумента задать указатель полиморф-ного базового класса. В этом случае оператор автоматически возвращает тип реального объекта, на который указывает указатель. Этим объектом может быть как объект базового класса, так и объект любого класса, производного от этого базового. (Вспомните, указатель базового класса может указывать либо на объект базового класса, либо на объект любого класса, производ-ного от этого базового.) Таким образом, с помощью оператора typeid во время выполнения программы можно определить тип объекта, на который указывает указатель базового класса. То же самое относится и к ссылкам. Когда в качестве аргумента оператора typeid указана ссылка на объект поли-морфного класса, оператор возвращает тип реального объекта, на который имеется ссылка. Этим объектом, так же как и в случае с указателем, может быть объект производного класса. Когда оператор typeid применяют к не-полиморфному классу, получают указатель или ссылку базового типа. Ниже представлена вторая форма оператора typeid, в которой в качестве ар-гумента указывают имя типа: typeid (имя_тйпа) Обычно с помощью данной формы оператора typeid получают объект типа type_info, который можно использовать в инструкции сравнения типов. Поскольку оператор typeid чаще всего применяют к разыменованному указа-телю (т. е. указателю, к которому уже был применен оператор *), для обра-ботки положения, когда разыменованный указатель равен нулю, была придумана специальная исключительная ситуация bad_typeid, которую в этом случае возбуждает оператор typeid. Динамическая идентификация типа используется далеко не в каждой про-грамме. Тем не менее, если вы работаете с полиморфными типами данных, она позволяет в самых разнообразных ситуациях определять типы обрабаты-ваемых объектов. В следующей программе демонстрируется использование оператора typeid. Сначала с помощью этого оператора мы получаем информацию об одном из встроенных типов данных C++ - типе int. Затем оператор typeid дает нам возможность вывести на экран типы объектов, на которые указывает указа-тель р, являющийся указателем базового класса BaseClass. //Пример использования оператора typeid #include <iostream> ^include <typeinfo> using namespace std;
360 _ __ Самоучитель C++ class BaseClass { virtual void f() (}; //делаем класс BaseClass полиморфным class Derivedl: public BaseClass { class Derived2 : public BaseClass { int main ( ) i int i; BaseClass *p, baaeob; Derivedl obi; Derived2 ob2; //Вывод на экран встроенного типа данных cout " "Тип переменной i - это "; cout " typeid(i) .name () " endl; -//Обработка полиморфных типов р = Sbaseob; cout " "Указатель р указывает на объект типа "; cout " typeid (*p) .name () " endl; р = &obl; cout " "Указатель р указывает на объект типа "; cout " typeid (*p) .name {) " endl;. р = &ob2; cout " "Указатель р указывает на объект типа "; cout " typeid{*p) .name (} " endl; return 0; Программа выводит на экран следующую информацию: Тип переменной i - это int Указатель р указывает на объект типа BaseClass Указатель р указывает на объект типа Derivedl Указатель р указывает на объект типа Derived2 Как уже отмечалось, когда в качестве аргумента оператора typeid задан указа-тель полиморфного базового класса, реальный тип объекта, на который ука-зывает указатель определяется во время выполнения программы, что очевидно по выводимой на экран информации. В качестве эксперимента за-
Глава 12. Динамическая идентификация и приведение типов _ 361 комментируйте виртуальную функцию f() в определении базового класса BaseClass и посмотрите, что получится. 2. Ранее уже говорилось, что когда в качестве аргумента оператора typeid указа-на ссылка полиморфного базового класса, возвращаемым типом будет тип реального объекта, на который дана ссылка. Чаще всего это свойство ис-пользуется в ситуациях, когда объекты передаются функциям по ссылке. На-пример, в следующей программе в объявлении функции WhatType() объект типа BaseClass задан параметром-ссылкой. Это означает, что функции What-Туре() можно передавать ссылки на объекты типа BaseClass или типов, про-изводных от класса BaseClass. Если в операторе typeid задать такой параметр, то он возвратит тип реального объекта. //Использование оператора typeid со ссылкой в качестве аргумента ^include <iostream> ^include <typeinfo> using namespace std; class BaseClass { virtual void f() {}; //делаем класс BaseClass полиморфным class Derivedl: public BaseClass { class Derived2: public BaseClass { //Задание ссылки в качестве параметра функции void WhatType (BaseClass &ob) { cout " "ob - это ссылка на объект типа "; cout " typeid(ob) ,name{) " endl; int main() int i; BaseClass baseob; Derivedl obi ; Derived2 ob2; WhatType (baseob) WhatType (obi) WhatType (ob2)
362 _ _ Самоучитель C++ Программа выводит на экран следующую информацию: ob - это ссылка на объект типа BaseClass ob - это ссылка на объект типа Derived! ob - это ссылка на объект типа Derived2 3. Хотя получение имени типа объекта в некоторых ситуациях оказывается весьма полезным, часто бывает необходимо узнать, соответствуют ли друг другу типы нескольких объектов. Это легко сделать, зная что объект типа type_info, возвращаемый оператором typeid, перегружает операторы == и !- , В представленной ниже программе показано использование этих операторов. //Использование операторов == и != с оператором typeid ^include <iostream> ^include <typeinfo> using namespace std; class X { virtual void f() {} class Y { virtual void f () { } int main() { X xl, x2; Y yl; if (typeid(xl) == (typeid(x2)) cout " "Тип объектов xl и х2 одинаковХп"; elsecout " "Тип объектов xl и х2 не одинаков \п"; if (typeid(xl) != ( typeid (yl)) cout " "Тип объектов xl и yl не одинаков \п"; elsecout " "Тип объектов xl и yl одинаков\п"; return 0; Программа выводит на экран следующую информацию: Тип объектов xl и х2 одинаков Тип объектов xl и yl не одинаков 4. Хотя в предыдущих примерах и были показаны некоторые приемы работы с оператором type_info, главных его достоинств мы не увидели, поскольку ти-пы объектов были известны уже на этапе компиляции программы. В еле-
Глава 12. Динамическая идентификация и приведение типов 363 дующем примере этот пробел восполнен. В программе определена простая иерархия классов, предназначенных для рисования на экране разного рода геометрических фигур. На вершине иерархии находится абстрактный класс Shape. Его наследуют четыре класса: Line, Square, Rectangle и NulIShape Функция generator() генерирует объект и возвращает указатель на него. (Функцию, предназначенную для создания объектов, иногда называют фабрикой объектов.) То, какой именно объект создается, определяет генера-тор случайных чисел rand(). В функции main{) реализован вывод получаю-щихся объектов разных типов на экран, исключая объекты типа NulIShape, у которых нет какой бы то ни было формы. Поскольку объекты возникают случайно, заранее неизвестно, какой объект будет создан следующим. Следо-вательно, для определения типа создаваемых объектов требуется динамиче-ская идентификация типа. //Использование операторов - и != с оператором typeid #include <iostream> tinclude <cstdlib> #include <typeinfo> using namespace std; class Shape ( public: virtual void example(} = 0; class Rectangle: public Shape { public: void example (} { cout " "*****\n* *\n* *\n*****\n"; class Triangle: public Shape { public: void example ( } { cout " "*\n* *\n* *\n*****\n"; class Line: public Shape ( public: void example () { cout " "*****\n"; class NulIShape: public Shape { public:
364 _ Самоучитель C++ void example () { I //Фабрика производных от класса Shape объектов Shape *generator{) switch(rand(} % 4) { case 0: . return new Line; case 1 ; return new Rectangle; case 2; return new Triangle/-case 3: return new NullShape; 1return NULL; int main ( ) { int i; Shape *p; for(i=0; i p =* generator (}; //создание следующего объекта cout " typeid(*p) .name () " endl; //рисует объект, если он не типа NullShape if (typeid(*p) != typeid (NullShape) ) p->example () ; }return 0; Программа выводит на экран следующее: class Rectangle class NullShape class Triangle
Глава 12. Динамическая идентификация и приведение типов 365 class Line ***** class Rectangle class Line ***** class Triangle **:*:*:* class Triangle ***** class Triangle class Line 5. Оператор typeid может работать с классами-шаблонами. Например, рассмот-рим следующую программу. В ней для хранения некоторых значений созда-ется иерархия классов-шаблонов. Виртуальная функция get_val() возвращает определенное в каждом классе значение. Для класса Num это значение соот-ветствует самому числу. Для класса Square - это квадрат числа. Для класса Sqr_root - это квадратный корень числа. Объекты, производные от класса Num, генерирует функция genegator(). С помощью оператора typeid опреде-ляется тип генерируемых объектов. //Использование оператора typeid с шаблонами ^include <iostream> linclude <cstdlib> ttinclude <cmath #include <typeinfo> using namespace std; template <class T> class Num { public: Т х; Num(T i) { x = i; }
366 _ Самоучитель C++ virtual Т get_val() { return x; } }; : template <class T> class Squary: public Num<T> { public: Squary (T 1} : Num<T>(i) {} Т get_val() { return x*x; } template <class T> class Sqr_root: public Num<T> { public: Sqr_root(T i): Num<T>(i) {} Т get_val() { return sqrt ( (double) x) ; } ); //Фабрика производных от класса Num объектов Num<double> * generator {) ( switch {rand () % 2) { case 0: return new Squary<double> (rand{) % 100); case 1: return new Sqr_root<double> (rand() % 100); }return NULL; int main() { Num<double> obi (10), *pl; Squary<double> ob2(100.0); Sqr_root<double> ob3{999.2); int i; cout " typeid (obi) .name () " endl; cout " typeid (ob2) .name () " endl; cout " typeid (ob3) .name () " endl; if (typeid(ob2) == typeid (Squary<double>) ) cout " "is Squary<double>\n"; pi = fiob2; if (typeid{*pl) != typeid(obl)) cout " "Значение равно: " " pl->get__val (} ; cout " "\n\n"; cout " "Теперь генерируем объекты\п"; for(i=0; i<10; i++) { pi = generator{); //получение следующего объекта
Глава 12. Динамическая идентификация и приведение типов 367 if(typeid(*pl) == typeid CSquary<double>)) cout " "Квадрат объекта: "; if (typeid(*pl) == typeid(Sqr__root<double>) ) cout " "Квадратный корень объекта: "; cout " "Значение равно: " " pl->get_val() cout " endl; return 0; Программа выводит на экран следующее: class Num<double> class Squary<double> class Sqr_root<double> is Squary<double> Значение равно: 10000 Теперь генерируем объекты Квадратный корень Квадрат объекта: Квадратный корень Квадрат объекта: Квадрат объекта: Квадратный Квадратный Квадратный Квадратный Квадратный корень корень корень корень корень объекта : Значение объекта : Значение Значение объекта : объекта : объекта : объекта: объекта : Значение равно : 0 Значение равно : равно: 8. ^1. 18535 89898 равно: 3364 равно: 4096 Значение Значение Значение Значение Значение равно: равно: равно : равно : равно: 6. 5. 9. 6. 6 7082 19616 53939 43074 1. Зачем нужна динамическая идентификация типа? 2. Проведите эксперимент, о котором говорилось в примере 1. Что вы увидите на экране? 3. Правилен ли следующий фрагмент программы? cout " typeid(float).name(); 4. Дан фрагмент программы. Как определить, является ли р указателем на объ-ект типа D2? class В { virtual void f(} {}
368 Самоучитель C++' class Dl: public В ( void f () {} class D2: public В { void f ( > {} i . int rnainO В *р; 5. По отношению к классу Мшп из примера 5 следующее выражение является истинным или ложным? typeid(Num<int>) == typeid(Num<double>) 6. Поэкспериментируйте с RTTI. Хотя польза от динамической идентификации типа в контексте приведенных здесь простых примеров может показаться не слишком очевидной, тем не менее это мощный инструмент упраачения объ-ектами во время работы программы. 12.2. Оператор dynamicjcast Хотя в C++ продолжают поддерживаться характерные для языка С операто-ры приведения типов, имеется и несколько новых. Это операторы dynamic_cast, const_cast, reinterpret_cast и static_cast. Поскольку оператор dynamic_cast имеет непосредственное отношение к динамической иденти-фикации типа, мы рассмотрим его первым. Остальные операторы приведе-ния типов рассматриваются в следующем разделе. Оператор dynamic_cast реализует приведение типов в динамическом режиме, что позволяет контролировать правильность этой операции во время работы программы. Если при выполнении оператора dynamic_cast приведения типов не произошло, будет выдана ошибка приведения типов. Ниже представлена основная форма оператора dynamic_cast: dynamic сазЪ<целевой тип> (выражение) Здесь целевой_пшп - это тип, которым должен стать тип параметра выраже-ние после выполнения операции приведения типов. Целевой тип должен быть типом указателя или ссылки и результат выполнения параметра выра-жение тоже должен стать указателем или ссылкой. Таким образом, оператор dynamic_cast используется для приведения типа одного указателя к типу другого или типа одной ссылки к типу другой. Основное назначение оператора dynamic_cast заключается в реализации операции приведения полиморфных типов. Например, пусть дано два поли-
Глава 12. Динамическая идентификация иприведеиие^гипов 369 морфных класса В и D, причем класс D является производным от класса В, тогда оператор dynamic_cast всегда может привести тип указателя D* к типу указателя В*. Это возможно потому, что указатель базового класса всегда может указывать на объект производного класса. Оператор dynamic_cast мо-жет также привести тип указателя В* к типу указателя D*, но только в том случае, если объект, на который указывает указатель, действительно являет-ся объектом типа D. Как правило, оператор dynamic__cast выполняется ус-пешно, когда указатель (или ссылка) после приведения типов становится указателем (или ссылкой) либо на объект целевого типа, либо на объект производного от целевого типа. В противном случае приведения типов не происходит. При неудачной попытке приведения типов результатом выпол-нения оператора dynamic_cast является нуль, если в операции использова-лись указатели. Если же в операции использовались ссылки, возбуждается исключительная ситуация bad_cast. Рассмотрим простой пример. Предположим, что Base - это базовый класс, a Derived - это класс, производный от класса Base. Base *bp, b_ob; Derived *dp, d_ob; bp = &d_ob; //указатель базового класса //указывает на объект производного класса dp = dynamic_cast<Derived *> (bp) if(!dp) cout "Приведение типов прошло успешно"; Здесь приведение типа указателя bp базового класса к типу указателя dp производного класса прошло успешно, поскольку указатель bp на самом де-ле указывает на объект производного класса Derived. Таким образом, после выполнения этого фрагмента программы на экране появится сообщение Приведение типов прошло успешно. Однако в следующем фрагменте опера-ция приведения типов заканчивается неудачей, поскольку указатель bp ука-зывает на объект базового класса Base, а приводить тип объекта базового класса к типу объекта производного класса неправильно. bp = Sb_ob; //указатель базового класса //указывает на объект базового класса dp = dynamic_cast<Derived *> (bp) if{!dp) cout "Приведения типов не произошло"; Поскольку попытка приведения типов закончилась неудачей, на экран будет выведено сообщение Приведения типов не произошло. Оператор dynamic_cast в некоторых случаях можно использовать вместо оператора typeid. Например, опять предположим, что Base - это базовый класс, a Derived - это класс, производный от класса Base. В следующем фрагменте указателю dp присваивается адрес объекта, на который указывает указатель bp, но только в том случае, если это действительно объект класса Derived.
370 Самоучитель C++ Base *bp; Derived *dp; //... if(typeid(*bp) == typeid(Derived)) dp = (Derived *) bp; В данном примере для фактического выполнения операции приведения ти-пов используется стиль языка С. Это безопасней, поскольку инструкция if с помощью оператора typeid проверяет правильность выполнения операции еще до того, как она действительно происходит. Тем не менее для этого есть более короткий путь. Оператор typeid с инструкцией if можно заменить опе-ратором dynamic cast: f М. - dp = dynamic_cast<Derived *> (bp) Поскольку оператор dynamic^cast заканчивается успешно только в том слу-чае, если объект, к которому применяется операция приведения типов, яв-ляется либо объектом целевого типа, либо объектом производного от целевого типа, то после выполнения приведенной выше инструкции указа-тель dp будет либо нулевым, либо указателем на объект типа Derived. Таким образом, оператор dynamic_cast успешно завершается только при правиль-ном приведении типов, а это значит, что в определенных ситуациях он мо-жет упростить логику программы. 1. В следующей программе продемонстрировано использование оператора dynamic_cast: //Использование оператора dynamic_cast ^include <iostream> using namespace std; class Base { public: virtual void f ( ) { cout " "Внутри класса Base"\n; } class Derived: public Base { public: void f ( ) { cout " "Внутри класса Derived"\n; } }; int main{) Base *bp, b_ob; Derived *dp, d ob;
Глава 12. Динамическая идентификация и приведение типов 371 dp = dynamic_cast<Derived *> (&d_ob); if(dp) { cout " "Тип Derived * к типу Derived * приведен успешно\п"; dp->f О; } else cout " "Ошибка\п"; cout " endl; bp = dynamic__cast<Base *> (&d_ob); if(bp) { cout " "Тип Derived * к типу Base * приведен успешно\п"; bp->f(); } else cout " "Ошибка\n"; cout " endl; bp = dynamic_cast<Base *> (&b_ob); if(bp) { cout " "Тип Base * к типу Base * приведен успешно\п"; bp->f(); } else cout " "ОшиОка\п"; cout " endl; dp = dynamic_cast<Derived *> (sb_ob); if (dp) { cout " "Ошибка\п"; } else cout " "Тип Base * к типу Derived * не приведен\п"; cout " endl; bp = &d_ob; //bp указывает на объект типа Derived dp = dynamic cast<Derived *> (bp); if(dp) { cout " "Указатель bp к типу Derived * приведен успешно\п" " "поскольку Ьр в действительности указывает\п" " "на объект типа Derived\n"; dp->f(); } else cout " "ОшибкаХп"; cout " endl; bp = &b_ob; //bp указьгаает на объект типа Base dp = dynamic_cast<Derived *> (bp); if(dp) cout " "Ошибка\п";
372 _ Самоучитель C++ else { cout " "Указатель Ьр к типу Derived * не приведен\п" " "поскольку Ьр в действительности указывает\п" " "на объект типа Вазе\п" ; cout " endl; dp = &d_ob; //dp указывает на объект типа Derived bp = dynamic_cast<Base *> (dp) ; if(bp) { cout " "Указатель dp к типу Base * приведен успешно\п" " bp->f ( } ; ) else cout " "Ошибка \n"; return 0; Программа выводит на экран следующую информацию: Тип Derived * к типу Derived * приведен успешно Внутри класса Derived Тип Derived * к типу Вазе * приведен успешно Внутри класса Derived Тип Base * к типу Derived * не приведен Указатель Ьр к типу Derived * приведен успешно поскольку Ьр в действительности указывает на объект типа Derived Внутри класса Derived Указатель Ьр к типу Derived * не приведен поскольку Ьр в действительности указывает на объект типа Вазе Указатель dp к типу Base * приведен успешно Внутри класса Derived 2. В следующем примере показано, как оператор typeid можно заменить опера-тором dynamic_cast. /* Использование оператора dynaraic_cast для замены оператора typeid */^include <iostream>
Глава 12. Динамическая идентификация и приведение типов 373 ^include <typeinfo> using namespace std; class Base { public: virtual void f() (} }; class Derived: public Base { public: void derivedOnly() { cout " "Это объект класса Derived"\n; int main() Base *bp, b_ob; Derived *dp, d_ob; //использование оператора typeid bp = &b_ob; if(typeid(*bp) = typeid(Derived)) { dp = (Derived *) bp; dp->derivedOnly(); } else cout " "Тип Base к типу Derived не приведен\п"; bp -&d_ob; if(typeid(*bp) == typeid(Derived)} { dp = (Derived *) bp; dp->derivedOnly(); } else cout " "Ошибка, приведение типов должно работать!\п"; //использование оператора dynamic_cast bp = Sb_ob; dp = dynarnic_cast<Derived *> (bp) ; if(dp) dp->derivedOnly(}; elsecout " "Тип Base к типу Derived не приведен\п"; bp = sd_ob; dp = dynamic_cast<Derived *> (bp);
374 Самоучитель if(dp) dp->derivedOnly{); elsecout " "Ошибка, приведение типов должно работать!\п"; return 0; Как видите, использование оператора dynamic_cast делает проще логику при-ведения типа указателя базового класса к типу указателя производного клас-са. После выполнения программы на экран будет выведена следующая информация: Тип Base к типу Derived не приведен Это объект класса Derived Тип Base к типу Derived не приведен Это объект класса Derived 3. Оператор dynamic_cast, как и оператор typeid, можно использовать с класса-ми-шаблонами. Например, в следующем примере представлен переработан-ный класс-шаблон из примера 5 раздела 12.1. Здесь тип объекта, возвращаемый функцией genegator(), определяется с помощью оператора dynamic_cast. //Использование оператора dynamic_cast с шаблонами ^include <iostream> ^include <cstdlib> ^include <cmath> #include <typeinfo> using namespace std; template <class T> class Num { public: Т x; Num(T i) { x = i; } virtual Т get_val() { return x; } template <class T> class Squary: public Num<T> { public: Squary(T i): Num<T>(i) {} Т get_val() { return x*x; } 1; template <class T> class Sqr_root: public Num<T> { public: Sqr_root(T i): Num<T>{i} (} Т get_val(} { return sqrt((double) x}; }
Глава 12. Динамическая идентификаций и приведение типов 375 //Фабрика производных от класса Num объектов Num<double> *generator() switch(rand() % 2) { case 0: return new Squary<double> (randf) % 100); case 1: return new Sqr_root<double> (rand() % 100}; return NULL; int main() Num<double> obl(lO), *pl; Squary<double> ob2 (100.0), *p2; Sqr_root<double> ob3(999.2), *p3; int i; cout " "Генерируем несколько объектов\п"; for(i=0; i<10; i++) { pi = generator ( } ; p2 = dynamic_cast<Squary<double> *> (pi); if(p2) cout " "Квадрат объекта: "; рЗ = dynamic_cast<Sqr_root<double> *> (pi); if(p3) cout " "Квадратный корень объекта: cout " "Значение равно: " " pl->get_val {) cout " endl; }return 0; 1. Своими словами объясните назначение оператора dynamic_cast. 2. Дан следующий фрагмент программы. Покажите, как с помощью оператора dynamic_cast сделать так, чтобы указатель р указывал на некоторый объект ob только в том случае, если объект ob является объектом типа D2. class В { virtual void f ( ) {} }; class Dl: public В { void f ( } {} };
376 Самоучитель C++ class D2 : public В { void f { ) {} 3. Переделайте функцию main() из раздела 12.1, упражнение 4 так, чтобы для запрещения вывода на экран объектов типа NuMShape использовался не опе-ратор typeid, а оператор dynamic_cast. 4. Будет ли работоспособен следующий фрагмент программы в иерархии клас-сов с базовым классом Num из примера 3 этого раздела? Num<int> *Вр; Square<double> *Dp; Dp = dynamic cast<Num<int" (Bp) ; 12.3. Операторы const_cast, reinterpret_cast и staticjcast Хотя оператор dynamic_cast самый полезный из новых операторов приведе ния типов, кроме него программистам доступны еще три. Ниже представле-ны их основные формы: сопз1:_сазЬ<целевой_тяп> (выражение) _ _ (выражение) static_cast<4&neBa#__!TJim> (выражение) Здесь целевой_тип - это тип, которым должен стать тип параметра выраже-ние после выполнения операции приведения типов. Как правило, указанные операторы обеспечивают более безопасный и интуитивно понятный способ выполнения некоторых видов операций преобразования, чем оператор при-ведения типов, более характерный для языка С. Оператор const_cast при выполнении операции приведения типов использу-ется для явной подмены атрибутов const (постоянный) и/или volatile (переменный). Целевой тип должен совпадать с исходным типом, за исклю-чением изменения его атрибутов const или volatile. Обычно с помощью опе-ратора const_cast значение лишают атрибута const. Оператор static_cast предназначен для выполнения операций приведения типов над объектами неполиморфных классов. Например, его можно ис-пользовать для приведения типа указателя базового класса к типу указателя производного класса. Кроме этого, он подойдет и для выполнения любой
Глава 12. Динамическая идентификация и приведение типов 377 стандартной операции преобразования, но только не в динамическом режи-ме (т. е. не во время выполнения программы). Оператор reinterpret_cast дает возможность преобразовать указатель одного типа в указатель совершенно другого типа. Он также позволяет приводить указатель к типу целого и целое к типу указателя. Оператор reinterpret_cast следует использовать для выполнения операции приведения внутренне не-совместимых типов указателей. Атрибута const объект можно лишить только с помощью оператора const_cast. С помощью оператора dynamic_cast, static_cast или reinterpret_cast этого сделать нельзя. Примеррыы ] 1. В с>лед^ующей программе демонстрируется использование оператора reinterpret_cast. //Пример использования оператора reinterpret_cast ttinclude <iostream> using namespace std; int main{) { int i ; char *p = "Это строка"; //приведение типа указателя к типу целого i = reinterpret_cast<int> (p} ; cout " i; return 0; В данной программе с помощью оператора reinterpret_cast указатель на стро-ку превращен в целое. Это фундаментальное преобразование типа и оно хо-рошо отражает возможности оператора reinterpret_cast. 2. В следующей программе демонстрируется оператор const_cast //Пример использования оператора const_cast #include <iostream> using namespace std; void f (const int *p) { int *v;
378 Самоучитель C++ 11 преобразование типа лишает указатель р атрибута const v = const_cast<int *> (р); *v = 100; //теперь указатель v может изменить объект I int main() { int x = 99; cout " "Объект х перед вызовом функции равен: " " х " endl; f(&x); cout " "Объект х после вызова функции равен: " " х " endl; return 0; Ниже представлен результат выполнения программы: Объект х перед вызовом функции равен: 99 Объект х после вызова функции равен: 100 Как видите, несмотря на то что параметром функции f() задан постоянный указатель, вызов этой функции с объектом х в качестве параметра изменил значение объекта. Возможность снятия оператором constjcast атрибута const при выполнении операция приведения типов потенциально очень опасна. Пользоваться этой возможностью следует с величайшей осторожностью. 3. Оператор static_cast, по существу, предназначен для замены прежнего опера-тора приведения типов. Он просто выполняет операцию приведения типов над объектами неполиморфных классов. Например, в следующей программе тип float приводится к типу int. //Пример использования оператора static__cast ^include <iostream> using namespace std; int main(} { int i; float f; f = 199.22; i = static cast<int> ( f } j
Глава 12. Динамическая идентификация и приведение типов 379 cout " i; return 0; Упражнения 1. Объясните, зачем нужны операторы const_cast, reinterpret_cast и static^cast. 2. В следующей программе имеется ошибка. Исправьте ее с помощью операто-ра const_cast. #include <iostream> using namespace std; void f (const double &i) { i = 100; //Ошибка! Исправьте ее с помощью оператора const_cast I int main() { double x = 98.6; cout " x " endl; f (x); cout " x " endl; return 0; 1 3. Объясните, почему оператор const_cast следует использовать только в самых крайних случаях. Проверка усвоения материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы. 1. Опишите операции, которые можно выполнить с помощью оператора typeid. 2. Какой заголовок нужно включить в вашу программу для использования оператора typeid?
380 Самоучитель C++ 3. Помимо стандартного приведения типов, в C++ определено для этой це-ли еще четыре оператора. Что это за операторы и зачем они нужны? 4. Допишите следующую программу, чтобы на экран выводилась информа-ция о выбранном пользователем типе объекта. ^include <iostream> #include <typeinfo> using namespace std; : class A { virtual void f(} {} class B: public A { class C: public В { int main{) A *p, a_ob; В b_ob; С c_ob; int i; cout " "Введите О для объектов типа А,"; cout " "1 для объектов типа В или"; cout " "2 для объектов типа С.\п"; cin " i; if (i-=l> p = &b_ob; else if (i==2) p = Sc_ob; else p = &a__ob; //выведите на экран сообщение о типе //выбранного пользователем объекта return 0; 5. Объясните, каким образом оператор typeid можно иногда заменить опе-ратором dynamic_cast 6. Тип какого объекта можно определить с помощью оператора typeid?
Глава 12. Динамическая идентификация и приведение типов 35? Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Переделайте программу из раздела 12.1, пример 4, чтобы возможную ошибку выделения памяти внутри функции generator() отслеживать с по-мощью механизма обработки исключительных ситуаций. 2. Измените функцию generator() из вопроса 1, чтобы в ней использовать версию оператора new с ключевым словом nothrow. 3. Особо сложное задание: попытайтесь создать иерархию классов с абст-рактным классом DataStruct на ее вершине. В основании иерархии соз-дайте два производных класса. В одном должен быть реализован стек, в другом - очередь. Создайте также функцию DataStructFactoryQ со сле-дующим прототипом: DataStruct *DataStructFactory(char метка); Функция DataStructFactoryO должна создавать стек, если параметр мет-ка равен s, и очередь, если параметр метка равен q. Возвращаемым зна-чением функции должен быть указатель на созданный объект. Покажите, что ваша "фабрика объектов" работает.
Глава 13 Пространства имен и другие темы В этой главе рассказывается о пространствах имен (namespaces), функциях преобразования (conversion functions), статических (static) и постоянных (const) членах класса, а также о других необычных инструментах C++. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Что собой представляют новые операторы приведения типов и для чего они используются? 2. Что собой представляет класс typejnfo? 3. С помощью какого оператора определяют тип объекта? 4. Дан следующий фрагмент программы. Покажите, как определить, объек-том какого типа является указатель р: объектом типа Base или объектом типа Derived. class Base { virtual void f ( ) {} class Derived: public Base ( }t int main() Base *p, b_ob; Derived d ob; 5. Оператор dynamic_cast успешно завершается только в том случае, если объект, над которым выполняется операция приведения типов, является
384 Самоучитель либо объектом целевого типа, либо объектом от целевого типа. (Вставьте нужное слово.) 6. Можно ли с помощью оператора dynamic_cast снять атрибут const? 13.1. Пространства имен О пространствах имен коротко было рассказано в главе 1, сейчас мы рас-смотрим это понятие более подробно. Пространства имен появились в C++ относительно недавно. Они предназначены для локализации имен иденти-фикаторов во избежание конфликтов имен (name collisions). В среде про-граммирования C++ сосуществует невероятное количество имен перемен-ных, функций и классов. До введения понятия пространств имен все эти имена находились в одном глобальном пространстве имен и возникало множество конфликтов. Например, если вы в своей программе определяли функцию toupperQ, то она могла бы (в зависимости от списка своих пара-метров) подменить стандартную библиотечную функцию (oupperO, посколь-ку имена обеих функций хранились бы в одном глобальном пространстве имен. Конфликты имен имеют место, когда в одной и той же программе используются библиотеки функций и классов разных производителей. В этом случае вполне возможно - и даже очень вероятно, - что имена, оп-ределенные в одной библиотеке, будут конфликтовать с теми же именами, но определенными в другой библиотеке. Все проблемы решило введение понятия пространств имен и ключевого слова namespace. Это ключевое слово позволяет локализовать область види-мости имен, объявленных в данном пространстве имен. Пространство имен дает возможность использовать одно и то же имя в разных контекстах и при этом почвы для конфликтов не возникает. Вероятно, больше всего выиграла от введения пространств имен стандартная библиотека C++ (C++ standard library). В ранних версиях языка вся библиотека C++ определялась в гло-бальном пространстве имен. Теперь библиотека C++ определяется в собст-венном пространстве имен std, что значительно снижает вероятность кон-фликтов имен. Вы также можете создавать в программе свои собственные пространства имен, чтобы локализовать область видимости тех имен, кото-рые, по вашему мнению, могли бы вызывать конфликты. Это особенно важно при создании собственных библиотек классов или функций. Ключевое слово namespace путем объявления именованных областей дает возможность разделить глобальное пространство имен. По существу, про-странство имен определяет область видимости. Ниже приведена основная форма использования ключевого слова namespace: namespace имя { I/объявления
Глава 13. Пространства имен и другие темы 355 Все, что определено внутри инструкции namespace, находится внутри облас-ти видимости данного пространства имен. Ниже приведен пример объявления пространства имен MyNameSpace: namespace MyNameSpace { int i, k; void myfunc(int j) { cout " j; } class myclass { public: void seti(int x) { i = x; } int geti{) { return i; } Здесь имена переменных i и k, функции myfunc(), а также класса myclass находятся в области видимости, определенной пространством имен My-NameSpace. К идентификаторам, объявленным в пространстве имен, внутри этого про-странства можно обращаться напрямую. Например, в пространстве имен MyNameSpace в инструкции return i переменная i указана явно. Однако по-скольку ключевое слово namespace определяет некоторую область видимо-сти, то при обращении извне пространства имен к объектам, объявленным внутри этого пространства, следует указывать оператор расширения области видимости. Например, чтобы присвоить значение 10 переменной i в той части программы, которая не входит в пространство имен MyNameSpace, необходимо использовать следующую инструкцию: MyNameSpace::i = 10; А чтобы объявить объект типа myclass в той части программы, которая не входит в пространство имен MyNameSpace, нужна такая инструкция: MyNameSpace:imyclass ob; Таким образом, для доступа к члену пространства имен извне этого про-странства перед именем члена следует указать имя пространства имен с оператором расширения области видимости. Можно себе вообразить, что если в вашей программе обращения к членам пространства имен происходят достаточно часто, необходимость каждый раз указывать имя пространства имен и оператор расширения области видимо-сти может быстро надоесть. Для решения этой проблемы была разработана инструкция using. У этой инструкции имеются две основные формы: using namespace имя; using имя; .-член;
386 Самоучитель C++ В первой форме параметр имя задает имя пространства имен, доступ к ко-торому вы хотите получить. При использовании этой формы инструкции using все члены, определенные в указанном пространстве имен, становятся доступными в текущем пространстве имен и с ними можно работать напря-мую, без необходимости каждый раз указывать имя пространства и оператор расширения области видимости. При использовании второй формы инст-рукции using видимым делается только указанный в инструкции член про-странства имен. Например, пусть у нас имеется описанное выше простран-ство имен MyNameSpace, тогда правильны все представленные ниже инст-рукции using и операторы присваивания: using MyNameSpace::k; //видимой делается только переменная k k = 10; //инструкция правильна, поскольку переменная k видима using namespace MyNameSpace; //видимыми делаются все члены //пространства имен MyNameSpace i = 10; //инструкция правильна, поскольку видимы все члены //пространства имен MyNameSpace Имеется возможность объявить более одного пространства имен с одним и тем же именем. Это позволяет разделить пространство имен на несколько файлов или даже разделить пространство имен внутри одного файла. Рас-смотрим следующий пример: namespace NS { int i; namespace NS { int j ; Здесь пространство имен NS разделено на две части. Несмотря на это, со-держимое каждой части по-прежнему остается в одном и том же простран-стве имен - пространстве NS. Пространство имен должно объявляться вне всех остальных областей види-мости за исключением того, что одно пространство имен может быть вло-жено в другое. То есть вложенным пространство имен может быть только в другое пространство имен, но не в какую бы то ни было иную область ви-димости. Это означает, что нельзя объявлять пространства имен, например, внутри функции. Имеется пространство имен особого типа - безымянное пространство имен (unnamed namespace). Безымянное пространство имен позволяет создавать идентификаторы, являющиеся уникальными внутри некоторого файла. Ни-же представлена основная форма безымянного пространства имен:
Глава 13. Пространства имен и другие темы 357 namespace { //объявления Безымянные пространства имен дают возможность задавать уникальные идентификаторы, известные только внутри области видимости одного фай-ла. Таким образом, внутри файла, содержащего безымянное пространство имен, к членам этого пространства можно обращаться напрямую, без необ-ходимости каких бы то ни было уточнений. Но вне этого файла такие иден-тификаторы неизвестны. Вам вряд ли понадобится создавать свои пространства имен для небольших и средних по объему программ. Однако, если вы собираетесь создавать биб-лиотеки функций или классов, предназначенных для многократного исполь-зования, или хотите гарантировать своим программам широкую переноси-мость, вам следует рассмотреть возможность размещения своих кодов внут-ри некоторого пространства имен. 1. В представленном ниже примере иллюстрируются атрибуты демонстрацион-ных пространств имен. //Демонстрационные пространства имен #include <iostream> using namespace std; //определение первого пространства имен namespace firstNS { class demo ( int i; public: demo(int x) ( i = x; } void seti(int x) { i = x; } int geti() { return i; J char str[] = "Иллюстрация пространств имен\п int counter; )//определение второго пространства имен namespace secondNS { int x, у; } int main{}
388 Самоучитель C++ I/расширяем область видимости firstNS::demo ob(10); /* После объявления объекта ob, его функции-члены могут использоваться прямо, без какого бы то ни было уточнения пространства имен */cout " "Значение объекта ob равно: " " ob.geti(); cout " endl; ob.seti(99); cout " "Теперь значение объекта ob равно: " " ob.getif); cout " endl; //вводим строку str в текущую область видимости using firstNS::str; cout " str; //вводим все пространство имен firstNS //в текущую область видимости using namespace firstNS; for(counter=10; counter; counter-) cout " counter " " "; cout " endl; //используем пространство имен secondNS secondNS::x = 10; secondNS::y = 20; cout " "Переменные x, у равны: " " secondNS::x; cout " ", " " secondNS::y " endl; //вводим все пространство имен secondNS //в текущую область видимости using namespace secondNS; demo xob{x), yob(y); : cout " "Значения объектов xob, yob равны: " " xob.geti() cout " ", " " yob.getiU " endl; return 0; После выполнения программы на экран будет выведено следующее: Значение объекта ob равно: 10 Теперь значение объекта ob равно: 99 Иллюстрация пространств имен 10 9 8 7 6 5 4 3 2 1 Переменные х, у равны: 10, 20 Значения объектов xob, yob равны: 10, 20
Глава 1 3. Пространства имен и другие темы _ 359 Программа иллюстрирует одно важное положение: при совместном исполь-зовании нескольких пространств имен одно пространство не подменяет другое. Когда вы вводите некоторое пространство имен в текущую область видимости, его имена просто добавляются в эту область, независимо от того, находятся ли в ней в это время имена из других пространств имен. Таким образом, ко времени завершения программы в глобальное пространство имен были добавлены пространства имен std, firstNS и secondNs. 2. Как уже упоминалось, пространство имен можно разделить либо между фай-лами, либо внутри одного файла, тогда содержимое этого пространства имен объединяется. Рассмотрим пример объединения разделенного пространства имен. //Объединение пространства имен ^include <iostreara> using namespace std; namespace Demo { int a; //объявление переменной а в пространстве имен Demo int x; //объявление переменной х в глобальном пространстве имен namespace Demo { int b; //объявление переменной Ь в пространстве имен Demo 'int rnain{) /using namespace Demo; a = b = x = 100; cout " a " " " " b " " " " x; return 0; В данном примере обе переменные, а и b, оказались в одном пространстве имен - пространстве имен Demo, а переменная х осталась в глобальном пространстве имен. 3. Как уже упоминалось, стандарт Standard C++ определяет целую библиотеку в собственном пространстве имен std. Именно по этой причине во всех программах этой книги имеется следующая инструкция: using namespace std; Эта инструкция делает пространство имен std текущим, что позволяет полу-чить прямой доступ к именам функции и классов, определенных в библиоте-ке языка Standard C++, без необходимости каждый раз с помощью оператора
390 Самоучитель С++ расширения области видимости уточнять, что используется пространство имен std. Тем не менее, если пожелаете, можете перед каждым идентификатором ставить имя пространства имен std и оператор расширения области видимости -ошибки не будет. Например, в следующей программе библиотека языка Standard C++ не введена в глобальную область видимости. //Явное задание используемого пространства имен ^include <iostream> int main () double val; std::cout " "Введите число: "; std; :cin " val; std::cout " "Вот ваше число: "; std::cout " val; return 0; Как показано в данной программе, чтобы воспользоваться стандартными потоками ввода и вывода cin и cout, перед именами этих потоков необходимо явно указывать их пространство имен. Если в вашей программе не предусмотрено широкое использование библио-теки языка Standard C++, вы можете не вводить пространство имен std в глобальную область видимости. Однако, если в вашей программе содержатся тысячи ссылок на стандартные библиотечные имена, включить в программу идентификатор std гораздо проще, чем добавлять его чуть ли не к каждой инструкции. 4. Если в своей программе вы используете только несколько имен из стандарт-ной библиотеки, может оказаться удобней с помощью инструкции using от-дельно задать эти несколько имен. Преимущество такого подхода в том, что указанные имена можно вносить в программу без необходимости их уточне-ния, и в то же время не нужно вводить всю стандартную библиотеку в гло-бальное пространство имен. Рассмотрим пример: //Введение в глобальное пространство только нескольких имен ^include <iostream> //обеспечение доступа к потокам cin и cout using std::cout; using std: :cin; int main() { double val;
Глава 13. Пространства имен и другие темы 391 cout " "Введите число: "; cin " val; cout " "Вот ваше число: "; cout " val; return 0; Здесь стандартными потоками ввода и вывода cin и cout можно пользоваться напрямую, но в то же время остальные имена из пространства имен std ос-тавлены вне текущей области видимости. 5. Ранее уже говорилось, что библиотека исходного языка C++ была определе-на в глобальном пространстве имен. Если вам придется модернизировать старую программу на C++, то вам понадобится либо включить в нее инст-рукцию using namespace std, либо перед каждой ссылкой на члена библиотеки дописывать имя пространства имен с оператором расширения области види-мости std::. Это особенно важно, если вы замените прежние заголовочные файлы заголовками нового стиля (без расширения -h). Помните, прежние заголовочные файлы размещают свое содержимое в глобальном пространстве имен, а заголовки нового стиля - в пространстве имен std. 6. В языке С, если вы хотите ограничить область видимости глобального имени только тем файлом, в котором это имя объявлено, вы должны объявить его как статическое, т. е. с идентификатором static. Например, предположим, что следующие два файла являются частью одной программы: Первый файл static int counter; void fl() { counter = 99; //OK Второй файл extern int counter; void f 2 ( ) { counter =10; //Ошибка Поскольку переменная counter определена в первом файле, то и использовать ее можно в первом файле. Во втором файле, несмотря на указание в инст-рукции с переменной counter идентификатора extern, попытка использования этой переменной ведет к ошибке. Объявляя в первом файле переменную counter статической, мы ограничиваем ее область видимости этим файлом. Хотя объявления глобальных переменных с идентификатором static в C++ по-прежнему доступны, для достижения той же цели здесь имеется лучший путь - использовать, как показано в следующем примере, безымянное про-странство имен. Первый файл namespace { int counter; 1 void f l ( ) { counter = 99; //OK Второй файл extern int counter; void f 2 ( ) { counter = 10; //Ошибка
392 Самоучитель C++ Здесь область видимости переменной counter также ограничена первым фай-лом. Использовать безымянное пространство имен вместо ключевого слова static рекомендует новый стандарт Standard C++. I. Переделайте представленную ниже программу из главы 9 так, чтобы в ней отсутствовала инструкция using namespace std. //Превращение пробелов в вертикальные линии | ftinclude <iostream> ^include <fstream> using namespace std; : int main{int argc, char *argv[]) ( if(argc!=3) { cout " "Преобразование <файл ввода> <файл вывода>\п"; return 1; ifstrearn fin (argvfl]); //открытие файла для ввода ofstreara fout(argv[2]); //создание файла для вывода if{!fout} { cout " "Файл открыть невозможно\п"; return 1; } if(!fin) { cout " "Файл открыть невоэможно\п"; return 1; }char ch; fin.unsetf(ios::skipws); //не пропускать пробелы while{!fin.eof{)) { fin " ch; if(ch==' ') ch = '|'; if (!fin.eof()) fout " ch; fin.close(); fout.close(); return 0; }
Глава 13. Пространства имен и другие темы 393 2. Объясните назначение безымянного пространства имен. 3. Опишите различия между двумя формами инструкции using. 4. Объясните, почему в подавляющее большинство программ данной книги введена инструкция using. Приведите альтернативу ее использованию. 5. Объясните почему, если вы создаете многократно используемый код, его же-лательно размещать в собственном пространстве имен. 13.2. функции преобразования Иногда бывает полезно преобразовать объект одного типа в объект другого типа. Хотя для этого можно воспользоваться перегруженной оператор-функцией, часто более легким (и лучшим) способом такого преобразования является функция преобразования. Функция преобразования (conversion function) преобразует объект в значение, совместимое с другим типом дан-ных, который часто является одним из встроенных типов данных C++. Уточним, функция преобразования автоматически преобразует объект в зна-чение, совместимое с типом выражения, в котором этот объект используется. Здесь показана основная форма функции преобразования: :: operator тип () { return значение; } Здесь тип - это целевой тип преобразования, а значение - это значение объекта после выполнения преобразования. Функции преобразования воз-вращают значение типа тип. У функции преобразования не должно быть параметров, и она должна быть членом класса, для которого выполняется преобразование. Как будет показано в примерах, обычно функция преобразования обеспечи-вает более ясный подход к преобразованию значения объекта в другой тип, чем любой другой метод C++, поскольку она позволяет явно включить объ-ект в выражение, содержащее переменные целевого типа. В следующей программе класс coord содержит функцию преобразования, которая преобразует объект в целое. В данном случае функция возвращает произведение двух координат; однако в каждом конкретном случае допуска-ется любое необходимое действие. //Простой пример функции преобразования ttinclude <iostream> using namespace std;
394 __ Самоучитель C++ class coord { int x, у; public: coord{int i, int j) { x = i; у = j; } operator int{) { return x*y; } //функция преобразования int main() coord ol(2, 3), o2(4, 3) ; int i; i = ol; //объект ol автоматически преобразуется в целое cout " i " '\n'; i = 100 4 o2; //объект о2 преобразуется в целое cout " i " '\n'; return 0; В результате выполнения этой программы на экран будут выведены значения 6 и 112. Обратите внимание, что функция преобразования вызывается тогда, когда объект ol присваивается целому, а также когда объект о2 используется, как часть большого выражения, оперирующего с целыми. Как уже установлено, с помощью функции преобразования вы разрешаете вставлять объекты соз-данных вами классов в "обычные" выражения, без образования сложных це-почек перегруженных оператор-функций. 2. Следующим представлен другой пример функции преобразования. Здесь преобразуется строка типа strtype в символьный указатель на str. ttinclude <iostream> ^include <cstring> using namespace std; class strtype { char str[80] ; int len; public: strtype [char *s) { strcpy(str, s); len = strlen(s); } operator char *() { return str; } //преобразование в тип char * int main() { strtype з{"Это проверка \n" }; char *p, s2[80J;
Глава 13. Пространства имен и другие темы _ 395_ р = s; //преобразование в тип char * cout " "Это строка: " " р " '\п'; //при вызове функции преобразуется в тип char * strcpy{s2, s) ; cout " "Это копия строки: " " s2 " '\n'; -return 0; Эта программа выводит на экран следующее: Это строка: Это проверка Это копия строки: Это проверка Как можно заметить, функция преобразования вызывается не только при присваивании объекта s объекту р (который имеет тип char *), но она также используется как параметр для функции strcpy(). Вспомните, функция strcpyO имеет следующий прототип: char *strcpy(char *sl, const char *s2) ; Поскольку прототип определяет, что объект s2 имеет тип char *, функция преобразования объекта в тип char * вызывается автоматически. Этот пример показывает, как функция преобразования может помочь интегрировать ваши классы в библиотеку стандартных функций C++. Упражнения) 1. Используя класс strtype из примера 2, создайте функцию преобразования для превращения строки в целое. Функция преобразования должна возвращать длину строки, хранящейся в str. Покажите, что ваша функция преобразова-ния работает. 2. Пусть дан класс: class pwr ( int base; int exp; public: pwr{int b, int e) { base = b; exp = e; } //здесь создайте функцию преобразования в целое 3. Создайте функцию преобразования для превращения объекта типа pwr в це-лое. Функция должна возвращать результат возведения в степень baseexp.
396 Самоучитель C++ 13.3. Статические члены класса Переменные - члены класса можно объявлять как статические (static). Ис-пользуя статические переменные-члены, можно решить несколько непро-стых проблем. Если вы объявляете переменную статической, то может суще-ствовать только одна копия этой переменной - независимо от того, сколько объектов данного класса создается. Каждый объект просто использует (совместно с другими) эту одну переменную. Запомните, для обычных пе-ременных-членов при создании каждого объекта создается их новая копия, и доступ к каждой копии возможен только через этот объект. (Таким обра-зом, для обычных переменных каждый объект обладает собственными ко-пиями переменных.) С другой стороны, имеется только одна копия статиче-ской переменной - члена класса, и все объекты класса используют ее со-вместно. Кроме этого, одна и та же статическая переменная будет использоваться всеми классами, производными от класса, в котором эта статическая переменная содержится. Может показаться необычным то, что статическая переменная - член клас-са создается еще до того, как создан объект этого класса. По сути, статиче-ский член класса - это просто глобальная переменная, область видимости которой ограничена классом, в котором она объявлена. В результате, как вы узнаете из следующих примеров, доступ к статической переменной-члену возможен без всякой связи с каким бы то ни было объектом. Когда вы объявляете статические данные-члены внутри класса, вы не опре-деляете их. Определить их вы должны где-нибудь вне класса. Для того чтобы указать, к какому классу статическая переменная принадлежит, вам необходимо переобъявить (redeclare) ее, используя операцию расширения области видимости. Все статические переменные-члены по умолчанию инициализируются ну-лем. Однако, если это необходимо, статической переменной класса можно дать любое выбранное начальное значение. Запомните, что основной смысл поддержки в C++ статических перемен-ных-членов состоит в том, что благодаря им отпадает необходимость в ис-пользовании глобальных переменных. Как можно предположить, если при работе с классами задавать глобальные переменные, то это почти всегда на-рушает принцип инкапсуляции, являющийся фундаментальным принципом OOP и C++. Помимо переменных-членов статическими можно объявлять и функции-члены, но обычно это не делается. Доступ к объявленной статической функции - члену класса возможен только для других статических членов этого класса. (Естественно, что доступ к объявленной статической функ-ции - члену класса возможен также и для глобальных данных и функций.) У статической функции-члена нет указателя this. Статические функции-члены не могут быть виртуальными. Статические функции-члены не могут
Глава 13. Пространства имен и другие темы 397 объявляться с идентификаторами const (постоянный) и volatile (перемен-ный). И наконец, статические функции - члены класса могут вызываться любым объектом этого класса, а также через имя класса и оператор расши-рения области видимости без всякой связи с каким бы то ни было объектом этого класса. Примерь! "":^igj^ 1. Простой пример использования статической переменной-члена. //Пример статической переменной-члена ttinclude <iostream> using namespace std; class myclass { static int i; public: void seti(int n) { i = n; } int geti(} { return i; } //Определение myclass: :i. Переменная i по-прежнему //остается закрытым членом класса myclass int myclass : :i; int main() { myclass ol, o2; ol.seti(lO); cout " "ol.i: " " ol.getiO " T\n'; //выводит значение 10 cout " "o2.i: " " o2.geti() " '\np; //также выводит 10 return 0; После выполнения программы на экране появится следующее: ol.i: 10 o2.i: 10 Глядя на программу, можно заметить, что фактически только для объекта ol устанавливается значение статической переменной-члена i. Однако посколь-ку переменная i совместно используется объектами ol и о2 (и, на самом де-ле, всеми объектами типа myclass), оба вызова функции geti() дают один и тот же результат.
398 Самоучитель C++ Обратите внимание, что переменная i объявляется внутри класса myclass, но определяется вне его. Этот второй шаг гарантирует, что для переменной i бу-дет выделена память. С технической точки зрения, определение класса явля-ется всего лишь определением типа и не более. Память для статической пе-ременной при этом не выделяется. Поэтому для вьщеления памяти статиче-ской переменной-члену требуется ее явное определение, 2. Поскольку статическая переменная - член класса существует еще до созда-ния объекта этого класса, доступ к ней в программе может быть реализован без всякого объекта. Например, в следующем варианте предыдущей про-граммы для статической переменной i устанавливается значение 100 без вся-кой ссылки на конкретный объект. Обратите внимание на использование оператора расширения области видимости для доступа к переменной i. //Для обращения к статической переменной объект не нужен tfinclude <iostream> using namespace std; class myclass { public: static int i; void seti{int n) { i = n; } int geti() { return i; } int myclass::i; int main () myclass ol, o2; //непосредственное задание значения переменной i myclass::! = 100; //объекты не упоминаются cout " "ol.i: " " ol.geti() " '\n'; //выводит 100 cout " "o2.i: " " o2.geti{) " '\n'; //также выводит 100 return 0; } Так как статической переменной i присвоено значение 100, программа выво-дит на экран следующее: ol.i: 100 o2.i: 100 3. Традиционным использованием статических переменных класса является координация доступа к разделяемым ресурсам, таким как дисковая память, принтер или сетевой сервер. Как вы уже, вероятно, знаете из своего опыта, координация доступа к разделяемым ресурсам требует некоторых знаний о
Глава 13. Пространства имен и_другие темы 399 последовательности событий. Чтобы понять, как с помощью статических пе-ременных-членов можно управлять доступом к разделяемым ресурсам, изу-чите следующую программу. В ней создается класс output, который поддер-живает общий выходной буфер outbnf, являющийся статическим символьным массивом. Этот буфер используется для получения выходной информации, передаваемой функцией-членом outbuf(). Эта функция посимвольно передает содержимое строки str. Сначала функция запрашивает доступ к буферу, а за-тем передает в него все символы str. Функция предотвращает доступ в буфер другим объектам до окончания вывода. Понять работу программы можно по комментариям к ней. //Пример разделения ресурсов ttinclude <iostream> ^include <cstring> using namespace std; class output { static char outbuf[255]; //это разделяемые ресурсы static int inuse; //если переменная inuse равна О, //буфер доступен; иначе - нет static int oindex; //индекс буфера char atr[80]; int i; //индекс следующего символа строки int who; //идентификатор объекта должен быть положительным public: output(int w, char *s) { strcpy(strr s); i = 0; who = w; } /* Эта функция возвращает -1 при ожидании буфера; 0 - при завершении вывода; who - если буфер все еще используется. */int putbuf() { if(!str[i]) { //вывод завершен inuse =0; //освобождение буфера return 0; //признак завершения }if (!inuse) inuse = who; //захват буфера if(inuse != who) return -1; //буфер кто-то использует if(str[i]) { //символы еще остались outbuf[oindex] = str[i]; i++; oindex++; outbuf[oindex] = '\0'; //последним всегда идет нуль return 1; return 0;
400 Самоучитель C++ void show() { cout " outbuf " '\n';} }; char output::outbuf[255]; //это разделяемые ресурсы int output::inuse = 0; //если переменная inuse равна О, //буфер доступен; иначе - нет int output::oindex = 0; //индекс буфера int main() { output ol(l, "Это проверка "), о2{2, "статических переменных"); while (ol.putbuf{) I o2.putbuf()); //вывод символов ol.show() ; return 0; 4. Статические функции-члены применяются достаточно редко, но для предва-рительной (до создания реального объекта) инициализации закрытых стати-ческих данных-членов они могут оказаться очень удобными. Например, ни-же представлена совершенно правильная программа. ^include <iostream> using namespace std; class static__func_demo { static int i; public: static void init(int x) { i = x; J void show() { cout " i; } }; int static_func_demo::i; //определение переменной i int main() ( //инициализация статических данных еще до создания объекта static_func_demo::init(100); static_func_demo x; x.show{); //вывод на экран значения 100 return 0; Здесь вызов функции init() инициализирует переменную i еще до создания объекта типа static func demo.
Глава 13. Пространства имен и другие темы 40 J Упражнеенниияя] 1. Переделайте пример 3 так, чтобы на экране отображался тот объект, который осуществляет вывод символов, и тот объект или те объекты, для которых из-за занятости буфера вывод запрещен. 2. Одним из интересных применений статических переменных-членов является хранение информации о количестве объектов класса, существующих в каж-дый конкретный момент времени. Для этого необходимо увеличивать на единицу статическую переменную-член каждый раз, когда вызывается конст-руктор класса, и уменьшать на единицу, когда вызывается деструктор. Реали-зуйте эту схему и продемонстрируйте ее работу. 13.4. Постоянные и модифицируемые члены класса Функции - члены класса могут объявляться постоянными (с идентифика-тором const). Если функция объявлена постоянной, она не может изменить вызывающий ее объект. Кроме этого, постоянный объект не может вызвать непостоянную функцию-член. Тем не менее, постоянная функция-член мо-жет вызываться как постоянными, так и непостоянными объектами. Для задания постоянной функции-члена используйте ее форму, представ-ленную в следующем примере: class X { int some_var; public: :int fl() const; //постоянная функция-член Обратите внимание, что ключевое слово const указывают следом за списком параметров функции, а не перед именем функции. Возможна ситуация, когда вам понадобится, чтобы функция-член, оставаясь постоянной, тем не менее была способна изменить один или несколько членов класса. Это достигается заданием модифицируемых членов класса (ключевое слово mutable). Модифицируемый член класса можно изменить с помощью постоянной функции-члена. 1. Функция-член объявляется постоянной, чтобы предотвратить возможность изменения вызвавшего ее объекта. Для примера рассмотрим следующую программу.
402 _ Самоучитель C++ /* Пример объявления постоянных функций-членов. Данная программа содержит ошибку и компилироваться не Судет */#include <iostream> using namespace std; class Demo { int i; public: int geti () const ( return i; //здесь все правильно } void seti{int x) const { i = x; //Ошибка! ! ! int main ( ) Demo ob; ob.seti(1900) ; cout " ob.getif); return 0; Данная программа не будет компилироваться, поскольку функция-член seti() объявлена постоянной, что означает невозможность изменения вызывающего ее объекта. Таким образом, попытка изменения функцией переменной i ве-дет к ошибке. С другой стороны, поскольку функция geti() не меняет пере-менной i, она совершенно правильна. 2. Чтобы допустить изменение избранных членов класса постоянной функцией-членом, они задаются модифицируемыми. Ниже представлен пример. //Пример задания модифицируемого члена класса #include <iostream> using namespace std; class Demo { mutable int i; int j ; public: int geti() const { return i; //здесь все правильно } void seti(int x) const { i = x; //теперь все правильно
Глава 13. Пространства имен и другие темы _ 403 /* Если убрать комментарии вокруг этой функции, то программа компилироваться не Судет void setj (int x) const { j = x; //здесь прежняя ошибка } */int main () { Demo ob; ob.seti(1900) ; cout " ob.geti () ; return 0; I Здесь переменная i задана модифицируемой, поэтому ее может изменить функция-член seti(). Тем не менее, поскольку переменная] по-прежнему ос-тается не модифицируемой, постоянная функция-член seti() не может изме-нить ее значение. УпраАне! _^ В следующей программе сделана попытка создать простой таймер для изме-рения временных интервалов. По истечении каждого такого интервала тай-мер должен подавать звуковой сигнал. К сожалению, в том виде, в котором программа представлена, она компилироваться не будет. Найдите и исправь-те ошибку. //В этой программе имеется ошибка #include <iostream> using namespace std; class CountDown { int incr; int target; int current; public: CountDown(int delay, int i ~ 1) { target = delay; incr = i; current = 0; }bool counting{) const { current += incr;
404 Самоучитель C++ if(current >= target) { cout " "\a"; return false; }cout " current "" "; return true; int main{) { CountDown ob(100, 2); while(ob.counting()); return 0; 2. Может ли постоянная функция-член вызвать непостоянную функцию? Если нет, то почему? 13.5. Заключительный обзор конструкторов Хотя тема конструкторов в этой книге уже обсуждалась, некоторые аспекты их применения остались нераскрытыми. Рассмотрим следующую программу: ^include <iostream> using namespace std; class myclass { int a; public: myclass(int x) { a = x; } int geta() { return a; ) int main{) myclass ob(4); cout " ob.geta(}; return 0; t
Глава 13. Пространства имен и другие темы _ 405 Здесь у конструктора класса myclass имеется один параметр. Обратите осо-бое внимание на то, как в функции main О объявлен объект ob. Значение 4, заданное в скобках сразу за объектом ob, - это аргумент, который передает-ся параметру х конструктора myclassQ и с помощью которого инициализи-руется переменная а. Именно такая форма инициализации использовалась в примерах программ, начиная с первых глав этой книги. Однако это не единственный способ инициализации. Рассмотрим, к примеру, следующую инструкцию: myclass ob = 4; //эта инструкция автоматически преобразуется //в инструкцию myclass ob{4); Как показано в комментариях, эта форма инициализации автоматически преобразуется в вызов конструктора myclassQ со значением 4 в качестве ар-гумента. Таким образом, предыдущая инструкция обрабатывается компиля-тором так, как будто на ее месте находится инструкция: myclass ob(4) ; Как правило, всегда, когда у конструктора имеется только один аргумент, можно использовать любую из представленных выше двух форм инициали-зации объекта. Смысл второй формы инициализации в том, что для конст-руктора с одним аргументом она позволяет организовать неявное преобразо-вание типа этого аргумента в тип класса, к которому относится конструктор. Неявное преобразование можно запретить с помощью спецификатора explicit (явный). Спецификатор explicit применим только к конструкторам. Для конструкторов, заданных со спецификатором explicit, допустим только обычный синтаксис. Автоматического преобразования для таких конструк-торов не выполняется. Например, если в предыдущем примере конструктор класса myclass объявить со спецификатором explicit, то для такого конструк-тора автоматического преобразования поддерживаться не будет. В представ-ленном ниже классе конструктор myclass() объявлен со спецификатором explicit. ^include <iostream> using namespace std; class myclass { int a; public: explicit myclass (int x) { a = x; } int geta() { return a; } Для такого класса допустима только одна форма конструкторов: myclass ob(4) ;
406 Самоучитель C++ 1. В классе может быть более одного преобразующего конструктора. Например, рассмотрим следующую версию класса myclass. #include <iostream> /#include <cstdlit>> using namespace std; class myclass { int a; public: myclass (int x) { a = x; } myclass (char *str) { a = atoi(str); } int geta() { return a; } i : int main() { //преобразование в вызов конструктора myclass ob{4) myclass obi = 4; //преобразование в вызов конструктора myclass ob("123"3 myclass ob2 = "123"; cout " "obi: " " obl.getaO " endl; cout " "ob2: " " ob2.geta{) " endl; return 0; Поскольку типы аргументов обоих конструкторов различны (как это и долж-но быть) каждая инструкция инициализации автоматически преобразуется в соответствующий вызов конструктора. 2. Автоматическое преобразование на основе типа первого аргумента конструк-тора в вызов самого конструктора имеет интересное применение. Например, для класса myclass из примера 1, чтобы присвоить объектам оЫ и оЬ2 новые значения, функция main() выполняет преобразования из типа int в тип char *. linclude <iostream> ^include <cstdlib> using namespace std; class myclass { int a; public: myclass (int x) { a = x; } myclass (char *str) { a = atoi(str); }
Глава 13. Пространства имен и другие темы 407 int geta() { return a; } } ; int main(} { //преобразование в вызов конструктора myclass ob(4) myclass obi = 4; //преобразование в вызов конструктора myclass ob("123") myclass ob2 = "123"; cout " "obi: " " obl.getaO " endl; cout " "ob2: " " ob2.geta{) " endl; /* использование автоматического преобразования для присваивания новых значений *///преобразование в вызов конструктора myclass ob("1776") myclass obi = "1776"; //преобразование в вызов конструктора myclass ob(2001) myclass obi = 2001; cout " "оЫ: " " obl.getaO " endl; cout " "ob2: " " ob2.geta(} " endl; return 0; 3. Чтобы запретить показанные в предыдущих примерах преобразования, для конструкторов можно задать спецификатор explicit: ^include <iostream> ftinclude <cstdlib> using namespace std; class myclass ( int a; public: explicit myclass(int x) { a = x; } . explicit myclass(char *str) { a = atoi(str); } int geta() { return a; } int mainO { //преобразование в вызов конструктора myclass ob(4) myclass obi = 4; . //преобразование в вызов конструктора myclass ob{"123"} myclass obi -"123";
408 Самоучитель C++ cout " "obi: " " obl.getaO " endl; cout " "ob2: " " ob2.geta() " endl; return 0; 'праЖнеенниияя] 1. В примере 3f если спецификатор explicit указать только для конструктора myclass(int), можно ли будет выполнить неявное преобразование также и для конструктора myclass(char *)? (Подсказка: попробуйте и посмотрите, что по-лучится.) 2. Работоспособен ли следующий фрагмент программы? class Demo { double x; public: Demo{double i) ( x = i; } Demo counter = 10; 3. Попытайтесь оправдать введение ключевого слова explicit. (Другими словами, объясните, почему неявное преобразование конструкторов в некоторых слу-чаях может оказаться нежелательным.) 13.6. Спецификаторы сборки и ключевое слово asm В C++ поддерживаются два важных механизма для облегчения связи C++ с другими языками программирования. Первым является спецификатор сборки (linkage specifier), который сообщает компилятору, что одна или более функ-ций вашей программы на C++ будет компоноваться с другим языком про-граммирования, который может иметь другие соглашения о передаче пара-метров процедуре заполнения стека и т. д. Вторым является ключевое слово asm, которое позволяет вставлять в исходную профамму команды ассембле-ра. Оба этих механизма рассматриваются в этом разделе. По умолчанию все функции программы на C++ компилируются и компо-нуются как функции C++. Однако компилятору C++ можно сообщить, что функция будет компоноваться как функция, написанная на другом языке
g. Пространства имен и другие темы _ 409 программирования. Все компиляторы C++ допускают компоновку функций либо как функций С, либо как функций C++. Некоторые также допускают компоновку функций для таких языков, как Pascal, Ada или FORTRAN. Чтобы компоновать функции для других языков программирования, исполь-зуется следующая основная форма спецификатора сборки: extern "язак" прототип функции; Здесь язык - это название языка программирования, как функцию которого вы хотите компоновать вашу функцию. Если необходимо использовать спе-цификатор сборки более чем для одной функции, используется такая его основная форма: ex-tern "язык" { прототипа функций; Все спецификаторы сборки должны быть глобальными; их нельзя задавать внутри функций. Чаще всего в программы на C++ приходится вставлять фрагменты программ на С. Путем задания сборки с "С" вы предотвращаете искажения (mangling) имен функций информацией о типе. Поскольку в C++ имеется возмож-ность перегружать функции и создавать функции-члены, то каждому имени функции обычно сопутствует некоторая информация о ее типе. С другой стороны, так как язык С не поддерживает ни перегрузки функций, ни функций-членов, он не может распознавать имена функций, искаженные информацией об их типе. Указание компилятору необходимости сборки с "С" позволяет решить проблему. Хотя вполне возможно совместно компоновать ассемблерные подпрофаммы с программами на C++, часто легче использовать язык ассемблера в процес-се написания программ на C++. В C++ поддерживается специальное клю-чевое слово asm, позволяющее вставлять ассемблерные инструкции в функ-ции C++. Преимущество встроенного ассемблера в том, что ваша программа полностью компилируется как программа на C++, и нет необходимости раздельно с ней компилировать, а затем совместно компоновать ассемблер-ные файлы. Здесь показана основная форма ключевого слова asm: asm <"ас_псядац""); где ас_инструкция - это ассемблерная инструкция, которая будет встроена в вашу программу. Важно отметить, что в некоторых компиляторах поддерживаются следующие три, несколько иные формы инструкции asm: asm ас_инструкцкя; asm ас инструкция физический конец строки
410 _ Самоучитель C++ asm {последовательность ассемблерных инструкций Здесь ассемблерные инструкции не выделяются кавычками. Для правиль ного встраивания ассемблерных инструкций вам понадобится изучить тех ническую документацию на ваш компилятор. S среде программирования Microsoft Visual C++ для встраивания ассемблер-ного кода используется инструкция asm. So всем остальном эта инструк-ция аналогична только что описанной инструкции asm. Примеры 1. В этой программе функция func() компонуется не как функция C++, а как функция С: //Демонстрация спецификатора сборки ttinclude <iostream> using namespace std; extern "C" int func(int x ) ; //компонуется как функция С //Теперь функция компонуется как функция С. int func(int x) ( return x/3; Теперь эта функция может компоноваться с программой, которая компили-ровалась компилятором С. 2. В представленной ниже программе компилятору сообщается, что функции П(), й() и f3() должны компоноваться как функции С: extern "С" { void f 1 ( ) ; int f2(int x); double f3 {double x, int *p) ; 3. В этом фрагменте в функцию func() вставляется несколько ассемблерных инструкций:
Глава 13. Пространства имен и другие темы 411 //Н е пытайтесь выполнить эту функцию! void funcO { asm ("mov bp, sp"}; asm {"push ax"); asm ("mov cl, 4"); Для успешного использования встроенного ассемблера вы должны быть опытным программистом на языке ассемблера. Кроме этого, нужно тщатель-но изучить техническую документацию на ваш компилятор. {Упражнения Изучите те разделы технической документации на ваш компилятор, которые относятся к спецификаторам сборки и интерфейсу с ассемблером. 13.7. Массивы в качестве объектов ввода/вывода Помимо ввода/вывода на экран и в файл, в C++ поддерживается целый ряд функций, в которых в качестве устройств для ввода и вывода используются массивы. Хотя ввод/вывод с использованием массивов (array-based I/O) в C++ концептуально перекликается с аналогичным вводом/выводом в С (в особенности это касается функций sscanfQ и sprintf() языка С), ввод/вывод с использованием массивов в C++ более гибкий и полезный, поскольку он позволяет интегрировать в него определенные пользователем типы данных. Хотя охватить все аспекты массивов в качестве объектов ввода/вывода не-возможно, здесь рассматриваются их наиболее важные и часто используе-мые свойства. Важно понимать, что для реализации ввода/вывода с использованием мас-сивов тоже нужны потоки. Все, что вы узнали о вводе/выводе C++ из глав 8 и 9 применимо и к вводу/выводу с использованием массивов. При этом, чтобы узнать о всех достоинствах массивов в качестве объектов вво-да/вывода, вам следует познакомиться с несколькими новыми функциями. Эти функции предназначены для связывания нужного потока с некоторой
412 Самоучитель C++ областью памяти. После того как эта операция выполнена, весь ввод/вывод производится посредством тех самых функций для ввода и вывода, о кото-рых вы уже знаете. Перед тем как начать пользоваться массивами в качестве объектов вво-да/вывода, необходимо удостовериться в том, что в вашу программу вклю-чен заголовок <strstream>. В этом заголовке определяются классы istrstream, ostrstream и strstream. Эти классы образуют, соответственно, основанные на использовании массивов потоки для ввода, вывода и ввода/вывода. Базовым для этих классов является класс ios, поэтому все функции и манипуляторы классов istream, ostream и iostream имеются также и в классах istrstream, ostrstream и strstream. Для вывода в символьный массив используйте следующую основную форму конструктора класса ostrstream: ostrstream лотох_вывода (char *буфер, streamsize размер, opemnode режим = ios: :out) ; Здесь поток_вывода - это поток, который связывается с массивом, задан-ным через указатель буфер. Параметр размер определяет размер массива. Параметр режим по умолчанию обычно настроен на обычный режим выво-да, но вы можете задать любой, определенный в классе ios, флаг режима вывода. (За подробностями обращайтесь к главе 9.) После того как массив открыт для вывода, символы будут выводиться в мас-сив вплоть до его заполнения. Переполнения массива произойти не может. Любая попытка переполнения массива приведет к ошибке ввода/вывода. Для определения количества записанных в массив символов используйте приведенную ниже функцию-член pcount(): int pcountO ; Функция должна вызываться только в связи с потоком и возвращает она число символов, записанных в массив, включая нулевой символ завершения. Чтобы открыть массив для ввода из него, используйте следующую форму конструктора класса istrstream: istrstream аоток_ввода (const char *буфер); Здесь буфер - это указатель на массив, из которого будут вводиться символы. Поток ввода обозначен через поток_ввода. При считывании входной инфор-мации из массива, функция eof() возвращает истину при достижении конца массива. Чтобы открыть массив для ввода/вывода, используйте следующую форму конструктора класса strstream: strstream поток_ввод_в*тод (char *буфер, streamsize размер, openmode режим = ios : : in | ios: : out) ;
Глава 13. Пространства имен и другие темы 413 Здесь поток__ввод_вывод - это поток ввода/вывода, для которого в качестве объекта ввода/вывода через указатель буфер задан массив длиной в размер символов. Важно помнить, что все описанные ранее функции ввода/вывода работают и с массивами, включая функции ввода/вывода двоичных файлов и функции произвольного доступа. . Применение потоковых классов для символьных массивов резко осуждается стандартом Standard C++. Это означает, что хотя сейчас потоковые классы для символьных массивов достаточно широко распространены, в будущих версиях языка C++ они могут не поддерживаться. Для решения тех же задач, для которых предназначены символьные массивы, стандартом Standard C+ + рекомендуются классы-контейнеры, описанные в главе 14. --Примеры 1. В этом простом примере показано, как открыть массив для вывода и запи-сать в него данные: //Короткий пример вывода в массив tinclude <iostream> ^include <strstreara> using namespace std; int main() char buf[255]; //буфер для вывода ostrstrearn ostr(buf, sizeof buf}; //открытие массива для вывода ostr " "ввод/вывод через массивы работает с потоками\п"; ostr " "точно так же, как при обычном вводе/выводе\п " " 100; ostr " ' ' " 123.23 " '\п'; //можно также использовать манипуляторы ostr " hex " 100 " ' '; //или флаги формата ostr.setf(ios::scientific}; ostr " 123.23 " '\n'; ostr " ends; //вывод на экран полученной строки cout " buf; return 0;
414 Самоучитель C++ В результате выполнения программы на экран выводится следующее: ввод/вывод через массивы работает с потоками точно так же, как при обычном вводе/выводе 100 123.23 64 01.2323е+02 Как вы могли заметить, перегруженные операторы ввода/вывода, встроенные манипуляторы ввода/вывода, функции-члены и флаги формата полностью доступны и для ввода/вывода с использованием массивов. (Это также отно-сится ко всем манипуляторам и перегруженным операторам ввода/вывода, которые вы создаете для своих классов.) В представленной выше программе с помощью манипулятора ends в массив специально добавляется завершающий нулевой символ. Будет ли нулевой сим-вол занесен в массив автоматически или нет, зависит от реализации. Поэтому, если это важно для вашей программы, лучше специально записать в массив за-вершающий нулевой символ. 2. Пример ввода данных из массива: //Пример ввода из массива #include <iostream> #include <strstream> using namespace std; int main ( ) char buf[] = "Привет 100 123.125 a"; istrstream istr(buf); //открытие массива для ввода из него int i ; char str[80]; float f; char c; istr " str " i " f " c; cout " str " ' ' " i " ' ' " f; cout " ' ' " с " '\n'; return. 0; Эта программа считывает и воспроизводит данные, содержащиеся в массиве, за-данном указателем buf. 3. Запомните, что массив для ввода, после того как он связан с потоком, стано-вится похожим на файл. Например, в следующей программе для считывания содержимого массива по адресу buf используются функции eof() и get():
Глава 13. Пространства имен и другие темы 415 /* Демонстрация того факта, что функции eof() и get() работают с вводом/выводом, основанным на использовании массивов */' tinclude <iostream> #include <strstream> using namespace std; int main {} { char buf[] = "Привет 100 123.125 a"; istrstream istr(buf); char c; while(listr.eof(" t istr.get(c); if (!istr.eof()}cout " c; return 0; 4. В следующей программе выполняется ввод данных из массива и вывод дан-ных в массив: //Демонстрация ввода/вывода с использованием массивов ^include <iostream> finclude <strstrearn> using namespace std; int mainO { char iobuf[255]; strstream iostr (iobuf, sizeof iobuf); iostr " "Это проверка\n"; iostr " 100 " hex " ' ' " 100 " ends; char str[80]; int i; iostr.getline(str, 79); //считывает строку вплоть до \п iostr " dec " i; //считывает 100 cout " str " ' ' " i " ' '; iostr " hex " i; cout " hex" i; return 0; }
416 Самоучитель ^ Эта программа сначала записывает информацию в массив по адресу iobuf, a затем считывает ее обратно. Сначала с помощью функции getline() строка "Это проверка" целиком считывается в массив, далее считывается десятичное значение 100, а затем шестнадцатеричное 0x64. _Упр_аж1не_ни^я! 1. Модифицируйте пример 1 так, чтобы перед завершением программы на эк-ран было выведено число символов, записанных в массив по адресу buf. 2. Используя массивы в качестве объектов ввода/вывода, напишите программу для копирования содержимого одного массива в другой. (Конечно это не са-мый эффективный способ решения подобной задачи.) 3. Используя массивы в качестве объектов ввода/вывода, напишите программу для преобразования строки, содержащей значение с плавающей точкой, в число с плавающей точкой. со усвоений материала главы Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы. 1. Что отличает статическую переменную-член от других переменных-членов? 2. Какой заголовок необходимо включить в вашу программу, чтобы в каче-стве объектов ввода/вывода можно было использовать массивы? 3. Не считая того, что при вводе/выводе через массивы память используется в качестве устройства ввода и/или вывода, имеется ли еще какое либо отличие между таким и "обычным" вводом/выводом? 4. Для заданной функции counterQ напишите инструкцию, позволяющую компилировать эту функцию для сборки с языком С. 5. Для чего нужна функция преобразования? 6. Объясните назначение спецификатора explicit. 7. Какое имеется принципиальное ограничение на использование постоян-ных функций-членов? 8. Объясните понятие пространств имен. 9. Для чего нужно ключевое слово mutable?
Глава 13. Пространства имен и другие темы 417 Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Поскольку для конструктора с одним аргументом преобразование типа этого аргумента в тип класса, в котором определен конструктор, проис-ходит автоматически, исчезает ли в такой ситуации необходимость в ис-пользовании перегруженного оператора присваивания? 2. Можно ли в постоянной функции-члене использовать оператор const_cast, чтобы разрешить этой функции-члену модифицировать вызвавший ее объект? 3. Философский вопрос: поскольку библиотека исходного C++ содержится в глобальном пространстве имен и для старых программ на C++ это уже свершившийся факт, какая польза от размещения указанной библиотеки в пространстве имен std "задним числом"? 4. Вернитесь к примерам первых двенадцати глав. Подумайте о том, в каких из них функции-члены можно было бы сделать постоянными или стати-ческими. Не те ли это примеры, в которых определение пространств имен наиболее предпочтительно?
Глава 14 Библиотека стандартных шаблонов Поздравляем! Если при изучении предыдущих глав этой книги вы действи-тельно работали, то теперь можете с полным правом называть себя состо-явшимся программистом на C++. В этой последней главе мы расскажем об одном из наиболее увлекательных и совершенных инструментов языка про-граммирования C++ - библиотеке стандартных шаблонов (Standard Template Library, STL). Библиотека стандартных шаблонов не являлась частью исходной специфи-кации C++, а была добавлена к ней позже, в процессе стандартизации, на что и были направлены основные усилия разработчиков. Библиотека стан-дартных шаблонов обеспечивает общецелевые, стандартные классы и функ-ции, которые реализуют наиболее популярные и широко используемые ал-горитмы и структуры данных. Например, в библиотеке стандартных шабло-нов поддерживаются уже известные нам векторы (vectors), списки (lists), очереди (queues) и стеки (stacks). В ней также определены различные проце-дуры доступа к этим структурам данных. Поскольку библиотека стандартных шаблонов строится на основе классов-шаблонов, входящие в нее алгоритмы и структуры применимы почти ко всем типам данных. Рассказ о библиотеке стандартных шаблонов необходимо начать с призна-ния того факта, что она представляет собой вершину искусства программи-рования, и в ней используются самые изощренные свойства C++. Чтобы научиться понимать и применять библиотеку стандартных шаблонов, вам следует досконально освоить материал предыдущих глав и уметь свободно оперировать полученными знаниями. В особенности это касается шаблонов. Синтаксис шаблонов, на котором написана библиотека стандартных шабло-нов, может показаться совершенно устрашающим, но не надо бояться, он выглядит сложнее, чем это есть на самом деле. Помните, в этой главе нет ничего более сложного, чем то, с чем вы уже познакомились в предыдущих главах книги, поэтому не надо расстраиваться или пугаться, если на первых порах библиотека стандартных шаблонов покажется вам непонятной. Не-много терпения, усидчивости, экспериментов и, главное, не позволяйте не-знакомому синтаксису заслонить от вас исходную простоту библиотеки стандартных шаблонов. Библиотека стандартных шаблонов достаточно велика, поэтому вы узнаете здесь далеко не обо всех ее свойствах. Фактически, полного описания биб-
420 Самоучитель C++ лиотеки, всех ее свойств, нюансов и приемов программирования хватило бы на большую отдельную книгу. Представленный в этой главе обзор предна-значен для того, чтобы познакомить вас с ее базовыми операциями, фило-софией, основами программирования. После усвоения этого материала вы, несомненно, легко сможете проделать оставшуюся часть пути самостоятельно. Помимо библиотеки стандартных шаблонов в этой главе описан один из наиболее важных новых классов C++ - строковый класс (string class). Стро-ковый класс определяет строковый тип данных, что позволяет с помощью операторов работать с символьными строками почти так же, как это делает-ся с данными других типов. Повторение пройденного Перед тем как продолжить, необходимо правильно ответить на следующие вопросы и сделать упражнения. 1. Объясните, зачем в C++ были добавлены пространства имен. 2. Как задать постоянную функцию-член? 3. Модификатор mutable (модифицируемый) позволяет пользователю вашей программы изменить библиотечную функцию. Так ли это? 4. Дан следующий класс: class X { int a, b; public: X(int i, int j) { a = i, b = j; } //создайте здесь функцию преобразования в целое }; Создайте функцию преобразования, возвращаемым значением которой была бы сумма переменных а и Ь. 5. Статическая переменная - член класса может использоваться еще до создания объекта этого класса. Так ли это? 6. Дан следующий класс: class Demo { int а; public: explicit Demo (int i) { a = i; } int geta() { return a; } Допустимо ли следующее объявление: Demo о = 10;
Глава 14. Библиотека стандартных шаблонов 42? 14.1. Знакомство с библиотекой стандартных шаблонов Хотя библиотека стандартных шаблонов достаточно велика, а ее синтаксис иногда пугающе сложен, с ней гораздо проще работать, если понять, как она образована и из каких элементов состоит. Поэтому перед изучением примеров программ вполне оправдано дать ее краткий обзор. Ядро библиотеки стандартных шаблонов образуют три основополагающих элемента: контейнеры, алгоритмы и итераторы. Эти элементы функциони-руют в тесной взаимосвязи друг с другом, обеспечивая искомые решения проблем программирования. Контейнеры (containers) - это объекты, предназначенные для хранения дру-гих объектов. Контейнеры бывают различных типов. Например, в классе vector (вектор) определяется динамический массив, в классе queue (очередь) - очередь, в классе list (список) - линейный список. Помимо базовых контейнеров, в библиотеке стандартных шаблонов определены так-же ассоциативные контейнеры (associative containers), позволяющие с помо-щью ключей (keys) быстро получать хранящиеся в них значения. Например, в классе тар (ассоциативный список) определяется ассоциативный список, обеспечивающий доступ к значениям по уникальным ключам. То есть, в ассоциативных списках хранятся пары величин ключ/значение, что позво-ляет при наличии ключа получить соответствующее ключу значение. В каждом классе-контейнере определяется набор функций для работы с этим контейнером. Например, список содержит функции для вставки, уда-ления и слияния (merge) элементов. В стеке имеются функции для разме-щения элемента в стеке и извлечения его из стека. Алгоритмы (algorithms) выполняют операции над содержимым контейнеров. Существуют алгоритмы для инициализации, сортировки, поиска или замены содержимого контейнеров. Многие алгоритмы предназначены для работы с последовательностью (sequence), которая представляет собой линейный спи-сок элементов внутри контейнера. Итераторы (iterators) - это объекты, которые по отношению к контейнерам играют роль указателей. Они позволяют получать доступ к содержимому контейнера примерно так же, как указатели используются для доступа к элементам массива. Имеется пять типов итераторов, которые описаны ниже: Итератор Описание Произвольного доступа Используется для считывания и записи значений. Доступ (random access) к элементам произвольный Двунаправленный Используется для считывания и записи значений. Может (bidirectional) проходить контейнер в обоих направлениях
422 Самоучитель C++ (продолжение) Итератор Описание Однонаправленный Используется для считывания и записи значений. Может (forward) проходить контейнер только в одном направлении Ввода Используется только для считывания значений. Может (input) проходить контейнер только в одном направлении Вывода Используется только для записи значений. Может прохо-{output) дить контейнер только в одном направлении (Не запутайтесь. По аналогии с потоковым вводом/выводом под вводом по-нимается ввод информации из контейнера, т. е. считывание, а под выводом - вывод информации в контейнер, т. е. запись, - примеч. пер.) Как правило, итератор с большими возможностями доступа к содержимому контейнера может использоваться вместо итератора с меньшими возможно-стями. Например, однонаправленным итератором можно заменить итератор ввода. С итераторами можно работать точно так же, как с указателями. Над ними можно выполнять операции инкремента и декремента. К ним можно при-менить оператор *. Типом итераторов объявляется тип iterator, который оп-ределен в различных контейнерах. В библиотеке стандартных шаблонов также поддерживаются обратные ите-раторы (reverse iterators). Обратными итераторами могут быть либо двуна-правленные итераторы, либо итераторы произвольного доступа, но прохо-дящие последовательность в обратном направлении. То есть, если обратный итератор указывает на последний элемент последовательности, то инкре-мент этого итератора приведет к тому, что он будет указывать на элемент перед последним. При упоминании различных типов итераторов в описаниях шаблонов, в данной книге будут использоваться следующие термины: Термин Randlter Btlter Forlter Inlter Outlter Тип итератора Произвольного доступа (random access) Двунаправленный (bidirectional) Однонаправленный (forward) Ввода (input) Вывода (output) Вдобавок к контейнерам, алгоритмам и итераторам, в библиотеке стандарт-ных шаблонов поддерживается еще несколько стандартных компонентов. Главными среди них являются распределители памяти, предикаты и функ-ции сравнения.
Глава 14. Библиотека стандартных шаблонов 423 У каждого контейнера имеется определенный для него распределитель памяти (allocator), который управляет процессом выделения памяти для контейнера. По умолчанию распределителем памяти является объект класса allocator, но вы можете определить собственный распределитель памяти, если хотите возложить на него какие-нибудь необычные функции. В боль-шинстве случаев достаточно распределителя памяти, заданного по умолчанию. В некоторых алгоритмах и контейнерах используется функция особого типа, называемая предикатом (predicate). Предикат может быть бинарным или унарным. У унарного предиката один аргумент, а у бинарного - два. Воз-вращаемым значением этих функций является значения истина либо ложь. Точные условия получения того или иного значения определяются про-граммистом. Все унарные предикаты, которые будут упомянуты в этой гла-ве, имеют тип UnPred, а все бинарные - BinPrcd. Аргументы бинарного предиката всегда расположены по порядку: первый, второй. Тип аргументов как унарного, так и бинарного предиката соответствует типу хранящихся в контейнере объектов. В некоторых алгоритмах и классах используется специальный тип бинар-ного предиката, предназначенный для сравнения двух элементов. Такой предикат называется функцией сравнения (comparison function). Функция срав-нения возвращает истину, если ее первый аргумент меньше второго. Типом функции сравнения является тип Сотр. Помимо заголовков для разнообразных классов-контейнеров, входящих в библиотеку стандартных шаблонов, стандартная библиотека C++ включает также заголовки <utility> и <functional>, предназначенные для поддержки классов-шаблонов. Например, заголовочный файл <utility> содержит опре-деление класса-шаблона pair (пара), в котором могут храниться пары значе-ний. Позднее в этой главе мы еще воспользуемся шаблоном pair. Шаблоны из заголовочного файла <functional> помогают создавать объекты, определяющие оператор-функцию operatorQ. Эти объекты называются объ-ектами-функциями (function objects) и во многих случаях могут использовать-ся вместо указателей на функцию. В заголовочном файле <functional> объ-явлено несколько встроенных объектов-функций, некоторые из которых перечислены ниже: plus minus multiplies divides modulus negate equal_to not_equal_to greater greater_equal less less_equal iogical_and logical_or logical_not Вероятно, чаще других применяется объект-функция less (меньше), которая позволяет определить, является ли значение одного объекта меньше, чем значение другого. В описываемых далее алгоритмах библиотеки стандартных шаблонов объектами-функциями можно заменять указатели на реальные функции. Если использовать объекты-функции вместо указателей на функ-цию, библиотека стандартных шаблонов будет генерировать более эффек-
424 Самоучитель C++ тивный код. Тем не менее для целей данной главы (обзор библиотеки стан-дартных шаблонов) объекты-функции не нужны и непосредственно приме-няться не будут. Хотя сами по себе объекты-функции не представляют осо-бой сложности, их подробное обсуждение достаточно продолжительно и выходит за рамки нашей книги. Этот материал вам следует освоить само-стоятельно, если в будущем вы захотите использовать библиотеку стандарт-ных шаблонов с максимальной эффективностью. 1. Что представляют собой контейнеры, алгоритмы и итераторы, входящие в библиотеку стандартных шаблонов? 2. Какие вы знаете два типа предикатов? 3. Какие существуют пять типов итераторов? 14.2. Классы-контейнеры Ранее уже объяснялось, что контейнерами называются объекты библиотеки стандартных шаблонов, непосредственно предназначенные для хранения данных. В табл. 14.1 перечислены контейнеры, определенные в библиотеке стандартных шаблонов, а также заголовки, которые следует включить в программу, чтобы использовать тот или иной контейнер. Хотя строковый класс, который управляет символьными строками, также является контей-нером, ему будет посвящен отдельный раздел. Таблица 14.1. Контейнеры, определенные в библиотеке стандартных шаблонов Контейнер Описание Заголовок bitset Множество битов <bitset> deque Двусторонняя очередь <deque> list Линейный список <list> map Ассоциативный список для хранения пар <тар> ключ/значение, где с каждым ключом связано только одно значение multimap Ассоциативный список для хранения пар <тар> ключ/значение, где с каждым ключом связано два или более значений multiset Множество, в котором каждый элемент не обя-<set> зательно уникален pnonty_queue Очередь с приоритетом <queue> queue Очередь <queue>
Глава 14. Библиотека стандартных шаблонов 425 Таблица 14.1 (продолжение) Контейнер Описание Заголовок set Множество, в котором каждый элемент уникален <set> stack Стек <stack> vector Динамический массив <vector> Поскольку имена типов элементов, входящих в объявление класса-шаблона, могут быть самыми разными, в классах-контейнерах с помощью ключевого слова typedef объявляются некоторые согласованные версии этих типов. Эта операция позволяет конкретизировать имена типов. Ниже представлены имена типов, конкретизированные с помощью ключевого слова typedef, ко-торые можно встретить чаще других: Согласованное имя типа Описание size_type Интегральный тип, эквивалентный типу size_t reference Ссылка на элемент const_reference Постоянная ссылка на элемент iterator Итератор constjterator Постоянный итератор reversejterator Обратный итератор const_reverse_iterator Постоянный обратный итератор value_type Тип хранящегося в контейнере значения allocator_type Тип распределителя памяти key_type Тип ключа key_compare Тип функции, которая сравнивает два ключа value_compare Тип функции, которая сравнивает два значения Хотя изучить все контейнеры в рамках одной главы невозможно, в следую-щих разделах рассказывается о трех из них: векторе, списке и ассоциатив-ном списке. Если вы поймете, как работают эти три контейнера, то с дру-гими классами библиотеки стандартных шаблонов у вас проблем не будет. 14.3. Векторы Вероятно, самым популярным контейнером является вектор. В классе vector поддерживаются динамические массивы. Динамическим массивом называ-ется массив, размеры которого могут увеличиваться по мере необходимости. Как известно, в C++ в процессе компиляции размеры массива фиксируют-
426 Самоучитель C++ ся. Хотя это наиболее эффективный способ реализации массивов, одновре-менно он и самый ограниченный, поскольку не позволяет адаптировать размер массива к изменяющимся в процессе выполнения программы усло-виям. Решает проблему вектор, который выделяет память для массива по мере возникновения потребности в этой памяти. Несмотря на то, что вектор является, по сути, динамическим массивом, для доступа к его элементам подходит обычная индексная нотация, которая используется для доступа к элементам стандартного массива. Ниже представлена спецификация шаблона для класса vector: template<class Т, class Allocator = allocator<T"class vector Здесь Т - это тип предназначенных для хранения в контейнере данных, а ключевое слово Allocator задает распределитель памяти, который по умолча-нию является стандартным распределителем памяти. В классе vector опреде-лены следующие конструкторы: explicit vector(const Allocator £a = Allocator{)); explicit vector (size_type число, const Т ^значение = Т() , const Allocator &a = Allocator()); vector(const vector<T, Allocator>£объект); template<class InlterXvector(Inlter начало, Inlter конец, const Allocator &a = Allocator {)>; Первая форма представляет собой конструктор пустого вектора. Во второй форме конструктора вектора число элементов - это число, а каждый эле-мент равен значению значение. Параметр значение может быть значением по умолчанию. В третьей форме конструктора вектор предназначен для одина-ковых элементов, каждый из которых - это объект. Четвертая форма - это конструктор вектора, содержащего диапазон элементов, заданный итерато-рами напало и конец. Для любого объекта, который будет храниться в векторе, должен быть опре-делен конструктор по умолчанию. Кроме этого, для объекта должны быть определены операторы < и =-. Для некоторых компиляторов может потре-боваться определить и другие операторы сравнения. (Для получения более точной информации обратитесь к документации на ваш компилятор.) Для встроенных типов данных все указанные требования выполняются автома-тически. Хотя синтаксис шаблона выглядит довольно сложно, в объявлении вектора ничего сложного нет. Ниже представлено несколько примеров такого объ-явления: vector<int> iv; //создание вектора нулевой длины для целых vector<char> cv(5); //создание пятиэлементного вектора для символов
Глава 14. Библиотека стандартных шаблонов 427 vector<char> cv(5, 'x'); //создание и инициализация //пятиэлементного вектора для символов vector<int> iv2(iv); //создание вектора для целых //из вектора для целых Для класса vector определяются следующие операторы сравнения: =, <, <=, !=, >, >= Кроме этого для класса vector определяется оператор индекса [], что обес-печивает доступ к элементам вектора посредством обычной индексной но-тации, которая используется для доступа к элементам стандартного массива. В табл. 14.2 представлены функции - члены класса vector. (Повторяем, не нужно пугаться необычного синтаксиса.) Наиболее важными функциями-членами являются функции sizeQ, begin(), end(), pushJbackQ, inscrt() и erase(). Функция sizeQ возвращает текущий размер вектора. Эта функция особенно полезна, поскольку позволяет узнать размер вектора во время вы-полнения программы. Помните, вектор может расти по мере необходимо-сти, поэтому размер вектора необходимо определять не в процессе компи-ляции, а в процессе выполнения программы. Функция beginQ возвращает итератор начала вектора. Функция end() воз-вращает итератор конца вектора. Как уже говорилось, итераторы очень по-хожи на указатели и с помощью функций beginQ и end() можно получить итераторы (читай: указатели) начала и конца вектора. Функция pushJbackQ помещает значение в конец вектора. Если это необхо-димо для размещения нового элемента, вектор удлиняется. В середину век-тора элемент можно добавить с помощью функции insertQ. Вектор можно инициализировать. В любом случае, если в векторе хранятся элементы, то с помощью оператора индекса массива к этим элементам можно получить доступ и их изменить. Удалить элементы из вектора можно с помощью функции erase(). Таблица 14.2. Функции - члены класса vector Функция-член Описание template<class lnlter> Присваивает вектору последовательность, void assign(lnlter начало, определенную итераторами начало и конец inlter конец); template<class Size, class T> Присваивает вектору число элементов, при-void assign(Size число, чем значение каждого элемента равно пара-const Т &зиачение -Т("; метру значение reference at(slze_type /"); Возвращает ссылку на элемент, заданный const_reference параметром I at(size_type i) const;
428 Самоучитель С+-Таблица 14.2 (продолжение) Функция-член Описание reference backf); const_reference back() const; iterator beginO; const_iterator beginf) const; size_type capacltyO const; void clearf); bool empty() const; iterator end(); const_iterator end() const; iterator erase(lterator i); iterator eraseflterator начало, iterator конец}; reference front(); const_reference front() const; allocator_type get_allocator() const; iterator insertflterator /, const Т &значение = T("; void insert(iterator /, size_typc число, const Т Азначение); template<class lnlter> void insert(iterator /, Inlter начало, Inlter конец); slze_type max_slze() const; reference operatorl] (size_type /) const; const_reference operator!] (slze_type /) const; void pop_back(); void push_back(const Т &значение); Возвращает ссылку на последний элемент вектора Возвращает итератор первого элемента век-тора Возвращает текущую емкость вектора, т. е. то число элементов, которое можно разместить в векторе без необходимости выделения до-полнительной области памяти Удаляет все элементы вектора Возвращает истину, если вызывающий вектор пуст, в противном случае возвращает ложь Возвращает итератор конца вектора Удаляет элемент, на который указывает ите-ратор i. Возвращает итератор элемента, кото-рый расположен следующим за удаленным Удаляет элементы, заданные между итерато-рами начало и конец. Возвращает итератор элемента, который расположен следующим за последним удаленным Возвращает ссылку на первый элемент вектора Возвращает распределитель памяти вектора Вставляет параметр значение перед элемен-том, заданным итератором i. Возвращает ите-ратор элемента Вставляет число копий параметра значение перед элементом, заданным итератором /Вставляет последовательность, определенную между итераторами начало и конец, перед элементом, заданным итератором i Возвращает максимальное число элементов, которое может храниться в векторе Возвращает ссылку на элемент, заданный параметром i Удаляет последний элемент вектора Добавляет в конец вектора элемент, значение которого равно параметру значение
Глава 14. Библиотека стандартных шаблонов 429 Таблица 14.2 (продолжение) Функция-член Описание reversejterator rbegin(); const_reverse_lterator rbeginf) const; reverse_iterator rend(); const_reversejterator rend() const; void reserve(size_type число); void resize(size_type число, Т значение = T()); size_type sized const; void swap(vector<T, Allocator> &объект); Возвращает обратный итератор конца вектора Возвращает обратный итератор начала вектора Устанавливает емкость вектора равной, по меньшей мере, параметру число элементов Изменяет размер вектора в соответствии с параметром число. Если при этом вектор удлиняется, то добавляемые в конец вектора элементы получают значение, заданное пара-метром значение Возвращает хранящееся на данный момент в векторе число элементов Обменивает элементы, хранящиеся в вызы-вающем векторе, с элементами в объекте объект 1. В представленном ниже коротком примере показаны основные операции, которые можно выполнять при работе с вектором. //Основные операции вектора tfiriclu.de <iostream> # include <vector> using namespace std; int main ( ) vector<int> v; //создание вектора нулевой длины int i; //вывод на экран размера исходного вектора v cout " "Размер = " " v.size(} " endl; //помещение значений в конец вектора, //по мере необходимости вектор будет расти for(i=0; i<10; i++) v.push back(i); //вывод на экран текущего размера вектора v cout " "Новый размер = " " v.sizeO " endl;
430 _ Самоучитель C++ /I вывод на экран содержимого вектора v cout " "Текущее содержимое: \п"; for(i=0; i<v.size{); i++) cout " v[i] " " "; cout " endl; //помещение новых значений в конец вектора, //и опять по мере необходимости вектор будет расти for(i=0; i<10; i++) v.push_back (i+10) ; //вывод на экран текущего размера вектора cout " "Новый размер = " " v. size О " endl; //вывод на экран содержимого вектора cout " "Текущее содержимое: \п"; for(i=0; i<v.size(); i4+) cout " v[i] " " "; cout " endl; //изменение содержимого вектора for(i=0; i<v. sized; i++) v[i] = v[i] + v[i]; //вывод на экран содержимого вектора cout " "Удвоенное содержимое : \п" ; for(i=0; i<v.size(); i++) cout " v[i] " " "; cout " endl; return 0 ; После выполнения программы на экране появится следующее: Размер = О Новый размер = 10 Текущее содержимое: 0 1 2 3 4 5 6 7 8 9 Новый размер = 20 Текущее содержимое: О 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Удвоенное содержимое: О 2 4 б 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 Тщательно проанализируйте программу. В функции main() создается вектор v для хранения целых. Поскольку не используется никакой инициализации, это пустой вектор с равной нулю начальной емкостью, то есть это вектор нулевой длины. Этот факт подтверждается вызовом функции-члена size(). Далее с по-мощью функции-члена push_back() к концу вектора v добавляется десять эле-ментов. Чтобы разместить эти новые элементы, вектор v вынужден увеличить-ся. Как показывает выводимая на экран информация, его размер стал равным 10. После этого выводится содержимое вектора v. Обратите внимание, что для этого используется обычный оператор индекса массива. Далее к вектору добав-
Глава 14. Библиотека стандартных шаблонов _ 43? ляется еще десять элементов и, чтобы их разместить, вектор снова автоматиче-ски увеличивается. В конце концов, с помощью стандартного оператора ин-декса массива меняются значения элементов вектора. В программе есть еще кое-что интересное. Отметьте, что функция v.sizeQ указана прямо в инструкции организации цикла вывода на экран содержи-мого вектора v. Одним из преимуществ векторов по сравнению с массивами является то, что вы всегда имеете возможность определить текущий размер вектора. Очевидно, что такая возможность может оказаться полезной в са-мых разных ситуациях, 2. Как вы знаете, в C++ массивы и указатели очень тесно связаны. Доступ к массиву можно получить либо через оператор индекса, либо через указатель. По аналогии с этим в библиотеке стандартных шаблонов имеется тесная связь между векторами и итераторами. Доступ к членам вектора можно полу-чить либо через оператор индекса, либо через итератор. В следующем при-мере показаны оба этих подхода. //Организация доступа к вектору с помощью итератора ^include <iostream> ^include <vector> using namespace std; int main { } { vector<int> v; //создание вектора нулевой длины int i; //помещение значений в вектор for (1=0; К10; 1+-Н v,push_back (i) ; //доступ к содержимому вектора //с использованием оператора индекса for{i=0; i<10; i++) cout " v[i] " " "; cout " endl; //доступ к вектору через итератор vector<int>: : iterator p = v.beginO; while{p != v.end)} { cout " *p " " "; P++; return 0; После выполнения программы на экране появится следующее: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
432 Самоучитель C++ В этой программе тоже сначала создается вектор v нулевой длины. Далее с помощью функции-члена push_back() к концу вектора v добавляются некото-рые значения и размер вектора v увеличивается. Обратите внимание на объявление итератора р. Тип iterator определяется с помощью класса-контейнера. То есть, чтобы получить итератор для выбран-ного контейнера, объявить его нужно именно так, как показано в примере: просто укажите перед типом iterator имя контейнера. С помощью функции-члена beginQ итератор инициализируется, указывая на начало вектора. Воз-вращаемым значением этой функции как раз и является итератор начала век-тора. Теперь, применяя к итератору оператор инкремента, можно получить доступ к любому выбранному элементу вектора. Этот процесс совершенно аналогичен использованию указателя для доступа к элементам массива. С помощью функции-члена end() определяется факт достижения конца векто-ра. Возвращаемым значением этой функции является итератор того места, которое находится сразу за последним элементом вектора, Таким образом, если итератор р равен возвращаемому значению функции v.end(), значит, ко-нец вектора был достигнут. 3. Помимо возможности размещения элементов в конце вектора, с помощью функции-члена insert() их можно вставлять в его середину. Удалять элементы из вектора можно с помощью функции-члена erase(). //Демонстрация функций insert() и erase () tinclude <iostream> ^include <vector> using namespace std; int main() ( vector<int> v(5, 1); //создание пятиэлементного вектора //из единиц int i; //вывод на экран исходных размера и содержимого вектора cout " "Размер = " " v.sizef) " endl; cout " "Исходное содержимое:\п"; for(i=0; i<v.size(}; !+:<-) cout " v[i] " " "; cout " endl; vector<int>::iterator p = v.begin{); p += 2; //указывает на третий элемент //вставка в вектор на то место, //куда указывает итератор р десяти новых элементов, //каждый из которых равен 9 v.insert(p, 10, 9) ; //вывод на экран размера //и содержимого вектора после вставки cout " "Размер после вставки = " " v.sizeO " endl;
Глава 14. Библиотека стандартных шаблонов 433 cout " "Содержимое после вставки:\п"; for(i=0; i<v.size(); i++) cout " v[i] " " "; cout " endl; //удаление вставленных элементов p = v.begin () ; p += 2; //указывает на третий элемент v.erase{p, р-ЫО); //удаление следующих десяти элементов //за элементом, на который указывает //итератор р //вывод на экран размера , , //и содержимого вектора после удаления cout " "Размер после удаления - " " v.sizeO " endl; cout " "Содержимое после удаления:\п"; for{i=0; i<v.size(); i++) cout " v[i] " " "; cout " endl; return 0; После выполнения программы на экране появится следующее: Размер = 5 Исходное содержимое: 1 1 1 1 1 Размер после вставки = 15 Содержимое после вставки: 1 1 9 9 9 9 9 9 9 9 9 9 1 1 1 Размер после удаления = 5 Содержимое после удаления: 1 1 1 1 1 4. В следующем примере вектор используется для хранения объектов класса, определенного программистом. Обратите внимание, что в классе определя-ются конструктор по умолчанию и перегруженные версии операторов < и ==. Помните, в зависимости от того, как реализована библиотека стандарт-ных шаблонов для вашего компилятора, вам может понадобиться определить и другие операторы сравнения. //Хранение в векторе объектов пользовательского класса #include <iostream> #include <vector> using namespace std; class Demo { double d;
434 Самоучитель C++ public: Demo () { d = 0.0; } Demo (double x) { d = x; } Demo ^operator-(double x) ( d = x; return ''this; } double getd() (return d; } boll operator< (Demo a, Demo b) { return a.getdf) < b.getdf); 1 boll operator- (Demo a, Demo b} { return a.getd() == b.getdO; }int mainO { vector<Demo> v; int i; for{i=0; i v.push_back(Demo (i/3. 0) ) ; for (i=0; Kv.size () ; i cout " v[i].getd() " " "; cout " endl; for(i=0; i<v.size(}; i++) v[i] = v[i] .getdO * 2.1; for (i=0; Kv.size () ; i cout " v[i].getd() " " "; return 0; После выполнения программы на экране появится следующее: О 0.333333 0.666667 1 1.33333 1.66667 2 2.33333 2.66667 3 О 0.7 1.4 2.1 2.8 3.5 4.2 4.9 5.6 6.3 Упражнеенниияя] 1. Поэкспериментируйте с представленными примерами. Попытайтесь делать небольшие изменения в программах и исследуйте результаты.
Глава 14. Библиотека стандартных шаблонов 435 2. В примере 4 для класса Demo были определены два конструктора - конст-руктор по умолчанию (конструктор без параметров) и конструктор с пара-метрами. Сможете ли вы объяснить, почему это так важно? 3. Ниже представлен пример класса Coord. Напишите программу для хранения объектов типа Coord в векторе. (Подсказка: не забудьте для класса Coord оп-ределить операторы < и ==.) class Coord ( public: int x, у; Coord(} { x = у = 0; } Coord(int a, int b) { x = а; у = b; } 14.4. Списки Класс list поддерживает двунаправленный линейный список. В отличии от вектора, в котором реализован произвольный доступ, к элементам списка доступ может быть только последовательным. Поскольку списки являются двунаправленными, доступ к элементам списка возможен с обеих его сторон. Ниже представлена спецификация шаблона для класса list: template<class Tr class Allocator = allocator<T"class list Здесь Т - это тип данных, предназначенных для хранения в списке, а клю-чевое слово Allocator задает распределитель памяти, который по умолчанию является стандартным распределителем памяти. В классе list определены следующие конструкторы: explicit list(const Allocator Sa - Allocator()); explicit list (size_type число, const Т &аначение = TO f const Allocator &a = Allocator{)); list(const list<T, Allocator>£объект); template<class Inlter>list{Inlter на"ало, Inlter конец, const Allocator fia = Allocator<)); Первая форма представляет собой конструктор пустого списка. Вторая фор-ма - конструктор списка, число элементов которого - это число, а каждый элемент равен значению значение, которое может быть значением по умол-чанию. Третья форма конструктора предназначена для списка из одинако-вых элементов, каждый из которых - это объект. Четвертая форма - это конструктор списка, содержащего диапазон элементов, заданный итерато-рами начало и конец.
436 Самоучитель C++ Для класса list определяются следующие операторы сравнения: ==, <, <=, г=, >, >= В табл. 14.3 представлены функции - члены класса list. Размешать элемен-ты в конце списка можно с помощью функции pushJbackQ (как и в случае с вектором), в начале - с помощью функции push_front(), а в середине - с помощью функции insert(). Для соединения (Join) двух списков нужна функ-ция splice(), а для слияния (merge) - функция merge(). Для любого типа данных, которые вы собираетесь хранить в списке, должен быть определен конструктор по умолчанию. Кроме этого, необходимо опре-делить различные операторы сравнения. К моменту написания этой книги точные требования к объектам, предназначенным для хранения в списке, у разных компиляторов были разными, поэтому перед использованием списка тщательно изучите техническую документацию на ваш компилятор. Таблица 14.3. Функции - члены класса list Функция-член Описание template<class lnlter> void assignflnlter начало, Inlter конец); template<class Size, class T> void assign (Size число, const Т &значение -T()); reference back(); const__reference backf) const; iterator beginf); constjterator begin() const; void clear(); bool emptyO const; iterator cnd(); const_iterator end() const; Iterator erasefiterator /); iterator erasefiterator начало^ iterator конец); reference frontf); const_reference front() const; allocator_type get_allocator() const; Присваивает списку последовательность, оп-ределенную итераторами начало и конец Присваивает списку число элементов, причем значение каждого элемента равно параметру значение Возвращает ссылку на последний элемент списка Возвращает итератор первого элемента спи-ска Удаляет все элементы списка Возвращает истину, если вызывающий список пуст, в противном случае возвращает ложь Возвращает итератор конца списка Удаляет элемент, на который указывает ите-ратор /. Возвращает итератор элемента, кото-рый расположен следующим за удаленным Удаляет элементы, заданные между итерато-рами начало и конец. Возвращает итератор элемента, который расположен следующим за последним удаленным Возвращает ссылку на первый элемент списка Возвращает распределитель памяти списка
Глава 14. Библиотека стандартных шаблонов 437 Таблица 14.3 (продолжение) Функция-член Описание iterator insertflterator i, const Т &значение = Т()); void insert(iterator j, size_type число, const Т &значение); template<class lnlter> void insert(iterator /, Inlter начало, Inlter конец); size_type max_size() const; void merge(list<T, Allocator> &объект); template<class Comp> void merge(llst<T, Allocator> &объект, Comp ф^сравн); void pop_back(); void pop_front(); void push_back(const Т ^значение); void p u sh__f го nt( const Т & значение); reversejterator rbeginf); const.reversejterator rbeglnO const; void remove(const Т &значение); template<class UnPred> void remove_lf(UnPred пред); reversejterator rend(); const_reverse_iterator rendO const; void resize(size_type число, Т значение = T()); void reverse!); Вставляет параметр значение перед элемен-том, заданным итератором /. Возвращает ите-ратор элемента Вставляет число копий параметра значение перед элементом, заданным итератором i Вставляет последовательность, определенную между итераторами начало и конец, перед элементом, заданным итератором i Возвращает максимальное число элементов, которое может храниться в списке Выполняет слияние упорядоченного списка, хранящегося в объекте объект, с вызываю-щим упорядоченным списком. Результат упо-рядочивается. После слияния список, храня-щийся в объекте объект становится пустым. Во второй форме для определения того, явля-ется ли значение одного элемента меньшим, чем значение другого, может задаваться функция сравнения ф_сравн Удаляет последний элемент списка Удаляет первый элемент списка Добавляет в конец списка элемент, значение которого равно параметру значение Добавляет в начало списка элемент, значение которого равно параметру значение Возвращает обратный итератор конца списка Удаляет из списка элементы, значения кото-рых равны параметру значение Удаляет из списка значения, для которых ис-тинно значение унарного предиката пред Возвращает обратный итератор начала списка Изменяет размер списка в соответствии с параметром число. Если при этом список удлиняется, то добавляемые в конец списка элементы получают значение, заданное пара-метром значение Выполняет реверс (т. е. реализует обратный порядок расположения элементов) вызываю-щего списка
438 Самоучитель C++ Таблица 14.3 (продолжение) Функция-член Описание sizejtype size() const; void sort(); template<class Comp> void sort Comp ф_сравн); void splicefiterator /, list<T, AHocator> &объекг); void spllcefiterator i, list<T, Allocator> &объект, iterator элемент); void splicefiterator /, list<T, Allocator> Лобьскг, iterator начало, iterator конец); void swap(list<T, Allocator> & объект); void unlque(); template<class BinPred> void unique(BinPred пред); Возвращает хранящееся на данный момент в списке число элементов Сортирует список. Во второй форме для оп-ределения того, является ли значение одного элемента меньшим, чем значение другого, может задаваться функция сравнения ф_сравн Вставляет содержимое объекта объект в вы-зывающий список. Место вставки определяет-ся итератором /. После выполнения операции объект становится пустым Удаляет элемент, на который указывает ите-ратор элемент, из списка, хранящегося в объекте объект, и сохраняет его в вызываю-щем списке. Место вставки определяется итератором /Удаляет диапазон элементов, обозначенный итераторами начало и конец, из списка, хранящегося в объекте объект, и сохраняет его в вызывающем списке. Место вставки определяется итератором /Обменивает элементы из вызывающего спи-ска с элементами из объекта объект Удаляет из вызывающего списка парные эле-менты, Во второй форме для выяснения уни-кальности элементов используется предикат пред Примерры int main i) 1. Ниже представлен пример простого списка. //Основные операции списка ^include <iostream> ^include <list> using namespace std; list*^char> 1st; //создание пустого списка int i; for{i=0; i<!0; i++) 1st .push_back ( 'A' + i) cout " "Размер = " " 1st. size () " endl;
Глава 14. Библиотека стандартных шаблонов 439 list<char>::iterator p; cout " "Содержимое: "; while(!1st.empty(}) { p = lst.begin(); cout " *p; 1st.pop front(); return 0; После выполнения программы на экране появится следующее: Размер = 10 Содержимое: ABCDEFGHIJ В этой программе создается список символов. Сначала создается пустой спи-сок. Затем туда помещается десять символов (буквы от А до J включительно). Зга операция выполняется с помощью функции push_back(), которая поме-щает каждое следующее значение в конец существующего списка. Далее раз-мер списка выводится на экран. После этого организуется вывод на экран содержимого списка, для чего каждый раз последовательно извлекают, выво-дят на экран и удаляют очередной первый элемент списка. Этот процесс продолжается, пока список не опустеет. 2. В предыдущем примере, пройдя список от начала до конца, мы его опусто-шили. Это, конечно, не обязательно. Ниже представлена переработанная версия программы. #include <iostream> ^include <list> using namespace std; int main{) list<char> 1st; int i; for{i=0; i<10; i++) 1st-push_back('A1 + i}; cout " "Размер = " " 1st.size () " endl; list<char>::iterator p = lst.begin{); cout " "Содержимое: "; while(p != 1st.end(}) { cout " *p;
440 Самоучитель C++ return 0; J. В данной программе итератор р инициализируется таким образом, чтобы он указывал на начало списка, Затем при каждом проходе цикла итератор р ин-крементируется, что заставляет его указывать на следующий элемент списка. Цикл завершится, когда итератор р укажет на конец списка. 3. Поскольку список является двунаправленным, размещать элементы в нем можно как с начала списка, так и с его конца. В следующей программе соз-дается два списка, причем во втором списке организуется обратный первому порядок расположения элементов. //Элементы можно размещать не только начиная с начала списка, //но также и начиная с его конца ^include <iostream> ^include <list> using namespace std; int main() ( list<char> 1st; list<char> revlst; int i; for(i=0; i<10; i-H-) 1st .push_back ('A' + i) ; cout " "Размер прямого списка = " " 1st.size () " endl; cout " "Содержимое прямого списка: "; list<char>;:iterator p; //Удаление элементов из первого списка //и размещение их в обратном порядке во втором списке while(!1st.empty{)) { р = 1st.begin(); cout " *р; 1st.pop_front!); revlst.push_front(*p); }cout " endl; cout " "Размер обратного списка = "; cout " revlst.size() " endl; cout " "Содержимое обратного списка: "; р = revlst.begin(); while(р != revlst.end{)) { cout " *p; P+-H;
Глава 14. Библиотека стандартных шаблонов _ 447 return 0; 1 После выполнения программы на экране появится следующее: Размер прямого списка = 10 Содержимое прямого списка: ABCDEFGHIJ Размер обратного списка = 10 Содержимое обратного списка: JIHGFEDCBA В данной программе реверс списка 1st достигается следующим образом: эле-менты поочередно извлекаются из начала списка 1st и размешаются в начале списка revlst. Таким образом в списке revlst реализуется обратный порядок расположения элементов. 4. Вызвав функцию-член sortQ, вы можете отсортировать список. В следующей программе создается список случайных символов, а затем эти символы сор-тируются. //Сортировка списка ^include <iostream> ^include <list> tinclude <cstdlib> using namespace std; int main() { list<char> 1st; int i ; //заполнение списка случайными символами for(i=0; i<10; i++) 1st .push_back ( 'A' + (rand { ) %26) } ; cout " "Исходное содержимое : " ; list<char>: : iterator p = Ist.beginf); while (p != 1st. end!) ) { cout " *p; cout " endl; //сортировка списка 1st . sort ( } ; cout " "Отсортированное содержимое p = lst.begin() ; while (p != 1st. end () ) { cout " *p;
442 _ Самоучитель C++ return 0; )После выполнения программы на экране появится следующее: Исходное содержимое : PHQGHUMEAY Отсортированное содержимое: AEGHHMPQQY 5. Отсортированный список можно слить с другим. В результате будет получен новый отсортированный список с содержимым, состоящим из содержимого обоих исходных списков. Новый список остается в вызывающем списке, а второй список оказывается пустым. Ниже представлен пример слияния двух списков. В первом находятся символы ACEGI, а во втором - BDFHJ. После слияния мы получим последовательность ABCDEFGHIJ. //Слияние двух списков ^include <io5tream> #include <list> using namespace std; int main ( ) { list<char> Istl, Ist2; int i; for (1=0; i<10; i+=2) Istl .push_back ( 'A1 + i) ; for (1=1; i<ll; i+=2) Ist2 .push_back ( 'A' + i) ; cout " "Содержимое первого списка : list<char>; : iterator p = Istl. begin ( while(p != Istl. end () ) ( cout " *p; P++; }cout " endl; cout " "Содержимое второго списка : p -Ist2.begin() ; whileip != Ist2.end()) { cout " *p; cout " endl; //Слияние двух списков Istl.merge(Ist2); if {Ist2.empty() ) cout " "Теперь второй список пуст\п";
Глава 14. Библиотека стандартных шаблонов _ 443_ cout " "Содержимое первого списка после слияния :\п"; р = Istl. begin ( ) ; while (p 1= Istl.endO) { cout " *p; return 0; После выполнения программы на экране появится следующее: Содержимое первого списка: ACEGI Содержимое второго списка: BDFHJ Теперь второй список пуст Содержимое первого списка после слияния: ABCDEFGHIJ 6. В следующем примере список используется для хранения объектов типа Project. Project - это класс, с помощью которого организуется управление программными проектами. Обратите внимание, что для объектов типа Project перегружаются операторы <, >, != и ==. Перегрузки этих операторов требует компилятор Microsoft Visual C+4-5. (Именно этот компилятор использовался при отладке примеров данной главы.) Для других компиляторов может по-требоваться перегрузить какие-либо дополнительные операторы. В библиоте-ке стандартных шаблонов с помощью указанных оператор -функций сравни-ваются объекты, хранящиеся в контейнере. Хотя список не является контей-нером с упорядоченным хранением элементов, тем не менее и здесь при поиске, сортировке или слиянии элементы приходится сравнивать. ^include <iostream> ^include <list> #include <cstring> using namespace std; class Project { public: char name [40] ; int days_to_completion; ProjectO { strcpy (name, " ") ; days__to_completion = 0; }Project (char *n, int d) { strcpy {name, n) ; days_to_completion = d; \
444 Самоучитель C++ void add_days(int i) ( days_tcj_completion += i; void sub_days(int i) { days_to_completion -= i; } bool completed() { return !days_to_completion; } void report() { cout " name " ": "; cout " days__to_completion; cout " " дней до завершения\п"; bool operator<(const Project &a, const Project sb) return a,days_to_completion < b.days_to_completion; bool operator>(const Project &a, const Project &b) return a.days_to_completion > b.days_to_completion; i bool operator==(const Project &a, const Project &b) return a.days_to_completion == b.days_to_completion; } bool operator!=(const Project &a, const Project &b) return a.days_to_completion != b.days_to_completion; int main() list<Project> proj; proj.push_back(Project("Разработка компилятора", 35}); proj.push_back(Project("Разработка электронной таблицы", 190)) proj.push_back(Project{"Разработка STL", 1000}); list<Project>::iterator p = proj.begin(}; //вывод проектов на экран while (p != proj.endO) { p->report(}; P++;
Глава 14. Библиотека стандартных шаблонов 445 //увеличение сроков выполнения первого проекта на 10 дней р = proj.begin(); p~>add_days{10); //последовательное завершение первого проекта do {p->sub_days(5); p->report () ; } while (!p->completeci{) ) ; return 0; После выполнения программы на экране появится следующее: Разработка компилятора: 35 дней до завершения Разработка электронной таблицы: 190 дней до завершения Разработка STL: 1000 дней до завершения Разработка компилятора: 40 дней до завершения Разработка компилятора: 35 дней до завершения Разработка компилятора: 30 дней до завершения Разработка компилятора: 25 дней до завершения Разработка компилятора: 20 дней до завершения Разработка компилятора: 15 дней до завершения Разработка компилятора: 10 дней до завершения Разработка компилятора: 5 дней до завершения Разработка компилятора: 0 дней до завершения 1. Поэкспериментируйте с представленными примерами. Попытайтесь делать небольшие изменения в программах и исследуйте результаты. 2. В примере 1 после вывода информации на экран список опустел. В примере 2 вы узнали об одном из способов исследования содержимого списка, при котором он остается неповрежденным. Можете ли вы придумать другой спо-соб просмотреть список, не опустошая его при этом? Продемонстрируйте ваше решение, заменив необходимые инструкции в программе из примера 1. 3. Отталкиваясь от программы из примера 6, создайте еще один список, в ко-тором представьте следующие проекты: Проект Срок завершения Разработка базы данных 780 Разработка стандартных писем 50 Разработка объектов СОМ 300
446 Самоучитель C++ После создания второго списка выполните сортировку и затем слияние обо-их списков. Выведите на экран итоговый результат. 14.5. Ассоциативные списки Класс тар поддерживает ассоциативный контейнер, в котором каждому зна-чению соответствует уникальный ключ. По существу, ключ - это просто имя, которое вы присваиваете значению. После того как значение помещено в контейнер, извлечь его оттуда можно с помощью ключа. Таким образом, в самом общем смысле можно сказать, что ассоциативный список представляет собой список пар ключ/значение. Преимущество ассоциативных списков со-стоит в возможности получения значения по данному ключу. Например, ис-пользуя ассоциативный список, можно хранить имена телефонных абонентов в качестве ключей, а номера телефонов в качестве значений. Ассоциативные контейнеры в программировании становятся все более и более популярными. Как уже упоминалось, в ассоциативном списке можно хранить только уни-кальные ключи. Дублирования ключей не допускается. Для создания ассоциа-тивного списка с неуникальными ключами используется класс-контейнер multimap. Ниже представлена спецификация шаблона для класса тар: template<class Key, class Т, class Comp = less<Key>, class Allocator = allocator<T"class map Здесь Key - это данные типа ключ, Т - тип данных, предназначенных для хранения (в карте), a Comp -функция для сравнения двух ключей, которой по умолчанию является стандартная объект-функция lessQ, Ключевое слово Allocator задает распределитель памяти (которым по умолчанию является allocator). В классе тар определены следующие конструкторы: explicit map (const Comp &ф_сравн = СошрО, const Allocator Sa = Allocator()); map (const map<Key, T, Comp, Allocator>fiooieJC!r) ; teroplate<class Inlter>map(Inlter начало, Inlter конец, const Comp &ф_сравн = CompO , const Allocator &a = Allocator ()) ; Первая форма представляет собой конструктор пустого ассоциативного спи-ска. Вторая форма конструктора предназначена для ассоциативного списка из одинаковых элементов, каждый из которых - это объект. Третья фор-ма - это конструктор ассоциативного списка, содержащего диапазон эле-ментов, заданный итераторами начало и конец. Функция сравнения ф_сравн,
Глава 14. Библиотека стандартных шаблонов 447 если она присутствует, задает порядок сортировки элементов ассоциатив-ного списка. Как правило, для любого объекта, заданного в качестве ключа, должны быть определены конструктор по умолчанию и несколько операторов сравнения. Для класса тар определяются следующие операторы сравнения: = = , <, <=, !=, >, >= В табл. 14.4 представлены функции - члены класса тар. В данной таблице тип key_type - это тип ключа, a key_value - тип пары ключ/значение (тип pair < Key, T>). Функция-член Таблица 14.4. Функции - члены класса тар Описание iterator beginf); constjterator begin() const; void clear(); size_type count (const key_type &k) const; bool emptyO const; iterator end(); const_iterator end() const; pair<iterator, lterator> equal_range (const key_type &k); pair<const_iterator, const_Iterator> equal_range(const key^type &k) const; void erase(iterator /); void eraseflterator начало, iterator конец); size_type erase (const key_type &k); iterator find(const key_type &k); constjterator find (const key_type &k) const; allocator_type get_allocator() const; Возвращает итератор первого элемента ассо-циативного списка Удаляет все элементы ассоциативного списка Возвращает 1 или 0, в зависимости от того, встречается или нет в ассоциативном списке ключ k Возвращает истину, если вызывающий ассо-циативный список пуст, в противном случае возвращает ложь Возвращает итератор конца ассоциативного списка Возвращает пару итераторов, которые указы-вают на первый и последний элементы ассо-циативного списка, содержащего указанный ключ k Удаляет элемент, на который указывает ите-ратор i Удаляет элементы, заданные между итерато-рами начало и конец Удаляет элементы, соответствующие значе-нию ключа k Возвращает итератор по заданному ключу к. Если ключ не обнаружен, возвращает итера-тор конца ассоциативного списка Возвращает распределитель памяти ассоциа-тивного списка
448 Самоучитель C++ Таблица 14.4 (продолжение) Функция-член Описание iterator insertffterator /, const value_type ^значение); template<class lnlter> void Ensert(lnlter начало, Inlter конец); paiKiterator, bool>insert (const value_type &значение); key_compare key_comp() const; iterator lower_bound (const key_type &fc); constjterator lower_bound (const key_type &k) const; size_type max_size() const; reference operator[] (const key_type &i); reverse_iterator rbegin(); const_reverse_iterator rbegin() const; reversejterator rendf); const_reverse_lterator rend() const; size_type size() const; void swap(map<Key, T, Comp, Allocator> & объект); iterator upper_bound (const key_type &.k); constjterator upper_bound (const key_type &k) const; value_compare value_comp() const; Вставляет параметр значение на место эле-мента или после элемента, заданного итера-тором i". Возвращает итератор этого элемента Вставляет последовательность элементов, заданную итераторами начало и конец Вставляет значение в вызывающий ассоциа-тивный список. Возвращает итератор встав-ленного элемента. Элемент вставляется толь-ко в случае, если такого в ассоциативном спи-ске еще нет. При удачной вставке элемента функция возвращает значение pair<iterator, true>, в противном случае - paiKiterator, false> Возвращает объект-функцию сравнения клю-чей Возвращает итератор первого элемента ассо-циативного списка, ключ которого равен или больше заданного ключа k Возвращает максимальное число элементов, которое можно хранить в ассоциативном списке Возвращает ссылку на элемент, соответст-вующий ключу I. Если такого элемента не су-ществует, он вставляется в ассоциативный список Возвращает обратный итератор конца ассо-циативного списка Возвращает обратный итератор начала ассо-циативного списка Возвращает хранящееся на данный момент в ассоциативном списке число элементов Обменивает элементы из вызывающего ассо-циативного списка с элементами из объекта объект Возвращает итератор первого элемента ассо-циативного списка, ключ которого больше заданного ключа k Возвращает объект-функцию сравнения зна-чений
Глава 14. Библиотека стандартных шаблонов 449 В ассоциативном списке хранятся пары ключ/значение в виде объектов типа pair. Шаблон объекта типа pair имеет следующую спецификацию: template<class Ktype, class Vtype> struct pair { typedef Ktype первый_тяп; //тип ключа typedef Vtype второй тип; //тип значения Ktype первый; //содержит ключ второй; //содержит значение //конструкторы pair () ; pair (const Ktype &k, const Vtype fiv) ; template< class A, class B> pair (const<A, B> &объект) Ранее уже говорилось, что значение переменной первый содержит ключ и значение, а значение переменной второй - значение, соответствующее это-му ключу. Создавать пары ключ/значение можно не только с помощью конструкторов класса pair, но и с помощью функции make_pair(), которая создает объекты типа pair, используя типы данных в качестве параметров. Функция make_pair() - это родовая функция со следующим прототипом: template<class Ktype, class Vtype> pair<Ktype, Vtype>make_pair (const Ktype fit, const Vtype fiv) ; Как видите, функция возвращает объект типа pair, содержащий заданные в качестве параметров функции значения типов Ktype и Vtype. Преимущество использования функции make_pair() состоит в том, что она дает возмож-ность компилятору автоматически распознавать типы предназначенных для хранения объектов, и вам не нужно указывать их явно. В следующей программе на примере ассоциативного списка, предназначен-ного для хранения десяти пар ключ/значение, иллюстрируются основы ис-пользования ассоциативных списков. Ключом здесь является символ, а зна-чением - целое. Пары ключ/значение хранятся следующим образом: А О в 1 С 2 . . . J 9 Поскольку пары хранятся именно таким образом, то, когда пользователь на-бирает на клавиатуре ключ (т. е. одну из букв от А до J), программа выводит на экран соответствующее этому ключу значение.
450 _ _ Самоучитель С++ II Иллюстрация возможностей ассоциативного списка ^include <iostream> ^include <map> using namespace std; int main{} { map<char, int> m; int i ; //размещение пар в ассоциативном списке for(i=0; i<10; i++) { m. insert !pair<char, int>('A' + i, i) ) ; 1char ch; cout " "Введите ключ: "; cin " ch; map<char, int>: : iterator p; //поиск значения по заданному ключу Р = m. find(ch) ; if (p != m.endO } cout " p->second; elsecout " "Такого ключа в ассоциативном списке нет\п"; return 0; Обратите внимание на использование класса-шаблона pair для образования пар ключ/значение. Типы данных, указанные в классе -шаблоне pair, должны соответствовать типам данных, хранящимся в ассоциативном списке. После того как ассоциативный список инициализирован парами ключ/значе-ние, найти нужное значение по заданному ключу можно с помощью функ-ции findQ. Функция find() возвращает итератор соответствующего ключу эле-мента или итератор конца ассоциативного списка, если указанный ключ не найден. Когда соответствующее ключу значение найдено, оно сохраняется в качестве второго члена класса-шаблона pair. 2. В предыдущем примере типы пар ключ/значение были указаны явно в кон-струкции pair<char, int>. Хотя такой подход совершенно правилен, часто проще использовать функцию make_pair(), которая создает пары объектов на основе типов данных своих параметров. ^include <iostream> ^include <map> using namespace std;
Глава 14. Библиотека стандартных шаблонов _ 451 int main { ) { map<char, int> m; int i; //размещение пар в ассоциативном списке for(i=0; i<10; i++) { m. insert {make__pair (char) ( ' A ' H-i, i) ) ; char ch; cout " "Введите ключ: "; с in " ch; map<char, int>: : iterator p; //поиск значения по заданному ключу р = m. find(ch) ; if (р !-т. end () ) cout " p->second; elsecout " "Такого ключа в ассоциативном списке нет\п"; return 0; Данный пример отличается от предыдущего только строкой m. insert (make_pair (char) ( ' A ' + i, i) ) ; В данном случае, чтобы в операции сложения 'А* + i не допустить автомати-ческого преобразования в тип int, используется приведение к типу char. Во всем остальном процесс определения типов объектов выполняется автомати-чески. Так же как и в других контейнерах, в ассоциативных списках можно хранить создаваемые вами типы данных. Например, в представленной ниже програм-ме создается ассоциативный список для хранения слов с соответствующими словам антонимами. С этой целью используются два класса: word (слово) и opposite (антоним). Поскольку для ассоциативных списков поддерживается отсортированный список ключей, в программе для объектов типа word опре-деляется оператор <. Как правило, оператор < необходимо перегружать для всех классов, объекты которых предполагается использовать в качестве клю-чей. (Помимо оператора < в некоторых компиляторах может потребоваться определить дополнительные операторы сравнения.) //Ассоциативный список слов и антонимов tinclude <iostream> # include <map> #include <cstring> using namespace std;
452 _ ___________ _ Самоучитель C++ class word { char str [20]; public: wordO { strcpy(str, ""); } word(char *s) { strcpyfstr, s); } char *get() { return str; } //для объектов типа word следует определить оператор < (меньше) bool operator< (word a, word b) { return strcmp(a.get {) , b.getO) < 0; }class opposite { char str [20] ; public: opposite!) { strcmp(str, ""); } opposite (char *s) ( strcpyfstr, s) ; } char *get() { return str; } )! int main() { map<word, opposite> m; //размещение в ассоциативном списке слов и антонимов m. insert (pair<word, opposite> (word ("да") , opposite ("нет") } ) ; m. insert (pair<word, opposite> (word ("хорошо") , opposite ("плохо") } ) ; m. insert {pair<word, opposite> (word ("влево") , opposite ("вправо") ) ) ; m. insert (pair<word, opposite> (word ("вверх") , opposite ("вниз") } ) ; //поиск антонима по заданному слову char str [80] ; cout " "Введите слово: "; cin " str; map<word, opposite>: : iterator p; p = m. find{word(str) ) ; if (p != m.endO ) cout " "Антоним: " " p->second.get () ; elsecout " "Такого слова в ассоциативном списке нет\п";
Глава14. Библиотека стандартных шаблонов 453 return 0; i В данном примере любой объект, который вводится в ассоциативный спи-сок, представляет собой символьный массив для хранения заканчивающейся нулем строки. Далее в этой главе будет показано, как упростить эту про-грамму, используя стандартный тип данных string. 1. Поэкспериментируйте с представленными примерами. Попытайтесь делать небольшие изменения в программах и исследуйте результаты. 2. Создайте ассоциативный список для хранения имен абонентов и их теле-фонных номеров. Имена и номера телефонов должны вводиться пользовате-лем, а поиск нужного номера должен выполняться по введенному имени абонента. (Подсказка: в качестве модели воспользуйтесь примером 3.) 3. Нужно ли определять для объектов оператор <, если эти объекты использу-ются в качестве ключей ассоциативного списка? 14.6. Алгоритмы Как уже объяснялось, алгоритмы предназначены для разнообразной обра-ботки контейнеров. Хотя в каждом контейнере поддерживается собственный базовый набор операций, стандартные алгоритмы обеспечивают более ши-рокие и комплексные действия. Кроме этого, они позволяют одновременно работать с двумя контейнерами разных типов. Для доступа к алгоритмам библиотеки стандартных шаблонов в программу необходимо включить заго-ловок <algorithm>. В библиотеке стандартных шаблонов определяется большое число алгорит-мов, которые систематизированы в табл. 14.5. Все алгоритмы представляют собой функции-шаблоны. Это означает, что их можно использовать с кон-тейнерами любых типов. Наиболее показательные варианты такого исполь-зования приведены в примерах данного раздела. Таблица 14.5. Алгоритмы библиотеки стандартных шаблонов Алгоритм Назначение adjacentjflnd Выполняет поиск смежных парных элементов в последовательности. Возвращает итератор первой пары bfnary_search Выполняет бинарный поиск в упорядоченной после-довательности
454 Самоучитель C++ Таблица 14.5 (продолжение) Алгоритм Назначение copy copy_backward count count_If equal equal_range fill find find_end find_first_of findjf for_each generate generate.n includes inplace_merge iter_swap lexicographical_compare lower_bound make_heap Копирует последовательность Аналогична функции сору{), за исключением того, что перемещает в начало последовательности эле-менты из ее конца Возвращает число элементов в последовательности Возвращает число элементов в последовательности, удовлетворяющих некоторому предикату Определяет идентичность двух диапазонов Возвращает диапазон, в который можно вставить элемент, не нарушив при этом порядок следования элементов в последовательности Заполняет диапазон заданным значением Выполняет поиск диапазона для значения и возвра-щает первый найденный элемент Выполняет поиск диапазона для подпоследователь-ности. Функция возвращает итератор конца подпос-ледовательности внутри диапазона Находит первый элемент внутри последовательно-сти, парный элементу внутри диапазона Выполняет поиск диапазона для элемента, для кото-рого определенный пользователем унарный преди-кат возвращает истину Назначает функцию диапазону элементов Присваивает элементам в диапазоне значения, воз-вращаемые порождающей функцией Определяет, включает ли одна последовательность все элементы другой последовательности Выполняет слияние одного диапазона с другим. Оба диапазона должны быть отсортированы в порядке возрастания элементов. Результирующая последо-вательность сортируется Меняет местами значения, на которые указывают два итератора, являющиеся аргументами функции Сравнивает две последовательности в алфавитном порядке Обнаруживает первое значение в последовательно-сти, которое не меньше заданного значения Выполняет пирамидальную сортировку последова-тельности (пирамида, на английском языке heap, - полное двоичное дерево, обладающее тем свойст-вом, что значение каждого узла не меньше значения любого из его дочерних узлов. - Примеч. пер.)
Глава 14. Библиотека стандартных шаблонов 455 Таблица 14.5 (продолжение) Алгоритм Назначение max max element merge mln min_element mismatch next_per mutation nth_element parti assort partial_sort_copy partition pop_heap prev_permutation push_heap random_shuffle remove remove_lf remove_copy re m ove_co py_if replace replacejf replace_copy replace_copy_if reverse reverse_copy Возвращает максимальное из двух значений Возвращает итератор максимального элемента внутри диапазона Выполняет слияние двух упорядоченных последова-тельностей, а результат размещает в третьей после-довательности Возвращает минимальное из двух значений Возвращает итератор минимального элемента внут-ри диапазона Обнаруживает первое несовпадение между элемен-тами в двух последовательностях. Возвращает ите-раторы обоих несовпадающих элементов Образует следующую перестановку (permutation) последовательности Упорядочивает последовательность таким образом, чтобы все элементы, меньшие заданного элемента Е, располагались перед ним, а все элементы, боль-шие заданного элемента Е, - после него Сортирует диапазон Сортирует диапазон, а затем копирует столько эле-ментов, сколько войдет в результирующую последо-вательность Упорядочивает последовательность таким образом, чтобы все элементы, для которых предикат возвра-щает истину, располагались перед элементами, для которых предикат возвращает ложь Меняет местами первый и предыдущий перед по-следним элементы, а затем восстанавливает пира-миду Образует предыдущую перестановку последова-тельности Размещает элемент на конце пирамиды Беспорядочно перемешивает последовательность Удаляет элементы из заданного диапазона Заменяет элементы внутри диапазона Меняет порядок сортировки элементов диапазона на обратный
456 Самоучитель C++ Таблица 14.5 (продолжение) Алгоритм Назначение rotate rotate_copy search search_n set_difference set_intersection set_symmetric_dif fere nee set_unlon sort sort_heap stable^partition stable_sort swap swap_ranges transform unique unique_copy upper_bound Выполняет циклический сдвиг влево элементов в диапазоне Выполняет поиск подпоследовательности внутри последовательности Выполняет поиск последовательности заданного числа одинаковых элементов Создает последовательность, которая содержит раз-личающиеся участки двух упорядоченных наборов Создает последовательность, которая содержит одинаковые участки двух упорядоченных наборов Создает последовательность, которая содержит симметричные различающиеся участки двух упоря-доченных наборов Создает последовательность, которая содержит объединение (union) двух упорядоченных наборов Сортирует диапазон Сортирует пирамиду внутри диапазона Упорядочивает последовательность таким образом, чтобы все элементы, для которых предикат возвра-щает истину, располагались перед элементами, для которых предикат возвращает ложь. Разбиение на разделы остается постоянным; относительный поря-док расположения элементов последовательности не меняется Сортирует диапазон. Одинаковые элементы не пе-реставляются Меняет местами два значения Меняет местами элементы в диапазоне Назначает функцию диапазону элементов и сохраня-ет результат в новой последовательности Удаляет повторяющиеся элементы из диапазона Обнаруживает последнее значение в последова-тельности, которое не больше некоторого значения [Примеры l"""'''"^f 1. Одними из самых простых алгоритмов являются алгоритмы count() и coimt_if(). Ниже представлены их основные формы: template<class Inlter, class T> size_t count(Inlter начало, Inlter окончание, const Т
Глава 14. Библиотека стандартных шаблонов _ 457 template<class Inlter, class T> size_t count (Inlter начало, Inlter окончание, UnFred &ф_предикат) ; Алгоритм count() возвращает число элементов в последовательности, начиная с элемента, обозначенного итератором начало, и заканчивая элементом, обо-значенным итератором окончание, значение которых равно параметру значе-ние. Алгоритм countJfO возвращает число элементов в последовательности, начиная с элемента начало и заканчивая элементом окончание, для которых унарный предикат ф_предикат возвращает истину. В следующей программе демонстрируются алгоритмы count() и count_if(). //Демонстрация алгоритмов count и count_if ^include <iostream> ttinclude <vector> ^include <algoritm> using namespace std; /* это унарный предикат, который определяет, является ли значение четным */bool even(int x) { return ! (x%2) ; int main { } { vector<int> v; int i ; for{i=0; i<20; if(i%2) v.push_back(l) ; else v.push_back(2) ; cout " "Последовательность: "; for(i=0; i<v.size(}; i-н-) cout " v[i] cout " endl; int n; n = count ( v. begin () , v.end(), 1); cout " n " " элементов равно 1\п"; n = count_if (v. begin () , v.endO, even) cout " n " " четных элементов\п"; return 0;
458 _ Самоучитель C++ После выполнения программы на экране появится следующее: Последовательность: 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 10 элементов равно 1 10 четных элементов Программа начинается с создания 20-элементного вектора, содержащего че-редующиеся значения 1 и 2. Для подсчета единиц используется алгоритм count (), а для подсчета четных элементов - алгоритм count_if() Отметьте, как программируется унарный предикат even(). Все унарные предикаты по-лучают в качестве параметра объект, тип которого тот же, что и тип объектов контейнера, для работы с которым предназначен предикат. В зависимости от значения этого объекта унарный предикат должен возвращать истину либо ложь. 2. Иногда полезно генерировать новую последовательность, состоящую только из определенных фрагментов исходной последовательности. Одним из пред-назначенных для этого алгоритмов является алгоритм remove_copy(), основ-ная форма которого представлена ниже: template<class Inlter, class Outlter, class T> Outlter remove copy (Inlter начало, Inlter окончание, Outlter результат, const Т йзнауение) ; Алгоритм remove_copy() копирует элементы, равные параметру значение, из заданного итераторами начало и окончание диапазона и размещает результат в последовательности, обозначенный итератором результат. Алгоритм воз-вращает итератор конца новой последовательности. Результирующий кон-тейнер должен быть достаточно велик для хранения новой последовательности. В следующем примере показана работа алгоритма remove_copy(). Сначала в программе создается чередующаяся последовательность значений 1 и 2. За-тем из последовательности удаляются все единицы. //Демонстрация алгоритма remove_copy ttinclude <iostream> tfinclude <vector> ^include <algorithm> using namespace std; int main( ) { vector<int> v, v2(20); int i; for(i=0; i<20; if(i%2) v.push_back(l) ; else v.push__back{2) ;
Глава 14. Библиотека стандартных шаблонов _ 459 cout " "Последовательность: "; for(i=0; Kv.sizeO; i++) cout " v[i] " " "; cout " endl; //удаление единиц remove_copy ( v . begin () , v.end() , v2 .begin {) , 1) ; cout " "Результат: "; for(i=0; i<v2.size(); i++) cout " v2[i] " " cout " endl; return 0; , После выполнения программы на экране появится следующее: Последовательность: 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 Результат: 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 3. Еще одним полезным алгоритмом является алгоритм reverse(), который ме-няет порядок расположения элементов последовательности на обратный. Ниже представлена основная форма этого алгоритма: template<class Bilter> void reverse (Bitter начало, Bilter окончание) ; Алгоритм reverse() меняет на обратный порядок расположения элементов в диапазоне, заданном итераторами начало и окончание. В следующем примере показана работа алгоритма reverse(). //Демонстрация алгоритма reverse ^include <iostream> #include <vector> ^include <algorithrn> using namespace std; int main{) { vector<int> v; int i; for(i=0; i<10,-i++) v.push_back(i) ; cout " "Исходная последовательность : " ; for(i=0; i<v. size(); i++) cout " v[i] " " "; cout " endl; reverse (v. begin ( ) , v.end(} ) ; cout " "Обратная последовательность: "; for(i=0; Kv.sizeO; i++) cout " v[i] " " "; return 0;
460 _ Самоучитель C++ После выполнения программы на экране появится следующее: Исходная последовательность : 0 1 2 3 4 5 6 7 8 9 Обратная последовательность : 9 8 7 6 5 4 3 2 1 0 4. Одним из наиболее интересных алгоритмов является алгоритм transform(), который модифицирует каждый элемент некоторого диапазона в соответст-вии с заданной вами функцией. Алгоритм transform() имеет две основные формы: template<class Inlter, class Outlter, class FunO Outlter transform (Inlter качало, Inlter окончание, Outlter результат, Func унарная_^функцяя) ; template<class Inlterl, class Inlter2, class Outlter, class Func> Outlter transform (Inlterl начало!, Inlterl окончание!, Inlter2 аачало2, Outlter результат, Func бииарная_функция) ; Алгоритм transform() применяет функцию к диапазону элементов и сохраня-ет результат в месте, определенном итератором результат. В первой форме диапазон задается итераторами начало и окончание, а применяемой функцией является унарная_функция. Эта функция в качестве параметра получает зна-чение элемента и должна возвратить модифицированный элемент. Во второй форме модификация осуществляется с помощью бинарной оператор-функции бинарная_функция, которая в качестве первого параметра получает значение элемента из предназначенной для модификации последовательно-сти, а в качестве второго параметра - элемент из второй последовательно-сти. Обе версии возвращают итератор конца итоговой последовательности. В следующей программе для модификации используется функция xformQ, которая возводит в квадрат элементы списка. Обратите внимание, что итого-вая последовательность хранится в том же списке, что и исходная последова-тельность. //Пример использования алгоритма transform ^include <iostream> #include <list> ^include <algorithm> using namespace std; //Простая функция модификации int xformfint i) { return i * i; //квадрат исходного значения int main () { list<int> xl; int i;
Глава 14. Библиотека стандартных шаблонов _ 461__ II размещение значений в списке for (1=0; i<10; 1++) xl .push_back (i) ; cout " "Исходное содержимое списка xl: "; list<int>: : iterator p = xl.beginO; whiletp !=xl.end()) { cout " *p " " "; P++; cout " endl; //модификация элементов списка xl p = transform(xl. begin () , xl.endf), xl. begin (), xform) ; cout " "Модифицированное содержимое списка xl: "; p = xl. begin () ; while (p != xl.endO) { cout " *p " " "; return 0; }После выполнения программы на экране появится следующее: Исходное содержимое списка xl: 0 1 2 3 4 5 6 7 8 9 Модифицированное содержимое списка xl: О 1 4 9 16 25 36 49 64 81 Как видите, возведен в квадрат каждый элемент списка xl. Алгоритм sort() имеет следующие основные формы: template<class Randlter> void sort(Randlter начало, Randlter окончание); template<class Randlter, class Comp> void sort(Randlter начало, Randlter окончание, Comp фуяхция_сравн&ния); Алгоритм сортирует элементы диапазона, заданного итераторами начало и окончание. Во второй форме имеется возможность задать функцию сравне-ния, которая определяет, является ли один элемент меньше, чем другой. На-пишите программу, демонстрирующую работу алгоритма sort(). (Выберите ту его форму, которая вам больше нравится.)
462 Самоучитель C++ 2. Алгоритм merge() выполняет слияние двух упорядоченных последовательно-стей, а результат слияния размещает Б третьей последовательности. Ниже показана одна из основных форм этого алгоритма: template<class Inlterl, class Inlter2, class Outlter> Outlter merge(Inlterl начало!, Inlterl окончание!, Inlter2 начало2, Inlter2 oxonva*use2, Outlter результат) ; Последовательности, предназначенные для слияния, обозначены итератора-ми начало!, окончание! и начало2, окончание2. Место размещения итоговой последовательности обозначено итератором результат. Алгоритм возвращает итератор конца итоговой последовательности. Продемонстрируйте работу этого алгоритма. 14.7. Строковый класс Как известно, в C++ встроенный строковый тип данных сам по себе не поддерживается. Тем не менее для обработки строк здесь имеется две воз-можности. Во-первых, можно использовать хорошо вам знакомый оканчи-вающийся нулем символьный массив. О таком массиве иногда говорят как о строке в стиле С (С string). Второй метод, который и рассматривается в этом разделе, подразумевает использование объектов типа string. Фактически, класс string является конкретизацией более общего класса-шаблона basic_string. На самом деле у класса basic_string имеется два произ-водных класса: класс string, который поддерживает строки 8-разрядных сим-волов, и wstring, который поддерживает строки широких символов. По-скольку при обычном программировании чаще всего имеют дело именно с 8-разрядными символами, мы рассмотрим только версию string базового класса basic_string. Перед тем как начать изучение класса string, важно понять, почему он включен в библиотеку классов C++. Стандартные классы появились в C++ не случайно. Фактически, включению в библиотеку каждого нового класса сопутствовало множество споров и дискуссий. Добавление в C++ класса string на первый взгляд кажется исключением из этого правила, поскольку в C++ в качестве строк уже поддерживаются оканчивающиеся нулем масси-вы. Тем не менее это далеко не так, и вот почему: оканчивающиеся нулем символьные массивы нельзя обрабатывать посредством стандартных опера-торов C++ и они не могут быть частью обычных выражений C++. Напри-мер, рассмотрим следующий фрагмент программы: char si[80], s2[80], s3[80]; si = "раз"; //не допускается s2 = "два"; //не допускается s3 = si + s2; //ошибка, снова не допускается
Глава 14. Библиотека стандартных шаблонов 463 Как показано в комментариях, в C++ нельзя использовать оператор при-сваивания, чтобы дать символьному массиву новое значение (за исключени-ем инициализации), а для конкатенации двух строк нельзя использовать оператор сложения. Эти операции приходится выполнять с помощью пока-занных ниже библиотечных функций: strcpy(si, "раз"); Strcpy{s2, "два"); strcpy{s3, si); strcpy (s3, s2); Поскольку оканчивающиеся нулем символьные массивы по своей сути тех-нически не являются типами данных, к ним нельзя применять операторы C++. Это приводит к тому, что даже самые элементарные операции со строками становятся чрезвычайно запутанными. Невозможность использо-вания стандартных операторов C++ для работы с оканчивающимися нулем символьными массивами и стала основной причиной разработки стандарт-ного строкового класса. Вспомните, когда вы в C++ определяете класс, вы определяете новый тип данных, который может быть полностью интегриро-ван в среду программирования C++. Само собой это означает, что относи-тельно нового класса можно перегружать операторы. Таким образом, благо-даря добавлению в C++ стандартного класса string, становится возможным обрабатывать строки точно таким же образом, каким обрабатываются дан-ные других типов, а именно с помощью операторов. Имеется, однако, и еще один довод в пользу использования стандартного класса string - это обеспечение безопасности. Неопытный или неосторож-ный программист может очень легко выйти за границы массива, в котором хранится оканчивающаяся нулем строка. Например, рассмотрим стандарт-ную функцию копирования строк strcpy(). В этой функции совершенно от-сутствуют какие бы то ни было атрибуты, предназначенные для контроля границ целевого массива. Если в исходном массиве оказывается больше символов, чем может поместиться в целевом массиве, вполне возможна (и даже весьма вероятна) программная или даже системная ошибка. Как вы в дальнейшем увидите, стандартный класс string предотвращает саму возмож-ность возникновения подобных ошибок. Итак, для включения в C++ стандартного класса string имеется три довода: совместимость (теперь строка становится типом данных), удобство (можно использовать стандартные операторы C++) и безопасность (границы масси-ва не нарушаются). Запомните, что это не доводы в пользу отказа от обыч-ных, оканчивающихся нулем массивов. Они остаются наиболее эффектив-ным способом реализации символьных строк. Тем не менее, если при соз-дании приложения скорость выполнения программы не является доминирующим фактором, новый класс string предоставляет вам безопас-ный и полностью интегрированный в среду программирования C++ способ обработки строк.
464 СамоучительС++ Хотя строковый класс традиционно не считают частью библиотеки стан-дартных шаблонов, тем не менее, это один из определенных в C++ классов-контейнеров. Это, в частности, означает, что он поддерживает описанные в предыдущем разделе алгоритмы. Кроме этого, для обработки строк имеются дополнительные возможности. Чтобы получить доступ к классу string, в программу следует включить заголовок <string>. Класс string очень велик, в нем имеется множество конструкторов и функ-ций-членов. Помимо этого многие функции-члены имеют массу перегру-женных форм. По этой причине в одной главе невозможно рассказать о всех членах класса string. Вместо этого мы исследуем только некоторые, основ-ные его возможности. После получения базовых знаний о работе класса string в целом, все остальное вы сможете легко понять самостоятельно. В классе string поддерживается несколько конструкторов. Ниже представле-ны прототипы трех из них, которые чаще всего используются: String () ; string(const char *строка); string(const string Ьстрока); В первой форме создается пустой объект типа string. Во второй форме -объект типа string из оканчивающейся нулем строки, обозначенной указате-лем строка. Эта форма обеспечивает преобразование из оканчивающейся нулем строки в объект типа string. В третьей форме объект типа string созда-ется из другого объекта типа string. Ниже перечислена часть операторов, допустимых при работе с объектами типа string: Оператор Значение = Присваивание + Конкатенация += Присваивание с конкатенацией и Равенство ! = Неравенство < Меньше <= Меньше или равно > Больше >= Больше или равно [] Индекс " Вывод " Ввод
Главаi_?4, Библиотека стандартных шаблонов 465 Указанные операторы позволяют использовать объекты типа string в обыч-ных выражениях и отказаться от вызовов специализированных функций, например, функций strcpyQ или strcatQ, Как правило, объекты типа string в выражениях можно записывать вместе с обычными, оканчивающимися ну-лем строками. Например, объект типа string можно присвоить оканчиваю-щейся нулем строке. Оператор + можно использовать для конкатенации объекта типа string с другим объектом типа string или для конкатенации объекта типа string со строкой в стиле С. Поддерживаются следующие варианты: string + string string + C-string C-atring + string Кроме этого, оператор + можно использовать для присоединения одиноч-ного символа к концу строки. В классе string определена константа npos, обычно равная -1. Эта константа отражает максимально возможную длину строки. Несмотря на то, что большая часть операций над строками может быть вы-полнена с помощью строковых операторов, для некоторых наиболее слож-ных или необычных операций нужны функции - члены класса string. Хотя их слишком много для одной главы, о некоторых наиболее полезных здесь будет рассказано. Чтобы присвоить одну строку другой используется функ-ция assign (). Ниже представлены две основные формы этой функции: string Sassign(const string &объекя_строка, size_type начало, siza__type число) ; string Sassign(const char *строка, size_type число); В первой форме несколько символов, количество которых равно параметру число из объекта объект_строка, начиная с индекса начало, присваиваются вызывающему объекту. Во второй форме вызывающему объекту присваива-ется первые несколько символов, количество которых равно параметру число из оканчивающейся нулем строки строка. В обоих случаях функция воз-вращает ссылку на вызывающий объект. Очевидно, что для присваивания одной целой строки другой гораздо проще использовать оператор =. Функ-ция assign О может понадобиться только при присваивании части строки. Присоединить часть одной строки к другой можно с помощью функции-члена append(). Ниже представлены две основные формы этой функции: string fiappend (const string ЕооЧежт_с!грожа, size_type начало, size_type число) ; string Sappend(const char *строка, size__type число) ; В первой форме несколько символов, количество которых равно параметру число из объекта объект_строка, начиная с индекса начало присоединяются к вызывающему объекту. Во второй форме к вызывающему объекту присос-
466 Самоучитель C++ диняются первые несколько символов, количество которых равно параметру число, из оканчиваюшейся нулем строки строка. В обоих случаях функция возвращает ссылку на вызывающий объект. Очевидно, что для присоедине-ния одной целой строки к другой гораздо проще использовать оператор +. Функция appendQ может понадобиться только при присоединении части строки. С помощью функций insert() и replaceQ можно соответственно вставлять или заменять символы в строке. Ниже представлены прототипы основных форм этих функций: string &insert(size_type начало, const string £ооЧежт_с!грока) ; string fiinsert(size_type начало, const string &объект_сяроха, size_type начало_вставки, size_typa число); string fireplace (size_type начало, size_type тесло, const string йобФекг строка) ; string fireplace (size_type начало, size_type ксх_номер, const string &объект_строка, size type начало замени, size type число замены) ; В первой форме функции insertQ объект объект_спгрока вставляется в вызы-вающую строку по индексу начало. Во второй форме функции insert() число символов из объекта объект__строка, начиная с индекса начало_вставки, вставляется в вызывающую строку по индексу начало. В первой форме функции replace() число символов, начиная с индекса нача-ло, заменяется в вызывающей строке объектом объект^строка. Во второй форме функции replaceQ в вызывающей строке заменяется исх_число сим-волов, начиная с индекса начало, при этом из объекта объект_строка берут-ся число_замены символов, начиная с индекса начало_замены. В обоих слу-чаях функция возвращает ссылку на вызывающий объект. Удалить символы из строки можно с помощью функции eraseQ. Ниже пока-зана одна из форм этой функции: string fierase(size_type начало = 0, size_type число = npos); Функция удаляет число символов из вызывающей строки, начиная с индекса начало. Возвращаемым значением является ссылка на вызывающий объект. В классе string поддерживается несколько функций-членов, предназначен-ных для поиска строк. Среди них имеются функции find() и rfindQ. Ниже показаны прототипы основных версий этих функций: size_type find (const string Ьобъект__строка, size_type начало = 0) const; size_type rfind (const string &объек<р_строха, size_type начало = npos) const;
Глава 14. Библиотека стандартных шаблонов 467^ Начиная с индекса начало функция find() ищет в вызывающей строке пер-вое совпадение со строкой, содержащейся в объекте объект_строка. Если искомая строка найдена, функция find() возвращает индекс вызывающей строки, соответствующий найденному совпадению. Если искомая строка не найдена, функция fmd() возвращает значение npos. В противоположность функции find(), функция rfindQ, начиная с индекса начало, но в обратном направлении, ищет в вызывающей строке первое совпадение со строкой, содержащейся в объекте объект_строка. (То есть ищет последнее совпаде-ние со строкой, содержащейся в объекте объект_строка.) Если искомая строка найдена, функция rfindQ возвращает индекс вызывающей строки, соответствующий найденному совпадению. Если искомая строка не найде-на, функция iTind() возвращает значение npos. Для сравнения целых строковых объектов удобнее всего пользоваться опи-санными ранее перегруженными операторами отношения. Тем не менее, если вы захотите сравнить части строк, вам понадобится функция-член сот-раге(). Ниже представлен прототип этой функции: int compare(size_type начало, size_type число, const string 6объвкч!_строка) const; Здесь с вызывающей строкой сравниваются число символов объекта объ-ект_строка, начиная с индекса начало. Если вызывающая строка меньше, чем объект_строка, функция compareQ возвращает отрицательное значение. Если вызывающая строка больше, чем объект^строка, функция сотраге() возвращает положительное значение. Если вызывающая строка равна объек-ту объект_строка, возвращаемое значение функции сотраге() равно нулю. Хотя объекты типа string сами по себе очень удобны, иногда у вас все же будет возникать необходимость в версии строки в виде массива символов, оканчивающихся нулем. Например, объект типа string можно использовать для образования имени файла. Однако при открытии файла вам придется задавать указатель на стандартную, оканчивающуюся нулем строку. Для ре-шения проблемы в классе string имеется функция-член c_str(), прототип которой показан ниже: const char *c_str() const; Функция возвращает указатель на оканчивающуюся нулем версию строки, содержащуюся в вызывающем объекте типа string. Оканчивающаяся нулем строка не должна меняться. Кроме этого, если над объектом типа string вы-полнялись какие-либо другие операции, правильность выполнения функции c_str() не гарантируется. Поскольку класс string является контейнером, в нем поддерживаются функ-ции beginQ и end(), возвращающие соответственно итератор начала и конца строки. Также поддерживается функция sizeQ, возвращающая текущее чис-ло символов строки.
468 Самоучитель C++ Примеры 1.- Хотя^ мы уже привыкли к традиционным строкам в стиле С, в C++ класс string делает обработку строк существенно проще. Например, при работе с объектами типа string для присваивания строк можно использовать оператор -, для конкатенации строк - оператор +, а для сравнения строк - различ-ные операторы сравнения. В следующей программе показаны эти операции. //Короткий пример использования строкового класса ^include <iostream> ttinclude <string> using namespace std; int main() ( string strl("Представление строк"}; string str2("Вторая строка"); string str3; //присваивание строк str3 = strl; cout " strl " "\n" " str3 " "\n"; //конкатенация двух строк str3 = strl + Str2; cout " str3 " "\n"; //сравнение строк if(str3 > strl) cout " "str3 > strl\n"; if(str3 == strl+str2) cout " "str3 - strl+str2\n"; //строковому объекту можно присвоить обычную строку strl = "Это обычная строка\п"; cout " strl; //создание строкового объекта //с помощью другого строкового объекта string str4(strl); cout " str4; //ввод строки cout " "Введите строку: "; cin " str4; cout " str4; return 0; После выполнения программы на экране появится следующее: Представление строк Представление строк
Глава 14. Библиотека стандартных шаблонов 469 Представление строкВторая строка str3 > strl str3 == strl+str2 Это обычная строка Это оОычная строка Введите строку: Привет Привет Как видите, с объектами типа string можно обращаться так же, как и со встроенными типами данных C++. Это, фактически, и есть главное достоин-ство строкового класса. Отметьте простоту манипулирования со строками: для конкатенации строк ис-пользуется обычный оператор +, а для их сравнения - обычный оператор >. Чтобы выполнить те же операции для оканчивающихся нулем строк в стиле С, вам пришлось бы вызывать функции strcat() и strcmp(), что, согласитесь, го-раздо менее удобно. Поскольку объекты типа string можно совершенно сво-бодно указывать в выражениях вместе с оканчивающимися нулем строками в стиле С, то никаких неприятностей от их использования в ваших программах быть не может, а выгоды, наоборот, - очевидны. Имеется еще одна деталь, на которую следует обратить внимание в предыду-щей программе: размеры строк не задаются. Объекты типа string автоматиче-ски настраиваются на хранение строк требуемой длины. Таким образом, ко-гда вы выполняете присваивание или конкатенацию строк, размер целевой строки автоматически вырастает ровно настолько, насколько это нужно для размещения новой строки. Этот динамический аспект использования объек-тов типа string следует всегда принимать во внимание при выборе варианта представления строк в ваших программах. (Как уже отмечалось, стандартные оканчивающиеся нулем строки являются возможным источником нарушения границ массивов). 2. В следующей программе демонстрируются функции insert(), erase() и replace (). //Использование функций insert О, erase () и replace () ^include <iostream> ^include <string> using namespace std; int main() { string strl("Это проверка"); string 5^2("АБВГДЕЖ") ; cout " "Исходные строки:\п" cout " "strl: " " strl " endl; cout " "str2: " " str2 " "\n\n"; //работа функции insert(} cout " "Вставка строки str2 в строку strl:\n"
470 _ Самоучитель C++ strl, insert (4, str2) ; cout " strl " "\n\n"; //работа функции erase () cout " "Удаление семи символов из строки strl:\n" strl. erase (4, 1} ; cout " strl " "\n\n"; //работа функции replace () cout " "Замена восьми символов из strl символами из str2:\n" strl.replace(4, 8, str2) ; cout " strl " "\n\n"; return 0; После выполнения программы на экране появится следующее: Исходные строки: strl: Это проверка str2: АБВГДЕЖ Вставка строки str2 в строку strl: Это АБВГДЕЖпроверка Удаление семи символов из строки strl: Это проверка Замена восьми символов из strl символами из str2 : Это АБВГДЕЖ 3. Поскольку класс string определяет тип данных, появляется возможность соз-давать контейнеры для хранения объектов типа string. Например, ниже пред-ставлена усовершенствованная версия программы создания ассоциативного списка для хранения слов и антонимов, впервые показанная в примере 3 раздела 14.5. /* Ассоциативный список слов и антонимов для объектов типа string */^include <iostream> #include <map> ^include <string> using namespace std; int main ( ) { map<string, string> m; int i; m, insert (pair<string, string> ("да", "нет") ) ; m. insert (pair<string, string> ("хорошо", "плохо",) ) ; m. insert (pair<string, string>( "влево") , "вправо") ) ; m. insert (pair<string, string> ("вверх") , "вниз") ) ;
Глава 14. Библиотека стандартных шаблонов _ 4_71_ string s; cout " "Введите слово: "; cin " s; map<string, string>: : iterator p; p = m. find(s) ; if (p != m.endO ) cout " "Антоним: " " p->second; elsecout " "Такого слова в ассоциативном списке нет\п"; return 0; С помощью объектов типа string сохраните в списке следующие строки: один два три четыре пять шесть семь восемь девять десять Затем отсортируйте список и выведите на экран содержимое отсортирован-ного списка. Поскольку класс string является контейнером, он может использоваться со стандартными алгоритмами. Создайте программу, в которой пользователь вводит строку. Затем с помощью функции count() сосчитайте в строке число символов "е" и выведите это значение на экран. Модифицируйте решение упражнения 2 таким образом, чтобы подсчитыва-лись только символы в нижнем регистре. (Подсказка: воспользуйтесь функ-цией count_if().) Класс string - это конкретизация некоторого класса-шаблона. Какого? j Проверке усвоения I материала главы ~^ Теперь вам необходимо выполнить следующие упражнения и ответить на вопросы. 1. Каким образом библиотека стандартных шаблонов позволяет упростить процесс создания более надежных программ? 2. Опишите контейнер, итератор и алгоритм в терминах библиотеки стан-дартных шаблонов.
472 __ Самоучитель C++ 3. Напишите программу создания 10-элементного вектора, содержащего числа от 1 до 10. Затем из полученного вектора скопируйте в список только четные элементы. 4. В чем преимущество использования данных типа string? В чем их единст-венный недостаток? 5. Что такое предикат? 6. Переработайте пример 2 раздела 14.5 так, чтобы в нем использовались объекты типа string. 7. Начните изучение объектов-функций библиотеки стандартных шаблонов. Для начала познакомьтесь со стандартными классами unary_function и Ы-nary_fiinction, которые помогут вам создавать объекты-функции. 8. Изучите техническую документацию на библиотеку стандартных шабло-нов, поставляемую с вашим компилятором. Там вы обязательно обнару-жите массу полезных инструментов и приемов программирования. Проверка усвоения материала в целом В этом разделе проверяется, хорошо ли вы усвоили материал этой и преды-дущих глав. 1. Начиная с главы 1, вы проделали долгий путь. Потратьте еще немного времени для беглого просмотра книги. После этого подумайте, как мож-но было бы улучшить примеры (особенно в первых шести главах) с по-мощью всех известных вам теперь инструментов C++. 2. Программирование легче изучать в процессе работы. Пишите больше программ на C++. Пытайтесь экспериментировать с теми атрибутами языка, которые уникальны только для него. 3. Продолжайте изучение библиотеки стандартных шаблонов. В будущем большинство задач программирования будет решаться именно с помо-щью библиотеки стандартных шаблонов, поскольку, как правило, кажу-щаяся сложность работы с контейнерами может быть значительно сни-жена, благодаря алгоритмам. 4. И последнее. Запомните: C++ дает вам беспрецедентные возможности и важно научиться мудро ими пользоваться. Благодаря этим возможностям C++ позволит вам значительно расширить потенциальные области при-менения ваших приложений. Однако злоупотребление ими может при-вести к появлению программ, которые трудно понимать, которым почти невозможно следовать и которые слишком тяжело сопровождать. Язык программирования C++ - это мощнейший инструмент, но, как и любой другой инструмент, он хорош только тогда, когда находится в надежных руках.
Приложение А Некоторые отличия языков программирования С и C++ Для подавляющего большинства задач программирования C++ можно считать надмножеством языка С (как он описан в стандарте ANSI по С), поэтому фактически все программы С являются также программами C++. Имеется несколько отличий, о части из которых было рассказано в главе 1. Ниже пе-речислены оставшиеся отличия, о которых вам следует знать: О Незначительное, но потенциально важное отличие между С и C++ со-стоит в том, что в С символьная константа автоматически преобразуется в целое, а в C++ нет. Q В С можно объявить глобальную переменную несколько раз, что, хотя и считается плохим стилем программирования, но ошибкой не является. В C++ многократное объявление глобальной переменной считается ошиб-кой. Q В С по крайней мере первые 31 символ идентификатора являются зна-чащими. В C++ значащими являются все символы идентификатора. Тем не менее с точки зрения практики столь длинные идентификаторы вряд ли могут где-нибудь пригодиться. а В С вы можете вызвать функцию main() в любом месте программы, хотя какую-либо пользу от такого вызова представить себе довольно трудно. В C++ вызов функции main() из программы не допускается. а В С нельзя получить адрес регистровой переменной (переменной типа register), а в C++ - можно. Q В С тип wchar_t определяется с помощью объявления typedef. В C++ wchar t является ключевым словом.
Приложение В Ответы на вопросы ирешения упражнений В этом приложении вы найдете ответы на вопросы и решения упражнений для подавляющего большинства (но не всех) приведенных в книге заданий. Часть вопросов и упражнений оставлены вам для самостоятельного творче-ства. Советуем вам тщательно и добросовестно выполнять все задания, неза-висимо от того, есть в этом приложении ответы на них или нет. ГЛАВА 1 Упражнения 1.3 1. ttinclude <iostream> using namespace; int main() I double hours, wage; cout " "Введите количество проработанных часов: "; cin " hours ; cout " "Введите почасовую оплату: "; cin " wage; cout " "Зарплата равна: $" " wage * hours; return 0; 2. #include <iostream> using namespace std;
476 __ ___ __ Самоучитель C++ int main () I double feet; do {cout " "Введите число футов (0 для завершения) : "; cin " feet; cout " feet * 12 " " дюймов\п"; } while (feet != 0.0} ; return 0; 3. I* В этой программе рассчитывается наименьшее общее кратное V#include <iostream> using namespace std; int main ( ) { j int a, b, d, min; cout " "Введите два числа: "; cin " a " b; min = a > b ? b: a/-for (d=2; d<min; d4-+) if("a%d)==0) && ((bld)=0)) break; if {d==rain) { cout " "Нет общего кратного\п"; return 0; }cout " "Наименьшее общее кратное равно " " d " "\n"; return 0; 1.4 1. Этот комментарий, хотя и выглядит довольно странно, вполне допустим. 1.5 2. ^include <iostream> ^include <cstring> using namespace std;
Приложение В. Ответы на вопросы и решения упражнений 477 class card { char title[80]; //заглавие книги char author[40]; //автор int number; //количество имеющихся экземпляров public: void store(char *t, char *name, int num); void show(); void card::store(char *t, char *name, int num) i strcpy(title, t); strcpy(author, name); number = num; void card: :show(). cout " "Заглавие: " " title " "\n"; cout " "Автор: " " author " "\n"; cout " "Количество экземпляров: " " number " "\n"; int main() card bookl, book2, bookS; bookl.store("Dune", "Frank Herbert", 2); book2.store("The Foundation Trilogy", "Isaac Asimov", 2); books.store("The Rainbow", "D. H. Lawrence", 1); bookl. show{) ; book2. show() ; bookS. show{) ; return 0; 3. ^include <iostream> using namespace std; #define SIZE 100 class q_type ( int queue[SIZE]; //содержит очередь int head, tail; //индекс вершины и хвоста public: void init(); //инициализация void q(int num); //запоминание
478 _ Самоучитель C++ int deq(); //восстановление }; //Инициализация void q_type: :init () { head = tail = 0; //Помещение значения в очередь void q_type: :q{int num) { if (tail + l-=head I I (tail + 1==SIZE && Ihead) ) ( cout " "Очередь полна"; return; if (tail==SIZE) tail = 0; //круговой цикл queue[tail] = num; )//Удаление значения из очереди int q_type: :deq() { if (head==tail) ( cout " "Очередь пуста"; return 0; if (head==SIZE) head = 0; //круговой цикл return queue [head]; int main () q_type ql, q2; int i ; q2.init() ; for{i-l; i<=10; i ql.q(i); q2.q(i * i); for(i=l; i<=10; i cout " "Элемент из очереди 1: " " ql.deqO " "\n cout " "Элемент из очереди 2: " " q2 . deq ( ) " "\n
Приложение В. Ответы на вопросы it решения упражнений А[79 return 0; 1.6 1. У функции f() нет прототипа. 1.7 1. ^include <iostream> ^include <cmath> using namespace std; //Перегрузка функции sroot() для integers, longs и doubles int sroot(int i); long sroot(long i) ; double sroot (double i); int main(} { cout " "Квадратный корень 90.34 равен: " " sroot (90.34); cout " "\n"; cout " "Квадратный корень 90L равен: " " sroot(90L); cout " "\n"; cout " "Квадратный корень 90 равен: " " sroot(90); return 0; //Возвращает квадратный корень целого int sroot(int i) { cout " "расчет корня целогсЛп"; return (int) sqrt((double)i); //Возвращает квадратный корень длинного целого long sroot(long i) { cout " "расчет корня длинного целого\п"; return (long) sqrt((double)i); }//Возвращает квадратный корень вещественного double sroot(double i) { cout " "расчет корня вещественного\п"; return sqrt(i); i
480 __ __ _ __ Самоучитель C++ 2. Функции atof(), atoi() и atol() нельзя перегружать потому, что они отличают-ся только типом возвращаемого значения. Перегрузка функции требует, что-бы было отличие либо в типе, либо в числе аргументов. 3. //Перегрузка функции min() ^include <iostream> #include <cctype> using namespace std; char min{char a, char b) ; int minfint a, int b} ; double min (double a, double b) ; int main() { cout " "Минимум равен: " " min ( ' x ' , 'a') " "\n"; cout " "Минимум равен: " " rninflO, 20) " "\n"; cout " "Минимум равен: " " min{0.2234, 99.2} " "\n"; return 0; }//Минимум для chars char min (char a, char b) { return tolower(a) < tolower(b) ? a: b; }//Минимум для ints int min (int a, int b) { return a < b ? a: b; } \ //Минимум для doubles double min (double a, double b) { return a < b ? a: b; 4. ^include <iostream> using namespace std; //Перегрузка функции sleep ( ) для вызова с целым либо со строкой void sleepfint n) ; void sleepfchar *n) ; //Измените эту величину //в соответствии с быстродействием вашего процессора ^define DELAY 100000
Приложение В. Ответы на вопросы и решения упражнений 481 int main {) coot sleep (3) ; cout " ' . ' ; sleep("2") ; cout " ' . ' ; return 0; //Функция sleep () с целым аргументом void sleep (int n) { long i; for!; n; n - ) for (1=0; i<DELAY; //Функция sleep () с аргументом типа char * void sleep (char *n) { long i; int j; j = atoi (n) ; for(; j; j - ) for(i-0; i<DELAY; Проверка усвоения материала главы 1 1. Полиморфизм - это механизм, посредством которого можно использовать один общий интерфейс для доступа к разным реализациям задачи. Инкапсу-ляция обеспечивает защищенную связь инструкций и данных, с которыми работает программа. Доступ к таким скрытым частям программы может быть затруднен и этим предотвращается несанкционированный доступ к ним. На-следование - это процесс, посредством которого один объект может приоб-рести свойства другого. Наследование используется для поддержки иерархии классов. 2. Комментарии могут включаться в программу C++ либо как обычные ком-ментарии в стиле С, либо как однострочные комментарии, характерные для с++. 3. #include <iostream> using namespace std;
482 _ Самоучитель C++ int main ( } { int b, e, r; cout " "Введите основание степени: "; cin " b; cout " "Введите показатель степени : " ; cin " e; r = 1; for(; e; e - } r = r * b; cout " "Итог: " " r; return 0; 4. ^include <iostream> #include <cstring> using namespace std; //Перегрузка функции реверса строки void rev_str(char *s); //реверс строки по адресу s void rev_str(char *in, char *out) ; //реверс строки и пересылка ее //по адресу out int main () { char sl[80], s2[80J; strcpy(sl, "Это проверка"); rev_str (si, s2) ; cout " s2 " "\n"; rev_str{Sl); cout " si " "\n"; return 0; //Реверс строки и передача результата по адресу s void rev strfchar *s) char temp [80] ; int i , j ; for(i=strlen(s)-l, j=0; i>=0; i~, j++) temp [ j ] = s [ i ] ; teinp[ j ] = '\0'; //нуль завершает строку strcpy(s, temp);
Приложение В. Ответы на^ вопросы и решения упражнений 483 //Реверс строки и передача результата по адресу out void rev_str(char *in, char *out) int i, j; for(i=strlen(in}-l/j=0; i>=0; i-, j++) out[ j ] = in[ i ]; out[ j ] = r\0'; //нуль завершает строку 5. ^include <iostream.h> int f(int a); int main(} { cout " f(10); return 0; int f(int a) г return a * 3.1416; 6. Тип данных bool предназначен для хранения значений булева типа. Значе ниями булева типа являются только два значения - это true и false. ГЛАВА 2 Повторение пройденного 1. ^include <iostreara> #include <cstring> using namespace std; int min{> i char s[80]; cout " "Введите строку: "; cin " s; cout " "Длина строки равна: " " strlen(s) " "\n"; return 0;
484 Самоучитель C++ 2. #include <iostream> #include <cstring> using namespace std; class addr { char name[40J ; char street [40] ; char city[30] ; char state [3] ; char zip[10] ; publ i с : void store(char *n, char *s, char *c, char *t, char *z); void display () ; ); void addr: : store (char *n, char *s, char *c, char *t, char *z) \ strcpy(name, n) ; strcpy ( street , s ) ; strcpy {city, c) ; strcpy(state, t) ; strcpy (zip, z) ; void addr: : display () { cout " name " "\n"; cout " street " "\n"; cout " city " "\n"; cout " state " "\n"; cout " zip " "\n\n"; int main ( ) f addr a; a.store("J1. И. Иванов", "Невский проспект", "С.-Петербург", "Рос", "46576"}; a. display {) ; return 0; 3. ^include <iostream> using namespace std; int rotate (int i); long rotate (long i) ;
Приложение В. Ответы на вопросы и решения упражнений _ 455 int main(} { int a; long b; a = 0x8000; b = 8; cout " rotate ( a ) ; cout " "\n"; cout " rotate (b); return 0; }int rotate (int i) { int x; if (i & 0x8000} x = 1; else x = 0; i = i " 1; _:iL :1 = vЛ : е return i; >long rotateflong i) { int x; if (i S 0x80000000) x = 1; else x = 0; i = i " 1; i += x; return i; 4. Целое i является закрытым для класса myclass, и к нему нет доступа из функции main() Упражнения 2.1 1. ^include <iostream> using namespace std;
486 _ Самоучитель C++ ttdefine SIZE 100 class q_type { int queue[SIZE]; //содержит очередь int head, tail; //индексы вершины и хвоста public : q_type ( ) ; //конструктор void q{int num) ; //запоминание int deq(); //извлечение из памяти }; //Конструктор q_type: :q_type() ( head = tail = 0; //Постановка значения в очередь void q_type: :q{int num) i if {tail + l==head I I (tail + 1==SIZE && Ihead} cout " "Очередь полна"; return; if (tail==SIZE) tail = 0; //круговой цикл queue [tail] = num; \II Выталкивание значения из очереди int q_type : : deq ( ) i if (head==tail) { cout " "Очередь пуста"; return 0; } head++; if (head==SIZE) head = 0; //круговой цикл return queue [head] ; int main ( ) { q_type ql, q2; int i; for{i=l; i<=10; ql.q(i) ; q2.q(i * i) ;
Приложение В. Ответы на вопросы и решения упражнений 487 for (i=l; i<=10; H-+) { cout " "Элемент из очереди 1: " " ql.deq() " "\n"; cout " "Элемент из очереди 2: " " q2.deq() " "\n"; }return 0; \ 2. II Имитация секундомера ^include <iostream> ^include <ctime> using namespace std; class stopwatch { double begin, end; public: stopwatch(); -stopwatch(); void start (}; void stop () ; void show{) ; stopwatch::stopwatch() {. begin = end = 0.0; stopwatch::~stopwatch() { cout " "Удаление объекта stopwatch .,."; show(); } void stopwatch::start() { begin = (double) clock () /CLOCKS_PER_SEC; I void stopwatch::stop() { end = (double) clock(} /CLOCKS_PER_SEC; } void stopwatch::show() { cout " "Затраченное время: " " end - begin; cout " "\n"; I
488 Самоучитель C++ int main (} stopwatch watch; long i; watch.start() ; for(i=0; K320000; i++) ; //время цикла watch.stop(); watch.show(); return 0; } 3. У конструктора не может быть возвращаемого значения. 2.2 \. (I Динамическое выделение памяти для стека ^include <iostream> ^include <cstdlib> using namespace std; , //Объявление класса stack для символов class stack { char *stck; //содержит стек int tos; //индекс вершины стека int size; //размер стека public: stack(int s); //конструктор ~stack(); //деструктор void push{char ch); //помещает в стек символ char pop(); //выталкивает из стека символ //Инициализация стека stack::stack(int s) t cout " "Работа конструктора стека\п"; tos -0; stck = (char *) malloc(s); if (!stck) { cout " "Ошибка выделения памяти\п"; exit{l); }size = s;
Приложение В. Ответы на вопросы и решения упражнений _ 489 .stack: :~stack (} { free (stck) ; }//Помещение символа в стек void stack: :push(char ch) { if (tos==size) { cout " "Стек полон \п"; return; }stck[tos] = ch; tos++; *//Выталкивание символа из стека char stack:: pop () { if (tos=0) { cout " "Стек пуст \п"; return 0; //возврат нуля при пустом стеке )tos - ; return stck [tos]; iint main{) { //образование двух, автоматически инициализируемых, стеков stack sl(10) , s2(10) ; int i; si. push { 'a' ) ; s2.push('x'); si. push ( 'b' ) ; s2.push('y'); si. push ( 'c' ) ; s2.push('z'); for{i=0; i<3; i++) cout " "символ из стека si:" " sl.popO " "\n"; for{i=0; i<3; i++) cout " "символ из стека s2:" " s2.pop() " "\n"; return 0; 2. ttinclude <iostream> ^include <ctime> using namespace std;
490 Самоучитель C++ class t_and_d ( time_t systime; public: t_and_d(time_t t) ; //конструктор void show() ; t_and_d : : t_and_d ( t ime_t t } { systime = t; }void t_and d::show() { cout " ctime{fisystime) } int main() ' time_t x; x = time (NULL) ; t_and_d ob{x) ; ob . show { ) ; return 0; 3. ^include <iostream> using namespace std; class box ( double 1, w, h; double volume; public: box (double a, double b, double c) void vol ( ) ; box: :box (double a, double b, double c) { 1 = a; w = b; h -c; volume * 1 * w * h;
Приложение В, Ответы на вопросы и решения упражнений _ 491 void box: :vol (} { cout " "Объем равен: " " volume " "\n"; }int main() { box x(2.2, 3.97, 8.09), y(1.0, 2.0, 3.0); x . vol { } ; y.volf) ; return 0; 2.3 1. #include <iostream> using namespace std; class area_cl { public: double height; double width; class rectangle: public area__cl ( public: rectangle (double h, double w) ; double area (} ; class isosceles: public area_cl { public : isosceles (double h, double w) ; double area () ; rectangle:: rectangle (double h, double w) { height = h; width = w; }isosceles :: isosceles (double h, double w) { height = h; width = w;
492 _ Самоучитель C++ double rectangle: : area () ( return width * height; } double isosceles : : area { } { return 0.5 * width * height; }int mainO rectangle b(10.0, 5.0); isosceles i(4.0, 6.0); cout " "Прямоугольник: " " b.areaO " "\n" cout " "Треугольник: " " i.areaO " "\n"; : return 0; 2.5 1. //Класс стек, образуемый с помощью структуры #include <iostream> using namespace std; tdefine SIZE 10 //Объявление класса stack для символов struct stack { stack(); //конструктор void push(char ch); //помещает в стек символ char pop О; //выталкивает из стека символ private: char stckfSIZE]; //содержит стек :int tos; //индекс вершины стека }; //Инициализация стека stack::stack() ( cout " "Работа конструктора стека \п"; tos=0; 1//Помещение символа в стек void stack::push{char ch)
Приложение В. Ответы на вопросы и решения упражнений 493 ' if (tos==SIZE) { cout " "Стек полон \п"; return; stck[tos] = ch; tos++; //Выталкивание символа из стека char stack;:pop() if (tos==0) { cout " "Стек пуст \п"; return 0; //возврат нуля при пустом стеке tos-; return stck{tos]; гint main() i //образование двух, автоматически инициализируемых, стеков stack si, s2; int i; si.push('a'); s2.push('x'); sl.push('b1); s2.push('y'); si.push('c1); s2.push{'z'}; for(i=0; i<3; i++) cout " "символ из стека si:" " sl.popO " "\n";for(i=0; i<3; i++) cout " "символ из стека s2:" " s2.pop() " "\n";return 0; 2. ^include <iostream> using namespace std; union swapbytes { unsigned char с[2]; unsigned i; swapbytes(unsigned x);
494 _ __ _ Самоучитель C++ void swp() ; ) ! swapbytes : : swapbytes {unsigned x} { i = x; I void swapbytes: :swp(} { unsigned char temp; temp = c[0}; c[0] = c[l]; c[l] = temp; } int main() { swapbytes ob(l) ; ob . swp ( } ; cout " ob.i; return 0; 3. Анонимное объединение представляет собой особый синтаксический меха-низм, который позволяет двум переменным совместно использовать одну и ту же область памяти. Доступ к членам анонимного объединения можно реа-лизовать непосредственно, без ссылки на объект. Члены анонимного объе-динения находятся в той же области видимости, что и само объединение. 2.6 #include <iostream> using namespace std; //Перегрузка функции abs() тремя способами //Функция abs() для целых inline int abs{int n} 1 cout " "В функции absО для int\n"; return n<0 ? -n: n; }//Функция abs{) для длинных целых inline long abs(long n)
Приложение В. Ответы на вопросы и решения упражнений _ 495 { cout " "В функции abs{) для long\n"; . return n<0 ? -n: n; //Функция abs { ) для вещественных двойной точности inline double abs (double n) i cout " "В функции abs() для double \n"; return n<0 ? -n: n; int main() cout " "Абсолютная величина -10:" " abs (-10) " "\n"; cout " "Абсолютная величина -10L:" " abs(-lOL) " "\n"; cout " "Абсолютная величина -10.01:" " abs(-lO.Ol) " "\n return 0; 2. Функция не может быть встраиваемой, поскольку содержит цикл for. Боль-шинство компиляторов не поддерживает встраиваемые функции с циклами. 2.7 1. ^include <iostrearn> using namespace std; ttdefine SI2E 10 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека public: stack () { tos = 0; } void push(char ch) { if (tos==SIZE) { cout " "Стек полон"; return; } stck[tos]=ch; tos-t-t-;
496 _ _ Самоучитель C++ char pop ( } i if (tos==0) { cout " "Стек пуст"; return 0; //возврат-нуля при пустом стеке т tos - ; return stck[tos]; int main () ( //образование двух, автоматически инициализируемых, стеков stack si, s2; int i; si. push { 'a' ) ; s2.push('x') ; sl.push('b') ; s2.push( 'y' ) ; si. push ( 'c' ) ; s2.push('2'); for(i=0; i<3; i++) cout " "символ из стека si:" " sl.popO " 11 \n";for(i=0; i<3; i++) cout " "символ иэ стека s2 : " " s2.pop() " "\n";return 0; 2. #include <iostream> ^include <cstring> ttinclude <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype (char *ptr) len = strlen(ptr); p=(char *) mallocilen + 1) ; if(!p} { cout " "Ошибка вьщеления памяти\п"; exit ( 1 ) ;
Приложение В. Ответы на вопросы и решения упражнений 497 Strcpyfp, ptr); ~strtype() ( cout " "Освобождение p\n"; fгее (р); } void show() cout " p " " - длина: " " len; cout " "\n"; int main() strtype si ("Это проверка"), з2{"Мне нравится C++"}; si. show () ; s2. show () ; return 0; Проверка усвоения материала главы 2 1. Конструктор - это функция, которая вызывается при создании объекта. Деструктор - это функция, которая вызывается при удалении объекта. 2. ^include <iostream> using namespace std; class line { int len; public: line{int 1); line::line(int 1) { len = 1; int i; for(i=0; i<len; i+4) cout " '*'; }int main() line 1(10); return 0;
498 Самоучитель C++ 3. Ю 1000000 -0.0009 4. ^include <iostream> using namespace std; class area_cl { public: double height; double width; class rectangle: public area_cl { public: rectangle (double h, double w) { height *= h; width = w; } double area() { return height * width; } class isosceles: public area_cl { public : isosceles (double h, double w) { height = h; width = w; } double area() { return 0.5 * height * width; } class cylinder: public area_cl { public: cylinder (double h, double w) { height = h; width = w; } double area () -I return (2 * 3.1416 * (width/2) * (width/2)) + (3.1415 * height * width} ; int mainO { rectangle b(10.0, 5.0); isosceles i(4.0, 6.0); cylinder c(3.0, 4.0) ; cout " "Прямоугольник: " " b . a r e a f ) " "\n cout " "Треугольник: " " i . a r e a f ) " "\n"; cout " "Цилиндр: " " c.area() " "\n"; return 0; 5. Тело встраиваемой функции встраивается в программу. Это означает, что реально функция не вызывается, что позволяет избежать потерь производи-тельности, связанных с вызовом функции и возвращением функцией своего
Приложение В. Ответы на вопросы и решения упражнений 499 значения. Преимуществом встраиваемых функций является увеличение ско-рости выполнения программы, а их недостатком - увеличение ее объема. 6. ^include <iostream> using namespace std; class myclass { int i, j; public: myclass(int x, int y) { i = x; j = y; } void show() { cout " i " " " " j; } \. I r int main{) { myclass count(2, 3); count.show(); return 0; 7. Члены класса по умолчанию являются закрытыми. Члены структуры - от-крытыми. 8. Да. Это определение анонимного объединения. Проверка усвоения материала в целом 1. ^include <iostream> using namespace std; class prompt ( int count; public: prompt{char *s] { cout " s; cin " count; } -prompt(); prompt::-prompt(} { int i, j; for{i=0; i<count; i cout " '\a ' ; for(j=0; j<32000; J4+); //пауза
500 Самоучитель C++ int main ( } prompt ob( "Введите число: "); return 0; 2. #include <iostream> using namespace std; class ftoi { double feet; double inches; public : ftoi {double f ) ; ); ftoi: : ftoi (double f) feet = f; inches = feet * 12; cout " feet " "футов равно " " inches " "дюймам. \n"; int main() ftoi a (12.0) , b(99.0) ; return 0; 3. ^include <iostream> ^include <cstdlib> using namespace std; class dice { int val; public: void roll {) ; ); void dice: :roll () { val = (rand() % 6) +1; //генерация чисел от 1 до 6 cout " val " "\n"; int main О { dice one, two;
Приложение В. Ответы на вопросы и решения упражнений 507 one.roll(); two.roll(); one.roll ( ) ; two.roll () ; one.roll () ; two.roll { ) ; return 0; ГЛАВА 3 Повторение пройденного 1. Конструктор называется widgit(), а деструктор -~widgit(). 2. Конструктор вызывается при создании объекта (т. е., когда объект начинает существовать). Деструктор вызывается при удалении объекта. 3. class Mars: public planet { 4. Функцию можно сделать встраиваемой, если перед ее определением поста-вить спецификатор inline, или если ее определение разместить внутри объяв-ления класса. 5. Встраиваемая функция должна быть определена перед ее первым использо-ванием. В ней не должно быть циклов. Она не должна быть рекурсивной. В ней не может быть инструкций goto и switch. И наконец, она не должна со-держать статических переменных. 6. sample ob(100, ' X ' ) ; Упражнения 3.1 1. Инструкция присваивания х = у неправильна, поскольку ell и с!2 - это два разных класса, а объекты разных типов присваивать нельзя. 2. #include <iostream> using namespace std; #<3efine SIZE 100
502 _ Самоучитель C++ class q_type { . int queue [SIZE]; //содержит очередь int head, tail; //индексы вершины и хвоста public: q_type(); //конструктор void q(int num) ; //запоминание int deq(); //удаление из начала очереди }; //Конструктор q_type: :q_type{) { head -tail = 0; }//Помещение значения в очередь void q_type : : q ( int num) if (tail -I-l==head || (tail + 1"SIZE SS Ihead)} { cout " "Очередь полна"; return; }tail-м-; if (tail==SIZE) tail = 0; //круговой цикл queue [tail] = num; //Выталкивание значения из очереди int q_type: :deq() if (head==tail) { cout " "Очередь пуста"; return 0; head++; if (head==SIZE) head = 0; //круговой цикл return queue[head]; int main{) q_type ql, q2; int i; for(i=l; i<=10; i++) { ql.q(i); }//присваивание одного объекта очередь - другому q2 = ql;
Приложение В. Ответы на вопросы и решения упражнений //демонстрация того факта, //что обе очереди имеют одинаковое содержимое for(i=l; i<=10; i-н-) cout " "Элемент очереди 1: " " ql . deq ( ) " "\n"; for(i=l; i<=10; i++) cout " "Элемент очереди 2: " " q2.deq() " "\n"; return 0; 3. Если для хранения очереди память выделяется динамически, тогда, после присваивания одной очереди другой, когда объекты удаляются, для очереди, стоящей в инструкции присваивания слева, память освобождена не будет, а для очереди, стоящей в инструкции присваивания справа, память будет осво-бождена дважды. Оба этих условия неприемлемы, что и вызывает ошибку. 3.2 1. ^include <iostream> using namespace std; ttdefine SIZE 10 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека public: stack (}; //конструктор void push (char ch) ; //помещает символ в стек char pop (); //выталкивает символ из стека }; //Инициализация стека stack: :stack () { cout " "Работа конструктора стека \п" ; tos = 0; //Помещение символа в стек void stack: :push (char ch) { if (tos==SIZE) { cout " "Стек полон \п"; return;
504 Самоучитель C++ stckftos] = ch; tos-n-; '//Выталкивание символа из стека char stack::pop() if (tos=0) { cout " "Стек пуст \п"; return 0; //возврат нуля при пустом стеке tos-; return stck[tos]; void showstack{stack o) ; int main() \ stack si; int i; si.push('a'}; sl.push('b'); sl.push('c'); showstack(sl); //объект si в функции main{) по-прежнему существует cout " "Стек si все еще содержит следующее: \п"; for(i=0; i<3; i-н-) cout " sl.popO " "\n"; return 0; //Вывод содержимого стека void showstack(stack o) char c; //когда выполнение этой инструкции завершится, //стек о опустеет while(с=о.рор()} cout " с " "\п"; cout " "\п"; Эта программа выводит на экран следующее: Работа конструктора стека сbа
Приложение В. Ответы на вопросы и решения упражнений 505 Стек пуст Стек si все еще содержит следующее: сьа 2, Память для хранения целого, на которую указывает указатель р в объекте о, который используется при вызове функции neg(), освобождается, когда при завершении функцией neg() своей работы копия объекта о удаляется; однако эта память все еще необходима для объекта о в функции mainO 3.3 1. ^include <iostreaici> using namespace std; class who { char name; public: who(char c) { name = c; cout " "Создание объекта who tt"; cout " name " "\n"; ~who() { cout " "Удаление объекта who #" " name " "\n"; } who rnakewho () f who temp('В') ; return temp; int main() who ob('A'); makewho(); return 0; 2. Имеется несколько ситуаций, в которых возвращать объект было бы непра-вильно. Вот одна из таких ситуаций: если при создании объекта файл откры-вается, а при удалении объекта файл закрывается, тогда к закрытию файла приведет удаление временного объекта, которое происходит, когда функция возвращает объект.
506 Самоучитель C++ 3.4 1. ^include <iostream> using namespace std; class pr2; //предварительное объявление class prl { int printing; . public: prl() { printing = 0; } void set_print(int status) { printing = status; } friend int inuse{prl ol, pr2 o2); class pr2 { int printing; //... public: pr2() { printing =0; } void set__print (int status) { printing = status; } //... friend int inuse{prl ol, pr2 o2); //Возвращает истину при занятом принтере int inuse(prl ol, pr2 o2) { if(ol.printing I I o2,printing) return 1; else return 0; int main(} prl pi; pr2 P2; if(linuse(pi, p2)) cout " "Принтер свободен\п"; cout " "Установка для печати принтера pi ..An"; pl.set_print (1); if(inuse(pl, p2)) cout " "Теперь принтер занят\п" cout " "Отключение принтера р! ... \п"; pl.setjprint(0); if (linuse{pi, p2)) cout " "Принтер свободен\п";
Приложение В. Ответы на вопросы_и_решения_ упражнений 507 cout " "Подключение принтера р2 ... \п"; p2.set_print(l); if{inuse{pl, p2)) cout " "Теперь принтер занят\п"; return 0; Проверка усвоения материала главы 3 1. Для того чтобы присвоить один объект другому, необходимо, чтобы тип обо-их объектов был одинаков. 2. Присваивать obi и оЬ2 неправильно, так как память, на которую в начале указывал указатель р объекта оЬ2, теряется, поскольку это значение указателя р при присваивании переписывается. Таким образом, такую память стано-вится невозможно освободить, и наоборот, память, на которую в начале ука-зывал указатель р объекта obi, при удалении этого объекта освобождается дважды, что может привести к повреждению системы динамического выде-ления памяти. 3. int light (planet p) { return p.getjnilesU /186000; 4. Да. 5. //Загрузка алфавита в стек ^include <iostream> using namespace std; kiefine SIZE 27 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека public: stack (); //конструктор :void push (char ch) ; //помещает символ в стек char рор(); //выталкивает символ из стека \ . //Инициализация стека stack: : stack () { cout " "Работа конструктора стека \п";
508 Самоучитель C++ tos -0; /I Запись символа в стек void stack: :push(char ch) ( if (tos==SISE) { cout " "Стек полон \п"; return; stckftos] = ch; tos++; 1//Выталкивание символа из стека char stack: :pop() { if (tos==0) { cout " "Стек пуст \п"; return 0; //возврат нуля при пустом стеке 1 tos - ; return stck[tos]; void showstack (stack o) ; stack loadstackO; int main() t stack si; si = loadstackO ; showstack (si) ; return 0; //Вывод на экран содержимого стека void showstack(stack о) { char с; //когда выполнение этой инструкции завершится, стек о опустеет while(c=o.pop(}) cout " с " "\п"; cout " "\п"; //Загрузка стека символами алфавита stack loadstackf)
Приложение В. Ответы на вопросы и решения упражнений 509 stack t; char с; for ( с= ' а ' ; с<= ' z ' ; с++ ) t . push ( с ) ; return t; 6. При передаче объекта функции в качестве аргумента и при возвращении объекта из функции в качестве возвращаемого значения, создается времен-ный объект, который удаляется при завершении работы функции. При уда-лении временного объекта деструктор может удалить в программе нечто та-кое, что может еще пригодиться. 7. Дружественная функция - это функция, не являющаяся членом класса, но обеспечивающая доступ к закрытой части класса, для которого она дружест-венна. Еще раз, дружественная функция имеет доступ к закрытой части класса, для которого она дружественна, но не является членом этого класса. Проверка усвоения материала в целом 1. //Загрузка алфавита в стек ^include <iastream> ^include <cctype> using namespace std; ^define SIZE 27 //Объявление класса stack для символов class stack { char stckfSIZE]; //содержит стек int tos; //индекс вершины стека public: stack(); //конструктор void push(char ch) ; //помещает символ в стек char pop(); //выталкивает символ из стека //Инициализация стека stack: : stack {} { cout " "Работа конструктора стека \п tos = 0; //Запись символа в стек void stack: : push (char ch)
510 Самоучитель if (tos- SIZE) { cout " "Стек полон \п"; return; }stck[tos] = ch; tos++; }//Выталкивание символа из стека char stack: :pop() { if (tos-0) { cout " "Стек пуст \п"; return 0; //возврат нуля при пустом стеке tee- i return stckftos]; void showstack (stack o) ; stack loads t ack (); stack loadstack(int upper); int rnainO { stack si, s2, s3; si = loadstackO ; showstack (si) ; , , //используется верхний регистр s2 = loadstack(l) ; showstack (s2) ; //используется нижний регистр s3 = loadstack(O) ; showstack (s3} ; return 0; //Вывод на экран содержимого стека void showstack (stack о) { char с; //когда выполнение этой инструкции завершится, стек о опустеет while (c=o. pop (}) cout " с " "\п";
Приложение В. Ответы на вопросы и решения упражнений _ 511 cout " "\п"; //Загрузка стека символами алфавита stack loadstack() { stack t; char с; for(c='a'; c<='z'; с++) t.push(c) return t; /* Загрузка стека символами алфавита . Символами верхнего регистра, если переменная upper равна 1, в противном случае символами нижнего регистра */stack loadstack{int upper) ( stack t; char c; if (upper) с = 'A' ; else с = 'a' ; for (; toupper (c}<='Z' ; с++) t .push (c) ; return t; 2. ^include <iostream> ^include <cstring> ^include <cstdlib> using namespace std; class strtype ( char *p; int len; public: strtype (char *ptr) ; -strtype (); void show ( ) ; friend char *get_string( strtype *ob) ; }; strtype: : strtype (char *ptr) ( len=strlen(ptr) ; p=(char *) malloc(len+l) ;
512 _ _ __ ______ Самоучитель C++ cout " "Ошибка выделения памяти\п"; exit(l) ; }strcpyfp, ptr); strtype : : -strtype ( ) { cout " "Освобождение памяти по адресу р\п"; free (p) ; } void strtype: : show () { cout " p " " -длина: " " len; cout " "\n"; } char *get_string (strtype *ob) f return ob->p; }int main!) { strtype si ("Это проверка-'); char *s; si . show ( ) ; //получение указателя на строку s = get_string(£sl) ; cout " "Это строка, содержащаяся в объекте si: "; cout " s " "\n"; return 0 ; 3. Итог эксперимента следующий: Да, если один объект производного класса присваивается другому, то данные базового класса также копируются. Далее приводится программа для демонстрации этого факта. #include <iostream> using namespace std; class base { int a; public:
Приложение В. Ответы на вопросы и решения упражнений 513 void load_a(int n) { а = n; } int get_a() { return a; } }; class derived: public base { int b; public: void load_b (int n) { b = n; } int get_b() { return b; } int main() derived obi, ob2; obl.load_a(5); obl.load_b(10}; //Объект obi присваивается объекту оЬ2 ob2 = obi; cout " "Это переменные а и b объекта obi: "; cout " obl.get_a() " ' ' " obl.get_b() " "\n"; cout " "Это переменные а и b объекта оЬ2: "; cout " ob2.get_a() " ' ' " ob2.get_b() " "\n"; /* Как вы, вероятно, догадались, выводимые на экран значения одинаковы для обоих объектов */return 0; ГЛАВА 4 Повторение пройденного 1. При присваивании одного объекта другому объекту того же типа, текущие значения данных всех членов объекта, стоящего справа от оператора при-сваивания, передаются соответствующим членам объекта, стоящего слева от оператора присваивания. 2. При присваивании одного объекта другому, ошибка может случиться тогда, когда эта операция перезаписывает важные данные, уже существующие в це-левом объекте. Например, если значение указателя на динамически выделен-ную область памяти или на открытый файл будет перезаписано, то очевидно, что тогда теряется исходное значение указателя.
574 Самоучитель С++_ 3. Если объект передается функции в качестве аргумента, создается его копия. Однако конструктор копии не вызывается. При завершении работы функ-ции, когда объект удаляется, вызывается деструктор копии. 4. Нарушение принципа независимости объекта и его копии при передаче па-раметра может возникать в нескольких ситуациях. Например, если деструк-тор освобождает динамическую память, тогда эта память для аргумента будет потеряна. В общем случае, если деструктор удаляет что-то, что требуется ис-ходному аргументу, аргумент будет испорчен. 5. #include <iostream> using namespace std; class summation { int num; long sum; //суммирование чисел num public: void set_sum(int n) ; void show_sum{) { cout " " сумма чисел " " num " " равна " " sum " "\n"; void summation: :set_sum(int n) { int i; num = n; sura = 0; for(i=l; i<=n; sum += i; summation make_sum() { int i; summation temp; cout " "Введите число: cin " i; temp. set_sum(i) ; return temp; int main ( } { summation s;
Приложение В. Ответы на вопросы и решения упражнений _ 515 s = make_sum() ; s .show_sura{) ; return 0; 6. Для некоторых компиляторов требуется, чтобы во встраиваемых функциях не было циклов. 7. tinclude <iostream> using namespace std; class myclass { int num; public: myclass (int x) { num = x; } friend int isneg (myclass ob) ; int isneg (myclass ob) { return (ob.num < 0) ? 1: 0; }int main( ) { myclass a(-l), b(2); cout " isneg(a) " ' ' " isneg(b); cout " "\n"; return 0; 8. Да, дружественная функция может быть дружественной более чем одному классу. Упражнения 4.1 1. #include <iostream> using namespace std; class letters ( char ch;
516 _ _ _ Самоучитель C++ public: letters (char с) { ch = с; } char get_ch() ( return ch; } int main { ) { letters ob [10] = { 'a', 'b', 'c1, 'd', '&', :f, 'g1, 'h', 'i', 'j' }; int i; for(i=0; i<10; i++) cout " ob[ i ].get_ch() " ' '; cout " "\n"; return 0; 2. ^include <iostrearti> using namespace std; class squares { int num, sqr; public : squares {int a, int b) { num = a; sqr = b; } void show() {cout " num " ' ' " sqr " "\n"; } ! i int main () { squares ob[10] = { squares (1, 1) , squares (2, 4) , squares (3, 9) , squares (4, 16) , squares (5, 25) , squares (6, 36} , squares (7, 49) , squares (8, 64) , squares (9, 81) , squares (10, 100} , }; int i; for{i=0; i<10; i++) ob [ i ] . show ( ) ; return 0;
Приложение В. Ответы на вопросы и решения упражнений _ 517 3. ttinclude <iostream> using namespace std; class letters { char ch; public: letters (char c) { ch = c; } char get_ch() ( return ch; ) int main{) { letters ob[10] = { letters ( 'a' ) , letters {'b1) , letters ('c') , letters ('d') , letters ( 'e1 ) , letters Cf) , letters ('g') , letters{'hr) , letters ( ' i1 ) , letters (' j M }; int i; for(i=0; i<10; i++) cout " ob [ i ] . get_ch ( } " cout " "\n"; return 0 ; 4.2 1. //Вывод содержимого массива в обратном порядке ^include <iostream> using namespace std; class samp { int a, b; public: sarap{int n, int m) { a = n; b = m; } int get_a{) { return a; } int get_b{) { return b; }
518 Самоучитель C++ int main{) samp ob[4] = ( samp (1, 2), samp (3, 4), samp(5, 6), samp(1, 8) int i; sarnp *p; p = &ob[3]; //получение адреса последнего элемента массива for(i=0; i<4 cout " p -> get_a() " ' '; cout " p -> get_b!) " "\n"; p - ; //переход к предыдущему объекту cout " "\n"; return 0 ; 2. /* Создание двумерного массива объектов с доступом к элементам через указатель */#include <iostream> using namespace std; class samp { int a; public: samp (int n) { a = n; } int get_a ( ) { return a; } int main { ) 1 samp ob [4] [2] = { 1, 2, 3, 4, 5, 6, int i;
Приложение В. Ответы на вопросы и решения упражнений _ 519 samp *p; р = (samp *) ob; for(i=0; i<4; i cout " p->get_a ( } " ' ' ; P++; cout " p->get_a() " "\n"; P++; }cout " "\n"; return 0; 4.3 1. //Использование указателя this #include <iostream> using namespace std; class niyclass { int a, b; public: myclass(int n, int m) { this->a = n; this->b = m; } int add() { return this->a + this->b; } void showf) ; }; void myclass::show() ( int t; t = this->add(); //вызов функции-члена cout " t <<"\n"; }int main() { myclass ob(10, 14); ob.show(); return 0;
520 Самоучитель C++ 4.4 1. ttinclude <iostream> using namespace std; int main{) { float *f; long *1; char *c; f = new float; 1 = new long; с = new char; if (!f I I !1 I I !c) { cout " "Ошибка вьщеления памяти. return 1; }*f = 10.102; *1 = 100000; *c = 'A'; cout " *f " ' ' " *1 " ' ' " *c; cout " '\n'; delete f; delete 1; delete c; return 0; 2. ^include <iostream> ^include <cstring> using namespace std; class phone { char name[40]; char number[14]; public: void store(char *n, char *mm) ; void show{) ; void phone::store(char *n, char *num) strcpy(name, n); strcpy (number, mm) ;
Приложение В. Ответы на вопросы и решения упражнений _ 521 void phone: : show ( ) { cout " name " ": " " number,-cout " "\n"; )int rnain{) i phone *p; p = new phone; i f ( ! p ) ( cout " "Ошибка выделения памяти."; return 1; } p->store( "Исаак Ньютон", "111 555-2323"); p->show ( ) ; delete p; return 0; 3. В случае неудачной попытки выделения памяти, оператор new может либо возвратить нулевой указатель, либо возбудить исключительную ситуацию. Чтобы выяснить, какой механизм используется в вашем компиляторе, необ-ходимо просмотреть соответствующую техническую документацию. В соот-ветствии с требованиями стандарта по C++, оператор new по умолчанию возбуждает исключительную ситуацию. 4.5 1. char *p; p = new char[100] ; //.... strcpy(p, "Это проверка"}; 2. ^include <iostream> using namespace std; int main() < double *p; .p = new double(-123.0987);
522 Самоучитель C++ cout " *р " '\n'; return 0; 4.6 1. ^include <iostream> using namespace std; void rneg(int &i); //версия функции со ссылкой void pnegfint *i); //версия функции с указателем int main (} { int i = 10; int j = 20; rneg(i); pneg(sj); cout " i " ' ' " j " '\n'; return 0; //использование параметра-ссыпки void rneg(int si) //использование параметра-указателя void pneg(int *i) *i = -*i; 2. При вызове функции tripleQ адрес d получен явно, посредством оператора &. Это ненужно и неправильно. При использовании ссылки в качестве парамет-ра перед аргументом не ставится оператор &. 3. Адрес параметра-ссылки передается в функцию автоматически. Для получе-ния адреса нет необходимости производить какие бы то ни было действия. Передача по ссылке быстрее, чем передача по значению. При передаче по ссылке не делается копии аргумента и поэтому не бывает сторонних эффек-тов, связанных с вызовом деструктора копии.
Приложение В. Ответы на вопросы и решения упражнений 523 4.7 1. В исходной программе объект передается в функцию show() по значению. По-этому делается его копия. Когда функция showQ возвращает свое значение, копия удаляется и при этом вызывается деструктор копии. Это приводит к ос-вобождению памяти, на которую указывает указатель р, но освобожденная па-мять все еще необходима аргументам функции show(). Здесь представлена пра-вильная версия программы, в которой, для того чтобы предотвратить появле-ние копии при вызове функции, в качестве параметра используется ссылка: //Теперь программа исправлена ^include <iostream> ^include <cstring> #include <cstdlib> using namespace atd; class strtype { char *p; public: strtype(char *s) ; ~strtype() { delete [] p; } char *get() ( return p; } }; strtype::strtype(char *s) int 1; 1 = strlen(s) + 1; p = new char [1] ; cout " "Ошибка выделения памяти\п"; exit(l); strcpy{p, s) ; 1//Проблема решена с помощью параметра -ссылки void show(strtype sx) { char *s; s = x.get () ; cout " s " "\n"; int main() { strtype а ("Привет") , b ("Здесь") ;
524 Самоучитель C++ show(a); show(b) ; return 0; 4.8 1. //Пример защищенного двумерного массива ^include <iostream> ttinclude <cstdlib> using namespace std; class array ( int isize, jsize; int *p; public : array (int i, int j); int&put(int i, int j); int get (int i, int j); }; array: : array (int i, int j) { p = new int [ i * j ] ; if(!p) ( cout " "Ошибка выделения ламятиЛп"; exit(l) ; isize = i; jsize = j; i //Запись значения в массив int fiarray: :put (int i, int j) | i>=isize I I j<0 I I j>=jsize) { cout " "Ошибка, нарушены границы массива! !! \n"; exit С 1 ) i }return p[i * jsize + j]; //возврат ссылки на p[ i ] i//Получение значения из массива int array: :get (int i, int j) ( if(i<0 || i>=isize I I j<0 I I j>=jsize} { cout " "Ошибка, нарушены границы массива! ! !\n"; exit ( 1 ) ;
Приложение В. Ответы на вопросы и решения упражнений 525 return p[i * jsize + j ] ; //возврат символа } int main{) { array a {2, 3); int i, j; for(i=0; i<2; i++) for(j=0; j<3; j++) a.put(i, j ) = i + j; for(i=0; i<2; i-b+) for(j=0; j<3; j++) cout " a.get(i, j ) " ' '; //генерация ошибки нарушения границ массива a.put(10, 10}; return 0; 1 2. Нет. Возвращаемую функцией ссылку нельзя присвоить указателю. Проверка усвоения материала главы 4 1. ^include <io5tream> using namespace std; class a_type { double a, b; public: a_type(double x, double y} ( a = x; b = y; } void show() ( cout " a " ' ' " b " "\n"; } I; int main() { a_type ob[2][5] = { a_type(l, 1), a__type(2, 2 ) , a_type(3, 3), a_type(4, 4), a_type(5, 5), a_type(6, 6), a_type{7, 7), a_type(B, 8), a_type(9r 9), a_type(10, 10}
526 Самоучитель C++ int i, j; for(i=0; i<2; for(j=0; j ob[ i ][ j ],show(); cout " r\n'; return 0; 2. #include <iostream> using namespace std; class a_type ( double a, b; public: a_type (double x, double y) { a = x; b = y; void show{) { cout <:< a " ' ' " b " "\n"; } }; int mainO ,\ a_type ob[2] [5] = { a_type(l, 1), a_type(2, 2}, a__type(3, 3), a_type(4, 4), a_type(5, 5), a_type(6, 6), a_type(7, 7), a_type(8, 8), a_type(9, 9), a_type(10, 10} 1; a_type *p; p = (a_type *) ob; int i, j; for(i=0; i<2 for(j=0; j<5; p->ShOW ( ) ; P++; } cout " '\nr ; return 0 ;
Приложение В Ответы на вопросы и решения упражнений 527 3. Указатель this - это указатель, который автоматически передается функции-члену и который указывает на объект, вызвавший функцию. 4. Основными формами операторов new и delete являются следующие: p-var - new type; delete p-var; При использовании оператора new нет необходимости в приведении типов. Размер объекта определяется автоматически, поэтому не нужен оператор sizeof. Кроме этого, незачем включать в программу заголовок <cstdlib>. 5. Ссылка по существу является скрытым константным указателем и просто играет роль другого имени переменной или аргумента. Преимущество от использования параметра-ссылки в том, что никакой копии аргумента не делается. 6. ftinclu.de <iostream> using namespace std; void recip(double &d); int main(} double x = 100.0; cout " "x равно " " x " '\n'; recip (x); cout " "Обратная величина равна " " x " '\n'; return 0; void recip (doubles &d) d = 1/d; Проверка усвоения материала в целом 1. Для доступа к члену объекта с помощью указателя используется оператор стрелка (->). 2, ^include <iostream> #include <cstring> ttinclude <cstdlib> using namespace std;
528 Самоучитель C+ class strtype { char *p; int len; public: strtype(char *ptr); -strtype(); void showf) ; strtype:rstrtype(char *ptr) len = strlen(ptr); p = new char[len + 1]; cout " "Ошибка выделения памяти\п"; exit(l) ; strcpy(p, ptr); strtype::-strtype() cout " "Освобождение памяти по адресу р\п"; delete [] p; void strtype::show() cout << p " " - длина: " " len; cout " "\n"; int main() strtype si("Это проверка"), з2("Мне нравится C++" si.show(); s2.show(); return 0; > ГЛАВА 5 Повторение пройденного 1. Ссылка - это особый тип указателя, который разыменовывается автоматиче-ски. Ссылка в инструкциях может использоваться точно так же, как объект,
Приложение В. Ответы на вопросы^ решения упражнений 529 на который она указывает. Имеются три вида ссылок: ссылка может быть параметром, ссылка может быть возвращаемым значением функции и, кроме этого, ссылка может быть независимой. Самыми важными являются ссылка в качестве параметра и ссылка в качестве возвращаемого значения функции. 2. ^include <iostream> using namespace std; int main() { float *f; int *i; f = new float; i = new int; i f ( i f I I !i) { cout " "Ошибка выделения памяти\п"; return 1; *f = 10.101; *i = 100; cout " *f " ' ' " *i " '\n delete f; delete i; return 0; 3. Здесь показана основная форма оператора new, используемая для инициали-зации динамических переменных: указатель__яа_переменную = new ткп(инициализяруюа{ее_дначенив) ; Например, .в следующем фрагменте выделяется память для целого и этому целому присваивается значение 10: int *p; р = new int(10); 4. ^include <iostream> using namespace std; class samp { int x; public: samp (int n) { x = n; }
530 _ Самоучитель C++ int getxf) { return x; } }; int raaint) { samp A[10] -{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } ; int i; for(i=0; i<10; i-н-) cout " A[ i ] . getx ( ) " ' '; cout " "\n"; return 0; 5. Достоинства: Ссылка в качестве параметра при вызове функции не приводит к появлению копии объекта. Передача параметра по ссылке часто быстрее, чем его передача по значению. Параметр -ссылка упрощает синтаксис и про-цедуру вызова функции по ссылке, снижая вероятность ошибки. Недостатки: Изменения в параметре -ссылке меняют и используемую в вы-зове исходную переменную, следовательно параметр-ссылка открывает воз-можность сторонних эффектов в вызывающей программе. 6. Нет. 7. ^include <iostream> using namespace std; void mag (long snum, long order); int main() ( long n = 4 ; long o = 2; cout " "Значение 4, увеличенное на два порядка равно "; mag (n, о) ; cout " n " '\n' ; return 0; } void mag (long snum, long order) i for(; order; order - ) num = num * 10;
Приложение В. Ответы на вопросы и решения^пражнений 53? Упражнения 5-1 . 1. ^include <iostream> i ^include <cstring> ^include <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype(); strtypefchar *s, int 1); char *getstring() { return p; } int getlengthO { return len; } }; strtype::strtype(} { p = new char[255]; if(!p> { cout " "Ошибка выделения памяти\п"; exit(l); }*p = '\0'; //нулевая строка len = 255; }strtype::strtype(char *s, int 1) { if(strlen(s) >= 1) { cout " "Выделено слишком мало памяти!\п"; exit (1); } p = new char[ 1 ]; if(!p) { cout " "Ошибка выделения памяти\п"; exit(l) ; } strcpy(p, s); len = 1; )int main ()
532 Самоучитель C++ strtype si; strtype з2{"Это проверка", 100); cout " "Строка si: " " si.getstring () " "-Длиной: " cout " sl.getlengthf) " "\n"; cout " "Строка s2: " " s2.getstring{) " "-Длиной: " cout " s2.getlength(J " "\n"; return 0; 2. //Имитация секундомера ^include <iostream> ^include <ctime> using namespace std; class stopwatch { double begin, end; public: stopwatch () ; stopwatch (clock_t t) -stopwatch () ; void start () ; void stop () ; void show() ; stopwatch: :stopwatch(} { begin = end = 0.0; stopwatch: : stopwatch (clock_t t) i begin = (double) t /CLOCKS_PER_SEC; end = 0.0; stopwatch: :~stopwatch() ! cout " "Удаление объекта stopwatch .,."; show ( ) ; i void stopwatch: : start () { begin = (double) clockf) /CLOCKS_PER_SEC;
Приложение В. Ответы на вопросы и решения упражнений 533 void stopwatch::stop () end -(double) clock О /CLOCKS_PER_SEC; void stopwatch::show() cout " "Истекшее время: " " end - begin; -cout " "\n"; Iint main() stopwatch watch; long i; watch.start(); for{i=0; i<3200000; i+4-) ; //время цикла watch.stop(}; watch.show(); //Создание объекта с использованием его начального значения stopwatch s2(clock{)); for{i=0; i<250000; 1-й-) ; //время цикла s2.stop() ; s2 . show () ; return 0; }5.2 1. Для объектов obj и temp вызывается обычный конструктор. Однако, когда объект temp становится возвращаемым значением функции f{), создается временный объект, который генерирует вызов конструктора копий. # include <iostream> using namespace std; class myclass { public: myclass () ; myclass (const myclass So) ; myclass f () ; II Обычный конструктор
534 Самоучитель C++ myclass: :myclass () { cout " "Работа обычного конструктора\п" ; }//Конструктор копий myclass: irnyclass (const myclass So) { cout ": "Работа конструктора копий\п"; }//Возвращение объекта myclass myclass: :f() { myclass temp; return temp; 'int main ( ) { myclass ob j ; obj=obj . f () ; return 0 ; 2. В соответствии с программой, когда объект передается в функцию getvalQ, создается его поразрядная копия. Когда функция getval() возвращает свое значение и копия удаляется, выделенная для этого объекта память (на кото-рую указывает указатель р) освобождается. Однако эта память по-прежнему требуется исходному объекту, который использовался при вызове функции getvalQ. Далее представлена исправленная версия программы. Для решения проблемы потребовался конструктор копий. //Исправленная версия программы #include <iostream> ^include <cstdlib> using namespace std; class myclass { int *p ; public: myclass (int i) ; myclass (const myclass so); //конструктор копий ~myclass() (delete p;} friend int getval (myclass o) ;
Приложение В. Ответы на вопросы и решения упражнений _ 535 rnyclass: :myclass (int i) i p=new int; cout <:< "Ошибка выделения памяти\п"; exit(l) ; }*p=i; }1 1 Конструктор копий myclass: irnyclass (const myclass &o) f p=new int; //выделение памяти для копии if(!p) { cout " "Ошибка выделения ламяти\п"; exit(l) ; }*р=*о.р; }int getval (myclass о) t return *o.p; //получение значения } int main() { myclass a(l) , b(2) ; cout " getval (a) " " " " getval (b) ; cout " "\n"; cout " getval (a) " " " " getval (b) ; return 0; 3. Конструктор копий вызывается, когда один объект используется для ини-циализации другого. Обычный конструктор вызывается, когда объект созда-ется. 5.4 1. ^include <iostream> #include <cstdlib>
536 Самоучитель C++ using namespace std; long mystrtol(const char *s, char **end, int base = 10) return strtol(s, end, base); int main () long x; char *sl -"100234"; char *p; x = mystrtol{si, &p, 16); cout " "Основание системы счисления 16: " " x " p\n'; x -mystrtol(si, &p, 10); cout " "Основание системы счисления 10: " " x " '\г.'; x = mystrtol(si, 5p); //основание системы счисления, //заданное по умолчанию cout " "Основание системы счисления по умолчанию 10: " " х " '\п'; return 0; 2. Все параметры, которые получают аргументы по умолчанию, должны нахо-диться правее параметров, которые этих аргументов не получают. Таким об-разом, после того как вы начали присваивать значения аргументам по умол-чанию, все последующие параметры также должны получать свои значения по умолчанию. Что касается приведенного в вопросе прототипа функции, то в нем параметр q значения по умолчанию не получает. 3. Поскольку функции управления позиционированием курсора у различных компиляторов и сред программирования разные, показано только одно из возможных решений задачи. Следующая программа предназначена для рабо-ты в среде программирования Borland C++. /* Эта программа работает только в среде программирования Borland C++ */#include <iostream> ^include <conio.h> using namespace std; void rnyclreol (int len = -1) ; int main() f int i;
Приложение В. Ответы на вопросы и решения упражнений 537 gotoxy(1, 1) ; for(i=0; i<24; i++) cout " "abcdefghijklmnopqrstuvwxyzl23456789Q\n"; gotoxyd, 2) ; inyclreol () ; gotoxyd, 4) ; myclreol{20) ; return 0; I//Стирание строки на величину, заданную параметром len void inyclreol (int len} { int x, у; x = wherex(); //получение положения по х у = whereyi); //получение положения по у if(len == -1) len = 80 -x; int i = x; for(; i<=len; i++) cout " ' '; gotoxy(x, y); //установка курсора J 4. Аргумент по умолчанию не может быть другим параметром или локальной переменной. 5.6 1. ^include <iostream> using namespace std; int dif(int a, int b) { return a - b; }float dif(float a, float b) { return a - b; )int main f) { int (*pl)(int, int};
535 Самоучитель C++ float (*р2) (float, float); pi = dif; //адрес функции diffint, int) p2 = dif; //адрес функции dif(float, float) cout " pi (10, 5) " ' '; cout " p2!10.5, 8.9} " '\n'; return 0; Проверка усвоения материала главы 5 1. //Перегрузка конструктора date() для параметра типа time_t ^include <iostream> ^include <cstdio> //заголовок включен для функции sscanffi ^include <ctime> using namespace std; class date { int day, month, year; public: date (char *str) ; date (int m, int d, int y) { day = d; month = m; year = y; }//Перегрузка конструктора для параметра типа time_t date{time_t t) ; void show() { cout " month " '/' " day " '/'; cout " year " '\n'; date: : date (char *str) { sscanf (str, "%d%*c%d%*c%d", fimonth, &day, &year) } date: :date (time_t t) { struct tm *p; p = localtirne ( f i t ) ; day = p -> tm_mday; month = p -> trn mon;
Приложение^. Ответы на вопросы и решения упражнений __ __ __ 539 year = р -> tm_year; } int main() { //Образование даты с помощью строки date sdate("ll/l/92") ; //Образование даты с помощью трех целых date idate(ll, I, 92) ; /* Образование даты с помощью параметра типа time_t, что ведет к созданию объекта, использующего системную дату Vdate tdate (time (NULL) ) ; sdate. show() ; idate. show() ; tdate. show() ; return 0; 2. В классе samp определен только один конструктор - конструктор с парамет-ром. Поэтому нельзя объявлять объект типа samp без параметра. (То есть ин-струкция samp x - это неправильное объявление.) 3. Первый довод в пользу перегрузки конструктора состоит в том, что такая перегрузка обеспечивает гибкость, позволяя вам выбрать в каждом конкрет-ном случае наиболее подходящий конструктор. Другой довод в том, что пе-регрузка позволяет объявлять как инициализируемые, так и не инициализи-руемые объекты. Вам может потребоваться перегрузить конструктор для ди-намического выделения памяти под массив. 4. Ниже представлена основная форма конструктора копий: имя класса (const имя класса ^объект) { тело конструктора 5. Конструктор копий вызывается, когда имеет место инициализация, а имен-но: когда один объект явно используется для инициализации другого, когда объект передается в функцию в качестве параметра, когда создается времен-ный объект при возвращении объекта функцией. 6. Ключевое слово overload является устаревшим. В ранних версиях C++ оно информировало компилятор о том, что функция будет перегружена. В совре-менных компиляторах это ключевое слово не поддерживается.
540 __ Самоучитель C++ 7. Аргумент по умолчанию - это значение, которое присваивается параметру функции при ее вызове, если при этом соответствующий аргумент функции не указан. 8. ^include <iostream> ^include <cstring> using namespace std; void reverse (char *str, int count = 0); int main ( ) { char *sl = "Это проверка"; char *s2 = "Мне нравится C++"; reverse (si); //Реверс всей строки reverse (s2, 7); //Реверс первых семи знаков cout " si " '\n'; cout " s2 " '\n' ; return 0; void reverse (char *str, int count) { int i, j; char temp; i f f l c o u n t ) count = strlen(str) - 1; for(i=0, j=count; i<j . temp = str[ i ]; str[ i ] = str[ j ] ; str[ j ] -temp; } 9. Все параметры, получающие аргументы по умолчанию, должны находиться правее параметров, не получающих таких аргументов. 10. Неоднозначность может возникнуть, когда по умолчанию происходит пре-образование типа, а также при использовании параметра-ссылки или аргу-мента по умолчанию. 11. Пример неоднозначен, поскольку компилятор не может определить, какую версию функции compute() следует вызвать. Вызвать ли первую версию с аргументом по умолчанию divisor, или вторую - в которой функция получа-ет только один параметр?
Приложение В. Ответы на вопросы и решения упражнений 541 12. При получении адреса перегруженной функции с помощью указателя, кон-кретную ее версию определяет способ объявления указателя. То есть для всех перегруженных версий функции, адреса которых мы хотели бы полу-чить, должна объявляться своя версия указателя. Проверка усвоения материала в целом 1. #include <iostream> using namespace std; void order{int &a, int fib) { int t; if (a<b) return; else { //а и b меняются местами t = a; a = b; b = t; int main() { int x = 10, у = 5; cout " "x: " " x " ", y: " " у " ' \n ' ; order {x, y) ; cout " "x: " " x ": ", y: " " у " ' \n ' ; return 0; 2. Синтаксис вызова функции, параметр которой передается по ссылке, иден-тичен синтаксису вызова функции, параметр которой передается по значению. 3. Аргумент по умолчанию, фактически, является компактной записью пере-грузки функции, поскольку приводит к тому же результату. Например, инст-рукция int f (int a, int b = 0) ; идентична следующим двум перегруженным функциям: int f (int a) ; int f (int a, int b) ;
542 Самоучитель С++ 4. ^include <iostream> using namespace std; class samp { int a; public: samp{) { a = 0; } samp(int n) { a = n; } int get_a() { return a; } }; int main() { samp ob (88); samp obarray[10]; 5. Конструкторы копий необходимы, если программист хотел бы точно управ-лять процессом создания копий объекта. Это важно только в том случае, ес-ли создаваемые по умолчанию поразрядные копии по каким-либо причинам нежелательны. ГЛАВА 6 Повторение пройденного 1. class myclass { int x, у; public: myclass (int i, int j) ( x = i; у = j; } myclass!) { x = 0; у = 0; } 2. class myclass { int x, y; public: myclass (int i = 0, int j = 0) { x = i; у = j; } 3. В объявлении функции после появления аргумента по умолчанию не должно быть обычных аргументов.
Приложение В. Ответы на вопросы и решения упражнений _ 543 4. Функции нельзя перегружать, если их отличие только в том, что одна полу-чает параметр по значению, а вторая - по ссылке. (Компилятор не в состоя-нии их отличить.) 5. Аргументы по умолчанию лучше использовать тогда, когда можно с уверен-ностью предположить, что при работе приложения одно или более значений будут встречаться чаще других. Аргументы по умолчанию лучше не использо-вать, когда такой уверенности нет. 6. Нет, поскольку нельзя инициализировать динамический массив. В этом классе имеется только один конструктор, которому требуется инициализа-ция. 7. Конструктор копий - это особый конструктор, который вызывается при инициализации одного объекта другим. Такая инициализация имеет место в следующих трех случаях: когда один объект явно используется для инициа-лизации другого, когда объект передается в функцию в качестве параметра, и когда в качестве возвращаемого значения функции создается временный объект. Упражнения 6.2 1. //Перегрузка операторов * и /относительно класса coord ^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord!) { x = 0; y-0; } coord (int i, int j) { x = i; у = j; } void get_xy{int &i, int & j ) { i = x; j = y; } coord operator* (coord ob2); coord operator/(coord ob2); //Перегрузка оператора * относительно класса coord coord coord: : operator* (coord ob2) ( coord temp; temp.x = x * ob2.x; temp. у = у * ob2.y; return temp;
544 _ _ _ Самоучитель C++ 1 1 Перегрузка оператора /относительно класса coord coord coord: : operator/(coord ob2) { coord temp; * temp.x = x /ob2.x; temp. у = у /ob2.y; return temp; int main () coord ol (10, 10), o2(5, 3), o3; int x, y; o3 = ol * o2; o3.get_xy(x, y) ; cout " "(ol * o2) X: " " x " ", Y: " " у " "\n"; o3 = ol /o2; o3.get_xy (x, y) ; cout " "(ol /o2) X: " " x " ", Y: " " у " "\n"; return 0; 2. Так перегружать оператор % нежелательно, поскольку перегруженная версия оператора не связана с его традиционным использованием. 6.3 1. //Перегрузка операторов < и > относительно класса coord #include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord() ( x = 0; y= 0; } coord(int i, int j) { x = i ; у = j; } void get_xy(int Si, int sj) { i = x; j = y; } int operator<(coord ob2); int operator>(coord ob2); }; //Перегрузка оператора < для класса coord int coord::operator<(coord ob2)
Приложение В. Ответы на вопросы и решения упражнений 545 { return х<оЬ2.х && у<оЬ2.у; }//Перегрузка оператора > для класса coord int coord::operator>(coord ob2) { return x>ob2.x && y>ob2.y; }int main() { coord 01(10, 10), o2(5, 3) ; if(ol>o2) cout " "ol > o2\n"; else cout " "ol <= o2\n"; if(ol<o2) cout " "ol < o2\n"; else cout " "ol >= o2\n"; return 0; 6.4 1. //Перегрузка оператора --относительно класса coord ^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord (} { x = 0; y= 0; } coord С int i, int j) { x = i; у = j; } void get_xy(int &i, int &j) { i = x; j = y; } coord operator - (}; //префиксная форма coord operator - (int notused) ; //постфиксная форма }; //Перегрузка префиксной формы оператора - для класса coord coord coord: : operator - () { х--; у- ; return *this; II Перегрузка постфиксной формы оператора --для класса coord coord coord: : operator - (int notused}
546 Самоучитель C++ { x-; у-; return *this; int main ( ) { coord olUO, 10); int x, y; ol - ; //декремент объекта ol.get_xy (x, y) ; cout " " (ol - } X: " " x " ", Y: " " у " "\n"; - ol; //декремент объекта ol.get_xy {x, y) ; cout " "(~ol) X: " " x " ", Y: " " у " "\n"; return 0; 2. //Перегрузка оператора + относительно класса coord ^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord() { x = 0; y= 0; } .coord{int i, int j) { x = i; у = j; } void get_xy(int Si, int Sj) { i = x; j = y; } coord operator+(coord ob2); //бинарный плюс coord operators(); //унарный плюс //Перегрузка бинарного оператора + для класса coord coord coord::operator+(coord ob2) coord temp; temp.x = x + ob2.x; temp.у = у + ob2.y; return temp; II Перегрузка унарного оператора + для класса coord coord coord::operator+О
Приложение В. Ответы на вопросы и решения упражнений 547 i f t x < 0 ) х = -х; if <y<0) у = -у; return *this; int main () coord 01(10, 10), o2{-2, -2); int х, у; 01 = ol + o2; //сложение ol.get_xy (х, у) ; cout " " (ol + o2) X: " " x " ", Y: " " у " "\n"; 02 = -Ю2; //абсолютное значение o2 ,get_xy (х, у) ; cout " "(+o2) X: " " x " ", Y: " " у " "\n"; return 0; 6.5 1. /* Перегрузка операторов - и /относительно класса coord с использованием дружественных функций V^include <iostream> using namespace std; class coord ( int x, у; //значения координат public: coord() { x = 0; y= 0; } coord(int i, int j) { x = i; у = j; } void get_xy(int si, int &j) { i = x; j = y; } friend coord operator-(coord obi, coord ob2); friend coord operator/(coord obi, coord ob2); //Перегрузка оператора - для класса coord //с использованием дружественной функции coord operator-(coord obi, coord ob2) { coord temp; temp.x = obl.x - ob2.x;
548 _ Самоучитель C++ temp. у = obl.y -оЬ2.у; return temp; //Перегрузка оператора /для класса coord //с использованием дружественной функции coord operator/(coord obi, coord ob2) { coord temp; temp.x = obl.x /ob2.x; temp. у = obl.y /ob2.y; return temp; int main ( ) { coord ol (10, 10), o2(5, 3), o3; int x, y; . o3 = ol -o2; o3.get_xy (x, y) ; cout " "(ol ~ o2) X: " " x " ", Y: " " у " "\n"; o3 = ol /o2; o3.get_xy{x, y) ; cout " "(ol /o2) X: " " x " ", Y: " " у " "\n"; return 0; 2. //Перегрузка оператора * для операций ob*int и int*ob #include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord () { x = 0; y= 0; } coord ( int i , int j ) { x = i ; у = j ; } void get_xy(int &i, int &j) { i = x,-j = y; } friend coord operator* {coord obi, int i) ; friend coord operator* (int i, coord ob2) ; }; //Перегрузка оператора * первым способом coord operator* (coord obi, int i)
Приложение В. Ответы на вопросы и решения упражнений coord temp; temp.x = оЫ.х * i; temp. у = оЫ.у * i; return temp; //Перегрузка оператора * вторым способом coord operator* (int i, coord ob2) { coord temp; temp.x = ob2.x * i; temp . у = ob2 .у * i ; return temp; int main{) { coord ol(10, 10} , o2; int x, y; o2 = ol * 2; //ob * int o2.get_xy (x, y} ; cout " "(ol * 2) X: " " x " ", Y: " " у " "\n o2 = 3 * ol; //int * ob o2.get_xy (x, y) ; cout " "(3 * ol) X: " " x " ", Y: " " у " "\n return 0; 3. Благодаря использованию дружественных оператор-функций, стало возмож-ным получить, в качестве левого операнда, встроенный тип данных. При ис-пользовании функций-членов, левый операнд должен быть объектом класса, для которого определяется оператор. 4. /* Перегрузка оператора - относительно класса coord с использованием дружественных функций */^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coordO { x = 0; у = 0; }
550 _ Самоучитель C++ coord (int i, int j) { x = i; у = j; } void get_xyfint Si, int &j) { i = x; j = y; } //префиксная форма friend coord operator - [coord &ob) ; //постфиксная форма friend coord operator - (coord &ob, int notused) ; }; //Перегрузка префиксной формы оператора - для класса coord //с использованием дружественной функции coord operator - (coord &ob) ( ob.x - ; ob.y - ; return ob; //Перегрузка постфиксной формы оператора - для класса coord //с использованием дружественной функции coord operator - (coord &ob, int notused) ( ob.x - ; ob.y - ; return ob; int main() i\ coord ol(10, 10) ; int x, y; - ol ; //декремент объекта ol ol.get_xy (x, y) ; cout " "( - ol) X: " " x " ", Y: " " у " "\n"; ol - ; //декремент объекта ol ol.get_xy (x, y) ; cout " "(ol - ) X: " " x " ", Y: " " у " "\n"; return 0; 6.6 1. ^include <iostream> #include <cstdlib> using namespace std;
Приложение В. Ответы на вопросы и решения упражнений 55? class dynarray { int *p; int size; public: dynarray(int s); int &put(int i); int get(int i); dynarray &operator=(dynarray Sob); //Конструктор dynarray::dynarray(int s) { p = new int[s]; if(!p) { cout " "Ошибка выделения памяти\п exit(l) ; 1 //Запоминание элемента int sdynarray: :put {int i) { if (i<0 I I i>=size) ( cout " "Ошибка нарушения границ массива !\п"; exit(l) ; return p[i] ; //Получение элемента int dynarray: ; get (int i) { if (i<0 | | i>=size) ( cout " "Ошибка нарушения границ массива !\п"; exit(l) ; return p[i] ; 1//Перегрузка оператора = для класса dynarray dynarray fidynarray: :operator= (dynarray &ob) { int i;
552 _ Самоучитель C++ if (size! =ob. size) { cout " "Нельзя копировать массивы разных размеров ! \n"; exit(l); for(i=0; i<size; i++) p[i] = ob.pfi]; return *this; int main () { int i; dynarray obi (10) , ob2{10), ob3(100); obl.put (3) -10; i = obl.get<3) ; cout " i " "\n"; Ob2 = obi; i = ob2.get(3) ; cout " i " "\n"; //Выполнение следующей инструкции ведет к ошибке obi = оЬЗ; //! !! return 0; 6.7 1. ^include <iostream> #include <cstring> ^include <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype(char *s) ; ~strtype{) { cout " "Освобождение памяти по адресу " " (unsigned) p " '\n delete []p; \ char *get() { return p; } strtype &operator=(strtype &ob);
Приложение В. Ответы на вопросы и решения упражнений _ 553_ char &operator[] (int i) ; }; strtype: : strtype {char *s) { int 1; 1 -strlen(s) + 1; p = new char [1] ; if(!p) { cout " "Ошибка выделения памятиХп"; exit(l) ; len = 1; strcpytp, s) ; }(f Присваивание объекта strtype sstrtype: :operator= (strtype sob) t //Выяснение необходимости дополнительной памяти if (len < ob.len) { //требуется выделение //дополнительной памяти delete [] p; p = new char г~г if(!p) f cout ^ши^л" _^" - .... i 11амяти\п"; exit(l); len = ob.len; strcpytp, ob.p); return *this; 1 1 Индексируемые символы в строке char sstrtype: :operator[] (int i) { if (i<0 I [ i>len-l) { cout " "ХпЗначение индекса "; cout " i " " выходит за границы массиваЧп exit(l) ; return p[i]; 1
554 Самоучитель C++ int main() { strtype а("Привет"), b{"Здесь"); cout " a.getO " '\n'; cout " b.getO " '\n'; a = b; //теперь указатель р не перезаписывается cout " a. get {) " Лп1; cout " b.getO " '\n'; //Доступ к символам посредством индексирования массива cout " а[0] " а[1] " а[2] " "\п"; //Присваивание символов посредством индексирования массива а[0] = 'X'; а[1] = 'Y'; а[2] = 'Z'; cout " a.get() " "\п"; return 0; 2. ^include <iostream> ^include <cstdlib> using namespace std; class dynarray { int *p; int size; public: dynarray (int s} ; dynarray &operator= (dynarray sob} ; int soperator [ ] {int i) ; //Конструктор dynarray: : dynarray {int s) { p = new int [s] ; if(!p) ( cout " "Ошибка выделения памятиЛп"; exit(l); size = s;
Приложение В. Ответы на вопросы и решения упражнений _ 555 1.1 Перегрузка оператора = для класса dynarray dynarray sdynarray: :operator= {dynarray sob) { int i; if (size! =ob. size} { cout " "Нельзя копировать массивы разных размеров ! \n" ; exit(l) ; for(i=0; i<size; i++) p[i] = ob.p[i]; return *this; 1//Перегрузка оператора [] int Sdynarray: : operator [] (int i) { if (i<0 | | i>size) { cout " "ХпЗначение индекса "; cout " i " " выходит за границы массива \п"; exit(l) ; }return p[i] ; int main{) { int i ; dynarray obi(10), ob2(10}, ob3(100}; obl[3] = 10; i = obi[3]; cout " i " "\n"; ob2 = obi; i = ob2[3]; cout " i " "\n"; //Выполнение следующей инструкции ведет к ошибке оЫ = оЬЗ; //присваивание массивов разных размеров return 0; Проверка усвоения материала главы 6 1. //Перегрузка операторов " и "
556 _ Самоучитель C++ ^include <iostream> using namespace std; class coord { int x, у; //значения координат public: coord () { x -0; у = 0; } coord (int i, int j) { x = i; у = j; } void get_xy(int si/int &j) { i = x; j = y; ) coord operator" (int i) ; coord operator" (int i); //Перегрузка оператора " coord coord: :operator" (int i) ;\ coord temp; temp.x = x " i; temp. у = у " i; return temp; //Перегрузка оператора " coord coord: : operator" (int i) { coord temp; temp.x = x " i; temp. у = у " i; return temp; int main () { coord ol (4, 4) , o2; int x, y; o2 = ol " 2; //ob " int o2.get_xy (x, y) ; cout " " (ol " 2) X: " " x " ", Y: " " у " "\n"; o2 = ol " 2; //ob " int o2.get_xy (x, y) ; cout " " (ol " 2) X: " " x " ", Y: " " у " "\n"; return 0;
Приложение В. Ответы на вопросы и решения упражнений _ 557 2. tinclude <iostream> using namespace std; class three_d { int x, y, z; public: three_d(int i, int j , int k) { x = i ; y = j ; z = k ; }three__d() { x = 0; у = 0; z = 0; } void getfint &i, int &j, int &k) ( i = x; j = y; k = z; } three_d operator+ (three_d ob2); three_d operator-(three_d ob2) ; three_d operator++ ( ) ; three_d operator - ( ) ; three_d three_d: :operator+ (three_d ob2) 1 three_d temp; temp.x = x + ob2.x; temp. у = у 4-ob2.y; temp.z = z-t-ob2.z; return temp; three_d three_d: roperator-(three_d ob2) { three_d temp; temp.x = x - ob2.x; temp. у = у - ob2.y; temp.z = z - ob2.z; return temp; three_d three_d: :operator++ { X4-+; return *this; }
555 Самоучитель C++ three__d three_d: : operator - ( ) { x - ; у- ; z - ; return *this; } int main() { three_d olUO, 10, 10), o2(2, 3, 4), o3 int x, y, z; o3 = ol + o2; оЗ-get (x, y, z) ; cout " " X: " " x " ", Y: cout " Z: " " z " "\n"; o3 = ol -o2; o3.get(x, y, z) ; cout " " X: " " x " ", Y: cout " Z: " " z " "\n"; " y; " y; ol.get (x, y, z) ; cout " " X: " " x " ", Y: " " y; cout " Z: " " z " "\n"; ol.get(x, y, z); cout " " X: " " x " ", Y: " " y; cout " Z: " " z " "\n"; return 0; 3. #include <iostream> using namespace std; class three_d { int x, y, z; public: three_d(int i, int j, int k) x = i ; y = j ; }three_d() { x = 0
Приложение^ В. Ответы на вопросы и решения упражнений 559 void get (int si, int &j, int &k) i = x; j = y; k = z; three_d operator+{three_d &ob2); three_d operator-{three_d &ob2); friend three_d operator++(three_d &ob) ; friend three_d operator-(three_d Sob); three_d three_d::operator+(three_d &ob2) three_jd temp/-temp.x = x + ob2.x; temp.у = у + ob2.y; temp.z = z + ob2.z; return temp; three_d three_d::operator-(three_d sob2) three_d temp; temp.x = x - ob2.x; temp.у = у - ob2.y; temp.z = z - ob2.z; return temp; three d operator++(three d Sob) return ob; }three_d operator-(three_d &ob} { ob.x-; ob.y-; ob. z -; return ob;
560 _ Самоучитель C++ int ma in (} { three_d ol{10, 10, 10), o2(2, 3, 4), o3; int x, y, z; o3 = ol + o2; o3.get(x, y, z); cout " " X: " " x " ", Y: " " y; cout " Z: " " z " "\n"; 03 = ol -o2; o3.get(x, y, z) ; cout " " X: " " x " ", Y: " " y; cout " Z: " " z " "\n"; ol.get(x, y, z) ; cout " " X: " " x " ", Y: " " y; cout " Z: " " z " "\n"; - ol; ol.getfx, y, z) ; cout " " X: " " x " ", Y: " " y; cout " Z: " " z " "\n"; return 0; 4. Бинарная оператор-функция - член класса получает левый операнд неявно, через указатель this. Дружественная бинарная оператор-функция явно полу-чает оба операнда. У унарной оператор-функции - члена класса нет явно заданных параметров. У дружественной унарной оператор-функции есть один параметр. 5. Перегрузка оператора = может потребоваться, когда применяемого по умол-чанию поразрядного копирования недостаточно. Например, вам может пона-добиться объект, в котором была бы копия только части данных исходного объекта. 6. Нет. 7. ^include <iostream> using namespace std; class three_d { int x, y, z; public: three d(int i, int j, int k)
Приложение В. Ответы на вопросы и решения^упражнений _ 567 { х = i; y= j ; z = k; }three_d() { х = 0; у = 0; z = 0; } void get (int si, int &j, int &k) { i = x; j = y; k = z; } friend three_d operator+ (three_d ob, int 1} ; friend three_d operator^-(int i, three_d ob) ; ); three_d operator+(three_d ob, int i) ( three_d temp; temp.x = ob.x + i; temp. у = ob.y + i; temp. z = ob. z + i; return temp; I three_d operator+ (int i, three_d ob) { three_d temp; temp .x = ob . x + i ; temp . у = ob . у + i ; temp.z = ob.z + i; return temp; int main ( ) i thread ol(10, 10, 10) ; int x, y, z; ol = ol + 10; ol.getfx, y, z) ; cout " " X: " " x " ", Y: " " y; cout " Z: " " z " "\n"; ol = -20 + ol; ol.get (x, y, z) ; cout " " X: " " x " ", Y: " " y; cout " 2,:. " " z " "\n"; return 0;
562 Самоучитель C++ 8. #include <iostream> using namespace std; class three_d ( int x, y, z; public: three_d(int i, int j, int k) { x = i ; у = j ; z = k ; i three_d() ( x = 0; у = 0; z = 0; } void get (int Si, int &j, int 5k) ( i = x; j = y; k = z; } int operator== (three d ob2) ; int operator !=(three_d ob2) ; int operator I I (three_d ob2) ; }; int three_d: : opera tor== (three_d ob2) { return x==ob2.x &s y==ob2 . у && z==ob2.z; }int three_d: :operator!= (three_d ob2) { return x!=ob2.x SS y!=ob2.y s& z!=ob2.z; }int three_d: : operator! I (three_d ob2) { return x||ob2.x SS у I I ob2 . у 5& z||ob2.z; } int main ( ) {, three_d ol(10, 10, 10), o2 (2, 3, 4), o3 (0, 0, 0) if(ol==ol) cout " "ol == ol\n"; if{ol!=o2) cout " "ol !-o2\n"; if(o3||ol) cout " "ol или оЗ равняется истина\п return 0;
Приложение В. Ответы на вопросы и решения упражнений 563 9. Оператор [] обычно перегружается для того, чтобы использовать привычный индексный синтаксис для доступа к элементам инкапсулированного в классе массива. Проверка усвоения материала в целом 1. /* В данной программе для простоты не был реализован контроль ошибок. Однако в реально функционирующем приложении такой контроль обязателен V#include <io5tream> #include <cstring> using namespace std; class strtype ( char s[80]; public: strtypeO { *s -'\0'; } strtype(char *p) { strcpyfs, p); } char *get{) { return s; } strtype operator-t-(strtype s2) ; strtype operator=(strtype s2) ; int operator<(strtype s2); int operator>(strtype s2); int operator=={strtype s2); strtype strtype::operator+(strtype s2) { strtype temp; strcpy (ternp.s, s) ; strcpy(temp.s, s2 .s); return temp; 1strtype strtype::operator=(strtype s2) ( strcpy(s, s2.s); return *this; !int strtype::operator<{strtype s2) { return strcmpfs, s2.s) < 0;
564 СамоучительC++ int strtype::operator>(strtype s2) { return strcmpfs, s2.s) > 0; }int strtype::operator==(strtype s2) , return strcntp(s, s2.s) == 0; }int main () { strtype ol("Привет"), o2(" Здесь"), оЗ; o3 = ol + o2; cout " o3.get() " "\n"; o3 = ol; if(ol==o3) cout " "ol равно o3\n"; if(ol>o2) cout " "ol > o2\n"; if(ol<o2) cout " "ol < o2\n"; return 0; ГЛАВА 7 Повторение пройденного 1. Нет. Перегрузка оператора просто увеличивает количество типов данных, с которыми оператор может работать, но не влияет на его исходные свойства. 2. Да. Не нужно перегружать операторы только для встроенных типов данных C++. 3. Нет, приоритет оператора изменить нельзя. Нет, нельзя изменить и число операндов. 4. ^include <iostream> using namespace std; class array { int nums[10]; public: array {) ;
Приложение В. Ответила вопросы и решения упражнений _ . _ 565 void set (int n[10] ) ; void show () ; array operator-f (array ob2) ; array operator-(array ob2) ; int operator== (array ob2) ; }; array: rarray () { int i ; for(i = 0; i < 10; i++) nums [i] = 0; void array: :set (int *n) { int i; forfi = 0; i < 10; i++) numsfi] = n[i] }void array: : show () { int i; ford = Q; i < 10; cout " nums[i] " ' '; cout " "\n"; }array array: :operator+ (array ob2) { int i; array temp; for(i=0; i<10; i++} temp.nuras[i] = nurns[i] + ob2.nums[i]; return temp; ) array array: : operator-(array ob2) { int i; array temp; for(i=0; i<10; i++) temp.numsfi] = nums[i] -ob2 . nurns [ i ] ; return temp; 1int array: :operator== (array ob2)
566 Самоучитель C++ { int i ; for(i=0; i<10; i++) if(nums[i] != ob2.nums[i]) return 0,-return 1; 1int main!) i\ array ol, o2, o3; int i[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; ol.set (i); o2.set (i); o3 -ol + o2; o3.show(); o3 = ol - o3; o3. show() ; if(ol==o2) cout " "ol равно o2\n"; else cout " "ol не равно о2\п"; if(ol==оЗ} cout " "ol равно o3\n"; else cout " "ol не равно оЗ\п"; .return 0; 5. ^include <iostream> using namespace std; class array { int nums[10]; public: array () ; void set(int n[10]); void show(); friend array operator-*-(array obi, array ob2); friend array operator-(array obi, array ob2); friend int operator==(array obi, array ob2); }; array: :array {) int i;
Приложение В. Ответы на вопросы и решения упражнений _ 567 for(i = 0; i < 10; i++) numsfi] = 0; 1 void array : :set (int *n) t int i; for(i = 0; i < 10; i++) nums[i] = n[i]; I void array: :show() { int i; ford = 0; i < 10; i++) cout " nums[i] " ' '; cout " "\n"; Jarray operator+ (array obi, array ob2) { int i; array temp; for(i=0; i<10; i++) temp.nums[i] = obl.nums[i] + ob2.nums[i]; return temp; } array operator-(array obi, array ob2) { int i; array temp; for(i=0; i<10; i++) temp. nums [i] = obl.nums[i] - ob2 . nums [ i ] ; return temp; 1 int operator== (array obi, array ob2) { int i; for(i=0; i<10; i++) if (obi .nums [i] != ob2.nums[i]J return 0; return 1; } int main{) { array ol, o2, o3;
568 _ _ __ Самоучитель int i[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; ol.set (i) ; o2.set (i) ; o3 -ol + o2; o3 . show ( } ; 03 -ol -o3; o3 . show ( ) ; if (ol==o2) cout " "ol равно o2\n"; else cout " "ol не равно о2\п"; if{ol==o3) cout " "ol равно o3\n"; else cout " "ol не равно оЗ\п"; return 0; 6. ttinclude <iostream> using namespace std; class array { int nums [10] ; public : array ( ) ; void set (int n[10]); void show() ; array operator++ () ; friend array operator - (array Sob) ; }; array: : array () { int i; for(i = 0; i < 10; i++) nums[i] = 0 void array: :set (int *n) { int i; for(i -0; i < 10; i++) nums[i] = n[i] } void array :: show () f int i;
Приложение В, Ответы на допросы и решения упражнений _ 569 for (i = 0; i < 10; i++) cout " nums[i] " ' '; cout " "\n"; //Перегрузка унарного оператора с использованием функции-члена array array: :operator++ f) int i; for{i=0; i<10; i++) nums[i]++; return *this; //Перегрузка унарного оператора //с использоеанием дружественной функции array operator - (array &ob) { int i; for{i=0; i<10; i+-f) ob.nums[i] - ; return ob; }int main() { array ol, o2, o3; int i[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; ol.set (i) ; o2.set(i) ; o3 = 4+o 1 ; o3.show() ; o3 = - ol; o3. show{) ; return 0; 7. Нет. Оператор присваивания может перегружаться только с использованием функции -члена.
570 Самоучитель С++_ Упражнения 7-1 1. Правильными являются инструкции А и С. 2. Когда открытые члены базового класса наследуются как открытые, они ста-новятся открытыми членами производного класса. Когда открытые члены базового класса наследуются как закрытые, они становятся закрытыми чле-нами производного класса. 7.2 1. Когда защищенные члены базового класса наследуются как открытые, они становятся защищенными членами производного класса. Когда защищенные члены базового класса наследуются как закрытые, они становятся закрытыми членами производного класса. 2. Категория защищенности позволяет сохранить закрытость определенных членов базового класса, оставляя, тем не менее, возможность доступа к ним из производного класса. 3. Нет. 7.3 1. ^include <iostream> ^include <cstring> using namespace std; class raybase { char str[aO]; public: mybase(char *s) { strcpy(str, s) char *get() { return str; } class myderived: public mybase { int len; public: myderived{char *s}: mybase(s) { len = strlen(s); int getlenf) { return len; } void show() { cout " get() " '\n'; } };
Приложение В. Ответы на вопросы и решения упражнений _ 571 int main () { myderived ob { "привет "); ob . show ( ) ; cout " ob.getlenf) " '\n'; return 0; 2. #include <iostream> :sing namespace st //Базовый класс для аь-о.мобилей разных типов class vehicle { int num_wheels; int range ; public: vehicle {int w, int r) num_wheels = w; range = r; } void showv ( ) { cout " "Число колес: " " num wheels " '\n' -- cout " "Грузоподъемность: " " range " '\n' class car: public vehicle { int passengers; public: car (int p, int w, int r) : vehicle (w, r) { passengers = p; } void show ( ) ( showv { ) ; cout " "Пассажироемкость : " " passengers " ' \n ' class truck: public vehicle ( int loadlimit; public: truck(int 1, int w, int r) : vehicle (w, r)
572 Самоучитель C++ { loadlimit = 1; void show { ) ( showv ( ) ; cout " "Пробег: " " loadlimit " ' \n ' ; int main () { car c(5, 4, 500) ; truck t (30000, 12, 1200) cout " "Легковушка: \n"; c.show() ; cout " "ХпГрузовик: \n"; t . show ( ) ; return 0; 7.4 1. Работа конструктора А Работа конструктора В Работа конструктора С Работа деструктора С Работа деструктора В Работа деструктора А 2. ^include <io5tream> using namespace std; class A { int i ; public: A (int a) { i -a; } class В { int j ; public: B{int a) { j = a; }
Приложение В. Ответы на вопросы и решения упражнений 573 class С: public A, public В { int k; public: C{int с, int b, int a ) : A ( a ) , B(b) { k = c; 7.5 2. Виртуальный базовый класс нужен тогда, когда производный класс наследует два (или более) класса, каждый из которых сам унаследовал один и тот же базовый класс. Без виртуального базового класса в последнем производном классе существовало бы две (или более) копии общего базового класса. Од-нако благодаря тому, что исходный базовый класс делается виртуальным, в последнем производном классе представлена только одна копия базового. Проверка усвоения материала главы 7 1. ttinclude <iostream> using namespace std; class building { protected; int floors; int rooms; double footage; class house: public building { int bedrooms; int bathrooms; public: house {int f, int r, double ft, int br, int bth) { floors = f; rooms = r; footage = ft; bedrooms = br; bathrooms = bth; } void show ( ) { cout " "этажей: " " floors " ' \ n ' ; cout " "комнат: " " rooms " '\n'; cout " "метраж: " " footage " ' \ n ' ; cout " "спален: " " bedrooms " ' \n ' ; cout " "ванн: " " bathrooms " '\n';
574 _ _ _ __ _ __ Самоучитель C++ class office: public building { int phones; int extinguishers; public : office (int f, int r, double ft, int p, int ext) ( floors = f; rooms = r; footage = ft; phones = p; extinguishers = ext; } void showO ( cout " "этажей: " " floors " '\n'; cout " "комнат: " " rooms " '\n'; cout " "метраж: " " footage " ' \n' ; cout " "телефонов: " " phones " '\n'; cout ": "огнетушителей: " " extinguishers " '\n'; int rnainO I house h_ob(2, 12, 5000, 6, 4); office o_ob(4, 25, 12000, 30, 8) ; cout " "Жилой дом: \п"; h_ob . show ( ) ; cout " "ХпОфис: \n"; o_ob.show() ; return 0; 2. Если базовый класс наследуется как открытый, открытые члены базового класса становятся открытыми членами производного класса, а закрытые чле-ны базового класса остаются закрытыми. Если базовый класс наследуется как закрытый, все члены базового класса становятся закрытыми членами производного. 3. Члены, объявленные как защищенные (protected), являются закрытыми чле-нами базового класса, но могут наследоваться (и к ним можно иметь доступ) любым производным классом. При наследовании со спецификатором досту-па protected все открытые и защищенные члены базового класса становятся защищенными членами производного класса. 4. Конструкторы вызываются в порядке наследования. Деструкторы - в обрат-ном порядке. 5. ^include <iostream> using namespace std;
Приложение В. Ответь! на вопросы и решения упражнений __ 575 class planet ( protected: double distance; //расстояние в милях от Солнца int revolve; //полный оборот в днях public: planet (double d, int r) { distance = d; revolve = r; } class earth: public planet ( double circumference; //окружность орбиты public : earth (double d, int r) : planet (d, r) { circumference = 2 * distance * 3.1416; } void show() ( cout " "Расстояние от Солнца: " " distance " '\n'; cout " "Полный оборот в днях : " " revolve " ' \n ' ; cout " "Окружность орбиты: " " circumference " '\n' int main() { earth ob (93000000, 365); ob . show ( ) ; return 0; 6. Для того чтобы программа стала верной, классы motorized и road_use должны наследовать базовый класс vehicle как виртуальный. Проверка усвоения материала в целом 1. Некоторые компиляторы не допускают использования инструкции switch во встраиваемых функциях. Такие функции автоматически трактуются компиля-тором как "обычные" функции. 2. Оператор присваивания является единственным оператором, который не на-следуется. Причину этого понять легко. Поскольку в производном классе появятся члены, которых нет в базовом, то при перегрузке оператора = отно-сительно базового класса в базовом классе ничего не будет известно о чле-нах, появившихся в производном классе, и поэтому невозможно правильно копировать эти новые члены.
5/6 _ Самоучитель C++ ГЛАВА 8 Повторение пройденного 1. ^include <iostrearn> using namespace std; class airship { , protected: int passegers; : double cargo; class airplane: public airship { char engine; //p для винтового, j для реактивного double range; public: airplane (int p, double c, char e, double r} { passegers = p; cargo = c; engine = e; range = r; } void show ( ) ; 11 class balloon: public airship { char gas; //h для водорода, е для гелия double altitude; public: -balloon (int p, double c, char g, double a) i passegers = p; cargo = c; gas = g; altitude = a; } void show f ) ; void airplane: : show () { cout " "Пассажировместимость : " " passegers " '\n'; cout " "Грузоподъемность : " " cargo " ' \n' ; cout " "Двигатель: ";
Приложение В, Ответы на вопросы и решения упражнений if (engine=='p' ) cout " "Винтовой\п"; else cout " "Реактивный\п"; cout " "Дальность: " " range " '\n'; void balloon: : show () { cout " "Пассажире вместимость : " " passegers " '\n' cout " "Грузоподъемность: " " cargo " '\n'; cout " "Наполнитель : " ; if(gas=='hM cout " "Водород\п"; else cout " "Гелий\п"; cout " "Потолок: " " altitude " '\n'; } int. ma in () { balloon Ь (2, 500.0, 'h1, 12000.0); airplane b727 (100, 40000.0, 'j', 40000.0); b. show() ; cout " ' \ n ' ; b727.show() ; return 0; 2. Спецификатор доступа protected оставляет члены базового класса закрытыми, но при этом позволяет получить к ним доступ из любого производного класса. 3. Выводимый на экран результат работы программы иллюстрирует очередность вызова конструкторов и деструкторов. Работа конструктора А Работа конструктора В Работа конструктора С Работа деструктора С Работа деструктора В Работа деструктора А 4. Порядок вызова конструкторов - ABC, порядок вызова деструкторов - СВА. 5. #include <iostream> using namespace std; class base { int i, j; public: base (int к, int y) {i = x; j = y; }
575 _ -^___ __ Самоучитель C++ void showij (} { cout " i " ' ' " j " '\n'; } class derived: public base { int k; public : derived(int a, int b, int c) : base(b, c) ( k = a; } void showO { cout " k " ' '; showij {); } hint main{) { derived ob(l, 2, 3) ; ob. show{) ; return 0; 6. Пропущены слова "общего" и "специальным". Упражнения " 8.2 1. Hnclude <iostream> using namespace std; ' int main() < cout .setf (ios: : showpos) ; cout " -10 " ' ' " 10 " r\n'; return 0; } 2. ^include <iostream> using namespace std; int main{) { cout. setf {ios: : showpoint | ios: : uppercase [ ios: : scientific) ; cout " 100.0;
приложение В. Ответы на вопросы и решения упражнений 579 return 0; 3. ^include <iostream> using namespace std; int main() { ios::fmtflags f; f = cout.flags(); //сохранение флагов cout.unsetf(ios::dec); cout,setf(ios::showbase | ios::hex); cout " 100 " '\n'; cout-flags(f); //возврат флагов в исходное состояние return 0; 8.3 1. /* Создание таблицы натуральных и десятичных логарифмов чисел от 2 до 100 */tfinclude <iostream> ^include <cmath> using namespace std; int main () double x; cout,precision(5) ; cout " "x Ig x In x\n\n"; for(x = 2.0; x <= 100.0; x++) { cout.width(10); cout " x " " "; cout.widthUO)/cout " loglOCx) " " "; cout.width(10); cout " log(x) " "\n"; return 0; }
580 Сзмоучитель^:++ 2. ^include <iostream> ttinclude <cstring> using namespace std; void center(char *s); int mainf) center("Это здесь!"); .center("Мне нравится C++."); return 0; void center(char *s) { int len; len = 40 + (strlen(s}/2); cout.width(len); cout " з " "\n"; 8.4 la.//Таблица натуральных и десятичных логарифмов чисел от 2 до 100 ^include <iostream> ^include <iomanip> ftinclude <cmath> using namespace std; int main() double x; cout " setprecision(S); cout " "x Ig x In x\n\n"; for(x = 2.0; x <= 100.0; x++} { cout " setw(10} " x " " "; cout " setw(lO) " loglO(x) " " "; cout " setw(10} " log(x) " "\n"; return 0; lb.^include <iostream> ^include <iomanip>
Приложение В. Ответы на вопросы и решения упражнений 581 ^include <cstring> using namespace std; void center(char *s); int main() t center("Это здесь!"); centsг("Мне нравится C++."); return 0; void centerfchar *s) int len; len = 40 + (strlen(s)/2); cout " setw(len) " s " "\n"; } 2. cout " setiosflags(ios:ishowbase I ios::hex) " 100; 3. Установка флага boolalpha для потока вывода приводит к тому, что значения булева типа выводятся на экран в виде слова trae или false. Установка флага boolalpha для потока ввода позволяет вводить значения булева типа с помо-щью слова trae или false. 8.5 1. ^include <iostream> #include <cstring> #include <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype(char *ptr); -strtype() (delete [] p; } friend ostream soperator"(ostream &stream, strtype &ob); strtype::strtype(char *ptr) len = strlen(ptr) + 1;
582 _ ___ _ Самоучитель C++ р = new char [len]; i f ( ! p > ( cout " "Ошибка выделения памятиХп"; exit(l); }strcpy(p, ptr} ; ostream &operator" {ostream &stream, strtype &ob) { stream " ob.p; return stream; int main() { strtype si ("Это проверка"), з2("Мне нравится C++"}; cout " si; cout " endl " s2 " endl; return 0; 2. Hnclude <iostream> using namespace std; class planet { protected: double distance; //расстояние в милях от Солнца int revolve; //полный оборот в днях public : planet {double d, int r) { distance = d; revolve = r; ) class earth: public planet { double circumference; //окружность орбиты public: earth(double d, int r) : planetfd, r) ( circumference = 2 * distance * 3.1416; 1friend ostream &operator" (ostream sstream, earth sob) ; }; ostream &operator" (ostream ^stream, earth Sob) { stream " "Расстояние от Солнца: " " ob. distance " '\n';
Приложение В, Ответы на вопросы и решения упражнений _ 533 stream " "Оборот вокруг Солнца: " " ob. revolve " '\п'; stream " "Окружность орбиты: " " ob. circumference; stream " ' \n' ; return stream; int main() ( earth ob(93000000, 365); cout " ob; return 0; 3. Пользовательская функция вывода не может быть функцией-членом потому, что объект, который вызывает функцию, не является объектом определен-ного пользователем класса. 8.6 1. tfinclude <iostream> ttinclude <cstring> ^include <cstdlib> using namespace std; class strtype { char *p; int len; public: strtype(char *ptr); -strtype 0 { delete [] p; } friend ostream &operator" [ostream sstream, strtype &ob) friend istream soperator"(istream fistream, strtype &ob) }; strtype::strtype(char *ptr) { len = strlen(ptr)+l; p = new char [len]; if(!p) { cout " "Ошибка выделения памяти\п"; exit(1); strcpy(p, ptr);
584 Самоучитель C++ ostream &operator" (ostream sstream, strtype sob) stream " ob.p; return stream; istream ^operator" (istream sstream, strtype sob) { char temp[255J; stream " temp; if(strlen(temp) >= ob.len) { delete И ob.p; ob.len = strlen(temp) + 1; ob.p = new char [ob.len]; if(!ob.p) { cout " "Ошибка выделения памяти\п"; exit(1); } 1 strcpy(ob.p, temp); return stream; } int main () f strtype si("Это проверка"), з2("Мне нравится C++") cout " si; cout " '\n' " s2; cout " "ХпВведите строку: "; cin " si; cout " si; return 0; 2. ^include <iostream> using namespace std; class factor j int num; //число int Ifact; //наименьший делитель public: factor (int i);
Приложение В. Ответы на вопросы и решения упражнений 555 friend ostream &operator" (ostream ustream, factor ob) ; friend istream ^operator" (istream ustream, factor &ob) ; factor: : factor (int i) { int n; nura = i; for(n=2; if {! (i%n) } break; if (n"i/2) ) Ifact = n; else Ifact = 1; }istream ^operator" (istream sstream, factor Sob) { stream " ob.num; int n; for{n=2; n<(ob.num/2) ; n+4} if ( ! (ob.nurnfcn) ) break; if (n<(ob.num/2) ) ob. Ifact = n; else ob. Ifact = 1; return stream; I ostream fioperator" (ostream Sstream, factor ob} { stream " ob. Ifact " " Это наименьший делитель числа " stream " ob.num " '\n'; return stream; } int main ( ) { factor o(32) ; cout " o; cin " o; cout " o; return 0;
586 Самоучитель C++ Проверка усвоения материала главы 8 1. tinclude <iostraam> using namespace std; int main() { cout " 100 " ' ' ; cout.unsetf (ios: :dec) ; //сброс флага dec cout.setf {ios: :hex) ; cout " 100 " ' ' ; cout ,unsetf( ios: : hex) ; //сброс флага hex cout.setf (ios: :oct) ; cout " 100 " '\n'; return 0; 2. ^include <iostream> using namespace std; int main ( ) I" cout.setf (ios: :left) ; cout.precision(2) ; cout. fill ('*'}, : cout.width(20) ; cout " 1000.5354 " '\nr; return 0; За. #include <iostream> using namespace std; int main() { cout " 100 " ' '; cout " hex " 100 " ' '; cout " oct " 100 " '\n'; return 0;
Приложение В. Ответы на вопросы и решения упражнений _ 587 3b. #include <iostream> ^include <iomanip> using namespace std; int main() ( cout " setiosflags (ios: :left) ; cout " setprecision (2) ; cout " setfilK1*1} ; cout " setw(20) ; cout " 1000.5354 " '\n'; return 0; 4. ios: : fmtf lags f; f = cout. flags (); //сохранение cout. flags ( ) ; //отображение 5. ttinc" ->stream> us? . HU!: : "-ас std; Lt exponent; double result; //результат возведения в степень public: pwr(int b, int e); friend ostream &operator"(ostream sstream, pwr ob); friend istream fioperator" (istream fistream, pwr &ob) }; pwr::pwr(int b, int e) { base = b; exponent = e; result = 1; for{; e; e -) result = result * base; }ostream &operator"(ostream Sstream, pwr ob) ! stream " ob.base " " в степени " " ob.exponent; stream " " равно " " ob.result " '\n';
588 Самоучитель C++ return stream; "istream ^operator" (istream sstrearn, pwr sob) ( int b, e; 'cout " "Введите основание и показатель степени: stream " fa " e; -. pwr temp(b, e) ; ob = temp; return stream; }int main ( ) < pwr ob(10, 2) ; cout " ob; cin " ob; cout " ob; return 0; ,6. //Эта программа рисует квадраты #include <iostream> using namespace std; class box { int len; public: box(int 1) { len -1; } friend ostream &operator" (ostream ^stream, box ob) ; //рисование квадрата ostream &operator" (ostream &stream, box ob) int i, j; for{i=0; i<ob.len; i++) stream " '*'; stream " '\n'; for(i=0; i<ob.len-2; i++) { stream " '* ' ; for(j=0; j<ob.len-2; j++) stream " ' ';
Приложение В. Ответы на вопросы и решения упражнений 589 stream " "*\п"; 1for{i=0; i<ob.len; i++) stream " '*'; stream " ' \n'; return stream; } int main() { box Ы{4), Ь2(7) ; cout " Ы " endl " b2; return 0; Проверка усвоения материала в целом 1. ^include <iostream> using namespace std; ^define SIZE 10 //Объявление класса stack для символов class stack { char stck[SIZE]; //содержит стек int tos; //индекс вершины стека public: stack () ; void push (char ch) ; //помещает в стек символ char pop(); //выталкивает из стека символ friend ostream &operator" (ostream sstream, stack ob) ; }; //Инициализация стека stack: : stack () { tos=0; //Помещение символа в стек void stack: :push(char ch) { if (tos==SIZE) ( cout " "Стек полон"; return;
-590 _ _ _ Самоучитель C++ stck[tos]=ch/tos-н-; }//Выталкивание символа из стека char stack:: pop () { if (tos==0) { cout " "Стек пуст"; return 0; //возврат нуля при пустом стеке }tOS--; return stck[tos]; }ostream &operator" (ostream Sstream, stack ob) { char ch; while (ch=ob.pop() } stream " ch; stream " endl; return stream; int main () { stack s; s.pushf 'a') ; s . push ( ' b ' ) ; s.push ( 'c' ) ; cout " s; cout " s; return 0; 2. ^include <iostream> ^include <ctime> using namespace std; class watch { time_t t; public: watch {} ( t = time (NULL); } friend ostream &operator" {ostream Sstream, watch ob) ;
Приложение В, Ответы на вопросы и решения упражнений 597 ostream &operator" (ostream &stream, watch ob) { struct tin *localt; localt -localtime(sob.t); stream " asctime(localt) " endl; return stream; }int main () t watch w; cout " w; return 0; 3. #include <iostream> using namespace std; class ft_to_inches { double feet; double inches; public: void set (double f} { feet = f; inches = f * 12; } friend istream soperator" (istrearn sstrearn, ft_to_inches Sob); friend ostream &operator"(ostream fistream, ft_to_inches ob); }; istream separator"{istream fistream, ft_to_inches iob) 1 double f; cout " "Введите число футов: "; stream " f; ob.set(f); return stream; 1ostream &operator" (ostream Sstrearn, ft_to_inches ob) t stream " ob.feet " " футов равно " " ob.inches; stream " " дюймам\п";
592 Самоучитель C++ return stream; int main{) ft_to__inches x; cin " x; cout " x; return 0; ГЛАВА 9 Повторение пройденного 1. ^include <iostream> using namespace std; int main () { cout.width(40); cout. fillC : ') ; cout " "C++ прекрасен" " '\n'; return 0; 2. #iriclude <iostream> using namespace std; int main() { cout.precision(4}; cout " 10.0/3.0 " '\np; return 0; I 3. #include <iostream> ^include <iomanip> using namespace std; int main() { cout " setprecision(4) " 10.0/3.0 " '\n';
Приложение В. Ответы на вопросы и решения упражнений _ 593 return 0; 4. Пользовательская функция вывода - это перегруженная оператор-функция operator"(), которая передает данные класса в поток вывода. Пользователь-ская функция ввода - это перегруженная оператор-функция operator"(), которая принимает данные класса из потока ввода. 5. ^include <iostream> using namespace std; class date { char d[9]; //дата хранится в виде строки: mm/dd/yy public: friend ostream &operator" (ostream sstream, date ob) ; friend istream ^operator" (istreara sstream, date &ob) ; }; ostream &operator" (ostream sstream, date ob) { stream " ob.d " '\n'; return stream; istream ^operator" (istream fistream, date fiob) { cout " "Введите дату (mm/dd/yy) : "; stream " ob.d; return stream; int mainO { date ob; cin " ob; cout " ob; return 0; 6. Для использования манипуляторов с параметрами необходимо включить в программу заголовок <iomanip>. 7. Встроенными потоками являются потоки: cin cout cere clog
594 Самоучитель C++ Упражнения 9.1 1. //Представление времени и даты ^include <iostream> tinclude <ctime> using namespace std; //Манипулятор вывода времени и даты ostreara &td(ostream &stream) { struct tm *localt; time_t t; t = time(NULL); localt = localtime(St); stream "asctime (localt) " endl; return stream; }int main{) { cout " td " '\n'; return 0; 2. ^include <iostream> using namespace std; //Установка шестнадцатеричного вывода с символом X //в верхнем регистре ostrearn &sethex (ostream Sstream) i stream.unsetf(ios::dec | ios::oct); stream.setf(ios::hex I ios::uppercase | ios::showbase); return stream; }//Сброс флагов ostream sreset(ostream fistream) { stream, unsetf (ios : :hex I ' -"-: : uppercase I ios: : showbase) ; stream.setf(ios::dec); return stream; }
Приложение В. Ответы на вопросы и решений упражнений 595 int main () { cout " sethex " 100 " '\n'; cout " reset " 100 " '\n'; return 0; 3. ^include <iostream> using namespace std; //Пропуск 10 символов istream sskipchar(istream "stream) int i; char c; for{i=0; i<10; i++) stream " c; return stream; int main() char atr[80]; cout " "Введите несколько символов: "; cin " skipchar " str; cout " str " '\n'; return 0; }9.2 1. //Копирование файла и вывод числа скопированных символов ttinclude <iostream> ^include <fstream> using namespace std; int main{int argc, char *argv[ ]) t if(argc!=3) { cout " "Копирование <файл_ввода> <файл_вьшода>\п"; return 1; }ifstream fin{argv[l]); //открытие файла для ввода ofstream fout(argv[2]); //создание файла для вывода
596 _ __ Самоучитель C++ i f ( ! f i n ) ( cout " "Файл для ввода открыть невозможно\п"; return 1; }if (! fout) { cout " "Файл для вывода открыть невозможной"; return 1; >char ch; unsigned count = 0; fin.unsetf (ios: :skipws) ; //не пропускать пробелы while (Ifin.eof 0 ) { fin " ch; if (Ifin.eof () ) { fout " ch; count++; cout " "Число скопированных байтов: " " count " '\n'; fin. closed ; fout .close {) ; return 0; Результат, выводимый этой программой, может отличаться от того, который выводится в каталоге, поскольку некоторые символы могут интерпретиро-ваться иначе. Уточним, когда считывается последовательность возврат ка-ретки/перевод строки, она преобразуется в символ новой строки. При выводе новая строка считается одним символом, но опять преобразуется в последо-вательность символов возврат каретки/перевод строки. 2. ^include <iostream> #include <fstream> using namespace std; int main (} { of stream pout ("phone") ; ifUpout) { cout " "Файл PHONE открыть невозможной"; return 1;
Приложение В. Ответы на вопросы и решения упражнений 597 pout " "Иссак Ньютон, 415 555-3423\п"; pout " "Роберт Годдард, 213 555-2312\п"; pout " "Энрико Ферми, 202 555-1111\п"; pout.close(); return 0; 3. //Подсчет числа слов ^include <iostream> ^include <fstream> ^include <cctype> using namespace std; int main (int argc, char *argv[]) { if(argc!=2) { cout " "Подсчет слов: <файл_ввода>\п return 1; ifstream in(argv[ 1 ]); cout " "Файл ввода открыть невозможно\п" return 1 ; int count = 0; char ch; in " ch; //нахождение первого символа - не пробела //Теперь пробелы пропускать нельзя in.unsetf (ios: iskipws) ; //не пропускать пробелы while ( ! in.eof {) ) ( in " ch; if (isspace (ch) ) ( count++; while {isspace (ch) && ! in.eof (}) in " ch; cout " "Число слов : " " count " ' \n ' ; in. close {}; return 0;
598 __ Самоучитель C++ (Если между словами имеется более одного пробела, то общее число слов подсчитывается программой неправильно. Кроме этого необходимо, чтобы последним символом в файле был пробел. - Примеч. пер.) 4. Функция is_open возвращает истину, если вызывающий поток связан с от-крытым файлом. 9.3 1а. //Копирование файла и вывод числа скопированных символов # include <iostream> ^include <fstream> using namespace std; int rnain(int argc, char *argv[]) if(argc!=3) { cout " "Копирование: <файл_ввода> <файл__вывода>\п"; return 1; } ifstream fin(argv[l], ios::in I ios : :binary) ; //открытие //файла ввода ofstrearn fout (argv[2] , ios::out | ios : :binary) ; //создание //файла вывода if{!fin) ( cout " "Файл ввода открыть невозможно \n"; return 1; "iff! fout) { cout " "Файл вывода открыть невозможной"; return 1; char ch; unsigned count = 0; while (Ifin.eof (} ) ( fin. get (ch) ; if ( Ifin.eof {) } fout. put (ch) ; count++; cout " "Число скопированных байтов: " " count " '\n'; fin. closed ; fout .close () ;
Приложение В. Ответы на вопросы и решения упражнений _ _ 599 return 0; 1 lb. //Подсчет числа слов #include <iostream> #include <fstream> ^include <cctype> using namespace std; int main (int argc, char *argv[]) { if (argc!=2) { cout " "Подсчет: <файл_авода>\п"; return 1; )if stream in{argv[l] , ios: :in | ios : : binary) ; if('in) { cout " "Файл ввода открыть невозможно \п"; return 1; }int count - 0; char ch; //нахождение первого символа - не пробела do {in. get (ch) ; } while (isspace (ch) } ; while ( lin.eof (} } { in. get (ch) ; if (isspace (ch) ) { count ++; //Поиск следующего слова while (isspace (ch) && lin.eof () ) in. get (ch) ; cout " "Число слов: " " count " '\n'; in. close () ; return 0; 2. //Вывод содержимого класса account в файл с помощью //пользовательской функции вывода ^include <iostream>
600 _ __ __ _ _ Самоучитель C++ ^include <fstream> ^include <cstring> using namespace std; class account { int custnum; char name[80] ; double balance; public : account (int c, char *n, double b) { custnum = c; strcpy(name, n) ; balance = b; }friend ostream &operator" (ostream sstream, account ob) ; >' ostream &operator" {ostream Sstream, account ob) t stream " ob. custnum " ' '; stream " ob.name " ' ' " ob. balance; stream " '\n' ; return stream; int main ( ) { account RexflOll, "Ralph Rex", 12323.34); ofstream out ("accounts", ios::out I ios: :binary) ; if (lout) f cout " "Файл вывода открыть невозможной" return 1; } : out " Rex; out .close {) ; return 0; 9.4 1. //Использование функции get() для считывания строки с пробелами ^include <iostream> ^include <fstream> using namespace std;
Приложение В. Ответы на вопросы и решения упражнений 601 int main() char str [80]; cout " "Введите Ваше имя: "; cin.get (str, 79); cout " str " '\n'; return 0; Программа работает одинаково, независимо от того, какая функция исполь-зуется - get() или getlineO 2. //Использование функции getlineO для вывода файла на экран ttinclude <iostream> ^include <fstream> using namespace std; int main(int argc, char *argv[]) { if{argc!=2) { cout " "Считывание: <имя__файла>\п"; return 1; ifstreara in(argv[l]); cout " "Файл ввода открыть невозможной"; return 1; char str[255]; while(lin.eof()) { in.getline(str, 254); cout " str " '\n'; J in.closeO ; return 0; I9.5 1. //Вывод содержимого файла на экран в обратном порядке ^include <iostream> ^include <fstream> using namespace std;
602 _ _ __ _ _ Самоучитель C++ int main(int argc, char *argv[]) { if(argc!=2) { cout " "Реверс: <имя_файла>\п"; return 1; }if stream in (argv [ 1 ] , ios : : in I ios : : binary) ; if(!in) { cout " "Файл ввода открыть невозможно \п"; return 1; char ch; long i; //переход в конец файла (до символа eof) in.seekg(0, ios::end); i = (long) in.tellgO; //выяснение количества байтов в файле i -=s 9 : 4-£, f for(; i>=0; i~) { in.seekg(i, ios::beg); in.get(ch); cout <<; ch; in. close {) ; return 0; 2. //Перестановка местами символов в файле ^include <iostream> ttinclude <fstream> using namespace std; int main(int argc, char *argv[]) { if(argc!=2) { cout " "Перестановка: <имя_файла>\п"; return 1; //Открытие файла для ввода/вывода f stream io(argv[ 1 ] , ios; :in 1 ios : :out | ios: : binary) ; cout " "Файл открыть невозможно\п";
Приложение В. Ответы на вопросы и решения упражнений 603 return 1; } char chl, ch2; long i; for(i=0; !io.eof(); i+=2) { io.seekg (i, ios::beg); io.get(chl); if(io.eof()) continue; io.get(ch2); if(io.eof()) continue; io.seekg(i, ios::beg); io.put(ch2); io.put(chl); }io.close (}; return 0; 9.6 la./* Вывод содержимого файла на экран в обратном порядке с контролем ошибок */^include <iostream> ^include <fstream> using namespace std; int main(int argc, char *argv[]) { if (argc!=2) ( cout " "Реверс: <имя_файла>\п"; return 1 ; if stream in (argv [ 1 ] , ios : : in | ios : : binary) ; if(!in) f cout " "Файл ввода открыть невозможно \п" ; return 1 ; char ch; long i; //Переход в конец файла (до символа eof) in. seekg(0, ios: :end) ;
604 _ Самоучитель C++ if { !in.good() } return 1; i = (long) in.tellgO; //выяснение количества байтов в файле if ( ! in. good О ) return 1; i -= 2; for(; i>=0; i - } { in.seekg (i, ios : :beg) ; if ( ! in. good () ) return 1; in. get (chj ; if { ! in. good {) ) return 1; cout " ch; in. close () ; if ( ! in. good{) } return 1; return 0; 1Ь. //Перестановка местами символов в файле с контролем ошибок ftinclude <iostream> ^include <fstream> using namespace std; int main(int argc, char *argv[]) { . if (argc!=2) { cout " "Перестановка: <имя_файла>\п"; return 1 ; //Открытие файла для ввода/вывода f stream io (argv [ 1 ] , ios : : in | ios : : out i ios : : binary) ; if(!io) { cout " "Файл открыть невозможно\п"; return 1; char chl, ch2; long i; for(i=0; !io.eof(); i+=2) { io.seekg (i, ios: :beg) ; if ( !io.good(} ) return 1; io.get (chl) ; if (io.eof () ) continue; io.get (ch2) ; if ( ! io. good ( ) ) return 1;
Приложение В. Ответы на вопросы и решения упражнений _ 605 if (io.eof {) ) continue; io.seekg (i, ios: :beg) ; if ( !io.good() ) return 1; io.put (ch2) ; if { ! io. good () } return 1; io.put (chl) ; if ( lio.goodf) ) return 1; io. close () ; if ( ! io.good () ) return 1; return 0; Проверка усвоения материала главы 9 1. ^include <iostream> using namespace std; ostream Stabs(ostream &stream) { stream " '\t' " '\t' " f\t'; stream.width(20); return stream; int main () cout " tabs " "ПроверкаХп"; return 0; 2. ^include <iostream> ^include <cctype> using namespace std; istream Sfindalpha(istream sstream) char ch; do {stream.get(ch); } while{Jisalpha(ch)); return stream; }
606 Самоучитель C++ int main{) char str[80]; cin " findalpha " str; cout " str " "\n"; return 0; ! 3. //Копирование файла и смена регистра букв ^include <iostream> ^include <fstream> ^include <cctype> using namespace std; int main(int argc, char *argv[]) { char ch; if(argc!=3) { cout " "Копирование <источник> <целевой_файл>\п"; return 1; ifstream in{argv[l] ) ; if(!in> { cout " "Файл ввода открыть невозможно\п"; return 1 ; } ofstream out (argv[2] ) ; if (lout) { cout " "Файл вывода открыть невозможно\п"; return 1; while ( !in. eof {)) { ch = in . get ( ) ; if (iin.eof () ) { if (islower {ch) ) ch = toupper(ch); else ch = tolower(ch); out. put (ch) ; in. close () ; out. close () ;
Приложение^. Ответы на вопросы и решения упражнений 607 return 0; 4. //Подсчет букв ttinclude <iostream> ^include <fstream> ^include <cctype> using namespace std; int alpha [26]; int main (int argc, char *argv[]) { char ch; if(argc!=2) { cout " "Подсчет: <имл_файла>\п"; return 1; }ifstream in(argv[l]); if(!in) { cout " "Файл ввода открыть невозможноЧп"; return 1; }//Инициализация массива alpha [] int i ; for(i=0; i<26; i++) alpha [i] = 0; while ( ! in.eof {) ) { ch = in. get () ; if (isalpha (ch) ) { //если найдена буква, считаем ее ch = toupper (ch) ; alpha[ch -'A']++; //'A' -'A1 == 0, //'B' -'A' == 1, и т. д. //Вывод на экран результата for (i-0; i<26; i++) { cout " (char) ('A' -(-i) " ": " " alpha [i] " '\n' in. close () ; return 0;
608 _ Самоучитель 5а. //Копирование файла и смена регистра букв с контролем ошибок ^include <iostrearn> ^include <fstreara> linclude <cctype> using namespace std; int main(int argc, char *argv[]) { char ch; if(argc!=3) { cout " "Копирование <откуда> <куда>\п"; return 1; ifstream in {argv [1] ) ; if С ! in) { cout " "Файл ввода открыть невозможной"; return 1; of stream out {argv [2] ) ; if (lout) { cout " " Файл вывода открыть невозможной" return 1; while ( lin.eof () ) ( ch = in. get ( ) ; if ( ! in. good (} && lin.eof ()) return 1 if (lin.eof 0) { if (islower (ch) ) ch = toupper(ch) else ch = tolower(ch); out .put (ch) ; if ( lout. good ( ) ) return 1; in.close(); out.close(); if (!in.good{) S5 lout.good()) return 1 return 0; 5Ь.//Подсчет букв с контролем ошибок ttinclude <iostream> ^include <fstream>
Приложение В. Ответы на вопросы и решения упражнений 609^ #include <cctype> , using namespace std; int alpha [26]; int mainfint argc, char *argv[]) char ch; if(argc!=2) { cout " "Подсчет: <имя_файла>\п"; return 1; 1 ifstream in(argv[l]); cout " "Файл ввода открыть невозможной"; return 1; //Инициализация массива alpha[] 'int i; for(i=0; i<26; i++) alpha[i] = 0; while(lin.eof()) { ch = in.get(); if(!in.good() s& lin.eof ()) return 1; if(isalpha(ch)) { //если найдена буква, подсчитаем ее ch = toupper(ch); alpha[ch -'A']++; //'A1 -'A' == 0, //'B' -'A' == 1, и т. д. }; //Вывод на экран результата for(i=0; i<26; i-м-) { cout " (char) ('A' + i) " ": " " alpha[i] " '\n'; 1in. close () ; if(!in.good()) return 1; return 0; 6. Для установки указателя чтения (get) используется функция seekg(). Для ус тановки указателя записи (put) используется функция seekp().
610 Самоучитель C++ Проверка усвоения материала в целом 1. ^include <iostream> ^include <fstream> ^include <cstring> using namespace std; ftdefine SIZE 40 class inventory { char item[SIZE]; //название предмета int onhand; //количество экземпляров, выданных на руки double cost; //цена экземпляра public: inventory(char *i, int o, double c) { strcpy(item, i); onhand = o; cost -c; } void store(fstream sstream); void retrieve(fstream &stream}; friend ostream &operator" (ostream ustrearn, inventory ob); friend istream &operator" (istream fistream, inventory Sob); }; ostream &operator" (ostream Sstream, inventory ob) { stream " ob.item " ": " " ob.onhand; stream " " $" " ob.cost " '\n'; return stream; )istream ^operator" (istream Sstream, inventory &ob) { .cout " "Введите название предмета: "; stream " ob.item; cout " "Введите число выданньос экземпляров: "; stream " ob.onhand; cout " "Введите стоимость экземпляра: "; stream " ob.cost; return stream; } void inventory::store(fstream Sstream) { stream.write(item, SIZE);
Приложение В. Ответы на вопросы и решения упражнений _ 61 1 stream. write ( (char *) sonhand, sizeof (int) ) ; stream. write ( (char *) ficost, sizeof (double) ) ; void inventory::retrieve(fstream sstream) stream, read(item, SIZE); stream.read((char *) fionhand, sizeof(int)); stream.read((char *) ficost, sizeof(double)); ) int mainf) fstream invC'inv", ios::out I ios: :binary) ; int i; inventory pliers("плоскогубцы", 12, 4.95); inventory hammers("молотки", 5, 9.45); inventory wrenches{"ключи", 22, 13.90); inventory tempC'", 0, 0.0); if(!inv} { cout " "Файл для вывода открыть невозможно\п"; return 1; //Запись в файл pliers.store(inv); hammers.store(inv); wrenches.store(inv); inv. close {) ; //Открытие файла для ввода inv.open("inv", ios::in I ios::binary); if(!inv) { cout " "Файл для ввода открыть невозможной"; return 1; do {cout " "Запись # (для выхода введите -1) : "; cin " i; if(i == -1) break; inv.seekg{i* (SIZE-t-sizeof (int) -fsizeof (double) ) , ios: :beg) ; temp. retrieve (inv) ; cout " temp; } while (inv. good {) ) ;
612 Самоучитель C++ inv.close (); return 0; ГЛАВА 10 Повторение пройденного 1. ^include <iostream> using namespace std; ostream fisetsci (ostream fistream) { stream. set f (ios: : scientific I ios: : uppercase) ; return stream; )int main ( ) { double f = 123.23; cout " setsci " f; cout " '\n'; return 0; 2. //Копирование файла и преобразование табуляций в пробелы ^include <iostreara> ^include <fstream> using namespace std; int mainiint argc, char *argv[]} { if(argc!=3) { cout " "Копирование: <ввод> <вывод>\п"; return 1; ifstream in(argv[l]}; if(!in) { cout " "Файл ввода открыть невозможной"; return 1;
Приложение В. Ответы на вопросы и решения упражнений _ 613 ofstreara out (argv[2j ) ; if ( l o u t ) { cout " "Файл вывода открыть невоэможно\п" ; return 1 ; char ch.; int i = 8; while ( ! in. eof (} ) { in. get (ch) ; if(ch=='\t') for{; i>0; i --) out.putC ' else out. put {ch}; if (i==-l j I ch=='\n') i = 8; i - ; in. close ( ) ; out .close {} return 0; 3. //Поиск слова в файле ^include <iostream> #include <fstrearn> ^include <cstring> using namespace std; int mainlint argc, char *argv[]} { if (argc!=3) { cout " "Поиск: <файл> <слово>\п return 1 ; ifstream in(argv[l]); ifUin) { cout " "Файл ввода открыть невозможно \п"; return 1; char str[255] ; int count = 0; while (! in. eof (} ) i in " str; if ( !strcmp(str, argv[2])) count++;
614 _ Самоучитель C++ cout " argv[2] " " найдено " " count; cout " " раз. \п"; in. close () ; return 0; 4. Искомой инструкцией является следующая: out.seekp (234, ios: :beg) ; 5. Такими функциями являются rdstate(), good(), eof(), fail() и bad(). 6. Ввод/вывод C++ обеспечивает возможность работы с создаваемыми вами классами. Упражнения 10.2 1. ^include <iostream> using namespace std; class num { public: int i; num(int x) {i = x; } virtual void shownumO ( cout " i " '\n'; } class outhex: public num { public: outhex (int n) : num{n) {} void shownumO ( cout " hex " i " ' \ n ' ; } class outoct: public num { public: outoct(int n) : num(n) { } void shownumO { cout " oct " i " '\n'; } int main() { outoct o(10) ; outhex h(20}; o. shownumO ; h . shownum ( } ;
Приложение В. Ответы на вопросы и решения упражнений _ 6/5 return 0; 2. # include <iostream> using namespace std; class dist { public: double d; dist (double f) {d -f; } virtual void trav_time{} 1 cout " "Время движения со скоростью 60 миль/час:"; cout " d /60 " '\n'; class metric: public dist { public: metric(double f ) : dist(f) {} void trav_time() { cout " "Время движения со скоростью 100 км/час:"; cout " d /100 " '\n'; int main() { dist *p, mph(88.0) ; metric kph(88) ; p = &mph; p -> trav__time ( ) ; p = &kph; p -> trav_time (} ; return 0; 10.3 2. По определению в абстрактном классе содержится, по крайней мере, одна чистая виртуальная функция. Это означает, что в классе отсутствует тело этой функции. Таким образом, создание объекта абстрактного класса невоз-можно, поскольку определение класса неполно.
616 Самоучитель C++ 3. При вызове функции funcQ относительно класса derivedl используется функ-ция ftincO из класса base. Так происходит потому, что виртуальные функции имеют иерархическую структуру. 10.4 1. //Демонстрация возможностей виртуальных функций #include <iostream> # include <cstdlib> using namespace std; class list { public: list *head; //указатель на начало списка list *tail; //указатель на конец списка list *next; //указатель на следующий элемент списка int num; //число для хранения list () { head = tail = next = NULL; } virtual void store (int i) = 0; virtual int retrieve () = 0; //Создание списка типа очередь class queue: public list { public: void store (int i) ; int retrieve (} ; void queue: : store (int i) { list *itern; item = new queue; if (! item) { cout " "Ошибка выделения памяти\п"; exit(l) ; }item -> num = i; //Добавление элемента в конец списка if (tail) tail -> next = item; tail = item; item -> next = NULL; iff! head) head = tail;
Приложение В. Ответы на вопросы и решения упражнений _ 617 int queue: : retrieve () { int i; list *p; if (! head) { cout " "Список пуст\п"; return 0; i//Удаление элемента из начала списка i = head -> num; p = head; head = head -> next; delete p; return i; //Создание списка типа стек class stack: public list { public: void store (int i); int retrieve (} ; }; void stack: : store (int i) I list *item; item = new stack; if (! item) { cout " "Ошибка выделения памяти\п exit ( 1 ) ; i: item -> num = i; //Внесение элемента в начало списка if (head) item -> next = head; head = item; if ('tail) tail = head; I int stack : : retrieve ( ) { int i; list *p; if (! head) { cout " "Список пуст\п";
618 _ Самоучитель C++ return 0; //Удаление элемента из начала списка i = head -> пшп; р = head; head = head -> next; delete p; return i; 1//Создание отсортированного списка class sorted: public list { public: void store (int i) ; int retrieve () ; }; void sorted: : store (int i) f list *item; list *p, *p2; item = new sorted; if (! item) { cout " "Ошибка выделения памяти\п"; exit(l); }item -> nura = i; //Поиск места внесения следующего элемента списка р = head; р2 = NULL; while (р) { //идем в середину if (p->num > i) { item -> next = p; if(p2) p2 -> next = item; //не первый элемент if (p==head) head = item; //новый первый элемент break; 1 p2 = p; p = p -> next; }if{!p) { //идем в конец if (tail) tail -> next = item; tail = item; item -> next = NULL;
Приложение В. Ответы^ на вопросы и решения упражнений _ 6/9 if(!head) //первый элемент head = item; int sorted: :retrieve() { int i; list *p; if(lhead) { cout " "Список пуст\п"; return 0; //Удаление элемента из начала списка i = head -> num; p = head; head = head -> next; delete p; return i; int main() ( list *p; //Демонстрация очереди queue q ob; p -£q_obi-; ////указывает на очередь p -> store (1} ; p -> store (2) ; p -> store (3} ; cout ": "Очередь: "; cout " p -> retrieve ( ) ; cout " p -> retrieve C); cout " p -> retrieve (); cout " '\n'; //Демонстрация стека stack s_ob; p = &s_ob; //указывает на стек p -> store (1) ; p -> store (2) ; p -> store (3) ; cout " "Стек: "; cout " p -> retrieve (};
620 _ . __ Самоучитель C++ cout " р -> retrieve!); cout " р -> retrieved; cout " '\n' ; //Демонстрация отсортированного списка sorted sorted_ob; p = &sorted_ob; p -> store (4) ; p -> store (1) ; p -> store (3) ; p -> store (9) ; p -> store (5) ; cout " "Отсортированный список : " ; cout " p -> retrieved; cout " p -> retrieved; cout " p -> retrieved; cout " p -> retrieved; cout " p -> retrieved; cout " '\n'; return 0; Проверка усвоения материала главы 10 1. Виртуальная функция - это функция, обязательно являющаяся членом клас-са, объявляемая в базовом классе и переопределяемая в производном от ба-зового классе. Процесс переопределения называют подменой (overriding). 2. Виртуальными не могут быть функции, не являющиеся членами класса, а также конструкторы. 3. Виртуальные функции поддерживают динамический полиморфизм путем использования указателей базового класса. Если указатель базового класса указывает на объект производного класса, содержащего виртуальную функ-цию, то выбор конкретной версии вызываемой функции определяется типом объекта, на который он указывает. 4. Чистая виртуальная функция - это функция, у которой нет определения в базовом классе. 5. Абстрактный класс - это базовый класс, в котором содержится по крайней мере, одна чистая виртуальная функция. Полиморфный класс - это класс, в котором содержится, по крайней мере, одна виртуальная функция. 6. Этот фрагмент неправилен, поскольку переопределение виртуальной функ-ции должно обеспечивать тот же тип возвращаемого значения, тот же тип
Приложение В. Ответы на вопросы и решения упражнений 621 параметров и то же их количество, что и исходная функция. В данном слу-чае, переопределенная функция f() отличается числом своих параметров. 7. Да. Проверка усвоения материала в целом 1. //Демонстрация возможностей виртуальных функций ^include <iostream> #include <cstdlib> using namespace std; class list ( public: list *head; //указатель на начало списка list *tail; //указатель на конец списка list *next; //указатель на следующий элемент списка int num; //число для хранения list () ( head = tail = next = NULL; } virtual void store(int i) = 0; virtual int retrieved = 0; //Создание списка типа очередь class queue: public list ( public: void store(int i) ; int retrieve d; queue operator+(int i) { store (i); return *this; } int operator -(int unused) { return retrieved; } }: void queue::store(int i) list *item; item = new queue; if (!item) { cout " "Ошибка выделения памяти\п"; exit(l); item -> num = i; //Добавление элемента в конец списка if(tail) tail -> next = item; tail = item; item -> next = NULL; if('head) head = tail;
622 _ _ _ Самоучитель C++ int queue : : retrieve ( ) { int i ; list *p; if (! head) { cout " "Список луст\п"; return 0; //Удаление элемента иэ начала списка i = head -> num; р = head; head = head -> next; delete p; return i; //Создание списка типа стек class stack: public list { public: void store{int i) ; int retrieve ( ) ; stack operator^-(int i) { store(i); return *this; } int operator - {int unused) { return retrieved; } void stack: :store (int i) { list *item; item = new stack; if (! item) { cout " "Ошибка выделения памяти\п"; exit (1) ; }item -> num = i; //Добавление элемента в начало списка if (head) item -> next = head; head = item; iff! tail) tail -head; int stack: : retrieve (} { int i; list *p;
Приложение В. Ответы на вопросы и решения упражнений 623 if (!head) { cout " "Список пуст\п"; return 0; //Удаление элемента из начала списка i = head -> num; р = head; head = head -> next; delete p; return i; int main() { //Демонстрация очереди queue q_ob; q__ob + 1; q_ob + 2; q_ob + 3; cout " "Очередь : " ; cout " q_ob - ; cout " q_ob - ; cout " q_ob - ; cout " r\n' ; //Демонстрация стека stack s_ob; s_ob + 1; s_ob + 2; s_ob 4 3; cout " "Стек: "; cout " s_ob - ; cout " s_ob - ; cout " s_ob - ; cout " '\n' ; return 0; 1 2. Отличие виртуальных функций от перегружаемых в том, что перегружаемые функции должны отличаться либо числом, либо типом своих параметров. Подменяемая виртуальная функция должна иметь точно такой же прототип (поэтому такой же тип возвращаемого значения, такой же тип параметров и то же их число), как и исходная функция.
624 Самоучитель C++ ГЛАВА 11 Повторение пройденного 1. Виртуальная функция - это функция, которая в базовом классе объявляется с ключевым словом virtual и затем в производном классе подменяется другой функцией. 2. Чистая виртуальная функция - это функция, которая в базовом классе не имеет определения функции. Это означает, что функция обязательно должна подменяться соответствующей ей функцией в производном классе..Базовый класс, который содержит, по крайней мере, одну чистую виртуальную функ-цию, называется абстрактным. 3. Динамический полиморфизм достигается посредством использования вирту-альных функций и указателей базового класса. 4. Если в производном классе отсутствует подмена не чистой виртуальной функции, то производный класс будет использовать версию виртуальной функции из базового класса. 5. Главным преимуществом динамического полиморфизма является гибкость. Главным его недостатком является некоторое снижение быстродействия. Упражнения 11.1 2. tinclude <iostream> using namespace std; template <class X> X min(X a, X b) { if(a<=b) return a; else return b; }int main() { cout " min(12.2, 2.0); cout " endl; cout " min(3, 4); cout " endl; cout " min('c', 'a'); return 0;
Приложение В. Ответы на вопросы и решения упражнений _ 625 3. # include <iostreara> ^include <cstring> using namespace std; template <class X> int find(X object, X *list, int size) { int i; for(i=0; i<size; i if (object == listfi]} return i; return -i; int main{) int a[]=U, 2, 3, 4}; char *с="это проверка"; double d[]-{l.l, 2.2, 3.3}; cout " find(3, a, 4); cout " endl; cout " find('a', c, (int) strlen(c)); cout " endl; cout " find(0.0, d, 3); return 0; 4. Ценность родовых функций в том, что они позволяют определить общий алгоритм, который можно применить к разным типам данных. (Следо-вательно, не нужно явно задавать конкретные версии алгоритма.) Кроме этого, родовые функции помогают реализовать основную идею программи-рования на C++, а именно "один интерфейс - множество методов". 11.2 2. //Создание родовой очереди ^include <iostream> using namespace std; tfdefine SIZE 100 template <class Qtype> class q_type ( Qtype queue[SIZE]; //содержит очередь int head, tail; //индекс вершины и хвоста очереди public: q_type() { head = tail =0; } void q(Qtype num); //помещает объект в очередь
626 Самоучитель C++ Qtype deq{}; //извлекает объект из очереди }; //Размещение значения в очередь template <class Qtype> void q_type<Qtype>::q(Qtype num) { if (tail+l==head || (tail+l==SIZE && Ihead)) { cout " "Очередь полна\п"; return; } tail-H-; if {tail==SIZE) tail = 0; //замыкание цикла queue[tail] = num; }//Удаление значения из очереди template <class Qtype> Qtype q_type<Qtype>::deq () { if {head == tail) { cout " "Очередь пуста"; return 0; //очередь пуста или какая-то иная ошибка } head++; if(head==SIZE) head = 0; //замыкание цикла return queue[head]; } int main{) { q_type<int> ql; q_type<char> q2; int i; for(i=l; i ql.q(i); for(i=l; i cout " "Первая очередь " " ql.deqO " "\n cout " "Вторая очередь " " q2.deq() " "\n } return 0; 3. ^include <iostream> using namespace std;
Приложение В. Ответы на вопросы и решения упражнений _ 627 template <class X> class input { X data; public: input (char *s, X man, X max); template <class X> input <X> :: input (char *s, X min, X max) { do {cout " s " "; "; cin " data; } while (data<min [| data>max) ; }int main{) { input<int> 1("ввод целых", О, 10); input<char> с("ввод символов", 'A', 'Z'}; return 0; 11.3 2. Инструкция throw вызывается еще до того, как управление передано в блок try. 3. Вызывается символьная исключительная ситуация, а инструкция catch пред-назначена только для обработки исключительной ситуации типа указатель на символ. (То есть для обработки символьной исключительной ситуации нет соответствующей инструкции catch.) 4. Если возбуждается исключительная ситуация, для которой не задано соот-ветствующей инструкции catch, то вызывается функция terminate(), что мо-жет привести к аварийному завершению программы. 11.4 2. Для инструкции throw нет соответствующей инструкции catch. 3. Одним из способов решить проблему является создание обработчика catcb(int). Другой способ - это перехватывать все исключительные ситуации с помощью обработчика catch(...). 4. Все типы исключительных ситуаций перехватываются инструкцией catch(,..). 5. ^include <iostream> ^include <cstdlib> using namespace std;
628double divide (double a, double b) { try {if(!b) throw (b); }catch (double) { cout " "На ноль делить нельзя\п"; exitU); }return a/b; int mainO cout " divide(10.0, 2.5) " endl; cout " divide(10.0, 0.0); return 0; 11.5 1. По умолчанию оператор new возбуждает исключительную ситуацию при по-явлении ошибки выделения памяти. Оператор new(nothrow) при невозможно-сти выделить память возвращает нулевой указатель. 2. р = new(nothrow) (int); if(!p) (cout " "Ошибка выделения памяти\п"; try {р = new int; } catch (bad alloc ba} { ™- cout " "Ошибка выделения памяти\п"; Проверка усвоения материала главы 1 1 1. ^include <iostream> ^include <cstring> using namespace std; //Родовая функция для поиска //наиболее часто встречающегося значения template <class X> X mode(X *data, int size)
Приложение В. Ответы на вопросы и решения упражнений 629 register int t, w; X md, oldmd; int count, oldcount; oldmd = 0; oldcount = 0; for(t=0; t<size; t++) { md=data [ t ] ; count = 1; for(w = t+1; w < size; w+-l-) if (md==data [w] ) count++ if {count > oldcount) { oldmd = md; oldcount = count; return oldmd; int main () { int i[] = {1, 2, 3, 4, 2, 3, 2, 2, 1, 5}; char *p = "Это проверка"; cout " "Значение для массива целых: " " rnode(i, 10) " endl cout " "Значение для массива символов: " " mode (p, (int) strlen (p) ) ; return 0; 2. ^include <iostream> using namespace std; template <class X> X sum(X *data, int size) I int i; X result = 0; for{i=0; i<size; i++) result += data[i]; return result; 1int main ( ) int i[] -{1, 2, 3, 4}; double d[] = {1.1, 2.2, 3.3, 4.4};
630 _ _ _ Самоучитель C++ cout " surn{i, 4) " endl; cout " sum(d, 4) " endl; return 0; 3. ^include <iostream> using namespace std; //Родовой класс для пузырьковой сортировки template <class X> void bubble (X *data, int size) { register int a, b; X t; for{a=l; a<size; for (b=size-l; b>=a; b - ) if(data[b-l] > data[b]) t = data[b-l] ; data[b-l] = data[b] data[b] = t; int main{) int i[] = {3, 2, 5, 6, 1, 8, 9, 3, 6, 9); double d[] = {1.2, 5.5, 2.2, 3.3}; int j ; bubble{i, 10); //сортировка данных типа int bubble (d, 4); //сортировка данных типа double for(j=0; j<10; j++) cout " i[j] " cout " endl; for(j=0; j<4; j++) cout " d[j] " ' cout " endl; return 0; 4. //Здесь показан родовой стек для хранения пар значений ^include <iostream> using namespace std; ttdefine SIZE 10 . //Создание родового класса для стека template <class StackType> class stack {
Приложение В. Ответы на вопросы и решения упражнений _ 63? StackType stckfSIZE] [2] ; //содержит стек int tos; //индекс вершины стека public : void init() { tos =0;} void push (StackType ob, StackType ob2) ; StackType pop (StackType &ob2); I; //Размещение объектов в стеке template <class StackType> void stack<StackType>: : push (StackType ob, StackType ob2) I if (tos==SIZE) ( cout " "Стек полон\п"; return; >stck[tos] [0] = ob; stck[tos] [1] = ob2; tos++; //Выталкивание объектов из стека template <class StackType> StackType stack<StackType>: : pop (StackType &ob2) ( if (tos- 0) ( cout " "Стек пуст\п"; return 0; //возврат нуля при пустом стеке I tos - ; ob2 = stck[tos] [1]; return stck[tosj [0] ; }int main () { //Демонстрация символьных стеков stack<char> si, s2; //создание двух стеков int i ; char ch; //Инициализация стеков sl.initO ; s2.init() ; s 1 . push ( ' a ' , ' b ' ) ; s2.push('xr, rzr ) ; sl.pusht'b', 'd') ;
632 _ ____ _ Самоучитель C++ s2.push( ' у ' , 'е') ; sl.push{'c', 'a' ) ; s2.push('z', 'x'); for(i=0; i<3; i++) f cout " "Из стека 1:" " sl.pop(ch); cout " ' ' " ch " "\n"; }for{i=0; i<3; i-n-J { cout " "Из стека 2:" " s2.pop(ch); cout " ' ' " ch " "\n"; }//Демонстрация стеков со значениями типа double stack<double> dsl, ds2; //создание двух стеков double d; //Инициализация стеков dsl.init () ; ds2.init() ; dsl.pushfl.l, 2.0); ds2.push{2.2, 3.0); dsl.push(3.3, 4.0); ds2.push(4.4, 5.0); dsl. push (5. 5, 6.0) ; ds2.push(6.6, 7.0); for(i=0; i<3 cout " "Из стека 1:" " dsl. pop (d); cout " ' ' " d " "\n"; for(i=0; cout " "Из стека 2:" " ds2.pop(d); cout " ' ' " d " "\n"; return 0; } 5. Ниже представлены обычные формы инструкций try, catch и throw: try {//блок try throw искл_ситуация catch (type arg) { //.
Приложение В. Ответы на вопросы и решения упражнений _ 633 6. /* В этой программе показан родовой класс stack, в который встроена обработка исключительных ситуаций */ttinclude <iostream> using namespace std; ^define SIZE 10 //Создание родового класса stack template <class StackType> class stack ( StackType stck[SIZE]; //содержит стек int tos; //индекс вершины стека public: void init() { tos = 0;} //инициализация стека void push (StackType ch) ; //помещает объект в стек StackType pop О; //выталкивает объект из стека //Размещение объекта в стеке template <class StackType> void stack<StackType>: :push(StackType ob) { try {if (tos=SIZE) throw SIZE; } catch (int) { cout " "Стек полон\п"; return; } stck[tos] = ob; tos++; //Выталкивание объекта из стека template <class StackType> StackType stack<StackType>: :pop() { try {if (tos==0) throw 0; i catch (int) { cout " "Стек пуст\п"; return 0; //возврат нуля при пустом стеке )tos - ; return stckftos];
634 Самоучитель С++ int main() { //Демонстрация символьных стеков stack<char> si, s2; //создание двух стеков int i; //Инициализация стеков sl.initO ; s2.init()j si.push('a') s 2 . p u s h ( ' x ' J sl.pushCb1 ) s 2 . p u s h ( ' y ' ) si.push('c1 ) s2.push{'z') i++) cout " "Из стека 1:" " sl.popO " "\n"; cout " "Из стека 2:" " s2.pop(J " "\n"; for(i=0; i<3 for{i=0; i<4 //Демонстрация стеков со значениями типа double stack<double> dsl, ds2; //создание двух стеков //Инициализация стеков dsl.initO ; ds2.init () ; dsl.push(1.1); ds2.push(2.2); dsl.push(3.3); ds2.push(4.4); dsl.push(5.5}; ds2.push(6.6); for(i=0; i<3; i++) cout " "Из стека 1:" " dsl.pop(J " "\n for(i=0; i<4; i++) cout " "Из стека 2:" " ds2.pop() " "\n return 0; 8. Если при ошибке выделения памяти оператор new возбуждает исключитель-ную ситуацию, вы можете быть уверены, что эта ошибка будет обработана тем или иным способом (даже путем аварийного завершения программы). И наоборот, если при ошибке выделения памяти оператор new возвращает ну-левой указатель, а вы забыли организовать контроль этого возвращаемого значения, то такая ошибка может остаться незамеченной и в конечном итоге при попытке использования нулевого указателя привести к краху программы, причем будет чрезвычайно трудно обнаружить причину этого.
Приложение В. Ответы ' на 'вопросы и решения упражнений _ 635 ГЛАВА 12 Повторение пройденного 1. В C++ родовая функция определяет общий набор операций для данных раз-ных типов. Она реализуется с помощью ключевого слова template. Ниже представлена основная форма родовой функции: template <class Ttype> возвр_значвнив имя_фуихцкх(сп_параметров) 2. В C++ родовой класс определяет все операции класса, но действительные данные задаются в качестве параметра при создании объекта этого класса. Ниже представлена основная форма родового класса: template <class Ttype> class имя_класса 3. ^include <iostream> using namespace std; //Возвращает значение а в степени b template <class X> X gexp{X a, X b) { X i, result = 1; for(i=0; i<b; i++) result *= a; return result; }int main() {cout " gexp(2, 3) " endl; cout " gexpUO.O, 2.0); return 0; 4. ttinclude <iostreara> ttinclude <fstream> using namespace std;
636 Самоучитель C++ template <class CoordType> class coord ( CoordType x, y; public: coord(CoordType i, CoordType j ) { x = i; у = j; } void show() { cout " x " ", " " у " endl; } int main() { coord<int> old, 2), o2{3, 4); : ol.show() ; o2.show(}; coord<double> o3{0.0, 0.23), o4(10.19, 3.098); o3.show(); o4.show(); return 0; 1 5. Совместная работа инструкций try, catch и throw происходит следующим об-разом. Поместите все инструкции, для которых вы хотите обеспечить кон-троль исключительных ситуаций, внутри блока try. При возникновении ис-ключительной ситуации она возбуждается с помощью инструкции throw и за-тем обрабатывается с помощью соответствующей инструкции catch. 6. Нет. 7. Вызов функции terminate() происходит в том случае, если исключительная ситуация возбуждается той инструкцией throw, для которой нет соответст-вующей инструкции catch. Вызов функции unexpected() происходит в том случае, если исключительная ситуация не указана в списке типов инструк-ции throw. 8. catch(...) Упражнения 12.1 1. Динамическая идентификация типа необходима потому, что в C++ при ком-пиляции программы не всегда есть возмозможность выяснить, на объект ка-кого типа указывает указатель базового класса или ссылается ссылка базо-вого класса. 2. Если класс BaseClass перестает быть полиморфным классом, на экране мы увидим следующее:
Приложение В. Ответы на вопросы и решения упражнений 637 Тип переменной i - это int Указатель р указывает на объект типа BaseClass Указатель р указывает на объект типа BaseClass Указатель р указывает на объект типа BaseClass 3. Да. 4. if(typeid{*p) == typeid(D2)) ... 5. Истинным. Несмотря на то, что здесь используется один и тот же класс-шаблон, тип данных в каждой из версий различен. 12.2 1. Оператор dynamic_cast позволяет проверить правильность выполнения опе-рации приведения полиморфных типов. 2. ^include <iostreara> #include <typeinfo> using namespace std; class В { virtual void f() {} }; class Dl: public В ( void f() {} >; class D2: public В { void f(J {} }; int main { ) ( В *р; D2 Ob; p = dynamic_cast<D2 *> (sob); if{p) cout " "Приведение типов прошло успешно"; else cout " "Приведение типов не произошло"; return 0; 3. int main О { int i ; ; Shape *p;
638 Самоучитель С+->-for(i=0; i p = generator!); //получение следующего объекта cout " typeid(*p) .name ( ) " endl; //объект изображается на экране только в том случае, //если это не объект типа NullShape if {!dynamic_cast<Null3hape *> (p) ) p->example () ; jreturn 0; 4. Нет. Указатели Вр и Dp указывают на объекты совершенно разных типов, 12.3 1, Новые операторы приведения типов обеспечивают более безопасные и по-нятные способы выполнения операции приведения типов. 2. ^include <iostream> using namespace std; void f (const double Si) { double sv = const_cast<double s> (i) ; v = 100.0; }int main() { double x -98.6; cout " x " endl; fix); cout " x " endl; return 0; 3. Поскольку оператор const_cast лишает объекты атрибута const, его исполь-зование может привести к неожиданной и нежелательной модификации объектов.
Приложение В. Ответы на вопросы и решения упражнений 639 Проверка усвоения материала главы 12 1. Оператор typeid возвращает ссылку на объект класса type_Jnfo, содержащего информацию о типе, 2. Для использования оператора typeid в программу необходимо включить заго-ловок <typeinfo>. 3. Ниже представлены новые операторы приведения типов. Оператор Назначение dynamic_cast Выполняет операцию приведения полиморфных типов reinterpret_cast Преобразует указатель на один тип в указатель на другой тип static_cast Выполняет операцию "обычного" приведения типов const_cast Лишает объекты атрибута const 4. #include <iostream> # include <typeinfo> using namespace std; class A { virtual void f{) {} 1; class B: public A { 1; class C: public В { int main ( ) { A *p, a__ob; В b_ob; С c_ob; int i; cout " "Введите О для объектов типа А, " cout " "1 для объектов типа В или"; cout " "2 для объектов типа С.\п"; cin " i; if (i==l) p = fib_ob; else if(i==2) p = ic_ob; else p = &a_ob;
640 Самоучитель C++ if(typeid(*p) == typeid(A) cout " "Объект А"; if (typeidt*p) == typeid(B} cout " "Объект В"; if(typeid(*p) == typeid(C) cout " "Объект С"; return 0; 5. Оператор typeid можно заменить оператором dynamic_cast в ситуациях, когда оператор typeid используется для проверки правильности выполнения опера-ции приведения полиморфных типов. 6. Оператор typeid возвращает ссылку на объект типа type_info. Проверка усвоения материала в целом 1. Здесь представлена версия функции genera tor(), в которой для контроля за выделением памяти используется механизм обработки исключительных ситуаций. /* Использование механизма обработки исключительных ситуаций для отслеживания ошибок выделения памяти VShape *generator() try {switch{rand{) % 4) { case 0: return new Line; case 1: return new Rectangle; case 2: return new Triangle; case 3: return new NullShape; catch (bad_alloc ba) { return NULL; }return NULL; 2. Ниже представлена версия функции generator(), в которой используется опе-ратор new(nothrow).
Приложение В. Ответы на вопросы и решения упражнений 641 //Использование оператора new(nothrow) Shape *generator() I Shape *temp; switch(rand() % 4) { case 0: return new(nothrow) Line; case 1: return new(nothrow) Rectangle; case 2: return new(nothrow) Triangle; case 3: return new(nothrow) NullShape; if(temp) return temp; else return NULL; J ГЛАВА 13 Повторение пройденного 1. Помимо обычных для языка С операторов приведения типов, в C++ под-держиваются дополнительные операторы, которые перечислены ниже: Оператор Назначение dynamic_cast Выполняет операцию приведения полиморфных типов reinterpret_cast Преобразует указатель на один тип в указатель на другой тип static_cast Выполняет операцию "обычного" приведения типов const_cast Лишает объекты атрибута const 2. Класс type_info - это класс, который инкапсулирует информацию о типе данных. Ссылка на объект типа typejmfo является возвращаемым значением оператора typeid. 3. С помощью оператора typeid. 4. if(typeid(Derived) == typeid(p*)) cout " "Указатель р указывает на объект класса Derived\n"; else cout " "Указатель р указывает на объект класса Base\n";
642 Самоучитель C++ 5. Пропущено слово "производного". 6. Нет. Упражнения 13-1 1. /* Программа превращения пробелов в вертикальные линии | без использования инструкции "using namespace std" */^include <iostream> linclude <fstream> int main(int argc, char *argv[]) * if(argc!=3) { std::cout " "Преобразование <файл_ввода> <файл_вывода>Хп"; return 1; 1std::ifstream fin(argv[l]); //открытие файла для ввода std::ofstream fout(argv[2]); //создание файла для вывода if(!fout) { std::cout " "Файл открыть невозможноХп"; return 1; if(!fin) { std::cout " "Файл открыть невозможноХп"; return 1; char ch; fin.unsetf{std::ios::skipws); //не пропускать пробелы while{!fin.eof(}) { fin " ch; if (ch-1 '} ch = ' | '; if(Ifin.eof()) fout " ch; 1fin.close(); fout.close(); return 0;
Приложение В. Ответы на вопросы и решения упражнений 643 2. Безымянное пространство имен ограничивает область видимости идентифи-каторов тем файлом, в котором они объявлены. 3. Представленная ниже форма инструкции using вводит в текущее пространст-во имен только указанный в инструкции член: using имя_пространства;:член; Следующая форма инструкции using делает видимым все пространство имен: using namespace кмя_пространстаа; 4. Поскольку вся стандартная библиотека C++, включая потоки cin и cout, объ-явлена в пространстве имен std, для совместимости большинство программ нужно вводить в пространство имен std. Это дает возможность использовать в программах имена стандартной библиотеки C++ непосредственно, без уточнения, к какому пространству имен они принадлежат. Для большинства программ альтернативой была бы необходимость задания всех ссылок на имена стандартной библиотеки с инструкцией std::. Другой альтернативой являются инструкции using только для потоков, т. е. using std::cin и using std::cout. 5. Размещая код библиотеки в собственном пространстве имен, вы снижаете вероятность возникновения конфликтов имен. 13.2 1. //Преобразование строки в целое ^include <iostreara> #include <cstring> using namespace std; class strtype { char str[80]; int len; public: strtype(char *s) { strcpy(str, s); len = strlen(s); } operator char *() { return str; } operator int() { return len; } int main () strtype s("Функции преобразования весьма удобны"); char *p; int 1; 1 = s; //преобразование строки s в целое - длину строки р = s; //преобразование строки s
644 _ __ Самоучитель C++ //в char * - указатель на строку cout " "Строка: \п"; cout " р " "\пимеет длину " " 1 " " символов . \п" ; return 0; J 2. ^include <iostream> using namespace std; int p(int base, int exp) ; class pwr ( int base; int exp; public: pwr (int b, int e) { base = b; exp = e; } operator int() f return p(base, exp}; } //Возвращает основание base в степени exp int p(int base, int exp) ' int temp; for(temp=l; exp; exp - ) temp = temp * base; return temp; int main() pwr ol(2, 3), o2(3, 3); int result; result = ol; cout " result " '\n'; result = o2; cout " result " '\n'; //объекты можно указывать непосредственно в инструкции cout, //как это сделано здесь cout " ol + 100 " '\n'; return 0; }13.3 1. //Пример разделения ресурса с трассировкой работы #include <iostream>
Приложение _R Ответы на вопросы и решения упражнений _ 645 ^include <cstring> using namespace std; class output { static char outbuf [255] ; //это разделяемый ресурс static int inuse; //если переменная inuse равна О, //буфер доступен; иначе он занят static int oindex; //индекс буфера char str[80] ; int i; //индекс следующего символа в str int who; //идентификатор объекта, должен быть положительным public : output{int w, char *s) ( strcpy(str, s) ; i = 0; who = w; } /* Эта функция возвращает -1 при ожидании освобождения буфера, она возвращает 0 при завершении вывода, и она возвращает who, если буфер все еще используется */int putbuf ( ) { if(!str[i]) { //вывод закончен inuse =0; //освобождение буфера return 0; //сигнал завершения }if (! inuse) inuse = who; //захват буфера if(inuse != who) ( cout " "Процесс" " who " "сейчас блокирован \п"; return -1; //буфер использует кто-то еще }if (str [i]) { //символы все еще выводятся outbuf [oindex] = str[i]; cout " "Процесс " " who " " выводит символы\п"; i++; oindex++; outbuf [oindex] = r\0'; //последним всегда идет нуль return 1; }return 0; } void show() ( cout " outbuf " '\n'; } char output :: outbuf [255] ; //это разделяемый ресурс int output :: inuse = 0; //если переменная inuse равна О, //буфер доступен; иначе нет int output: : oindex =0; //индекс буфера int main () { output ol(l, "Это проверка"), о2(2, " статических переменных");
Самоучитель C++ while(ol.putbuf() I o2.putbuf()); //вывод символов о Д..show(); return 0; I 2. ^include <iostream> # include <new> using namespace std; class test { static int count; public: testC) { count-t-+; } ~test() { count - ; } int getcountO { return count; } int test::count = 0; int main() test ol, o2, o3; cout " ol.getcount() " " объектов существуетХп"; test *p; /* Отслеживание ошибок выделения памяти с помощью старого и нового механизмов обработки ошибок */try {р = new test; //выделение памяти объекту if(!p) { //старый стиль cout " "Ошибка выделения памятиХп"; return 1; } catch(bad_alloc ba) { //новый стиль cout " "Ошибка выделения памяти\п"; return 1; cout " ol.getcount () ; cout " " объектов существует после выделения памяти\п //удаление объекта delete р; cout " ol.getcount {};
Приложение В. Ответы на вопросы и решения упражнений 647 cout " " объектов существует после удаленияХп"; return 0; 13.4 1. Для исправления программы просто сделайте переменную current модифи цируемой, чтобы ее можно было изменить с помощью постоянной функции-члена countingO Решение упражнения представлено ниже: //Теперь программа исправлена ttinclude <iostream> using namespace std; class CountDown { int incr; int target; mutable int current; //делаем переменную current модифицируемой public: CountDown (int delay, int i = 1) ( target = delay; incr = i; current = 0; i bool counting ( ) const { current +-incr; if {current >= target) { cout " "\a"; return false; }cout " current " " "; return true; int mainO { CountDown ob(100, 2); while (ob. counting ( ) ) ; return 0; 1 2. Нет, не может. Если бы у постоянной функции-члена была возможность вы-звать не постоянную функцию-член, то не постоянную функцию-член мож-но было бы использовать для модификации вызывающего объекта.
648 Самоучитель С_+_+_ 13.5 1-Да-2. Да, поскольку в C++ определено автоматическое преобразование из типа int в тип double. 3. Одна из проблем неявного преобразования конструкторов состоит в воз-можности просто забыть, что такое преобразование имело место. Например, неявное преобразование в инструкции присваивания очень напоминает пе-регруженный оператор присваивания, хотя их действия не обязательно ана-логичны. Когда вы создаете классы, предназначенные для широкого исполь-зования, чтобы не вводить в заблуждение потенциальных пользователей ва-ших классов, было бы правильным отказаться от неявного преобразования конструкторов. 13.7 1. /* В этой версии программы на экран выводится число символов, записанных в буфер */^include <iostream> ^include <strstream> using namespace std; int main{) { char buf[255]; ostrstream ostr(buf, sizeof buf); ostr " "ввод/вывод через массивы работает с потокамиХп"; ostr " "точно так же, как обычный ввод/вывод\п " " 103; ostr " ' ' " 123.23 " '\п'; //можно также использовать манипуляторы ostr " hex " 100 " ' '; //или флаги формата ostr.setf(ios::scientific); ostr " dec " 123.23; ostr " endl " ends; //гарантия того, //что буфер завершится нулем //вывод на экран содержимого буфера cout " buf; cout " ostr.pcount(); return 0;
Приложение В. Ответы на вопросы и решения упражнений _ 649 2. /* Массивы в качестве объектов ввода/вывода при копировании содержимого одного массива в другой */^include <iostream> #include <strstream> using namespace std; char inbuf[] = "Это проверка ввода/вывода C++, основанного на использовании символьных массивов"; char outbuf [255] ; int main () { istrstream istr(inbuf); ostrstream ostr (outbuf , sizeof outbuf}; char ch; while ( ! istr.eof () ) { istr.get (ch) ; if (listr.eof ()) ostr. put {ch) ; } ostr. put (' \0' ); //нулевой символ завершения cout " "Ввод: " " inbuf " '\n'; cout " "Вывод: " " outbuf " '\n'; return 0; 3. //Преобразование строки в число с плавающей точкой #include <iostream> #include <strstream> using namespace std; int main() { float f; char s [ ] = "1234.564"; //вещественное в виде строки istrstream istr(s); //Простой способ преобразования строки //в ее внутреннее представление istr " f; cout " "Преобразованная форма: " " f " '\n'; return 0;
650 Самоучитель C++ Проверка усвоения материала главы 13 1. В отличие от обычных переменных-членов, для которых характерно то, что в каждом объекте класса имеется их копия, у статической переменной-члена существует только одна копия, которую все объекты класса используют совместно. 2. Для использования массивов в качестве объектов ввода/вывода в программу необходимо включить заголовок <strstream>. 3. Нет. 4. extern "С" int counter О; 5. Функция преобразования просто превращает объект в значение, совместимое с другим типом данных. Как правило, этим другим типом данных является встроенный тип данных C++. 6. Ключевое слово explicit применяется только к конструкторам. Оно предот-вращает неявное преобразование конструкторов. 7. Постоянная функция-член не может модифицировать объект, который ее вызывает. 8. Пространство имен, объявляемое с помощью ключевого слова namespace, предназначено для локализации области видимости имен. 9. Ключевое слово mutable дает возможность постоянной функции - члену класса изменять данные, являющиеся членами этого класса. Проверка усвоения материала в целом 1. Да. В ситуациях, в которых неявное преобразование выполняет то же дейст-вие, которое в отношении типа параметра конструктора было бы выполнено перегруженным оператором присваивания, перегружать оператор присваива-ния не нужно. 2. Да. 3. Новые библиотеки можно размещать в собственных пространствах имен, предотвращая тем самым конфликты имен с кодами других программ. Эта полезная возможность оказывается столь же полезной и в отношении старых кодов, которые предполагается использовать с новыми библиотеками. ГЛАВА 14 Повторение пройденного 1. Пространства имен были добавлены в C++ для локализации имен иденти-фикаторов с целью предотвращения конфликтов имен. Проблема конфлик-
Приложение В. Ответы на вопросы и решения упражнений _ 657 тов имен серьезно заявила о себе в последнее время благодаря постоянному росту числа и объема библиотек классов сторонних фирм. 2. Чтобы функцию-член сделать постоянной, необходимо за списком парамет-ров функции указать ключевое слово const. Например: -int f(int a) con3t; 3. Нет. Модификатор mutable (модифицируемый) позволяет постоянной функ-ции-члену изменить переменную-член. 4. class X { int a, b; public: X(int i, int j) { a = i, b = j ; } operator int() { return a+b; } 5. Да, это так. 6. Нет. Спецификатор explicit запрещает автоматическое преобразование типа int в тип Demo. Упражнения 14.1 1. Контейнер - это объект, предназначенный для хранения других объектов. Алгоритм - это процедура, предназначенная для работы с содержимым кон-тейнеров. Итератор по отношению к объектам библиотеки стандартных шаб-лонов действует аналогично указателю. 2. Предикаты бывают бинарными и унарными. 3. Существуют следующие пять типов итераторов: произвольного доступа, дву-направленный, однонаправленный, ввода и вывода. 14.3 2. Для любого объекта, хранящегося в векторе, должен быть определен конст-руктор по умолчанию. 3. //Хранение в векторе объектов класса Coord #include <iostream> ^include <vector> using namespace std;
652 Самоучитель C++ class Coord { public: int x, y; Coord(} { x = у = 0; } Coord(int a, int b) ( x = а; у = b; } boll operator<(Coord a, Coord b) return (a.x + a.y) < (b.x :+: b.y); boll operator==(Coord a, Coord b) return (a.x + a.y) == (b.x + b.y); int main () vector<Coord> v; int i; for(i=0; i v.push_back(Coord(i, i)) ; for (1=0; i<v.size(); i cout " v [ i ] . x " "," " v[i].y " " "; cout " endl; for(1=0; i<v.sized; i++) v[i].x = v[i].x * 2; for(i=0; Kv.sizel); i++) cout " v [ i ] . x " "," " v [ i ] . y " " "; return 0; 14.4 2. //Основные операции списка ^include <iostream> tinclude <list> using namespace std; int mainO
Приложение В-Ответы на вопросы и решения упражнений list<char> 1st; //создание пустого списка int i; for{i=0; i<10; i++) lst.push_back( 'A' + i) ; cout " "Размер = " " 1st. size () " endl; list<char>: : iterator p; cout " "Содержимое: "; for(i=0; i<lst.size{) ; i++) { p = 1st. begin (} ; cout " *p; 1st .pop_front (} ; lst.push_back(*p) ; //размещение элемента в конце списка }cout " endl; if (list. empty () ) cout " "Список пустым не является \п" ; return 0; }После выполнения программы на экране появится следующее: Размер =10 Содержимое : ABCDE FGHI J Список пустым не является В данной программе элементы поочередно извлекаются из начала списка и размещаются в его конце. Таким образом список никогда не остается пус-тым. В цикле по выводу на экран содержимого списка с помощью функции sizeQ организуется непрерывный контроль его длины. 3. //Слияние двух списков проектов ttinclude <iostream> #include <list> ^include <cstring> using namespace std; class Project { public: char name [40] ; int days_to_completion; Project (} { strcpy(name, " "); days_to_completion = 0;
554 Самоучитель C++ Project (char *n, int d) { strcpy (name, n) ; days_to_completion = d; void add_days(int i) { days_to_completion += i void sub_days ( int i) ( days_to_completion -= i; } bool completed () { return !days_to_corapletion; } void report () { cout " name " ": "; cout " days_to_completion; cout " " дней до завершения\п"; bool operator< (const Project &a, const Project &b) { return a.days_to_completion < b. days_to__completion; } bool operator> (const Project sa, const Project &b) { return a.days_to_completion > b.days__to_completion; } bool operator== (const Project &a, const Project &b) ( return a.days_to_completion == b.days_to_completion; } bool operator != (const Project &a, const Project sb) { return a.days_to_completion != b. days_to_completion; }int main() ( list<Project> proj; list<Project> proj2; proj -push_back (Project ("Разработка компилятора", 35) ) ; proj .push_back (Project ("Разработка электронной таблицы", 190)); proj. push back(Project ("Разработка STL", 1000));
Приложение В. Ответы на вопросы и решения упражнений 655 proj2.push_back(Project("Разработка базы данных", 780)); proj2.push_back(Project{"Разработка стандартных писем", 50)); proj2.push_back(Project("Разработка объектов COM", 300)); proj.sort(); proj2.sort(} ; proj.merge(proj2); //слияние списков list<Project>::iterator p = proj.begin(); //вывод проектов на экран while(p != proj.end()) { p->report(}; p-H-; Jreturn 0; 14.5 2. //Ассоциативный список абонентов и телефонных номеров ^include <iostream> ^include <niap> ^include <cstring> using namespace std; class name ( char str[20] ; public: nameU { strcpyfstr, "") ; } name (char *s) { strcpy(str, s) ; } char *get() { return str; } //Для объектов типа name следует определить оператор < (меньше) bool operator< (name a, name b) < return strcmp (a. get {) , b.getO) < 0; }class phonenura { char str[20] ; public: phonenumO { strcmp(str, ""); } phonenum(char *s) { strcpyfstr, s) ; } char *get() { return str; }
656 : Самоучитель С++_ int main{} { map<name, phonenum> m; //Размещение в ассоциативном списке имен абонентов //и их телефонных номеров m.insert(pair<name, phonenum> (name ("Василий") , phonenuin("541-85-51") ) ) ; m.insert(pair<name, phonenum> (name("Иосиф"), phonenum("550-09-96"))); m.insert(pair<name, phonenum> (name ("Михаил"), phonenum("8-3712-41-16-36"))); ra.insert (pair<name, phonenum> {пате("Никодим") , phonenum("8-095-967-85-85") ) ) ; //Поиск телефонного номера по заданному имени абонента char str[80]; cout " "Введите имя; "; cin " str; map<name, phonenum>::iterator p; p = in. find (name (str) ) ; if (p i= m.end() ) cout " "Телефонный номер: " " p->second.get(); elsecout " "Такого имени в ассоциативном списке нет\п"; return 0; 3. Да. 14.6 1. //Сортировка вектора с помощью алгоритма sort ^include <iostream> ^include <vector> tinclude <cstdlib> ^include <algoritm> using namespace std; int main () { vector<char> v; int i; //Создание вектора из случайных символов
Приложение В. Ответы на вопросы и решения упражнений 657 for(i=0; v.push_back('A' + (rand()%26) ) ; cout " "Исходное содержимое: "; for (i=0; i<v. size () ; i++) cout " v[i] " " "; cout " endl " endl; //Сортировка вектора sort ( v . begin ( ) , v . end ( } ) ; cout " "Отсортированное содержимое: "; for(i=0; i<v.size(); i++) cout " v[i] " " "; return 0; 2. //Выполнение слияния двух списков с помощью алгоритма merge ^include <iostream> ^include <list> ^include <algoritm> using namespace std; int main ( ) < list<char> Istl, Ist2, Ist3(20); int i ; for(i=0; i<10; i+=2) Istl .push_back ( 'A' -t-i) ; for(i=0; i<ll; i+=2} Ist2 .push_back ( 'A' + i) ; cout " "Содержимое списка Istl: "; list<char>: : iterator p = lstl.begin.0 ; while (p != Istl. end () ) { cout " *p; P++; } cout " endl " endl; cout " "Содержимое списка Ist2: "; p = Ist2. begin (} ; while(p != Ist2.end() ) { cout " *p; P++; } cout " endl " endl;
658 _ _ __ Самоучитель С++ //Теперь выполняем слияние двух списков merge (Istl. begin ( ) , Istl.endO , Ist2.begin(), Ist2.end(), Ist3. begin (} ) ; cout " "Содержимое списка после слияния: "; р = Ist3.begin( ) ; while(p != Ist3.end() ) { cout " *p; return 0; 14.7 1. ^include <iostream> #include <string> ttinclude <list> using namespace std; int itiain() { list<string> str; str.push_back(string("один"}); str.push_back(string("два")); str.push_back{string("три")); str.push_back(string("четыре")); str.push_back(string("пять")); str.push__back(string ("шесть") ) ; str.push_back(string("семь")); str.push_back(string("восемь")); str.push_back(string("девять")); str.push_back(string("десять")); str.sort(); //сортировка списка list<string>::iterator p = str.beginf) while (p != str.endO) { cout " *p " " "; P++; }return 0;
Приложение В. Ответы на вопросы и решения упражнений 659 2. ^include <iostream> ^include <string> ^include <algorithm> using namespace std; int main() { string str; cout " "Введите строку: "; cin " str; int i = count {str. begin () , str.endf), 'e'); cout " i " " символов являются символом е\п"; return 0; 3. ^include <iostream> ^include <string> ^include <algorithm> ^include <cctype> using namespace std; int main() string str; cout " "Введите строку: "; cin " str; int i = count_if {str.beginO , str.endO, islower) ; cout " i " " символов введено в нижнем регистре\п"; return 0; 4. Класс string - это конкретизация класса-шаблона basic_string. Проверка усвоения материала главы 14 1. Библиотека стандартных шаблонов предоставляет многократно опробован-ные, отлаженные версии многих традиционных структур данных и алгорит-мов. Поскольку контейнеры, входящие в библиотеку стандартных шаблонов, являются классами-шаблонами, их можно использовать для хранения данных любых типов.
660 Самоучитель C++ 2. Контейнер - это объект, предназначенный для хранения других объектов. Алгоритм - это процедура, предназначенная для работы с содержимым кон-тейнеров. Итератор по отношению к объектам библиотеки стандартных шаб-лонов действует аналогично указателю. . _3. ^include <iostream> ^include <vector> ^include <list> using namespace std; int main {} { vector<int> list<int> 1st; int i; for(i=0; for(i=0; if(!(v[i]%2)) lst.push_back(v[i]) list<int>::iterator p = 1st.begin (); while{p != lst.end()) { cout " *p " " "; P++; return 0; 4. Строковый тип данных дает возможность обрабатывать строки с помощью обычных операторов. С другой стороны, работа с данными строкового типа не настолько эффективна, как работа с оканчивающимся нулем символьны-ми массивами. 5. Предикат - это функция, возвращаемым значением которой является исти-на либо ложь.
Приложение С Список английских технических терминов Настоящее приложение содержит список использованных в книге английских технических терминов. В табл. С.1 термины расположены в соответствии с порядком английского алфавита, а в табл. С.2 - русского. В первом столбце указан сам термин, во втором - его аббревиатура (если таковая имеется) или его наиболее общеупотребительное название, и в третьем - русский перевод термина. Таблица С. 1. Английские технические термины (A-Z) Название Аббревиатура Перевод Abstract Class Абстрактный класс Access Specifier Спецификатор доступа Algorithm Алгоритм Allocator Распределитель памяти Ambiguity Н еоднознач н ость American National Standards Institute ANSI Американский национальный институт стандартов Anonymous Union Анонимное объединение Array-Based I/O Ввод/вывод с использованием массивов Associative Container Ассоциативный контейнер Automatic Bounds Checking Автоматический контроль границ Base Class Базовый класс Bidirectional Iterator Bilter Двунаправленный итератор Bitmask Битовая маска Bounded Array Защищенный массив С string Строка в стиле С C++ Standard Library Стандартная библиотека C++
662 Самоучитель C++ Таблица С. 1 (продолжение) Название Casting Operator Class Comparison Function Const Class Member Constructor Container Container Class Conversion Function Copy Constructor Default Argument Derived Class Destructor Early Binding Encapsulation Enumeration Exception Exception Catching Exception Handling Exception Throwing Extraction Operator Extractor Format Flag Forward Declaration Forward Iterator Forward Reference Friend Function Function Object Function Overloading Generated Function Аббревиатура Перевод Оператор приведения типов Класс Функция сравнения Постоянный член класса Конструктор Контейнер Класс -конте и не р Функция преобразования Конструктор копий Аргумент по умолчанию Производный класс Деструктор Раннее связывание Инкапсуляция Перечисление, перечислимый тип данных Исключительная ситуация Перехват исключительной ситуации Обработка исключительной ситуации Возбуждение исключительной ситуации Оператор извлечения Функция извлечения Флаг формата Предварительное объявление Forlter Однонаправленный итератор Ссылка вперед Дружественная функция Объект-функция Перегрузка функций Порожденная функция
Приложение С. Список английских технических терминов 663 Таблица С, 1 (продолжение) Название Generic Class Generic Function Get Pointer Header Header File Heap Hierarchical Classification I/O Manipulator Independent Reference Indirect Base Class Inheritance In-Line Function Input Iterator Input/Output Inserter Inserter Function Inserter Operator Insertion Insertion Operation Instantiating International Standards Organization Iterator Join Key Large Character Set Late Binding Linkage Specifier List Mangling Manipulator Map Member Аббревиатура Перевод Родовой класс Родовая функция Указатель считывания Заголовок Заголовочный файл Пирамида Иерархия классов Манипулятор ввода/вывода Независимая ссылка Косвенный базовый класс Наследование Встраиваемая функция Inlter Итератор ввода I/O Ввод/вывод Функция вставки Функция вставки Оператор вставки Вставка Операция вставки Создание экземпляра функции ISO Международная организация по стандартам Итератор Соединение Ключ Расширенный набор символов Позднее связывание Спецификатор сборки Список Искажение Манипулятор Ассоциативный список Член
664 Самоучитель C++ Таблица С. 1 (продолжение) Название Member Function -Merge Microsoft Foundation Classes Multiple Inheritance Mutable Class Member Name Collision Name Mangling Namespace Object Object Factory Object Oriented Programming Operation Operator Operator Function Operator Overloading Output Iterator Overloading Overriding Pass by Reference Pass by Value Permutation Pointer Polymorphic Class Polymorphism Predicate Private Protected Public Pure Virtual Function Put Pointer Queue Аббревиатура Перевод Функция-член Слияние MFC Библиотека классов MFC Множественное наследование Модифицируемый член класса Конфликт имен Искажение имен Пространство имен Объект Фабрика объектов OOP Объектно -ориентире ванное программирование Операция Оператор Оператор-функция Перегрузка операторов Outlter Итератор вывода Перегрузка Подмена Передача по ссылке Передача по значению Перестановка Указатель Полиморфный класс Полиморфизм Предикат Закрытый Защищенный Открытый Чистая виртуальная функция Указатель записи Очередь
Приложение С. Список английских технических терминов 665 Таблица С. 1 (продолжение) Название Random Access Random Access Iterator Redefinition Reference Reverse Iterator Run-Time Error Run-Time Polymorphism Run-Time Type Identification Safe Array Scope Scope Resolution Operator Sequence Stack Standard Template Library Statement Static Class Member Stream String Class String Data Type Structure Structured Programming Language Template Template Class Template Function Type Promotion Union Unnamed Namespace Vector Virtual Base Class Virtual Function Аббревиатура Перевод Произвольный доступ Randlter Итератор произвольного доступа Переопределение Ссылка Обратный итератор Динамическая ошибка Динамический полиморфизм RTTI Динамическая идентификация типа Безопасный массив Область видимости Оператор расширения области видимости Последовательность Стек STL Библиотека стандартных шаблонов Инструкция Статический член класса Поток ввода/вывода Строковый класс Строковый тип данных Структура Язык структурного программиро-вания Шаблон Класс-шаблон Функция -шаблон Приведение типа Объединение Безымянное пространство имен Вектор Виртуальный базовый класс Виртуальная функция
666 Самоучитель C++ Таблица С.2. Английские технические термины (А-Я) Название Аббревиатура Перевод Abstract Class Абстрактный класс Automatic Bounds Checking Автоматический контроль границ Algorithm Алгоритм American National Standards Institute ANSI Американский национальный институт стандартов Anonymous Union Default Argument Associative Container Map Base Class Safe Array Unnamed Namespace Microsoft Foundation MFC Classes Standard Template Library STL Bitmask Input/Output I/O Array-Based I/O Vector Virtual Function Virtual Base Class Exception Throwing Insertion In-Line Function Bidirectional Iterator Bilter Destructor Run-Time Type Identification RTTI Run-Time Error Run-Time Polymorphism Friend Function Header Header File Анонимное объединение Аргумент по умолчанию Ассоциативный контейнер Ассоциативный список Базовый класс Безопасный массив Безымянное пространство имен Библиотека классов MFC Библиотека стандартных шаблонов Битовая маска Ввод/вывод Ввод/вывод с использованием массивов Вектор Виртуальная функция Виртуальный базовый класс Возбуждение исключительной си-туации Вставка Встраиваемая функция Двунаправленный итератор Деструктор Динамическая идентификация типа Динамическая ошибка Динамический полиморфизм Дружественная функция Заголовок Заголовочный файл
Приложение С. Список английских технических терминов 667 Название Private Protected Bounded Array Hierarchical Classification Encapsulation Statement Mangling Name Mangling Exception Iterator Input Iterator Output Iterator Random Access Iterator Class Container Class Template Class Key Constructor Copy Constructor Container Name Collision Indirect Base Class Manipulator I/O Manipulator International Standards Organization Multiple Inheritance Mutable Class Member Inheritance Independent Reference Ambiguity Scope Таблица С. 2 (продолжение) Аббревиатура Перевод Закрытый Защищенный Защищенный массив Иерархия классов Инкапсуляция Инструкция Искажение Искажение имен Исключительная ситуация Итератор Inlter Итератор ввода Outlter Итератор еывода Randlter Итератор произвольного доступа Класс Класс-контейнер Класс-шаблон Ключ Конструктор Конструктор копий Контейнер Конфликт имен Косвенный базовый класс Манипулятор Манипулятор ввода/вывода ISO Международная организация по стандартам Множественное наследование Модифицируемый член класса Наследование Независимая ссылка Неоднозначность Область видимости
668 Самоучитель C++ Таблица С. 2 (продолжение) Название Exception Handling Reverse Iterator Union Object Object Oriented Programming Function Object Forward Iterator Operator Inserter Operator Extraction Operator Casting Operator Scope Resolution Operator Operator Function Operation Insertion Operation Public Queue Overloading Operator Overloading Function Overloading Pass by Value Pass by Reference Redefinition Permutation Exception Catching Enumeration Heap Overriding Late Binding Аббревиатура Перевод Обработка исключительной ситуации Обратный итератор Объединение Объект OOP Объектно-ориентире ванное про-граммирование Объект-функция Forlter Однонаправленный итератор Оператор Оператор вставки Оператор извлечения Оператор приведения типов Оператор расширения области видимости Оператор-функция Операция Операция вставки Открытый Очередь Перегрузка Перегрузка операторов Перегрузка функций Передача по значению Передача по ссылке Переопределение Перестановка Перехват исключительной ситуации Перечисление, перечислимый тип данных Пирамида Подмена Позднее связывание
Приложение С. Список английских технических терминов 669 Название Polymorphism Polymorphic Class Generated Function Sequence Const Class Member Stream Forward Declaration Predicate Type Promotion Derived Class Random Access Namespace Early Binding Allocator Large Character Set Generic Function Generic Class Merge Join Instantiating Access Specifier Linkage Specifier List Reference Forward Reference C++ Standard Library Static Class Member Stack С string String Class String Data Type Structure Таблица С. 2 (продолжение) Аббревиатура Перевод Полиморфизм Полиморфный класс Порожденная функция Последовательность Постоянный член класса Поток ввода/вывода Предварительное объявление Предикат Приведение типа Производный класс Произвольный доступ Пространство имен Раннее связывание Распределитель памяти Расширенный набор символов Родовая функция Родовой класс Слияние Соединение Создание экземпляра функции Спецификатор доступа Спецификатор сборки Список Ссылка Ссылка вперед Стандартная библиотека C++ Статический член класса Стек Строка в стиле С Строковый класс Строковый тип данных Структура
670 Самоучитель C++ Таблица С. 2 (продолжение) Название Pointer Put Pointer Get Pointer Object Factory Format Flag Inserter Inserter Function Extractor Conversion Function Comparison Function Member Function Template Function Pure Virtual Function Member Template Structured Programming Language Аббревиатура Перевод Указатель Указатель записи Указатель считывания Фабрика объектов Флаг формата Функция вставки Функция вставки Функция извлечения Функция преобразования Функция сравнения Функция-член Функция-шаблон Чистая виртуальная функция Член Шаблон Язык структурного программиро-вания
Приложение D Описание дискеты На дискете находятся листинги программ, которые приведены в книге в разделах "Примеры" (каталог Example) и "Упражнения" (каталог Exercise). Листинги из главы с номером N находятся в соответствующем подкаталоге ChapN. Листинги программ - ответы на упражнения, расположенные в на-чале каждой главы (раздел "Повторение пройденного"), находятся в под-каталоге Review. Листинги программ - ответы на упражнения, расположен-ные в конце каждой главы (раздел "Проверка усвоения материала главы"), находятся в подкаталоге Mastery. Листинги программ - ответы на упражне-ния, расположенные также в конце каждой главы (раздел "Проверка усвое-ния материала в целом"), находятся в подкаталоге Cumulative. Тексты программ содержат символы русского языка и предназначены для компиля-ции и запуска в MS-DOS (каталог DOS). Если вы работаете в MS Windows, то необходимо компилировать эти программы как консольные приложения (каталог Windows). Для компиляции можно использовать любой современный компилятор C++. Не огорчайтесь,.если записанные на дискете программы будут работать не так, как вы ожидаете, или вообще не будут работать. Поиск и исправление синтаксических ошибок - это тоже прекрасный способ изучения языка программирования. Желаем удачи!
Предметный указатель abstract class, 314 access specifier, 207 algorithm, 421 allocator, 423 ambiguity, 165 American National Standards Institute (ANSI), 14 anonymous union, 66 array-based I/O, 411 associative container, 421 в base class, 57; 207 bitmask, 244 bounded array, 137 С string, 462 casting operator, 357 class, 26 comparison function, 423 const class member, 383 constructor function, 44 container, 421 conversion function, 383; 393 copy constructor, 52; 92; 149 D default argument, 158 derived class, 57; 207 destructor, 45 E early binding, 318 encapsulation, 11 exception handling, 325; 337 exception throwing, 337 extraction operator, 265 extractor, 265 format flag, 244 forward declaration, 101 forward reference, 101 friend functions, 97 function object, 423 function overloading, 12; 36 G generated function, 328 generic class, 243; 325 generic function, 325 get pointer, 292 н header, 15 hierarchical classification, 13 i I/O manipulators, 254 incapsulation, 59 independent reference, 139 indirect, 223 inheritance, 13; 57 in-line, 72 Input/Output (I/O), 19 inserter, 259 inserter function, 259 insertion, 259 insertion operator, 259 instantiating, 328 International Standards Organization (ISO), 14 iterator, 421
674К key, 421 L Самоучитель C++ Q queue, 419 R late binding, 318 linkage specifier, 408 list, 419 M mangling, 409 map, 421 member, 26 member function, 27 N namespace, 16; 18; 383 о object, 12 Object Oriented Programming (OOP), 5; 9 operator overloading, 13 operator function, 176 overriding, 308 pointer, 63 polymorphic class, 307 polymorphism, 12 predicate, 423 private, 12 public, 12 pure virtual function, 314 put pointer, 292 random access, 292 reference, 127 reverse iterator, 422 Run-Time Type Identification (RTTI), 357 safe array, 138 scope resolution operator, 27 sequence, 421 stack, 419 Standard C++, 10; 14; 351 Standard Template Library (STL), 332; 419 static class member, 383 stream, 242 string class, 420; 462 structured programming language, 11 template class, 242 template function, 328 template, 325 type promotion, 165 и unnamed namespace, 386 V vector, 419 virtual base class, 230 virtual function, 303; 306
Предметный указатель 675 Абстрактный класс, 314 Алгоритм, 421; 453 Американский национальный институт стандартов (ANSI), 14 Анонимное объединение, 66 Аргумент по умолчанию, 158 Ассоциативный контейнер, 446 Ассоциативный список, 421; 446 Двунаправленный список, 435 Деструктор, 45; 216 Динамическая идентификация типа (RTTI), 357; 358 Динамический массив, 425 Динамический полиморфизм, 303 Доступ произвольный, 292 Дружественная функция, 97 Базовый класс, 57 Безымянное пространство имен, 386; 391 Библиотека стандартных шаблонов, 332; 419 Битовая маска, 244 в Ввод/Вывод вставка, 259 двоичный, 283 контроль состояния, 295 манипуляторы, 254 на консоль, 19 оператор, 19 потоки, 242 произвольный доступ, 292 С, 19; 242 с использованием массивов, 411 C++, 19; 242 файловый, 276 форматируемый, 244 функция, 19 Вектор, 419; 425 Виртуальная функция, 303; 306 Виртуальный.базовый класс, 229 Возбуждение исключительной ситуации, 337 Встраиваемая функция, 72 Д Данные закрытые, 12 открытые, 12 тип, 65 Заголовок, 15 Заголовочный файл, 15 и Иерархия классов, 13; 205 Инкапсуляция, 11; 59 Искажение имен, 409 Исключительная ситуация возбуждаемая оператором new, 351 возбуждение, 337 перехват, 337 Итератор, 421 обратный, 422 к Класс, 26; 65 абстрактный, 314 базовый, 57; 207 виртуальный, 229; 230 косвенный, 223 деструктор, 45; 216 иерархия, 13; 205 конструктор, 44; 216 контейнер, 421 ассоциативный, 421 объявление, 27 полиморфный, 307 производный, 57; 207 родовой, 325; 332 строковый, 420; 462 функция-конструктор, 44 функция-член, 27 член класса, 26 защищенный, 212 модифицируемый, 401
676 Самоучитель C++ Класс, 26; 65 член класса, 26 постоянный, 383; 401 статический, 383; 396 Класс-контейнер, 424 Класс-шаблон, 242 Ключ, 421 Ключевое слово, 41 Комментарий в стиле С, 24 в стиле C++, 24 многострочный, 25 однострочный, 24 Конструктор, 44; 216; 404 копий, 52; 92; 149 параметры, 51 перегрузка, 144 Контейнер, 421 ассоциативный, 421; 446 ассоциативный список, 421; 446 вектор, 419; 425 ключ, 421 очередь, 419 список, 419; 435 стек, 419 Контроль состояния ввода/вывода, 295 Манипуляторы ввода/вывода, 254 пользовательские, 272 Массив безопасный, 138 динамический, 425 защищенный, 137 объектов, 108 Международная организация по стандартам (ISO), 14 Многострочный комментарий, 25 Множественное наследование, 223 Модифицируемый член класса, 401 Наследование, 13; 57; 205 множественное, 223 Независимая ссылка, 139 Неоднозначность программы, 165 О Обработка исключительных ситуаций, 325; 337 Обратный итератор, 422 Объединение анонимное, 66 Объект, 12 в качестве аргумента, 87 в качестве возвращаемого значения функции, 93 массив, 108 передача по ссылке, 132 присваивание, 82 указатель на объект, 113 Объектно-ориентированное программирование (OOP), 5; 9; 10; 11 Объект-функция, 423 Объявление класса, 27 Однострочный комментарий, 24 Оператор delete, 118; 122 new, 118; 121 ввода/вывода, 19 вставки, 259 извлечения, 265 индексирования массива, 197 перегрузка, 13; 15 приведения типов, 357 присваивания, 194 расширения области видимости, 27; 103 стрелка, 63; 113 точка, 63; 113 Оператор-функция, 176 дружественная, 191 Очередь, 419 п Параметры конструктора, 51 Перегрузка конструктора, 144 операторов, 13; 175 функции, 12; 36 аргумент по умолчанию, 158 неоднозначность, 165 Переопределение виртуальной функции, 306 Перехват исключительной ситуации, 337
Предметный указатель 677 Подмена, 308 Позднее связывание, 318 Полиморфизм, 12 динамический, 303; 317 Полиморфный класс, 307 Пользовательские манипуляторы, 272 Порожденная функция, 328 Последовательность, 421 Постоянный член класса, 383; 401 Поток флаги формата, 244 ввода/вывода, 242 Предварительное объявление, 101 Предикат, 423 Преобразования функции, 383; 393 Приведение типа, 165 Присваивание объектов, 82 Программирование объектно-ориентированное, 5; 9; 10; 11 язык структурного программирования, 11 Производный класс, 57 Пространство имен, 16; 18; 383 безымянное, 386; 391 Раннее связывание, 318 Распределитель памяти, 423 Родовая функция, 325; 326 Родовой класс, 243; 325; 332 Связывание позднее, 318 раннее, 318 Спецификатор доступа, 59; 207 Спецификатор сборки, 408 Список, 419; 435 двунаправленный, 435 Ссылка, 127 в качестве возвращаемого значения функции, 135 вперед, 101 независимая, 139 передача объекта по ссылке, 132 Статический член класса, 383 Стек, 419 Строка в стиле С, 462 Строковый класс, 420; 462 Структура, 65 Тип данных, 65 приведение типа, 165 у Указатель, 63 this, 117 записи, 292 на объект, 63; 113 производного класса, 304 считывания, 292 Ф Файл заголовочный, 15 Флаги формата, 244 перечисление, 244 Функция ввода/вывода, 19 виртуальная, 303; 306 переопределение, 306 подмена, 308 вставки, 259 встраиваемая, 72 деструктор, 45 дружественная, 97 извлечения, 265 конструктор, 44 перегрузка, 12; 36 пользовательская ввода, 266 пользовательская вывода, 259 порожденная, 328 создание экземпляра, 328 преобразования, 383; 393 родовая, 325; 326 сравнения, 423 чистая виртуальная, 314 Функция-член, 27 Функция-шаблон, 328
Самоучитель C++ ш Шаблон, 325 Я Язык структурного программирования, 11 678 Чистая виртуальная функция, 314 Член класса, 26 защищенный, 212 модифицируемый, 401 постоянный, 383; 401 статический, 383; 396
Содержание ВВЕДЕНИЕ 5 ОТЛИЧИЯ ТРЕТЬЕГО ИЗДАНИЯ 6 Если вы РАБОТАЕТЕ под WINDOWS 6 КАК ОРГАНИЗОВАНА ЭТА КНИГА 7 ИСХОДНЫЕ КОДЫ ПРОГРАММ 7 ГЛАВА 1. КРАТКИЙ ОБЗОР C++ 9 1.1. ЧТО ТАКОЕ ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ? 10 Инкапсуляция 11 Полиморфизм 12 Наследование 13 1.2. ДВЕ ВЕРСИИ C++ 14 Новые заголовки в программах на C++ 16 Пространства имен 18 Если вы работаете со старым компилятором 18 1.3. Консольный ввод и вывод в C++ 19 1.4. КОММЕНТАРИИ в C++ 24 1.5. КЛАССЫ. ПЕРВОЕ ЗНАКОМСТВО 26 1.6. НЕКОТОРЫЕ отличия языков С и C++ 32 1.7. ВВЕДЕНИЕ в ПЕРЕГРУЗКУ ФУНКЦИЙ 36 1.8. КЛЮЧЕВЫЕ СЛОВА C++ 41 ГЛАВА 2. ВВЕДЕНИЕ В КЛАССЫ 43 2.1. КОНСТРУКТОРЫ И ДЕСТРУКТОРЫ 44 2.2. КОНСТРУКТОРЫ С ПАРАМЕТРАМИ 51 2.3. ВВЕДЕНИЕ в НАСЛЕДОВАНИЕ 57 2.4. УКАЗАТЕЛИ НА ОБЪЕКТЫ 63 2.5. КЛАССЫ, СТРУКТУРЫ и ОБЪЕДИНЕНИЯ 65 2.6. ВСТРАИВАЕМЫЕ ФУНКЦИИ 72 2.7. ВСТРАИВАЕМЫЕ ФУНКЦИИ в ОБЪЯВЛЕНИИ КЛАССА 75 ГЛАВА 3. ПОДРОБНОЕ ИЗУЧЕНИЕ КЛАССОВ 81 3.1. ПРИСВАИВАНИЕ ОБЪЕКТОВ 82 3.2. ПЕРЕДАЧА ОБЪЕКТОВ ФУНКЦИЯМ 87 3.3. ОБЪЕКТЫ в КАЧЕСТВЕ ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ ФУНКЦИЙ 93 3.4. ДРУЖЕСТВЕННЫЕ ФУНКЦИИ: ОБЗОР 97 ГЛАВА 4. МАССИВЫ, УКАЗАТЕЛИ И ССЫЛКИ 107 4.1. МАССИВЫ ОБЪЕКТОВ 108 4.2. ИСПОЛЬЗОВАНИЕ УКАЗАТЕЛЕЙ НА ОБЪЕКТЫ... 113
680 Самоучитель C++ 4.3. УКАЗАТЕЛЬ THIS 114 4.4. ОПЕРАТОРЫ NEW и DELETE 118 4.5. ДОПОЛНИТЕЛЬНЫЕ СВЕДЕНИЯ ОБ ОПЕРАТОРАХ NEW и DELETE 121 4.6. Ссылки 127 4.7. ПЕРЕДАЧА ссылок НА ОБЪЕКТЫ 132 4.8. ССЫЛКА В КАЧЕСТВЕ ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ ФУНКЦИИ 135 4.9. НЕЗАВИСИМЫЕ ссылки и ОГРАНИЧЕНИЯ НА ПРИМЕНЕНИЕ ссылок 139 ГЛАВА 5. ПЕРЕГРУЗКА ФУНКЦИЙ 143 5.1. ПЕРЕГРУЗКА КОНСТРУКТОРОВ 144 5.2. СОЗДАНИЕ и ИСПОЛЬЗОВАНИЕ КОНСТРУКТОРОВ копий 149 5.3. УСТАРЕВШЕЕ КЛЮЧЕВОЕ слово OVERLOAD 157 5.4. АРГУМЕНТЫ по УМОЛЧАНИЮ 158 5.5. ПЕРЕГРУЗКА и НЕОДНОЗНАЧНОСТЬ 165 5.6. ОПРЕДЕЛЕНИЕ АДРЕСА ПЕРЕГРУЖЕННОЙ ФУНКЦИИ 168 ГЛАВА 6. ВВЕДЕНИЕ В ПЕРЕГРУЗКУ ОПЕРАТОРОВ 175 6.1. ОСНОВЫ ПЕРЕГРУЗКИ ОПЕРАТОРОВ 176 6.2. ПЕРЕГРУЗКА БИНАРНЫХ ОПЕРАТОРОВ 178 6.3. ПЕРЕГРУЗКА ОПЕРАТОРОВ ОТНОШЕНИЯ и ЛОГИЧЕСКИХ ОПЕРАТОРОВ.. 185 6.4. ПЕРЕГРУЗКА УНАРНЫХ ОПЕРАТОРОВ 186 6.5. ДРУЖЕСТВЕННЫЕ ОПЕРАТОР-ФУНКЦИИ 189 6.6. ОСОБЕННОСТИ ИСПОЛЬЗОВАНИЯ ОПЕРАТОРА ПРИСВАИВАНИЯ 194 6.7. ПЕРЕГРУЗКА ОПЕРАТОРА ИНДЕКСА МАССИВА [] 197 ГЛАВА 7. НАСЛЕДОВАНИЕ 205 7.1. УПРАВЛЕНИЕ ДОСТУПОМ к БАЗОВОМУ КЛАССУ 207 7.2. ЗАЩИЩЕННЫЕ ЧЛЕНЫ КЛАССА 212 7.3. КОНСТРУКТОРЫ, ДЕСТРУКТОРЫ И НАСЛЕДОВАНИЕ 216 7.4. МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ 223 7.5. ВИРТУАЛЬНЫЕ БАЗОВЫЕ КЛАССЫ 229 ГЛАВА 8. ВВЕДЕНИЕ В СИСТЕМУ ВВОДА/ВЫВОДА C++ 239 8.1. НЕКОТОРЫЕ БАЗОВЫЕ ПОЛОЖЕНИЯ СИСТЕМЫ ВВОДА/ВЫВОДА C++.... 242 8.2. ФОРМАТИРУЕМЫЙ ввод/вывод 244 8.3. ФУНКЦИИ WIDTH(), PRECISIONQ И FILLQ 251 8.4. МАНИПУЛЯТОРЫ ВВОДА/ВЫВОДА 254 8.5. ПОЛЬЗОВАТЕЛЬСКИЕ ФУНКЦИИ ВЫВОДА 259 8.6. ПОЛЬЗОВАТЕЛЬСКИЕ ФУНКЦИИ ВВОДА 265 ГЛАВА 9. ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ВВОДА/ВЫВОДА В C++ 271 9.1. СОЗДАНИЕ ПОЛЬЗОВАТЕЛЬСКИХ МАНИПУЛЯТОРОВ 272 9.2. ОСНОВЫ ФАЙЛОВОГО ВВОДА/ВЫВОДА 275
Содержание 681 9.3. НЕФОРМАТИРУЕМЫЙ двоичный ввод/вывод 282 9.4. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ о ФУНКЦИЯХ двоичного ВВОДА/ВЫВОДА 288 9.5. ПРОИЗВОЛЬНЫЙ ДОСТУП 292 9.6. КОНТРОЛЬ СОСТОЯНИЯ ВВОДА/ВЫВОДА 295 9.7. ПОЛЬЗОВАТЕЛЬСКИЙ ввод/вывод и ФАЙЛЫ 298 ГЛАВА 10. ВИРТУАЛЬНЫЕ ФУНКЦИИ 303 10.1. УКАЗАТЕЛИ НА ПРОИЗВОДНЫЕ КЛАССЫ 304 10.2. ЗНАКОМСТВО с ВИРТУАЛЬНЫМИ ФУНКЦИЯМИ 306 10.3. ДОПОЛНИТЕЛЬНЫЕ СВЕДЕНИЯ о ВИРТУАЛЬНЫХ ФУНКЦИЯХ 313 10.4. ПРИМЕНЕНИЕ ПОЛИМОРФИЗМА 317 ГЛАВА 11. ШАБЛОНЫ И ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ 325 11.1. РОДОВЫЕ ФУНКЦИИ 326 П.2. РОДОВЫЕ КЛАССЫ 332 11.3. ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ 337 11.4. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ ОБ ОБРАБОТКЕ ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ 344 11.5. ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ, ВОЗБУЖДАЕМЫХ ОПЕРАТОРОМ NEW '. 351 ГЛАВА 12. ДИНАМИЧЕСКАЯ ИДЕНТИФИКАЦИЯ И ПРИВЕДЕНИЕ ТИПОВ 357 12.1. ПОНЯТИЕ О ДИНАМИЧЕСКОЙ ИДЕНТИФИКАЦИИ ТИПА 358 12.2. ОПЕРАТОР DYNAMIC_CAST 368 12.3. ОПЕРАТОРЫ CONST_CAST, REINTERPRET_CAST и STATIC_CAST 376 ГЛАВА 13. ПРОСТРАНСТВА ИМЕН И ДРУГИЕ ТЕМЫ 383 13.1. ПРОСТРАНСТВА ИМЕН 384 13.2. ФУНКЦИИ ПРЕОБРАЗОВАНИЯ 393 13.3. СТАТИЧЕСКИЕ ЧЛЕНЫ КЛАССА 396 13.4. ПОСТОЯННЫЕ и МОДИФИЦИРУЕМЫЕ ЧЛЕНЫ КЛАССА 401 13.5. ЗАКЛЮЧИТЕЛЬНЫЙ ОБЗОР КОНСТРУКТОРОВ 404 13.6. СПЕЦИФИКАТОРЫ СБОРКИ и КЛЮЧЕВОЕ слово ASM 408 13.7. МАССИВЫ В КАЧЕСТВЕ ОБЪЕКТОВ ВВОДА/ВЫВОДА 411 ГЛАВА 14. БИБЛИОТЕКА СТАНДАРТНЫХ ШАБЛОНОВ 419 14.1. ЗНАКОМСТВО с БИБЛИОТЕКОЙ СТАНДАРТНЫХ ШАБЛОНОВ 421 14.2. КЛАССЫ-КОНТЕЙНЕРЫ 424 14.3. ВЕКТОРЫ 425 14.4. Списки 435 14.5. АССОЦИАТИВНЫЕ списки 446 14.6. АЛГОРИТМЫ 453 14.7. СТРОКОВЫЙ КЛАСС ... 462
682 ^амоучитель C++ ПРИЛОЖЕНИЕ А. НЕКОТОРЫЕ ОТЛИЧИЯ ЯЗЫКОВ ПРОГРАММИРОВАНИЯ С И C++ 473 ПРИЛОЖЕНИЕ В. ОТВЕТЫ НА ВОПРОСЫ И РЕШЕНИЯ УПРАЖНЕНИЙ 475 ГЛАВА 1 475 Упражнения 475 Проверка усвоения материала главы 1 481 ГЛАВА 2 483 Повторение пройденного 483 Упражнения 485 Проверка усвоения материала главы 2 497 Проверка усвоения материала в целом 499 ГЛАВА 3 501 Повторение пройденного 501 Упражнения 501 Проверка усвоения материала главы 3 , 507 Проверка усвоения материала в целом 509 ГЛАВА 4 513 Повторение пройденного 513 Упражнения 515 Проверка усвоения материала главы 4 525 Проверка усвоения материала в целом 527 ГЛАВА 5 528 Повторение пройденного 528 Упражнения 531 Проверка усвоения материала главы 5 538 Проверка усвоения материала в целом 541 ГЛАВА 6 542 Повторение пройденного 542 Упражнения 543 Проверка усвоения материала главы 6 555 Проверка усвоения материала в целом 563 ПЛАВА 7 564 Повторение пройденного 564 Упражнения 570 Проверка усвоения материала главы 7 573 Проверка усвоения материала в целом 575 ГЛАВА 8 576 Повторение пройденного 576 Упражнения 578 Проверка усвоения материала главы 8 586 Проверка усвоения материала в целом 589 ГЛАВА 9 592 Повторение пройденного 592 Упражнения ...594
Солержание 683 Проверка усвоения материала главы 9 605 Проверка усвоения материала в целом 610 ГЛАВА 10 612 Повторение пройденного 612 Упражнения 614 Проверка усвоения материала главы 10 620 Проверка усвоения материала в целом 621 ГЛАВА 11 624 Повторение пройденного 624 Упражнения 624 Проверка усвоения материала главы 11 628 ГЛАВА 12 635 Повторение пройденного 635 Упражнения 636 Проверка усвоения материала главы 12 639 Проверка усвоения материала в целом 640 ГЛАВА 13 641 Повторение пройденного 641 Упражнения 642 Проверка усвоения материала главы 13 650 Проверка усвоения материала в целом 650 ГЛАВА 14 650 Повторение пройденного 650 Упражнения 651 Проверка усвоения материала главы 14 659 ПРИЛОЖЕНИЕ С. СПИСОК АНГЛИЙСКИХ ТЕХНИЧЕСКИХ ТЕРМИНОВ 661 ПРИЛОЖЕНИЕ D. ОПИСАНИЕ ДИСКЕТЫ 671 ПРЕДМЕТНЫЙ УКАЗАТЕЛЬ 673
Книги издательства "БХВ-Петербург" в продаже: Серия "В подлиннике" Андреев А. и др. MS Windows XP: Home Edition и Professional 848 с. Андреев А. и др. Windows 2000 Professional. Русская версия 700 с. Андреев А. и др. Microsoft Windows 2000 Server. Русская версия 960 с. Андреев А. и др. Новые технологии Windows 2000 576 с. Андреев А. и др. Microsoft Windows 2000 Server и Professional. 1056 с. Русские версии Ахаян P. Macromedia ColdFusion 672 с. Браун М. HTML 3.2 {с компакт-диском) 1040 с. Вебер Дж. Технология Java (с компакт-диском) 1104 с. Власенко С. Компакт-диск с примерами к книгам серии 32 с, "В подлиннике": "MS Office XP в целом", "MS Access 2002", "MS Word 2002", "MS Excel 2002" Власенко С. Microsoft Word 2002 992 c. Гофман В., Хомоненко A. Delphi 6 1152с. Долженков В. MS Excel 2002 1072 с Закер К. Компьютерные сети. Модернизация и поиск неисправностей 1008 с. Колесниченко О., Шишигин И. Аппаратные средства PC, 1024 с. 4-е издание Мамаев Е. MS SQL Server 2000 1280 с. Матросов А. и др. HTML 4.0 672 с. Михеева В., Харитонова И. Microsoft Access 2000 1088 с. Михеева В., Харитонова И. Microsoft Access 2002 1040 с. Новиков Ф., Яценко A. Microsoft Office 2000 в целом 728 с. Новиков Ф., Яценко A. Microsoft Office XP в целом 928 с. Ноутон П., Шилдт Г. Java 2 1072 с. Пауэлл Т. Web-дизайн 1024 с. Персон P. Word 97 1120с. ПитцМ.,КиркЧ. XML 736с. Пономаренко С. Adobe Illustrator 9.0 608 с. Пономаренко С. Adobe Photoshop 6.0 832 с. Пономаренко С. CorelDRAW 9 576 с. Пономаренко С. Macromedia FreeHand 9 432 с. Русеев С. WAP: технология и приложения 432 с. Секунов Н. Обработка звука на PC (с дискетой) 1248 с. Сузи P. Python (с компакт-диском} 768 с. Тайц А. М., Тайц A. A. Adobe PageMaker 7.0 784 с. Тайц А. М., Тайц A. A. Adobe InDesign 704 с. Тайц А. М., Тайц A. A. CorelDRAW 9: все программы пакета 1136 с. Тайц А. М., Тайц A. A. CorelDRAW 10: все программы пакета 1136с. Тихомиров Ю. Microsoft SQL Server 7.0 720 с.
Уильяме Э. и др. Active Server Pages (с компакт-диском} 672 с, Усаров Г. Microsoft Outlook 2002 656 с. Ханкт Ш. Эффекты CorelDRAW (с компакт-диском) 704 с. Серия "Мастер" CD-ROM с примерами к книгам "Ресурсы MS Windows NT Server 4.0" и "Сетевые средства Windows NT Server 4" Microsoft Press. Электронная коммерция. 368 с. В2В-программирование (с компакт-диском) Microsoft Press. Visual Basic 6.0 992 с. Microsoft Press. Ресурсы MS Windows NT Server 4.0 752 c. Айзеке С. Dynamic HTML (с компакт-диском) 496 с. Анин Б. Защита компьютерной информации 384 с. Асбари С. Корпоративные решения на базе Linux 496 с. Березин С. Факс-модемы: выбор, подключение, 256 с. выход в Интернет Березин С. Факсимильная связь в Windows 250 с. Борн Г. Реестр Windows 98 (с дискетой) 496 с. Бухвалов А. и др. Финансовые вычисления для профессионалов 320 с. Валиков А. Технология XSLT 432 с, Габбасов Ю. Internet 2000 448 с. Гарбар П. Novell GroupWise 5.5: система электронной почты 480 с. и коллективной работы Гарнаев A. Microsoft Excel 2000: разработка приложений 576 с. Гарнаев A. Excel, VBA, Internet в экономике и финансах 816 с. Гарнаев А., Гарнаев С. Web-программирование на Java и JavaScript 1040 с. Гордеев О. Программирование звука в Windows (с дискетой) 384 с, Гофман В., Хомоненко А. Работа с базами данных в Delphi 656 с. Дарахвелидзе П. и др. Программирование в Delphi 5 (с дискетой) 784 с. Дронов В. JavaScript в Web-дизайне 880 с. Дубина А. и др. MS Excel в электронике и электротехнике 304 с. Дубина А. Машиностроительные расчеты в среде 416 с. Excel 97/2000 {с дискетой) Дунаев С. Технологии Интернет-программирования 480 с. Жарков С. Shareware: профессиональная разработка 320 с. и продвижение программ Зима В. и др. Безопасность глобальных сетевых технологий 320 с. Киммел П. Borland C++ 5 976 с. Костарев А. РНР в Web-дизайне 592 с. Краснов М. DirectX. Графика в проектах Delphi (с компакт-диском) 416 с. Краснов М. Open GL в проектах Delphi (с дискетой) 352 с. Кубенский А. Создание и обработка структур данных в примерах 336 с. на Java Кулагин Б. 3ds max 4: от объекта до анимации 448 с. Купенштейн В. MS Office и Project в управлении и делопроизводстве 400 с. Куприянов М. и др. Коммуникационные контроллеры фирмы Motorola 560 с. Лавров С. Программирование. Математические основы, средства, теория 304 с. Лукацкий А. Обнаружение атак 624 с.
Матросов A. Maple 6. Решение задач высшей математики 528 с. и механики Медведев Е., Трусова В. "Живая" музыка на PC (с дискетой) 720 с. Мешков А., Тихомиров Ю. Visual C++ и MFC, 1040 с. 2-е издание (с дискетой) Миронов Д. Создание Web-страниц в MS Office 2000 320 с. Мещеряков Е,, Хомоненко А. Публикация баз данных 560 с. а Интернете Михеева В., Харитонова И. Microsoft Access 2000: разработка приложений 832 с, Новиков Ф. и др. Microsoft Office 2000: разработка приложений 680 с. Нортон П. Разработка приложений в Access 97 (с компакт-диском) 656 с. Одинцов И. Профессиональное программирование. 512 с. Системный подход Олифер В., Олифер Н. Новые технологии и оборудование IP-сетей 512 с. Подольский С. и др. Разработка интернет-приложений 432 с. в Delphi {с дискетой) Полещук Н. Visual LISP и секреты адаптации AutoCAD 576 с. Понамарев В. СОМ и ActiveX в Delphi 320 с. Пономаренко С. Adobe InDesign: дизайн и верстка 544 с. Попов А. Командные файлы и сценарии Windows Scripting Host 320 с. Приписное Д. Моделирование в 3D Studio MAX 3.0 352 с. (с компакт-диском) Роббинс Дж. Отладка приложений 512 с. Рудометов В., Рудометов Е. PC: настройка, оптимизация и разгон, 336 с. 2-е издание Русеев Д. Технологии беспроводного доступа. Справочник 352 с. Соколенке П. Программирование SVGA-графики для IBM 432 с. Тайц А. Каталог Photoshop Plug-Ins 464 с. Тихомиров Ю. MS SQL Server 2000: разработка приложений 368 с. Тихомиров Ю. SQL Server 7.0: разработка приложений 370 с. Тихомиров Ю. Программирование трехмерной графики 256 с. в Visual C++ (с дискетой) Трельсен Э. Модель СОМ и библиотека ATL 3.0 (с дискетой) 928 с. Федоров А., Елманова Н. ADO в Delphi {с компакт-диском) 816 с. Федорчук А. Офис, графика, Web в Linux 416 с. Чекмарев A. Windows 2000 Active Directory 400 с. Чекмарев А. Средства проектирования на Java (с компакт-диском) 400 с. Шапошников И. Web-сайт своими руками 224 с. Шапошников И. Интернет-программирование 224 с. Шапошников И. Справочник Web-мастера. XML 304 с. Шилдт Г. Теория и практика C++ 416 с. Яцюк О., Романычева Э. Компьютерные технологии 464 с. в дизайне. Логотипы, упаковка, буклеты (с компакт-диском) Серия "Изучаем вместе с BHV" Березин С. Internet у вас дома, 2-е издание 752 с. Тайц A. Adobe Photoshop 5.0 {с дискетой) 448 с.
Серия "Самоучитель" Ананьев А., Федоров А, Самоучитель Visual Basic 6.0 624 с. Васильев В. Основы работы на ПК 448 с. Гарнаев А. Самоучитель VBA 512 с. Герасевич В. Самоучитель. Компьютер для врача 640 с. Дмитриева М. Самоучитель JavaScript 512 с. Долженков В. Самоучитель Excel 2000 {с дискетой) 368 с. Исагулиев К. Macromedia Dreamweaver 4 560 с. Исагулиев К. Macromedia Flash 5 368 с. Кетков Ю., Кетков А. Практика программирования: Бейсик, Си, Паскаль 480 с. (с дискетой) Кирьянов Д. Самоучитель Adobe Premiere 6.0 432 с. Кирьянов Д. Самоучитель MathCAD 2001 544 с. Коркин И. Самоучитель Microsoft Internet Explorer 6.0 288 с. Котеров Д. Самоучитель РНР 4 576 с. Культин Н. Программирование на Object Pascal 528 с. в Delphi 6 (с дискетой} Культин Н. Самоучитель. Программирование 416 с. в Turbo Pascal 7.0 и Delphi, 2-е издание (с дискетой) Леоненков А. Самоучитель UML 304 с. Матросов А., Чаунин М. Самоучитель Perl 432 с. Омельченко Л., Федоров А. Самоучитель Microsoft FrontPage 2002 576 с. Омельченко Л., Федоров А. Самоучитель Windows 2000 Professional 528 с. Омельченко Л., Федоров А. Самоучитель Windows Millennium 464 с. Пекарев Л. Самоучитель 3D Studio MAX 4.0 370 с. Полещук Н. Самоучитель AutoCad 2000 и Visual LISP, 672 с. 2-е издание Полещук Н. Самоучитель AutoCAD 2002 608 с. Понамарев В. Самоучитель Kylix 416 с. Секунов Н. Самоучитель Visual C++ 6 (с дискетой) 960 с. Секунов Н. Самоучитель С# 576 с. Сироткин С. Самоучитель WML и WMLScript 240 с. Тайц А. М., Тайц А. А. Самоучитель Adobe Photoshop 6 608 с. (с дискетой) Тайц А. М., Тайц А. А. Самоучитель CorelDRAW 10 640 с. Тихомиров Ю. Самоучитель MFC (с дискетой) 640 с. Хабибуллин И. Самоучитель Java 464 с. Хомоненко А. Самоучитель Microsoft Word 2002 624 с. Шапошников И. Интернет. Быстрый старт 272 с. Шапошников И. Самоучитель HTML 4 288 с. Шилдт Г. Самоучитель C++, 3-е издание (с дискетой) 512 с. Серия "Компьютер и творчество" Деревских В. Музыка на PC своими руками 352 с. Дунаев В. Сам себе Web-дизайнер 512 с. Дунаев В. Сам себе Web-мастер 288 с.
Людиновсков С. Музыкальный видеоклип своими руками 320 с. Петелин Р., Петелин Ю. Аранжировка музыки на PC 272 с. Петелин Р., Петелин Ю. Звуковая студия в PC 256 с. Петелин Р., Петелин Ю. Музыка на PC. Cakewalk Pro Audio 9. Секреты 420 с. мастерства Петелин Р., Петелин Ю. Музыка на PC, Cakewalk. 272 с. "Примочки" и плагины Петелин Р., Петелин Ю. Музыкальный компьютер. 608 с. Секреты мастерства Петелин Р., Петелин Ю. Персональный оркестр в PC 240 с. Серия "Учебное пособие" Бенькович Е. Практическое моделирование динамических систем 464с. (с компакт-диском) Гомоюнов К. Транзисторные цепи 240 с, Дорот В. Толковый словарь современной компьютерной лексики, 512 с. 2-е издание Культин Н, C/C++ в задачах и примерах 288 с. Культин Н, Turbo Pascal в задачах и примерах 256 с. Порев В. Компьютерная графика 432 с. Робачевскмй Г. Операционная система Unix 528 с. Сафронов И. Бейсик в задачах и примерах 224 с. Солонина А, и др. Алгоритмы и процессоры цифровой обработки сигналов 464 с. Солонина А, и др. Цифровые процессоры обработки сигналов фирмы 512 с. MOTOROLA Угрюмов Е. Цифровая схемотехника 528 с. Шелест В. Программирование 592 с. Серия "Знакомьтесь" Надеждин Н, Карманные компьютеры 304 с. Надеждин Н. Портативные компьютеры 288 с. Надеждин Н. Знакомьтесь, цифровые фотоаппараты 304 с. Серия "Быстрый старт" Васильева В. Персональный компьютер. Быстрый старт 480 с. Гофман В., Хомоненко A. Delphi. Быстрый старт 288 с. Дмитриева М. JavaScript. Быстрый старт 336 с. Культин Н. Microsoft Excel. Быстрый старт 208 с. Хомоненко А., Гридин В. Microsoft Access, Быстрый старт 304 с.