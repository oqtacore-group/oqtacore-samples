 Лекции 3-4. Алгоритмы геометрического поиска
Задача поиска
Задача поиска в общей абстрактной форме: есть набор данных, именуемый файлом, и некоторый новый элемент данных, именуемый образцом, нужно установить связь между образцом и файлом. 
Пример - задача двоичного поиска числа x в отсортированном по возрастанию массиве a[0..n]. Алгоритм двоичного поиска использует упорядоченность элементов массива. Для заданного подмассива a[n1..n2] ключ поиска x сравнивается с элементом a[m], расположенным примерно посредине между n1 и n2. Если x не больше, чем a[m], то двоичный поиск рекурсивно продолжается в левом подмассиве a[n1..m], в противном случае (при x больше a[m]) рекурсивный двоичный поиск продолжается для правого подмассива a[m+1..n2]. В конечной ситуации n1=n2 и возвращается значение n1, если x=a[n1] , или -1, если x(a[n1].
Алгоритм двоичного поиска в отсортированном массиве
 FUNCTION BinarySearch(x:INTEGER; a:SortArray; 
n1,n2:INTEGER): INTEGER;
VAR m: INTEGER;
BEGIN
  IF n1=n2 THEN
    IF a[n1]=x THEN Result:=n1
    ELSE Result:=-1
  ELSE
  BEGIN 
    m:=(n1+n2) DIV 2;
    IF (x<=a[m]) THEN Result:=BinarySearch(x,a,n1,m)
    ELSE Result:=BinarySearch(x,a,m+1,n2)        
  END ;
 END ;
Двоичный поиск числа x в массиве a[0..n] осуществляется обращением к функции 
 i:= BinarySearch(x,a,0,n);
 Время работы двоичного поиска в наихудшем случае определяется рекуррентным соотношением 
 T(n)= 2T(n/2)+a       при  n ( 1 
 T(n)=b                     при n=1
Нетрудно показать, аналогично тому, как это делалось для алгоритма сортировки массива, что T(n) ( ( (log n).
Геометрический поиск
Геометрический поиск имеет особенности, связанные со специфическим характером данных. Во-первых, они отображают сложные структуры (полигоны, полиэдры и т.п.), а во вторых, результатом поиска может оказаться не элемент файла, а положение образца относительно файла.
Поисковое сообщение, в соответствии с которым ведется просмотр файла, называется запросом. Разовый запрос называется уникальным. Запросы, обработка которых повторяется многократно на одном и том же файле, называются массивом. В последнем случае, возможно, стоит расположить информацию в виде структуры, облегчающей поиск. Анализ требуемого ресурса оценивается по четырем критериям:
1) Время запроса. Сколько времени необходимо на один запрос? 
2) Память. Сколько памяти необходимо для структуры данных?
3)Время предобработки. Сколько времени необходимо для организации данных перед поиском?
4) Время корректировки. Сколько времени потребуется на включение элемента данных в структуру или на удаление их нее?
Главные модели геометрического поиска:
А) Задача локализации, когда файл представляет собой разбиение геометрического пространства на области, а запрос является точкой. Нужно определить область, содержащую эту точку.
В) Задача регионального поиска. Файл содержит набор точек пространства, а запрос есть некоторая стандартная геометрическая фигура, произвольно перемещаемая в этом пространстве. Нужно извлечь (задача отсчета) или подсчитать (задача подсчета) все точки внутри запросной области.
Локализация точки в простом многоугольнике при уникальном запросе
Простой многоугольник - не имеющий самопересечений. 
Задача 1 (Принадлежность точки простому многоугольнику). Даны простой многоугольник  P  и точка  z . Определить, находится ли  z  внутри  P .
Рассмотрим случай уникального запроса.
Проведем через точку  z  горизонталь  l . Если  l  не пересекает  P , то  z  - внешняя точка. Пусть теперь  l  пересекает  P . 
Рассмотрим сначала случай, когда  l  не проходит через вершины  P . Пусть  L  - число точек пересечения  l  с границей  P  левее  z . Поскольку  P  ограничен, левый конец  l  лежит вне  P . Двигаясь из -( направо, при первом пересечении границы попадаем внутрь  P , при втором - выходим наружу из  P , при третьем - снова внутрь и т.д. Поэтому  z  лежит внутри  P  тогда и только тогда, когда  L  нечетно. 
Теперь рассмотрим вырожденный случай, когда  l  проходит через вершины  P . Бесконечно малый поворот  l  вокруг  z  против часовой стрелки не изменит локализации точки, но устранит вырожденность. Теперь видно следующее. Если обе вершины ребра, принадлежат  l , то его не следует учитывать. Если же только одна вершина ребра лежит на  l , то пересечение следует учесть, если это вершина с большей ординатой, и игнорировать в противном случае.
Алгоритм локализации точки в простом многоугольнике
 BEGIN L:=0;
  FOR i:=1 TO N DO (*  цикл по всем ребрам  *) 
  IF  (ребро( i ) не горизонтально) 
      AND  (ребро( i ) пересекает  l  нижним концом слева от  z ) 
      THEN L:=L+1; 
  IF (L  нечетно ) THEN z  внутри  ELSE z  снаружи ;
END ;
Очевидно, что требуемое время выполнения этого алгоритма - O( n ), где  n  - число вершин многоугольника. Таким образом, доказана 
Теорема. Принадлежность точки внутренней области простого  n -угольника можно установить за время  O ( n ) без предобработки.
Локализация точки в выпуклом многоугольнике при массовом запросе
Выпуклый многоугольник - целиком лежащий по одну сторону относительно любого своего ребра.
Задача 2 (Принадлежность точки выпуклому многоугольнику). Даны выпуклый многоугольник  P  и точка  z . Определить, находится ли  z  внутри  P .
Рассматривается случай массового запроса.
Вершины выпуклого многоугольника упорядочены по полярным углам относительно любой внутренней точки. В качестве таковой можно взять, например, середину любой диагонали (если вершин больше трех), либо центр тяжести любого треугольника, образованного вершинами полигона. Обозначим эту внутреннюю точку  q . 
Рассмотрим  n  лучей, выходящих из  q  и проходящих через вершины многоугольника  P . Эти лучи разбивают плоскость на  n  клиньев, а каждый клин разбивается ребром полигона на две части. Одна из этих частей лежит целиком внутри полигона, а другая - целиком снаружи. Таким образом мы можем сначала отыскать клин, в котором лежит точка  z , а затем сравнить  z  с единственным ребром, разделяющим этот клин. Поиск клина, содержащего  z , выполняется методом двоичного поиска.
Таким образом, нужно выполнить предобработку, которая состоит в следующем. Нужно найти точку  q  и расположить вершины полигона в какой-нибудь структуре данных, пригодной для двоичного поиска. В качестве такой структуры подойдет вектор, компонентами которого являются вершины, перечисленные в направлении против часовой стрелки ( p 0, p 1,., pn ), причем  p 0= pn . 
Проверка попадания точки  z  в клин, определяемый углом ( pi , q , pj ), осуществляется следующим образом. Если этот угол меньше (, то достаточно убедиться, что углы ( pi , q , z ) и ( z , q , pj ) положительны. Если же угол (pi,q,pj) больше (, то точка z попадает в него, если она не попадает в угол (pj,q,pi). Знак угла (p,q,r) совпадает со знаком векторного произведения направляющих векторов его сторон [(q,p)((q,r)].
Алгоритм локализации точки в выпуклом многоугольнике 
 TYPE Vector = ARRAY [0..n] OF Point;
VAR P: Vector;
    q: Point; (* q.x:=P[0].x+P[1].x+P[2].x;
                 q.y:=P[0].y+P[1].y+P[2].y; *)

FUNCTION PositivAngle(p,q,r: Point): BOOLEAN;
VAR ax,ay,bx,by: DOUBLE;
BEGIN
  ax:=p.x-q.x; ay:=p.y-q.y;
  bx:=r.x-q.x; by:=r.y-q.y;
  Result:=(ax*by-ay*bx>=0); 
END;

FUNCTION FindAngle(P: Vector; q,z: Point): INTEGER;
VAR m: INTEGER; 
BEGIN  
  n1:=0; n2:=n;
  WHILE (n2-n1>1) DO
  BEGIN
    m:=n DIV 2; 
    IF PositivAngle(P[n1],q,P[m]) THEN 
       IF PositivAngle(P[n1],q,z) 
          AND PositivAngle(z,q,P[m]) THEN n2:=m
       ELSE n1:=m
    ELSE
       IF PositivAngle(P[m],q,z) 
          AND PositivAngle(z,q,P[n2]) THEN n1:=m
       ELSE n2:=m;
    Result:=n1;
  END;

 FUNCTION PointInTriangle(q,p,r,z: Point): BOOLEAN;
 BEGIN
   Result:=(PositivAngle(q,p,r)=PositivAngle(z,p,r));
 END;

 FUNCTION PointInConvexPolygon(P: Vector; q,z: Point): BOOLEAN;
 VAR i: INTEGER;
 BEGIN 
   i:=FindAngle(P,q,z);
   Result:=PointInTriangle(q,P[i],P[i+1],z);
 END ;  
Предобработка в этом алгоритме состоит в поиске точки  q  и в размещении полигона в векторе, что требует время  O ( n ). Выполнение запроса требует для поиск сектора, содержащего точку  z , времени  O ( log n ) и постоянного времени для локализации точки внутри треугольника в секторе  O (1). Значит, общие затраты на запрос составляют  O ( n ). Следовательно, справедлива  
Теорема. Время ответа на запрос о принадлежности точки выпуклому  n -угольнику равно  O ( log n )  при затратах  O ( n ) памяти и  O ( n ) времени на  предобработку.
Планарные графы 
Граф  G =( V , E ) (где  V  - множество вершин, а  E  - множество ребер) называется планарным, если его можно уложить на плоскости без самопересечений. Плоская укладка планарного графа - это отображение каждой вершины из  V  в точку на плоскости, а каждого ребра из  E  - в простую линию, соединяющую пару образов концевых вершин этого  ребра так, чтобы образы ребер пересекались только в своих концевых точках. Известно, что любой планарный граф можно уложить на плоскости так, чтобы все ребра отобразились в прямолинейные отрезки.
Прямолинейная укладка плоского графа определяет разбиение плоскости, называемое планарным подразбиением или картой. Плоскость разбивается на связные области, называемые гранями. 
Пусть в планарном подразбиении  v  - число вершин,  e  - число ребер,  f  - число граней (включая единственную бесконечную грань такого подразбиения). Справедлива следующая классическая 
Теорема Эйлера. В планарном подразбиении связного графа  v - e + f =2.
Доказательство.
Рассмотрим последовательно графы  G 0,  G 1,  G 2, ., G , образованные из вершин и ребер графа G по следующему правилу. Граф G0 состоит из одной вершины. Граф G1 получается из G0 добавлением одного ребра, инцидентного этой вершине, и второй вершины этого ребра. Далее граф Gk+1 получается из графа Gk добавлением одного ребра такого, что хотя бы одна его вершина принадлежит Gk, и второй вершины этого ребра (если она еще не принадлежала Gk).
Для графа G0 имеем v0=1, e0=0, f0=1 - утверждение теоремы справедливо v0-e0+f0=2. Пусть для Gk оно справедливо vk-ek+fk=2. Покажем, что тогда и для Gk+1 оно тоже выполняется. Рассмотрим два возможных случая положения нового ребра, вошедшего в Gk+1 и отсутствующего в Gk. Одна вершина этого ребра принадлежит Gk. 
Рассмотрим сначала случай, когда вторая вершина, инцидентная этому ребру, не прнадлежит Gk. Тогда число ребер в Gk+1 по сравнению с Gk увеличивается на 1, число вершин - тоже на 1, а число граней остается прежним, т.е. имеет место 
 vk+1- ek+1+ fk+1= (vk+1)-(ek+1)+fk=2 
 и утверждение теоремы выполняется.
Теперь рассмотрим второй случай, когда вторая вершина вводимого в Gk+1 ребра также как и первая принадлежит Gk. В этом случае ребро делит какую-то грань карты Gk на две грани. Поэтому vk+1=vk, ek+1=ek+1, fk+1=fk+1 и 
 vk+1- ek+1+ fk+1= vk-(ek+1)+(fk+1)=2,
 что и завершает доказательство теоремы.
Степенью (( a ) вершины  a  называется число ребер, инцидентных этой вершине.
Теорема. В планарном подразбиении связного графа, у которого степень каждой вершины не менее 3, выполняются следующие неравенства:
 1) v ( e, 	2) e ( 3v-6,
3) e ( 3f-6,	4) f ( e,
5) v ( 2f-4, 	6) f ( 2v-4.
 Доказательство.
Докажем неравенство 1. 
Из определения степени вершины и из условия теоремы следует, откуда получаем требуемое неравенство.
Следствие. Величины  v , e , f  асимптотически попарно пропорциональны.
Локализация точки в планарном подразбиении
Планарный граф, уложенный на плоскости так, что все его ребра являются прямолинейными отрезками, называется  плоским прямолинейным графом (ППЛГ). Любой ППЛГ задает подразбиение плоскости на простые многоугольники. Будем рассматривать далее связные ППЛГ, у которых нет вершин степени меньше 2. Тогда согласно предыдущему разделу общее число ребер в ППЛГ составит величину  O ( n ).
Задача локализации точки в ППЛГ состоит в поиске многоугольника, содержащего эту точку. Методы локализации основаны на идее создания новых геометрических объектов, допускающих двоичный поиск. В качестве примера метода решения задачи рассмотрим метод полос.
Пусть задан ППЛГ  G ,  имеющий  n  вершин. Тогда согласно предыдущему разделу общее число ребер в ППЛГ составит величину  O ( n ). Проведем горизонтальные прямые через каждую его вершину. Они разделяют плоскость на  n +1 горизонтальных полос. Если провести сортировку этих полос по координате  y  на этапе предобработки, то появится возможность найти ту полосу, в которой лежит пробная точка, за время  O ( log n ).
Рассмотрим пересечение одной из полос с графом  G . Оно состоит из отрезков ребер графа  G . Эти отрезки определяют множество трапеций и треугольников. Эти отрезки можно упорядочить в каждой полосе слева направо и использовать двоичный поиск для нахождения трапеции или треугольника, содержащего пробную точку. Таким образом, можно обеспечить время запроса  O ( log n ). Однако затраты памяти для размещения информации о полосах составят  O ( n 2). Соответствующий случай иллюстрируется следующим ППЛГ.
Простая реализация идеи метода полос состоит в сортировке трапеций и треугольников в каждой полосе. Поскольку количество полос  O ( n ), а в каждой полосе число трапеций составляет также  O ( n ), получаем, что общее время составит  O ( n 2  log n ). Однако существует более экономичный алгоритм, позволяющий сократить время предобработки до O(n2) [Препарата, Шеймос, стр.64-66]. 
Таким образом, метод полос позволяет сформулировать следующее утверждение.
Теорема. Локализация точки в n-вершинном ППЛГ реализуется за O(log n)  время с использованием O(n2) памяти, если O(n2) времени ушло на предобработку.
Данный результат не является пределом. Следует упомянуть замечательный алгоритм Киркпатрика, описанный там же (стр.75-79), обеспечивающий тоже логарифмическое время запроса при памяти O(n) и времени предобработки  O ( n log n ).



 P
 
 z
 
 l
 
 P
 
 p0
 
 p1
 
 p2
 
 pn
 
 pn-1
 
 pn-2
 
 q
 
 pm
 
Число отрезков в полосе

12

10

6

4

2

8



