
В 
http://ru.wikipedia.org/wiki/19671967 году 
http://ru.wikipedia.org/w/index.php?title=%D0%92%D0%B8%D1%82%D0%B5%D1%80%D0%B1%D0%B8&action=editВитерби разработал и проанализировал 
http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BCалгоритм, в котором, по сути, реализуется декодирование, основанное на 
http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%B0%D0%B2%D0%B4%D0%BE%D0%BF%D0%BE%D0%B4%D0%BE%D0%B1%D0%B8%D1%8Fпринципе максимального правдоподобия; однако в нем уменьшается вычислительная нагрузка за счет использования особенностей структуры конкретной решетки 
http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4кода. Преимущество декодирования Витерби, по сравнению с декодированием по методу полного перебора, заключается в том, что сложность декодера Витерби не является функцией количества символов в последовательности 
http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%BE%D0%B2%D0%BE%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%BEкодовых слов. Алгоритм включает в себя вычисление меры подобия (или расстояния), между 
http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BBсигналом, полученным в момент времени tI, и всеми путями решетки, входящими в каждое состояние в момент времени ti. В алгоритме Витерби не рассматриваются те пути решетки, которые, согласно принципу максимального правдоподобия, заведомо не могут быть оптимальными. Если в одно и то же состояние входят два пути, выбирается тот, который имеет лучшую 
http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0метрику; такой путь называется выживающим. Отбор выживающих путей выполняется для каждого состояния. Таким образом, декодер углубляется в решетку, принимая решения путем исключения менее вероятных путей. Предварительный отказ от маловероятных путей упрощает процесс декодирования. В 
http://ru.wikipedia.org/wiki/19691969 году 
http://ru.wikipedia.org/w/index.php?title=%D0%9E%D0%BC%D1%83%D1%80%D0%B0&action=editОмура (Omura) показал, что основу алгоритма Витерби составляет оценка максимума правдоподобия. Отметим, что задачу отбора оптимальных путей можно выразить как выбор кодового слова с максимальной метрикой правдоподобия или минимальной метрикой расстояния.
Сущность метода
Наилучшей схемой декодирования корректирующих кодов, является декодирование методом максимального правдоподобия, когда декодер определяет набор условных вероятностей P(r / Ui), соответствующих всем возможным кодовым векторам Ui, и решение принимает в пользу кодового слова, соответствующего максимальному P(r / Ui). Для двоичного симметричного канала без памяти (канала, в котором вероятности передачи 0 и 1, а также вероятности ошибок вида 0 -> 1 и 1 -> 0 одинаковы, ошибки в j-м и i-м символах кода независимы) декодер максимального правдоподобия сводится к декодеру минимального хеммингова расстояния. Последний вычисляет 
http://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%A5%D0%B5%D0%BC%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0расстояние Хемминга между принятой последовательностью r и всеми возможными кодовыми векторами Ui и выносит решение в пользу того вектора, который оказывается ближе к принятому. Естественно, что в общем случае такой декодер оказывается очень сложным и при больших размерах кодов n и k практически нереализуемым. Характерная структура сверточных кодов (повторяемость структуры за пределами окна длиной n) позволяет создать вполне приемлемый по сложности декодер максимального правдоподобия.
Принцип работы декодера
На вход декодера поступает сегмент последовательности r длиной b, превышающей кодовую длину блока n. Назовем b окном декодирования. Сравним все кодовые слова данного кода (в пределах сегмента длиной b) с принятым словом и выберем кодовое слово, ближайшее к принятому. Первый информационный кадр выбранного кодового слова примается в качестве оценки информационного кадра декодированного слова. После этого в декодер вводится n0 новых символов, а введенные ранее самые старые n0 символов сбрасываются, и процесс повторяется для определения следующего информационного кадра. Таким образом, декодер Витерби последовательно обрабатывает кадр за кадром, двигаясь по решетке, аналогичной используемой кодером. В каждый момент времени декодер не знает, в каком узле находится кодер, и не пытается его декодировать. Вместо этого декодер по принятой последовательности определяет наиболее правдоподобный путь к каждому узлу и определяет расстояние между каждым таким путем и принятой последовательностью. Это расстояние называется мерой расходимости пути. В качестве оценки принятой последовательности выбирается сегмент, имеющий наименьшую меру расходимости. Путь с наименьшей мерой расходимости называется выжившим путем.
Пример
Схема кодера
Решетчатая диаграмма кодера
Рассмотрим работу декодера Витерби па простом примере. Полагаем, что кодирование производится с использованием сверточного (7,5)-кода. Пользуясь решетчатой диаграммой кодера, попытаемся, приняв некоторый сегмент r, проследить наиболее вероятный путь кодера. При этом для каждого сечения решетчатой диаграммы будем отмечать меру расходимости пути к каждому ее узлу. Предположим, что передана кодовая последовательность U = (00000000.), а принятая последовательность имеет вид r = (10001000.), то есть в первом и в третьем кадрах кодового слова возникли ошибки. Как мы уже убедились, процедура и результат декодирования не зависят от передаваемого кодового слова и определяются только ошибкой, содержащейся в принятой последовательности. Поэтому проще всего считать, что передана нулевая последовательность, то есть U = (00000000.). Приняв первую пару символов (10), определяется мера расходимости для первого сечения решетки, приняв следующую пару символов (00), - для второго сечения и т.д. При этом из входящих в каждый узел путей оставляем путь с меньшей расходимостью, поскольку путь с большей на данный момент расходимостью уже не сможет стать в дальнейшем короче. Заметим, что для рассматриваемого примера начиная с четвертого уровня метрика (или мера расходимости) нулевого пути меньше любой другой метрики. Поскольку ошибок в канале больше не было, ясно, что в конце концов в качестве ответа будет выбран именно этот путь. Из этого примера также видно, что выжившие пути могут достаточно долго отличаться друг от друга. Однако па шестом-седьмом уровне первые семь ребер всех выживших путей совпадут друг с другом. В этот момент согласно алгоритму Витерби и принимается решение о переданных символах, так как все выжившие пути выходят из одной вершины, т.е. соответствуют одному информационному символу.
Процесс декодирования
Глубина, на которой происходит слияние выживших путей, не может быть вычислена заранее; она является случайной величиной, зависящей от кратности и вероятности возникающих в канале ошибок. Поэтому па практике обычно не ждут слияния путей, а устанавливают фиксированную глубину декодирования.
На шаге i) степень различия метрик правильного и неправильного путей достаточно велика (dcorrect = 2, derror = 4), то есть в данном случае можно было бы ограничить глубину декодирования величиной b < = 6. Но иногда более длинный к данному сечению путь может оказаться в конечном итоге самым коротким, поэтому особенно увлекаться уменьшением размера окна декодирования b с целью упрощения работы декодера не стоит. На практике глубину декодирования обычно выбирают в диапазоне n < b < n + l, где l - число исправляемых данным кодом ошибок. Несмотря на наличие в принятом фрагменте двух ошибок, его декодирование произошло без ошибки и в качестве ответа будет принята переданная нулевая последовательность.
Сверточные коды
Сверточные коды относятся к непрерывным рекуррентным кодам. Кодовое слово является сверткой отклика линейной системы (кодера) на входную информационную последовательность. Поэтому сверточные коды являются линейными, для которых сумма любых кодовых слов также является кодовой последовательностью.
Ограничимся ниже рассмотрением лишь наиболее характерных (базовых, или материнских) для мобильной связи сверточных кодов со скоростями вида  Rk  = 1/ n 0, где  n 0 - некоторое натуральное число
file:///C:\\DOCUME%7E1\\nik\\LOCALS%7E1\\Temp\\svert_cod.html" \l "_ftn1" \o "[1]. Последовательность символов такого сверточного кода состоит из элементарных блоков длиной n0, причем n0 символов текущего блока (занимающие реальное время, отвечающее одному информационному биту) являются линейной комбинацией текущего информационного бита и т предшествующих. Значение т определяет память кода, а параметр m + 1 называется длиной кодового ограничения
file:///C:\\DOCUME%7E1\\nik\\LOCALS%7E1\\Temp\\svert_cod.html" \l "_ftn2" \o "[2]. Если один (например, первый) из n0 символов текущего блока повторяет текущий информационный бит, код называется систематическим.
Способы задания сверточных кодов во многом совпадают с используемыми для линейных блоковых. Одним из основных является описание сверточного кода набором  n 0 порождающих многочленов. Каждый многочлен устанавливает закон формирования одного из  n 0 символов в группе и имеет степень, не превышающую т. Ненулевые коэффициенты порождающего полинома прямо указывают, какие из информационных символов (включая текущий и т предыдущих) входят в линейную комбинацию, дающую данный символ кода (см. пример 1). Порождающие многочлены хороших сверточных кодов найдены перебором и табулированы [44].
Весьма важным с точки зрения понимания алгоритмов кодирования и декодирования инструментом описания сверточных кодов является кодовая решетка, смысл которой должен быть ясен из следующего примера.
Пример 1 (см. [44]). Пусть несистематический сверточный код со скоростью  Rk  =1/2 и кодовым ограничением  m  + 1 = 3 задается порождающими многочленами
g 1(х) = х2+х + 1 и  g 2(х) = х2+1.
Это означает, что первый из двух символов каждого двухсимвольного блока является линейной комбинацией (суммой по модулю 2) текущего и двух предшествующих информационных битов, тогда как второй получается сложением по модулю 2 текущего информационного бита с тем, который поступил от источника двумя тактами раньше.
Схема кодера приведена на Рис.2. Заметим, что при одном из многочленов, равном единице, получился бы систематический сверточный код.
 
Рис. 2. Схема кодера 
 
Кодовая решетка этого кода показана на рис. 3. При ее составлении учтено, что кодер содержит память в виде двухразрядного сдвигающего регистра. Каждому из четырех возможных состояний этого регистра отвечает один из четырех узлов решетки. Поэтому левый символ в обозначении узла равен последнему информационному биту, уже записанному в регистр. При записи в регистр очередного информационного символа регистр меняет состояние на одно из двух соседних. Этот переход обозначен ребрами решетки. Порядок узлов выбран таким, что при нулевом текущем информационном символе (а,=0) переход в следующее состояние соответствует верхнему ребру, а при а i  = 1 - нижнему. Маркировка ребер воспроизводит  n 0-блок, посылаемый
 
Рис.3. Кодовая решетка 
 
в канал. Каждой информационной последовательности соответствует определенный путь на кодовой решетке и кодовая последовательность, считываемая как метки, маркирующие последовательные ребра пути. К примеру, входным информационным битам 01100 отвечает кодовое слово 00 11 01 01 11, которому соответствует на рис. 3 путь, отмеченный жирной линией.
 
 
Известен ряд алгоритмов декодирования сверточных кодов. В практических системах и, в частности в мобильной связи, как правило, используется алгоритм Витерби, отличающийся простотой реализации при умеренных длинах кодового ограничения.
file:///C:\DOCUME%7E1\nik\LOCALS%7E1\Temp\svert_cod.htmlВернуться наверх
 
Алгоритм Витерби 
Алгоритм Витерби реализует оптимальное (максимально правдоподобное) декодирование как рекуррентный поиск на кодовой решетке пути, ближайшего к принимаемой последовательности. На каждой итерации алгоритма Витерби сопоставляются два пути, ведущих в данное состояние (узел решетки). Ближайший из них к принятой последовательности сохраняется для дальнейшего анализа как выживший, тогда как другой отбрасывается. Таким образом, если игнорировать случаи, когда оба конкурирующих пути равноудалены от принятой последовательности (о действиях в подобной ситуации см. ниже), число выживших путей, сохраняемых в памяти, равно числу узлов 2т . Основные операции алгоритма поясним для кода из примера 1.
Пусть передается нулевое кодовое слово, а в канале произошла трехкратная ошибка, так что принятая последовательность имеет вид 10 10 00 00 10 00 ... 00 .... Результаты поиска ближайшего пути после приема 14 элементарных блоков показаны на рис. 4. Промежуточные этапы работы декодера при сделанных предположениях подробно рассмотрены в [44].
 
Рис. 4. Пример работы алгоритма Витерби 
 
На правой части рисунка видны четыре пути, ведущие в каждый узел решетки. Рядом проставлены метрики (хэмминговы расстояния этих путей от принятой последовательности на отрезке из 14 блоков). Метрика верхнего пути значительно меньше метрик нижних. Поэтому можно предположить, что верхний путь наиболее вероятен. Однако декодер Витерби, не зная следующих фрагментов принимаемой последовательности, вынужден запомнить все четыре пути на время приема  L  элементарных блоков. Число  L  называется шириной окна декодирования. Для уменьшения ошибки декодирования величину  L  следует выбирать достаточно большой, многократно превышающей длину кодового ограничения, что естественно усложняет декодер. В данном случае  L  = 15.
Отметим, что тактика выбора и последующего анализа только одного пути с наименьшим расстоянием составляет сущность более экономного последовательного декодирования.
На средней части рис. 4 видно, что все пути имеют общий отрезок (сливаются от 5-го до 12-го шага) и, следовательно, прием новых блоков не может повлиять на конфигурацию этого участка наиболее правдоподобного пути. Поэтому декодер уже может принимать решение о значении информационных символов, соответствующих этим элементарным блокам.
Левая часть рисунка демонстрирует возможную ситуацию неисправляемой ошибки. Существует два пути с одинаковыми метриками. Декодер может разрешить эту неопределенность двумя способами: отметить этот участок как недостоверный или принять одно из двух конкурирующих решений (информационная последовательность равна 00000... или 10100...). Очевидно, что расширение окна декодирования не позволяет исправить такую ошибку. Ее исправление возможно при использовании кода с большей корректирующей способностью.
Поступление из канала нового элементарного блока вызывает сдвиг картинки в окне декодирования влево. В результате левое ребро пути исчезает, а справа, появляется новый столбец решетки, к узлам которого должны быть продолжены сохраненные пути от узлов предыдущего столбца. Для этого выполняются следующие операции.
Для каждого узла нового столбца вычисляются расстояния между принятым блоком и маркировкой ребер, ведущих в данный узел.
Полученные метрики ребер суммируются с расстоянием путей, которые они продолжают.
Из двух возможных путей оставляется путь с меньшей метрикой, а другой отбрасывается, так как следующие поступающие блоки не могут изменить соотношения расстояний этих путей. В случае равенства расстояний или случайно выбирается один путь, или сохраняются оба.
В результате этих операций к каждому узлу нового столбца вновь ведет один путь. Например, пусть новый блок из канала равен 00. Рассмотрим продолжение пути к нижнему узлу решетки, в который можно попасть из состояния кодера 10 по ребру 01 или из состояния 11 по ребру 10 (см. рис.3). В обоих случаях расстояние этих ребер от принятого блока 00 равно 1. Однако суммарное расстояние пути, продолженного из состояния 10, равно 6, а пути из состояния 11 равно 7. Поэтому второй путь будет отброшен вместе с ребром 01, которое входило в нижний узел на предыдущем шаге декодирования (см. рис. 4).
Оценка информационного символа производится по крайнему левому ребру пути в окне декодирования. Согласно правилу построения кодовой решетки принимается, что информационный символ равен 0, если это ребро верхнее, и 1, если ребро нижнее.