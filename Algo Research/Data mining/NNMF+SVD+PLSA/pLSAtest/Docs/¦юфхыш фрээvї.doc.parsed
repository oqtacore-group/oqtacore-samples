 Модели данных
Модель данных ( data model ) - это совокупность структур данных и операций их обработки.
Существуют 3 уровня модели данных:
- Обобщенное (концептуальное) описание предметной области, не привязанное к каким-либо техническим средствам или СУБД (набор данных, их типов, длин, связей и т.д.). Основными конструктивными элементами модели на этом уровне являются сущности, связи между ними и их свойства (атрибуты).
- Описание на языке конкретной СУБД.
- Описание хранимых данных (физический уровень).
Эта трехуровневая архитектура позволяет обеспечить независимость хранимых данных от использующих их программ. Администратор БД может при необходимости переписать хранимые данные на другие носители информации и/или реорганизовать их  структуру, изменив лишь физическую модель данных. Он может подключить к системе любое число новых пользователей (новых приложений). Указанные изменения не будут замечены существующими пользователями системы (окажутся "прозрачными" для них), так же как не будут замечены и новые пользователи. Следовательно, независимость данных обеспечит возможность развития системы БД без разрушения существующих приложений. С помощью модели данных можно легко отобразить структуру объектов и связи, установленные между ними. Следует выделить три модели данных, наиболее важные с практической точки зрения: 
Иерархические, сетевые и реляционные СУБД. Их достоинства и недостатки
Рассмотрим в общих чертах основные виды моделей данных.
Иерархическая модель данных. Это - совокупность связанных элементов, образующих иерархическую структуру - перевернутое дерево. Иерархическая модель данных основана на понятиях уровень, узел и связь. Узлом называется совокупность атрибутов данных, описывающих некоторый объект. Каждый узел связан с одним узлом более высокого уровня и с любым количеством (в том числе, и с нулевым) узлов нижнего уровня. Исключение составляет узел наиболее высокого уровня (корень дерева), который не связан ни с одним узлом более высокого уровня. Количество деревьев в БД определяется количеством корней деревьев. 
Организация данных в СУБД иерархического типа определяется в терминах: атрибут, агрегат, запись (группа), групповое отношение, база данных. 
Атрибут - наименьшая наименованная единица структуры данных  
Запись (группа) - именованная совокупность атрибутов. Использование записей позволяет за одно обращение к БД получить некоторую логически связанную совокупность данных. Экземпляр записи - конкретная запись с конкретным значением атрибутов. 
Групповое отношение - иерархическое отношение между записями двух типов. Родительская запись (владелец группового отношения) называется исходной записью, а дочерние записи (члены группового отношения) - подчиненными. Иерархическая база данных может хранить только такие древовидные структуры. При графическом изображении групповые отношения изображают дугами ориентированного графа, а типы записей - вершинами (диаграмма Бахмана). 
В качестве примера иерархической модели данных можно привести почтовый адрес. На 1-м уровне (в корне дерева) указывается страна, на 2-м - регион (область, край, район и т. д.), затем - город, улица, дом и номер квартиры. 
Важной особенностью иерархической структуры является то, что в ней дочерние записи не могут существовать без наличия родительских записей. Это объясняется тем, что при удалении корневого экземпляра удаляется все дерево (или поддерево). Недостатки такой структуры связаны с невозможностью хранения экземпляров записей, которые не имеют никаких родительских записей. Кроме того, в иерархической модели достаточно сложно моделируется связи типа "многие-ко-многим".
Простота организации, наличие заранее заданных связей между сущностями, сходство с физическими моделями данных позволяли добиваться приемлемой производительности иерархических СУБД на первых моделях компьютеров с весьма ограниченными объемами памяти. Но, если данные не имели древовидной структуры, то возникала масса сложностей при построении иерархической модели и обеспечении приемлемой производительности.
В последние годы произошло "второе рождение" иерархических моделей данных в связи с активным развитием стандарта  XML  ( extensible Markup Language ). По сути,  XML  - это просто синтаксис, который позволяет создавать языки разметки (схемы) для описания данных с иерархической структурой. Благодаря этому достигается следующее важное преимущество - отделение данных от процессов, оперирующих этими данными.
Сетевая модель данных. В этой модели используются те же понятия, что и в основе иерархической модели данных - узел, уровень и связь. Сетевые модели также создавались для мало ресурсных компьютеров. Это достаточно сложные структуры, состоящие из "наборов" - поименованных двухуровневых деревьев. Сетевая модель данных непосредственно поддерживает бинарные связи и связи более высоких степеней типа 1:1 и 1:М. Обладает ограниченной гибкостью по отношению к изменению требований к данным и методам доступа.
Сетевой подход к организации данных является расширением иерархического подхода. В иерархических структурах запись-потомок должна иметь в точности одного предка; в сетевой структуре данных потомок может иметь любое число предков. Однако в сетевой модели данных узел может быть связан с любым другим узлом, в том числе лежащим на уровне, не связанном непосредственно с уровнем исходного узла. Поэтому сетевая модель устраняет отмеченные выше недостатки иерархической модели. Сетевая БД состоит из набора записей и набора связей между этими записями, точнее, из набора экземпляров каждого типа из заданного в схеме БД набора типов записи и набора экземпляров каждого типа из заданного набора типов связи. 
Тип связи определяется для двух типов записи: предка и потомка. Экземпляр типа связи состоит из одного экземпляра типа записи предка и упорядоченного набора экземпляров типа записи потомка. Для данного типа связи L с типом записи предка P и типом записи потомка C должны выполняться следующие два условия: 
Каждый экземпляр типа P является предком только в одном экземпляре L; 
Каждый экземпляр C является потомком не более чем в одном экземпляре L. 
Реляционная модель данных. Эта модель является основой современной технологии БД. Сложность практического использования иерархических и сетевых СУБД привели к поиску иных способов представления данных. В основе реляционной модели данных положена идея о том, что любой набор данных можно представить в виде двумерной таблицы. Простейшая реляционная БД может состоять из единственной таблицы, в которой будут храниться все необходимые данные. Однако на практике реляционная БД обычно состоит из множества таблиц, связанных по определенным критериям. Главное преимущество реляционной модели состоит в простоте и возможности интуитивной интерпретации ее основных структурных понятий.
Критерии оценки качества модели данных
Среди критериев качества в терминах физической модели и конкретной реализации можно выделить следующие:
адекватность  БД предметной области. Состояние БД в любой момент времени должно соответствовать состоянию предметной области. Изменение состояния предметной области должно приводить к соответствующему изменению состояния БД. При этом ограничения предметной области, отраженные в моеди предметной области, должны отражаться и учитываться БД;
удобство разработки и сопровождения БД. Практически любая БД содержит программный код в виде хранимых процедур и триггеров.
Хранимые процедуры - это процедуры и функции, хранящиеся непосредственно в БД в откомпилированном виде. Основное назначение хранимых процедур - реализация бизнес-процессов предметной области. Они могут запускаться пользователями или приложениями, работающими с БД. Хранимые процедуры обычно пишутся либо на специальном процедурном расширении языка SQL, или на некотором универсальном языке программирования, например, C++, с включением в код операторов SQL в соответствии со специальными правилами такого включения. 
Триггеры - это хранимые процедуры, связанными с определенными событиями, происходящими во время работы БД. В качестве таких событий выступают операции вставки, обновления и удаления строк таблиц. Если в БД определен некоторый триггер, то он запускается автоматически всегда при возникновении события, с которым этот триггер связан. Весьма важным является то, что пользователь не может обойти триггер. Основное назначение триггеров - автоматическая поддержка целостности БД. 
Нормальные формы схем БД  
В неудачно спланированной БД может иметь место дублирование данных. Кроме того, при изменении одной копии БД может возникать необходимость в изменении и других ее экземпляров. В противном случае целостность данных нарушается.    
Пример. Сотрудники компании должны учитываться как отделе кадров, так и в отделе, где они работают. Поэтому необходимо следить, чтобы текущие изменения отображались во всех местах. 
В классическом подходе к проектированию реляционной БД исходят из представления предметной области в виде одного или нескольких отношений. На каждом шаге проектирования производится некоторый набор схем отношений, обладающих "лучшими" свойствами. Для этой цели  к реляционной модели данных применяется метод последовательных приближений, результатом которого является приемлемый набор схем отношений. При этом каждая следующая нормальная форма "предпочтительнее", чем предыдущая. 
Процесс представления БД в виде взаимосвязанных таблиц, при котором достигаются определённые качества БД, приводящие к большей надёжности, компактности и удобству её использования, называется нормализацией. 
Теория нормализации отношений описывает формальный аппарат ограничений на формирование таблиц, в целях устранения дублирования и обеспечения непротиворечивости данных, а также упрощения ведения БД.
Это достигается разбиением одной большой таблицы на более мелкие. Конечной целью нормализации является получение проекта БД, в которой исключена избыточность информации. Главной упор делается не столько на экономию памяти, сколько на исключение возможной противоречивости хранимых данных. 
В теории реляционных БД обычно выделяются следующие виды нормальных форм схем БД: 
первая нормальная форма (1NF); 
вторая нормальная форма (2NF); 
третья нормальная форма (3NF); 
нормальная форма Бойса - Кодда (BCNF); 
четвертая нормальная форма (4NF); 
пятая нормальная форма, или нормальная форма проекции-соединения (5NF или PJ/NF). 
Основные свойства нормальных форм заключаются в том, что каждая следующая нормальная форма  должна быть в определенном смысле лучше предыдущей и при переходе к следующей нормальной форме свойства предыдущих нормальных форм должны сохраниться. Как правило, для практических целей вполне достаточно первых трех  нормальных форм. 
Первая нормальная форма 
В первой нормальной форме значения всех атрибутов отношения должны быть атомарными (т.е. значения элементов в домене не являются ни списками, ни множествами). 
Отношение R находится в 1НФ, если значения в домене Dom (A) являются атомарными для каждого атрибута A в R.
Схема БД находится в 1НФ, если каждое его отношение находится в 1НФ.
Напомним свойства отношений (это и будут свойства 1НФ): 
В отношении нет одинаковых кортежей. 
Кортежи не упорядочены. 
Атрибуты не упорядочены и различаются по наименованию. 
Все значения атрибутов атомарны. 

Пример. Схема учебной БД "Торжок" (см. Приложение 2) находится в 1НФ.
Не первую нормальную форму можно получить, если допустить, что атрибуты отношения определены на сложных типах данных ( массивах,  структурах, или даже на других отношениях. Легко себе представить таблицу, у  которой в некоторых ячейках содержатся массивы, в других ячейках ( определенные  пользователями сложные структуры, а в третьих ячейках ( целые реляционные  таблицы, которые в свою очередь могут содержать такие же сложные объекты.  
Однако мы ограничимся рассмотрением только классической реляционной  теории, в которой все отношения имеют только атомарные атрибуты и заведомо  находятся в 1НФ.
Понятие функциональной зависимости. Детерминант
Нормализация основана на понятии функциональной зависимости атрибутов отношения: пусть  R  - отношение. 
Множество атрибутов  Y  функционально зависимо от множества атрибутов  X  тогда и только тогда, когда для любого состояния отношения  R  для любых кортежей  r 1,  r 2  ( R  из того, что  r 1. X  =  r 2. X  следует что   r 1. Y  =  r 2. Y . 
Функциональная зависимость записывается в виде   
 X(Y , где  X  называется детерминантом функциональной зависимости, а  Y  - зависимой частью. 
Подмножество атрибутов K отношения   R  называется  потенциальным ключом, если K обладает 
свойством уникальности: в отношении  R  не может быть двух различных кортежей с одинаковым значением K;
свойством неизбыточности: никакое собственное подмножество в K не обладает свойством уникальности.

Если атрибуты  X  составляют потенциальный ключ отношения  R , то любой атрибут отношения  R  функционально зависит от  X . 

Хотя функциональная зависимость атрибутов отношения напоминает понятие функциональной зависимости в математике, она имеет свои отличия.  
Если рассматривать математическое понятие функции, то для фиксированного значения  x ( X  соответствующее значение функции  y  =  f ( x ) всегда одно и то же. 
Например,  если задана функция  y  =  x 2, то для значения  x  = 2 соответствующее значение  y  всегда будет равно 4. В противоположность этому в отношениях значение зависимого атрибута может принимать различные значения в различных состояниях БД. Функциональная зависимость атрибутов утверждает лишь то, что для каждого конкретного состояния БД по значению детерминанта можно однозначно определить значение другого атрибута (зависимой части). Но конкретные значение зависимой части могут быть различны в различных состояниях БД.
Транзитивная функциональная зависимость. Замыкание множества зависимостей
Функциональная зависимость R.X ( R.Y называется полной, если атрибут Y не зависит функционально от любого собственного подмножества X. Функциональная зависимость R.X ( R.Y называется транзитивной, если существует такой атрибут Z, что имеются функциональные зависимости R.X ( R.Z и R.Z ( R.Y и отсутствует функциональная зависимость R.Z ( R.X.
Пример транзитивной функциональной зависимости дан ниже (см. пример третьей нормальной формы).
Примечание. При отсутствии последнего требования могут существовать "неприемлемые" транзитивные зависимости в любом отношении, обладающем несколькими ключами.
Два или более атрибута называются взаимно  независимыми, если ни один из них не является функционально зависимым от остальных.
Вторая нормальная форма
Функциональная зависимость R.X ( R.Y называется полной, если атрибут Y не зависит функционально от любого собственного подмножества X. 
Отношение R находится во второй нормальной форме (2NF) в том и только в том случае, когда оно находится в 1NF, и функциональная зависимость каждого неключевого атрибута от каждого ключа R является полной. 
Пример второй нормальной формы схемы БД будет приведен ниже.
Третья нормальная форма 
Если в отношении R существует лишь один ключ, то можно дать следующее определение третьей нормальной формы:
Отношение R находится в третьей нормальной форме (3NF) в том и только в том случае, если находится в 2NF и каждый неключевой атрибут нетранзитивно зависит от первичного ключа. 
Если  же отношение имеет нескольких ключей,  определение 3NF  видоизменяется следующим образом: 
Отношение R находится в третьей нормальной форме (3NF) тогда и только тогда, оно находится в 2NF, и каждый неключевой атрибут не является транзитивно зависимым от какого-либо ключа R. 
Корректность процедуры нормализации. Теорема Хеза
Как мы увидели, алгоритм нормализации состоит в выявлении функциональных зависимостей предметной области и соответствующей декомпозиции отношений. Пусть у нас уже есть действующая система с накопленными данными. Предположим, что данные корректны в текущий момент, т.е. факты предметной области правильно отражаются текущим состоянием БД. Если в предметной области обнаружена новая функциональная зависимость (либо она была пропущена на этапе моделирования предметной области, либо просто изменилась предметная область), то возникает необходимость заново нормализовать данные. При этом некоторые отношения придется декомпозировать в соответствии с алгоритмом нормализации. Возникают естественные вопросы - что произойдет с уже накопленными данными? Не будут ли данные потеряны в ходе декомпозиции? Можно ли вернуться обратно к исходным отношениям, если будет принято решение отказаться от декомпозиции, восстановятся ли при этом данные? 
Для ответов на эти вопросы нужно ответить на вопрос - что же представляет собой декомпозиция отношений с точки зрения операций реляционной алгебры? При декомпозиции мы из одного отношения получаем два или более отношений, каждое из которых содержит часть атрибутов исходного отношения. В полученных новых отношениях необходимо удалить дубликаты строк, если таковые возникли. 
Это в точности означает, что декомпозиция отношения есть не что иное, как взятие одной или нескольких проекций исходного отношения так, чтобы эти проекции в совокупности содержали (возможно, с повторениями) все атрибуты исходного отношения. Иначе говоря, при декомпозиции не должны теряться атрибуты отношений. Но при декомпозиции также не должны потеряться и сами данные. Данные можно считать не потерянными в том случае, если возможна обратная операция - по декомпозированным отношениям можно полностью восстановить исходное отношение в прежнем виде. Операцией, обратной операции проекции, является операция соединения отношений. Поскольку при восстановлении исходного отношения путем соединения проекций не должны появиться новые атрибуты, то необходимо использовать операцию естественное соединение ( JOIN ). 
Напомним, что операция  JOIN  производится по всем столбцам (атрибутам) таблиц А и В, имеющим одинаковые имена, и  заключается в соединении всех строк из А, В с равными значениями указанных атрибутов. В результирующую таблицу одинаковые столбцы вставляются только один раз.
Проекция  R [ X ] отношения  R  на множество атрибутов  X  называется собственной, если множество атрибутов  X  является собственным подмножеством множества атрибутов отношения  R  (т.е. множество атрибутов  R  не совпадает с множеством всех атрибутов отношения  R ). 
Собственные проекции  R 1 и  R 2 отношения  R  называются декомпозицией без потерь, если отношение  R  точно восстанавливается из них при помощи естественного соединения для любого состояния отношения  R  : 
 R1 JOIN R2 = R

 Теорема Хеза. Пусть   R ( A ,  B ,  C ) - отношение,  A ,  B ,  C  - атрибуты или множества атрибутов этого отношения. Если имеется функциональная зависимость , то проекции  R 1 =  R [ A ,  B ] и  R 2 =  R [ A ,  C ] образуют декомпозицию без потерь. 
Алгоритм нормализации (приведение к 3НФ)
Шаг 1 (Приведение к 1НФ). На первом шаге задается одно или несколько отношений, отображающих понятия предметной области. По модели предметной области выписываются обнаруженные функциональные зависимости. Все отношения автоматически находятся в 1НФ. 
Шаг 2 (Приведение к 2НФ). Если в некоторых отношениях обнаружена зависимость атрибутов от части сложного ключа, то проводим декомпозицию этих отношений на несколько отношений: те атрибуты, которые зависят от части сложного ключа выносятся в отдельное отношение вместе с этой частью ключа. В исходном отношении остаются все ключевые атрибуты: 
Исходное отношение:  R ( K 1,  K 2,  A 1, ...,  An ,  B 1, ...,  Bm ). 
Ключ: { K 1,  K 2} - сложный. 
Функциональные зависимости: 
{ K 1,  K 2}({ A 1, ...,  An ,  B 1, ...,  B m} - зависимость всех атрибутов от ключа отношения. 
{ K 1}({ A 1, ...,  An }- зависимость некоторых атрибутов от части сложного ключа. 
Декомпозированные отношения: 
 R 1( K 1,  K 2,  B 1, ...,  Bm ) - остаток от исходного отношения. Ключ { K 1,  K 2}. 
 R 2( K 1,  A 1, ...,  An ) - атрибуты, вынесенные из исходного отношения вместе с частью сложного ключа. Ключ  K 1. 
Шаг 3 (Приведение к 3НФ). Если в некоторых отношениях обнаружена зависимость одних неключевых атрибутов других неключевых атрибутов, то проводим декомпозицию этих отношений: те неключевые атрибуты, которые зависят от других неключевых атрибутов выносятся в отдельное отношение. В новом отношении ключом становится детерминант функциональной зависимости: 
Исходное отношение:  R ( K ,  A 1, ...,  An ,  B 1, ...,  Bm ). 
Ключ:  K . 
Функциональные зависимости: 
 K  ({ A 1, ...,  An ,  B 1, ...,  Bm } - зависимость всех атрибутов от ключа отношения. 
{ A 1, ...,  An } ( { B 1, ...,  Bm }- зависимость некоторых неключевых атрибутов других неключевых атрибутов. 
Декомпозированные отношения: 
 R 1( K ,  A 1, ...,  An ) - остаток от исходного отношения. Ключ  K . 
 R 2( A 1, ...,  An ,  B 1, ...,  Bm ) - атрибуты, вынесенные из исходного отношения вместе с детерминантом функциональной зависимости. Ключ { A 1,  An }. 
На практике, опытные разработчики сразу строят отношения в 3НФ. Кроме того, основным средством разработки логических моделей данных являются различные варианты ER-диаграмм. Особенность этих диаграмм в том, что они сразу позволяют создавать отношения в 3НФ. Тем не менее, приведенный алгоритм важен по двум причинам. Во-первых, этот алгоритм показывает, какие проблемы возникают при разработке слабо нормализованных отношений. Во-вторых, как правило, модель предметной области никогда не бывает правильно разработана с первого шага. Эксперты предметной области могут забыть о чем-либо упомянуть, разработчик может неправильно понять эксперта, во время разработки могут измениться правила, принятые в предметной области, и т.д. Все это может привести к появлению новых зависимостей, которые отсутствовали в первоначальной модели предметной области. Тут как раз и необходимо использовать алгоритм нормализации хотя бы для того, чтобы убедиться, что отношения остались в 3НФ, и логическая модель не ухудшилась. 
Роль нормализации БД при проектировании реляционных БД
Соберем воедино результаты анализа критериев, по которым следует оценить влияние логического моделирования данных на качество физических моделей данных и производительность БД: 
Критерий	Отношения слабо нормализованы(1НФ, 2НФ)	Отношения сильно нормализованы(3НФ)		Адекватность БД предметной области	ХУЖЕ (-)	ЛУЧШЕ (+)		Легкость разработки и сопровождения БД	СЛОЖНЕЕ (-)	ЛЕГЧЕ (+)		Скорость выполнения вставки, обновления, удаления	МЕДЛЕННЕЕ (-)	БЫСТРЕЕ (+)		Скорость выполнения выборки данных	БЫСТРЕЕ (+)	МЕДЛЕННЕЕ (-)		

