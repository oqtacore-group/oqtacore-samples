
Посвящается Франческо (Я часто забываю сказать, как сильно я тебя люблю) "Воображение важнее знания" Альберт Энштейн
Programming Microsoftr ASP.NET 2.0 Applications: Advanced Topics Dino Esposito
Москва * Санкт-Петербург * Нижний Новгород * Воронеж Новосибирск * Ростов-на-Дону * Екатеринбург * Самара Киев * Харьков * Минск 2008 Microsoftr ASP.NET 2.0Дино Эспозито Углубленное изучение МАСТЕР-КЛАСС
УДК 004.738.5 ББК 32.973.202 Э 85 ISBN 0-7356-2177-2 (англ.) ISBN 978-5-7502-0286-7 ("Русская Редакция") ISBN 978-5-91180-196-0 ("Питер") Эспозито Д. Э85 Microsoft ASP.NET 2.0. Углубленное изучение. /Пер. с англ. - М.: Издательство "Рус ская Ре дак ция"; СПб. : Питер, 2008. - 592 с.: ил. ISBN 978-5-7502-0286-7 ("Рус ская Ре дак ция") ISBN 978-5-91180-196-0 ("Питер") Эта книга - подробное руководство для профессионалов-разработчиков приложений ASP.NET. В ней раскрыты тонкости внутреннего функционирования исполняющей среды ASP.NET 2.0 и возможности ее конфигурирования, детально описан процесс выполнения приложений и средства, позволяющие сделать их надежными, эффективными и хорошо защищенными. Вы узнаете, как создавать пользовательские элементы управления, освоите новые навигационные средства ASP.NET 2.0 и научитесь формировать оптимальное пред-ставление данных с помощью новых элементов управления. Книга состоит из 15 глав и предметного указателя. Она адресована тем, кто не ограничивается прикладными сведениями, почерпнутыми из обычных учебных пособий, а намерен разобраться во всех деталях внутреннего функционирования исполняющей среды ASP.NET 2.0. УДК 004.738.5 ББК 32.973.202 Подготовлено к печати по лицензионному договору с Microsoft Corporation, Редмонд, Вашингтон, США. Active Directory, ActiveSync, Hotmail, Links, Microsoft, Microsoft Press, MSN, Natural, NetMeeting, Outlook, Powerpoint, Win32 и Windows являются товарными знаками или охраняемыми товарными знаками Microsoft Corporation. Все другие товарные знаки являются собственностью соответствующих фирм. Если не оговорено иное, все названия компаний, организаций и продуктов, а также имена лиц, исполь-зуемые в примерах, вымышлены и не имеют никакого отношения к реальным компаниям, организациям, продуктам и лицам. c Оригинальное издание на англий ском языке, Dino Esposito, 2006 c Перевод на русский язык, Microsoft Corporation, 2006 c Оформление и подготовка к из да нию, Издательство "Рус ская Ре дак ция", 2007
Оглавление Введение .......................................................................................................................................................XI Об авторе .................................................................................................................................................... XV Благодарности ........................................................................................................................................XVI Часть I Внутренние механизмы ASP.NET...............................................................................................1 Глава 1 Модель компиляции ASP.NET ..........................................................................................2 Исполняющая среда ASP.NET ....................................................................................................................3 Модель процесса ......................................................................................................................................3 Временные файлы ASP.NET ...............................................................................................................10 Скрытый код страницы .........................................................................................................................13 Предкомпиляция приложений..................................................................................................................21 Предкомпиляция на месте ...................................................................................................................21 Предкомпиляция для развертывания ..............................................................................................23 Строительные блоки приложения ASP.NET ........................................................................................26 Параметры компиляции .......................................................................................................................26 Зарезервированные папки ASP.NET ................................................................................................29 Провайдеры компиляции .....................................................................................................................34 Разработка пользовательских провайдеров компиляции ........................................................37 Провайдеры виртуального пути ........................................................................................................46 Заключение .....................................................................................................................................................49 Глава 2 Обработчики и модули HTTP ..........................................................................................50 Краткий обзор API расширения IIS ........................................................................................................51 Модель ISAPI ..........................................................................................................................................51 Ожидаемые изменения в IIS 7.0 ........................................................................................................54 Написание обработчиков HTTP ...............................................................................................................55 Интерфейс IHttpHandler .....................................................................................................................55 Обработчик HTTP для быстрого создания отчетов ...................................................................57 Обработчик для просмотрщика изображений ..............................................................................64 Более сложные технологии создания обработчиков HTTP ....................................................68 Написание модулей HTTP .........................................................................................................................72 Интерфейс IHttpModule ......................................................................................................................72 Пользовательский модуль HTTP ......................................................................................................73 Обновление страницы ...........................................................................................................................77 Заключение .....................................................................................................................................................82
VI Оглавление Глава 3 Конфигурация ASP.NET .....................................................................................................84 Конфигурационная иерархия ASP.NET .................................................................................................84 Конфигурационные файлы .................................................................................................................85 Раздел <system.web> .............................................................................................................................92 Другие разделы верхнего уровня .................................................................................................... 120 Управление конфигурационными данными ..................................................................................... 122 Использование конфигурационного API .................................................................................... 122 Применение средств управления ................................................................................................... 129 Заключение .................................................................................................................................................. 134 Глава 4 Создание пользовательских провайдеров ASP.NET ..................................... 136 Схема модели провайдеров ..................................................................................................................... 137 Архитектурные модели ...................................................................................................................... 137 Детали реализации .............................................................................................................................. 139 Встроенные провайдеры ASP.NET ....................................................................................................... 141 Сервис членства ................................................................................................................................... 142 Сервис управления ролями .............................................................................................................. 146 Сервис пользовательских профилей ............................................................................................. 149 Сервис состояния сеанса ................................................................................................................... 150 Провайдер карты сайта ...................................................................................................................... 152 Сервис обработки событий Web ..................................................................................................... 154 Сервис персонализации Web Parts ................................................................................................ 158 Сервис защиты конфигурации ........................................................................................................ 159 Ваш собственный провайдер................................................................................................................... 164 Архитектура провайдера ................................................................................................................... 164 Реализация провайдера профилей, использующего cookie .................................................. 166 Объединяем все вместе ...................................................................................................................... 172 Заключение .................................................................................................................................................. 174 Глава 5 Создание сложных страниц ......................................................................................... 175 Разработка асинхронных страниц ......................................................................................................... 175 Инструменты ASP.NET для асинхронного программирования ......................................... 176 Средства ASP.NET 2.0 ........................................................................................................................ 178 Реализация асинхронных страниц ................................................................................................. 183 Реальные применения асинхронных страниц............................................................................ 188 Пользовательские типы выражений .................................................................................................... 203 Блоки кода ASP-стиля ....................................................................................................................... 203 Выражения связывания с данными ............................................................................................... 206 Динамические выражения в ASP.NET 2.0 ................................................................................... 208 Написание пользовательского построителя выражений ....................................................... 210 Разработка фильтров анализатора для страниц ASP.NET ........................................................... 215 Класс PageParserFilter ........................................................................................................................ 215 Реальные примеры ............................................................................................................................... 217 Заключение .................................................................................................................................................. 221
Оглавление VII Часть II Специализированные средства ASP.NET ..................................................................... 223 Глава 6 Работа с кодом сценариев ............................................................................................ 224 Включение в страницы клиентских сценариев ................................................................................ 224 Определение возможностей браузера ........................................................................................... 225 Регистрация блоков сценариев ....................................................................................................... 228 Создание всплывающих окон .......................................................................................................... 236 Технология Script Callbacks .................................................................................................................... 239 Базовый API ASP.NET ....................................................................................................................... 240 Выполнение параллельного вызова .............................................................................................. 243 Библиотека Ajax.NET ............................................................................................................................... 252 Использование библиотеки .............................................................................................................. 253 Сравнение технологий Ajax.NET и ASP.NET Script Callbacks............................................. 257 Заключение .................................................................................................................................................. 259 Глава 7 Страницы с элементами Web Parts .......................................................................... 261 Обзор Web Parts .......................................................................................................................................... 261 Что такое Web Parts ............................................................................................................................. 261 Введение в Web Parts Framework ................................................................................................... 263 Создание страниц с элементами Web Parts ................................................................................. 266 Создание элементов Web Parts ............................................................................................................... 269 Web Part StockViewer ......................................................................................................................... 274 Другие способы создания элементов Web Parts ........................................................................ 281 Стили Web-зон ..................................................................................................................................... 284 Редактирование Web Parts и вывод их списка .................................................................................. 290 Изменение режима отображения ................................................................................................... 290 Изменение раскладки зоны .............................................................................................................. 292 Создание Editor Zone .......................................................................................................................... 294 Создание Catalog Zone ....................................................................................................................... 296 Соединение Web Parts ............................................................................................................................... 300 Модель соединения Web Parts ......................................................................................................... 300 Создание схемы "главный-подчиненный" ................................................................................ 302 Сводим все вместе ............................................................................................................................... 304 Заключение .................................................................................................................................................. 305 Глава 8 Программирование для мобильных устройств ................................................ 307 Обзор мобильных элементов управления .......................................................................................... 307 Архитектура мобильных элементов управления ...................................................................... 307 Мобильные страницы ASP.NET...................................................................................................... 310 Контейнерные элементы управления ........................................................................................... 316 Списочные элементы управления .................................................................................................. 316 Текстовые элементы управления .................................................................................................... 320 Проверочные элементы управления ............................................................................................. 323
VIII Оглавление Разработка мобильных приложений .................................................................................................... 325 Приложение для поиска клиентов ................................................................................................. 326 Навигационная модель приложения............................................................................................. 328 Адаптивный рендеринг ...................................................................................................................... 332 Заключение .................................................................................................................................................. 335 Глава 9 Работа с изображениями ............................................................................................... 336 Доступ к изображениям из Web-страниц ........................................................................................... 336 Ссылки на файлы, не являющиеся файлами изображений .................................................. 338 Загрузка изображений из ресурсов ............................................................................................... 339 Доступ к изображениям, хранящимся в базе данных .................................................................... 342 Работа с двоичными полями ............................................................................................................ 342 Примеры приложений ........................................................................................................................ 347 Динамическое генерирование изображений ..................................................................................... 350 Краткий обзор классов GDI+ .......................................................................................................... 350 Вывод изображений ............................................................................................................................ 353 Создание приложения, генерирующего диаграммы ................................................................ 358 Заключение .................................................................................................................................................. 364 Глава 10 Навигация по сайту ......................................................................................................... 366 Определение карты сайта ......................................................................................................................... 366 Создание карты сайта ......................................................................................................................... 366 Конфигурирование карты сайта ..................................................................................................... 369 Обработка информации карты сайта ................................................................................................... 372 Класс SiteMap ....................................................................................................................................... 372 Элемент управления SiteMapPath ................................................................................................. 375 Элемент управления SiteMapDataSource.................................................................................... 377 Вывод информации карты сайта ........................................................................................................... 380 Элемент управления TreeView ........................................................................................................ 380 Элемент управления Menu ............................................................................................................... 384 Заключение .................................................................................................................................................. 390 Часть III Элементы управления ASP.NET ............................................................................................. 391 Глава 11 Итеративные элементы управления ASP.NET ................................................. 392 Понятие итеративного элемента управления ................................................................................... 392 Сравнение итеративных элементов управления со списочными ....................................... 392 Сравнение итеративных элементов управления с элементами-представлениями ....... 393 Элемент управления Repeater ................................................................................................................ 394 Интерфейс программирования элемента управления Repeater .......................................... 394 Шаблоны элемента управления Repeater .................................................................................... 397 Работа с элементом управления Repeater ................................................................................... 401 Элемент управления DataList ................................................................................................................ 405 Интерфейс программирования элемента управления DataList .......................................... 405 Возможности форматирования ....................................................................................................... 408
Оглавление IX Шаблоны элемента управления DataList .................................................................................... 412 Работа с элементом управления DataList .................................................................................... 413 Заключение .................................................................................................................................................. 416 Глава 12 Пользовательские элементы управления ASP.NET ..................................... 418 Что такое пользовательский элемент управления .......................................................................... 418 Класс UserControl ............................................................................................................................... 419 Превращение страниц в пользовательские элементы управления .................................... 421 Разработка пользовательских элементов управления ................................................................... 424 Создание элемента управления TabStrip ..................................................................................... 424 Создание объектной модели пользовательского элемента управления ........................... 428 Обработка событий пользовательских элементов управления ........................................... 433 Пример усовершенствованного пользовательского элемента управления ............................ 436 Связывание пользовательского элемента управления с данными ..................................... 436 Динамическая загрузка элементов управления ........................................................................ 443 Заключение .................................................................................................................................................. 444 Глава 13 Создание специализированных элементов управления ASP.NET ...... 446 Расширение существующих элементов управления ............................................................... 447 Выбор базового класса ....................................................................................................................... 447 Усовершенствование элемента управления HyperLink .......................................................... 449 Создание элементов управления с нуля ............................................................................................. 451 Базовый класс и интерфейсы........................................................................................................... 451 Выбор способа рендеринга ............................................................................................................... 453 Элемент управления SimpleGaugeBar .......................................................................................... 455 Рендеринг элемента управления .................................................................................................... 459 Разработка элементов управления с богатыми функциональными возможностями ......... 468 Раскрывающаяся панель ................................................................................................................... 469 Механизм рендеринга ......................................................................................................................... 473 Генерирование событий возврата формы .................................................................................... 479 Добавление кода сценария ................................................................................................................ 482 Заключение .................................................................................................................................................. 485 Глава 14 Элементы управления, связанные с данными и использующие шаблоны ......................................................................................... 487 Проектирование элементов управления, связанных с данными ......................................... 487 Типы элементов управления, связанных с данными ............................................................... 488 Механизм связывания с данными .................................................................................................. 489 Создание простого элемента управления, связанного с данными ............................................. 493 Ключевые компоненты элемента управления ........................................................................... 494 Элемент управления GaugeBar ....................................................................................................... 496 Элемент данных и состояние представления ............................................................................. 499 Связывание списочного элемента управления с данными .......................................................... 503 Общие характеристики списочных элементов управления .................................................. 503 Элемент управления HyperLinkList .............................................................................................. 506
X Оглавление Построение составного элемента управления, использующего шаблоны .............................. 513 Общие характеристики составных элементов управления, связанных с данными ...... 513 Элемент управления BarChart ........................................................................................................ 516 Реализация поддержки шаблонов .................................................................................................. 524 Заключение .................................................................................................................................................. 530 Глава 15 Поддержка специализированных элементов управления во время разработки ..................................................................................................... 533 Архитектура .NET времени разработки .............................................................................................. 533 Сайты, контейнеры и элементы управления .............................................................................. 534 Элементы управления и дизайнеры .............................................................................................. 535 Атрибуты-метаданные.............................................................................................................................. 536 Атрибуты, действующие во время разработки .......................................................................... 536 Атрибуты, действующие во время выполнения ........................................................................ 542 Рендеринг значений разных типов ....................................................................................................... 543 Реализация конвертера типов ......................................................................................................... 543 Создание редактора типов ................................................................................................................ 552 Работа с пользовательскими коллекциями ................................................................................ 554 Пользовательские дизайнеры ................................................................................................................. 556 Встроенные дизайнеры ...................................................................................................................... 556 Написание пользовательских дизайнеров .................................................................................. 558 Заключение .................................................................................................................................................. 565 Алфавитный указатель ....................................................................................................................... 567
Введение Написать большую книгу об ASP.NET 2.0 я задумал еще летом 2004 года. По моим первоначальным расчетам она должна была содержать около 1600 страниц, что, ко-нечно же, слишком много, каким бы интересным ни был предмет книги и как бы увле-кательно ни писал о нем автор. Такой внушительный фолиант трудно даже удержать в руках, да и работать с такой книгой нелегко. К тому же и для автора задача по ее написанию чересчур сложна: только пред-ставьте, сколько информации необходимо собрать, изучить, критически осмыслить, проверить, а затем организовать и представить в требуемой форме. Можно, впрочем, собрать авторский коллектив, но и в этом случае понадобится не меньше девяти ме-сяцев непрерывной работы, не оставляющей времени ни на отдых, ни на семью. Обдумав все это, мы решили реализовать исходный замысел в виде двух книг: "Pro gramming Microsoft ASP .NET 2.0: Core Reference"*, и "Programming Microsoft ASP.NET 2.0 Applications: Advanced Topics" (настоящая книга). В них содержится всеохватывающий материал по программированию для платформы ASP.NET. Мы разделили общее оглавление на две части, отделив информацию, в первую очередь необходимую разработчику, желающему быстро научиться создавать каче-ственные приложения ASP.NET 2.0, от сведений по остальным темам, которые, хоть и важны, но являются более сложными либо просто не относятся к категории перво-очередных. Первоочередные темы были включены в книгу "Programming Microsoft ASP.NET 2.0: Core Reference", остальные же представлены в книге, которую вы сейчас держите в руках. Ее подзаголовок "Разработка сложных приложений" говорит о том, что в ней рассматриваются вопросы, которые заинтересуют вас позднее, когда вы освоите основы программирования для платформы ASP.NET. Необходимо подчеркнуть, что данная книга является не откорректированной и бо-лее углубленной версией книги "Programming Microsoft ASP.NET 2.0: Core Reference", а ее дополнением; здесь раскрываются темы, лишь вскользь затронутые в первой книге (такие как компиляция, провайдеры, элементы управления), а также новые, более сложные темы (в частности, компоненты Web Part, мобильные элементы управления, навигация, конфигурирование и развертывание). В эти две книги удалось поместить исчерпывающую информацию по технологии ASP.NET 2.0. Кому адресована книга Эта книга не адресована начинающим разработчикам по двум причинам. Я опираюсь в ней на материал предыдущей книги, "Programming Microsoft ASP.NET 2.0: Core Reference", предполагая, что она уже прочитана либо просто читатель обладает со-ответствующими знаниями. Кроме того, в книге вы не найдете таких банальностей, как снимки экранов мастеров Microsoft Visual Studio 2005 или указания о том, какой переключатель следует установить, чтобы активизировать либо деактивизировать ту или иную функцию IDE. Конечно, это не означает, что я не люблю Visual Studio 2005 или не рекомендую использовать ее для разработки приложений ASP.NET. Visual * Данная книга на русский язык пока не переведена. Ее название могло бы быть таким: "Microsoft ASP.NET 2.0: основы программирования". - Прим. перев.
XII Введение Studio 2005 - прекрасное средство, но по отношению к технологии ASP.NET это всего лишь рабочий инструмент. Книга же посвящена именно ASP.NET, ее возможностям и внутренней организации ее исполняющей среды. Итак, я рекомендую эту книгу разработчикам, которые прочитали мою книгу "Programming Microsoft ASP.NET 2.0: Core Reference" и усвоили ее материал либо полу-чили те же знания из других источников. Однако здесь освещены и такие темы, для изучения которых не требуется предварительной подготовки. В частности, я расскажу о компонентах Web Part, компонентах, используемых в приложениях для мобильных устройств, и о конфигурировании ASP.NET. К этой же категории относится и тема всей части III - элементы управления. Структура книги Книга разделена на три части: "Внутренние механизмы ASP.NET", "Специализиро-ванные средства ASP.NET", "Элементы управления ASP.NET". В части I подробно рассматриваются модель компиляции, вопросы настройки и кон-фигурирования системы и приложений, а также модель провайдеров. Глава 5 этой части содержит описание передовых средств и методов, позволяющих оптимизировать работу приложения, обогатить его возможности и содержание его страниц. Часть II посвящена специализированным средствам ASP.NET. Здесь рассказывает-ся о сценариях и об их обратном вызове, о компонентах Web Part, используемых при создании приложений портального типа, о разработке мобильных приложений для беспроводных устройств, а также о навигационном API, с помощью которого можно предоставить пользователю удобные средства работы с большим и сложным сайтом. Предметом рассмотрения в части III являются элементы управления. Я расскажу о низкоуровневых итеративных элементах Repeater и DataList, которые хотя и усту-пают новому семейству элементов GridView, DetailsView и FormView в отношении простоты применения, но в отличие от них позволяют создать произвольное пользо-вательское представление данных. Кроме того, эта часть содержит экспресс-курс по пользовательским элементам управления, шаблонам, связыванию данных, в ней также идет речь о дополнении собственных элементов управления средствами управления, используемыми во время разработки. Системные требования Для выполнения примеров программного кода, приведенных в этой книге, вам по-требуются следующие ресурсы: Microsoft Windows XP с Service Pack 2, Microsoft Windows Server 2003 с Service Pack 1 либо Microsoft Windows 2000 с Service Pack 4; Microsoft Visual Studio 2005 Standard Edition либо Microsoft Visual Studio 2005 Professional Edition; Internet Information Services (IIS); этот сервер не обязательно использовать для написания и отладки приложений ASP.NET в Visual Studio, но он необходим не-которым видам программного обеспечения, применяемого для инсталляции кода; Microsoft SQL Server 2005 Express (входит в состав Visual Studio 2005) либо Microsoft SQL Server 2005; база данных Northwind Traders из Microsoft SQL Server 2000, используемая во многих примерах этой книги для демонстрации технологий доступа к данным; если у вас установлен SQL Server 2005, вы можете загрузить инсталляционные сцена-рии базы данных Northwind с сайта Microsoft по адресу http://www.microsoft.com/
Введение XIII downloads/details.aspx?FamilyId=06616212-0356-46A0-8DA2-EEBC53A68034&display lang=en; процессор Pentium 766 МГц или же совместимый с ним (рекомендуется Pentium с часто той 1,5 ГГц); RAM объемом 256 Мбайт (рекомендуется 512 Мбайт или более); монитор с разрешением 800?600 или выше, поддерживающий минимум 256 цветов (рекомендуемые параметры: разрешение 1024?768, глубина цвета 16 бит); привод CD-ROM или DVD-ROM; мышь типа Microsoft Mouse либо совместимая с ней. Конфигурирование SQL Server 2005 Express Edition Для выполнения некоторых приведенных в этой книге примеров кода вам потребуется до ступ к СУБД SQL Server 2005 Express Edition (или SQL Server 2005), в которой должна быть создана используемая в этих примерах база данных Northwind Traders. Если у вас установлен SQL Server 2005 Express Edition, войдите в операционную си-стему своего компьютера с правами администратора и выполните перечисленные ниже действия, чтобы предоставить необходимые разрешения той учетной записи пользо-вателя, от имени которой вы будете запускать демонстрационные приложения. 1. В Windows выберите Пуск \ Все программы \ Стандартные \ Командная строка, чтобы открыть окно консоли. 2. В этом окне введите следующую команду, заменив в ней ваш_сервер именем своего компьютера: sqlcmd -S ваш_сервер\SQLExpress -E Чтобы узнать имя используемого компьютера, достаточно выполнить в окне кон-соли ко манду hostname (введя ее перед командой sqlcmd). 3. В ответ на приглашение 1> введите следующую команду, включая квадратные скобки: sp_grantlogin [ваш_сервер\имя_пользователя] Замените здесь ваш_сервер именем своего компьютера, а имя_пользователя - име-нем учетной записи Windows, которую вы будете использовать при работе с SQL Server. 4. В ответ на приглашение 2> введите такую команду: go Если увидите сообщение об ошибке, проверьте, правильно ли вы ввели команду sp_grantlogin. 5. Увидев приглашение 1>, введите указанную ниже команду, включая квадратные скобки: sp_addsrvrolemember [ваш_сервер\имя_пользователя], dbcreator 6. В ответ на приглашение 2> введите такую команду: go Если увидите сообщение об ошибке, проверьте, правильно ли вы ввели команду sp_addsrvrolemember. 7. И наконец, в ответ на приглашение 1> введите такую команду: exit 8. Закройте окно консоли. 
XIV Введение Обновления технологий По мере обновления упоминаемых в этой книге технологий на странице Microsoft Press Technology Updates будут появляться соответствующие ссылки. Поэтому сове-тую периодически посещать эту страницу, следя за обновлениями Visual Studio 2005 и других технологий. Вот ее адрес: http://www.microsoft.com/mspress/updates/Примеры программного кода Все обсуждаемые в этой книге примеры кода можно загрузить с ее страницы: http://www.microsoft.com/mspress/companion/0-7356-2177-2/Поддержка Мы приложили максимум усилий, для того чтобы обеспечить точность приведенной в книге информации и сопутствующих материалов. Кроме того, мы собираем измене-ния и исправления и добавляем их в статью Microsoft Knowledge Base. Поддержка книги издательством Microsoft Press предоставляется на следующей странице: http://www.microsoft.com/learning/support/books/Вопросы и комментарии Ваши комментарии, вопросы и предложения относительно этой книги, а также во-просы, ответов на которые вы не нашли на перечисленных выше сайтах, направляйте в Microsoft Press по адресу: mspinput@microsoft.com или же обычной почтой: Microsoft Press Attn: Programming Microsoft ASP.NET: Advanced Topics Editor One Microsoft Way Redmond, WA 98052-6399
Об авторе Дино Эспозито является экспертом по технологиям ASP.NET и ADO.NET в компании Solid Quality Learning, занимающей одну из лидирующих позиций в сфере тренинга и консалтинга. Автор этой книги ведет раздел "Cutting Edge" в журнале "MSDN Magazine" и регу лярно пишет статьи о .NET Framework для Microsoft ASP.NET Developer Center и Micro soft Visual Studio Developer Center, а также для различных журналов, в число которых входят "asp.netPRO Magazine", "CoDe Magazine" и информационный бюллетень "ASP.NET-2-The-Max". Перу Дино Эспозито принадлежат изданные в Microsoft Press книги "Programming Microsoft ASP.NET" (2003), "Building Web Solutions with ASP .NET and ADO.NET" (2002), "Applied XML Programming for Microsoft .NET" (2002) и"Programming Microsoft ASP.NET 2.0 Core Reference" (2006). Свежую информацию о планах автора можно найти в его блоге по адресу http://weblogs.asp.net/despos. Будучи членом команды докладчиков .NET Association (INETA), Дино Эспозито часто выступает на различных мероприятиях, организуемых сообществами разработчиков, главным образом в Европе и США. Прежде чем стать исключительно автором, консультантом и инструктором, Дино Эспозито работал в нескольких ведущих консалтинговых компаниях. Он положил начало внедрению систем DNA в Европе и разработал в 1994 году одно из первых серьезных Web-приложений - банк изображений. В наши дни Дино часто можно встретить на главных конференциях отрасли, таких как DevConnections, DevWeek, WinDev и Microsoft TechEd. Проживает он в Италии, в Риме.
Благодарности Своим появлением эта книга обязана усилиям небольшой, но слаженно работающей команды: Бена Райана (Ben Ryan), Линн Финнел (Lynn Finnel), Кена Скрибнера (Kenn Scribner), Роджера Леблана (Roger LeBlanc) и Роберта Лайона (Robert Lyon). Им я от всей души говорю "огромное спасибо" за доброту, терпение и аккуратность в работе. Ведь они вычитали, отрецензировали, редактировали и проте стировали текст этой книги и ее программный код. Я благодарен Кену Скрибнеру, с которым мы уже прежде работали вместе, и имен-но поэтому я захотел, чтобы он был техническим редактором моей новой книги. Конечно, он иногда пишет очень много комментариев, так что даже изменяется моя первоначальная мысль, но это именно те комментарии, которые ДОЛЖНЫ быть написаны. Кен находит каждую ошибку и каждую неточность, и я бы очень хотел, чтобы именно он помогал мне в работе над всеми последующими книгами. (У меня уже есть несколько идей на этот счет.) Хочется отметить, что именно Бен Райан стоял у истоков данного творения. Эта книга - его детище, а я был лишь инструментом, с помощью которого она создавалась, надеюсь, достаточно интеллектуальным. Множество других людей внесли весомый вклад в создание книги, помогли сделать ее более качественной. Это Фернандо Гуэрро (Fernando Guerrero), все сотрудники Solid Quality Learning, Мариус Константинеску (Marius Constantinescu), Марко Бел-линасо (Marco Bellinaso), Стив Тауб (Steve Toub), Джей Гринфилд (Jay Greenfield), Андреа Салтарелло (Andrea Saltarello) и Рафаэль Риалди (Raffaele Rialdi). Существенную поддержку оказали мне Мэтью Гиббс (Matthew Gibbs), Нихиль Котари (Nikhil Kothari), Дэйвид Эббо (David Ebbo), Саймон Калверт (Simon Calvert), Дмитрий Робсман (Dmitri Robsman) и Джонатан Хоукинс (Jonathan Hawkins) из команды разработчиков ASP.NET, они помогли превратить мои догадки и гипотезы в достоверные утверждения. Благодарю также Скотта Газраи (Scott Guthrie) за то, что он удивительно быстро находил ответы на все мои вопросы. Особого упоминания заслуживает Люц Роуэдер (Lutz Roeder) и его замечательное средство .NET Reflector, которым я постоянно пользовался для изучения внутренней структуры классов и элементов управления ASP.NET. Я пишу уже много лет, так что моя жена Сильвия и дети, Франческо и Мишела, к этому уже привыкли. Очередная книга на 800 страниц для них - это просто моя повседневная работа. Мои домашние знают, как себя вести, чтобы я всецело мог от-даваться творческому процессу. За это я очень признателен им. Выходом данной книги завершается проект, который начался около девяти месяцев на зад. За это время в моей личной жизни кое-что изменилось - я снова начал бегать и играть в теннис. Поверите ли, но я не раз обнаруживал, что к концу напряженного спортивного поединка ко мне приходили готовые решения сложных проблем, свя-занных с программным кодом и организацией создаваемой книги. Таким образом я упоминаю о своих друзьях из теннисного клуба города Монтеротондо. Ваш Дино
Часть I Внутренние механизмы ASP.NET Глава 1. Модель компиляции ASP.NET ................................................................................. 2 Глава 2. Обработчики и модули HTTP ................................................................................ 50 Глава 3. Конфигурация ASP.NET ......................................................................................... 84 Глава 4. Создание пользовательских провайдеров ASP.NET ......................................... 136 Глава 5. Создание сложных страниц ................................................................................. 175
Глава 1 Модель компиляции ASP.NET За небольшим исключением все файлы, необходимые исполняющей среде ASP.NET, автоматически компилируются по требованию, то есть тогда, когда они в первый раз понадобятся приложению. Это базовый принцип програм мной модели ASP.NET и ее модели компиляции. В ASP.NET 1.x динамическая компиляция поддерживалась лишь для файлов некоторых типов, включая страницы ASP.NET (*.aspx), Web-сервисы ASP.NET (*.asmx), обработчики HTTP (*.ashx), файлы global.asax и файлы классов. В частности, страницы ASP.NET компилировались при первом обращении к ним, а файлы global.asax - в тот момент, когда в первый раз запрашивалась любая страница приложения, причем перед компиляцией этой страницы. Страницы ASP.NET состоят из файлов разметки и файлов кода. Код страниц не интерпретируется, как в классической технологии ASP, а компилируется, что спо-собствует ускорению их загрузки. Еще одна особенность технологии ASP.NET за-ключается в том, что компиляции подлежат также и файлы разметки. Компиляция выполняется в два этапа: сначала разметка конвертируется во временный класс C# или Microsoft Visual Basic .NET, включаемый в иерархию классов ASP.NET, а затем этот класс компилируется в сборку. Готовая сборка загружается в домен приложения ( AppDomain), который служит хостом данного приложения. Большей части этого процесса пользователь, направивший запрос, конечно же, не видит. Он разве что чувствует небольшую задержку, если первым запрашивает данную страницу. В случае если в запрошенный ресурс (скажем, файл .aspx) будут внесены изменения, система автоматически обнаружит этот факт и перекомпилирует ресурс. Пользователь, который первым запросит его после изменения, опять-таки, может почувствовать небольшую задержку. У такой модели есть два преимущества. Во-первых, ускоряется разработка прило-жения: стоит программисту дать команду Save, и внесенные в программный код изме-нения сразу же вступают в силу. Во-вторых, предоставляемые конечному пользовате-лю страницы генерируются заранее откомпилированным кодом, а потому выдаются быстрее. Таким образом, в описанной модели простота тестирования, свойственная интерпретируемому коду, сочетается с устойчивостью и высокой производительно-стью, присущими коду откомпилированному. В ASP.NET 2.0 эта модель компиляции распространена и на другие типы файлов, такие как XSD, WSDL, ресурсы, темы и эталонные страницы. Кроме того, в ASP.NET 2.0 реализована модель расширяемости, позволяющая дополнять стандартный список поддерживаемых типов файлов пользовательскими типами. В отличие от ASP.NET 1.x модель ASP.NET 2.0 не требует явной компиляции, осуществляемой с использованием Microsoft Visual Studio .NET. Вся работа по компиляции возложена на Web-сервер. В этой главе я опишу внутреннюю структуру исполняющей среды ASP.NET, по-кажу, как страница ASP.NET превращается в класс, раскрою преимущества и недо-статки предкомпиляции сайта и поясню, как можно настроить механизм компиляции и расширить его функции.
Модель компиляции ASP.NET Глава 1 3 Исполняющая среда ASP.NET Любой входящий запрос, получаемый Web-сервером Internet Information Server ( IIS), анализируется им и передается для обработки соответствующему внешнему модулю. Из данного правила есть несколько исключений. IIS самостоятельно выполняет запро-сы статических ресурсов, таких как файлы изображений и HTML-страницы, а также запросы страниц, кэшированных ядром. Чтобы страница могла кэшироваться, для нее должны быть заданы соответствующие конфигурационные установки, разрешающие такое кэширование, и она не должна иметь параметров или компонентов, которые бы ему препятствовали. Данная тема подробно рассматривается в главе 14 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Внешним модулем IIS, отвечающим за обработку входящих запросов ASP.NET, является библиотека динамической компоновки (DLL) с именем aspnet_isapi. Это не обыкновенная DLL, а модуль ISAPI (Internet Server Application Programming Interface - интерфейс прикладного программирования интернет-сервера). ISAPI-модулем (или ISAPI-расширением) называется DLL, реализующая специальный протокол, по которому IIS может с нею взаимодействовать. Примечание Модулем ISAPI называется DLL Microsoft Win32, экспортирующая две функ ции с заданными именами и прототипами - GetExtensionVersion и HttpExtension-Proc, - являющиеся "сердцем" данного модуля. IIS вызывает функцию HttpExtensionProc для обработки запроса и генерирования результата. Соответствие между расширениями имен файлов ресурсов и модулем aspnet_isapi определено в метабазе IIS, а изменить его можно в диалоговом окне Properties кон-кретного Web-приложения IIS, показанном на рис. 1-1. Рис. 1-1. Список расширений, поддерживаемых приложением ASP.NET Задачи, за которые отвечает модуль aspnet_isapi, и, соответственно, выполняемая им работа зависят от используемой модели процесса. Модель процесса ASP.NET определяет последовательность действий, которые необходимо выполнить для обра-ботки запроса и генерирования ответа для браузера. Давайте подробно рассмотрим поддерживаемые ASP.NET модели процесса. Модель процесса ASP.NET поддерживает две модели процесса, названные соответственно версиям IIS, в которых они по умолчанию используются. Когда ASP.NET работает под управлением 
4 Часть I Внутренние механизмы ASP.NET IIS 5.x, единственно допустимой моделью процесса является IIS 5. Можно использо-вать ее и в системе IIS версии 6.0 или выше. Но учтите, что в этих версиях IIS она не является используемой по умолчанию. Модель процесса IIS 5.0 Согласно данной модели модуль aspnet_isapi не предоставляет сам запрошенные ресурсы, а лишь играет роль диспетчера. Этот модуль собирает о запрошенном URL всю доступную информацию, а затем передает запрос рабочему процессу ASP.NET с именем aspnet_wp.exe. Взаимодействие между расширением ISAPI и рабочим про-цессом осуществляется посредством именованных каналов. По умолчанию рабочий процесс выполняется от имени учетной записи ASPNET. Эта учетная запись создается при инсталляции ASP.NET. Как правило, единственная копия рабочего процесса выполняется безостановочно и служит хост-средой для активных Web-приложений, работающих каждое в сво-ем домене приложения. Но существует и альтернативная схема работы, именуемая Web-садом (Web-garden), при которой несколько рабочих процессов выполняются на сервере параллельно, на разных центральных процессорах. Когда клиент запрашивает страницу Web-приложения, которое в этот момент уже выполняется, ASP.NET просто перенаправляет запрос существующему AppDomain, связанному с данным виртуальным каталогом. При этом если для обработки стра-ницы требуется сборка, которая отсутствует в AppDomain, она создается на лету; в противном случае, то есть когда требуемая сборка уже создана при выполнении одного из предшествующих запросов, она используется повторно. Процесс создания сборки является основной темой данной главы. Диаграмма модели процесса IIS 5.0 представлена на рис. 1-2. Рис. 1-2. Модель процесса IIS 5.0 Модель процесса IIS 6.0 В IIS 6.0 реализован другой конвейер внутренних модулей, обрабатывающих входящие запросы. Он может имитировать поведение IIS 5.0 только при работе в режиме эмуля-ции. Модель процесса IIS 6.0, именуемая также режимом изоляции рабочего процесса, 
Модель компиляции ASP.NET Глава 1 5 основана на концепции пула приложений. Так называется группа Web-приложений, для выполнения которых используется одна и та же копия рабочего процесса. За счет использования раздельных процессов важные части Web-сервера отделяются от потенциально неправильно функционирующих приложений. При этом каждый пул приложений и его копию рабочего процесса можно конфигурировать отдельно, задавая для них разные параметры. Согласно модели процесса, используемой в IIS 6.0 по умолчанию, рабочим процес-сом, в котором выполняются приложения ASP.NET, является программа w3wp.exe. Это универсальный рабочий процесс, ничего не знающий об ASP.NET и обслуживающий любые приложения, которые могут выполняться на данном Web-сервере. Как уже было сказано, для каждого пула Web-приложений используется отдельный процесс, то есть отдельная копия программы w3wp.exe. Еще одним важным компонентом архитектуры IIS 6.0 является драйвер устройств ре жима ядра http.sys. Этот драйвер служит "слушателем" HTTP и отвечает за перехват и обслуживание входящих запросов. Когда поступает очередной запрос, http.sys ставит его в очередь, управляемую тем пулом приложений, к которому принадлежит вызыва-емое приложение. Каждый пул приложений имеет собственную очередь запро сов. В режиме эмуляции IIS 5.0 драйвер http.sys помещает запрос в единую очередь, общую для всех приложений. Примечание За дополнительными сведениями о внутренней архитектуре IIS 6.0 вы мо жете обратиться к книге "Internet Information Services (IIS) 6.0 Resource Kit" (Microsoft Press, 2004). Рабочий процесс (копия w3wp.exe) загружает aspnet_isapi.dll; это ISAPI-расшире-ние в свою очередь загружает общеязыковую исполняющую среду (CLR) и запускает конвейер обработки запроса. При использовании модели процесса IIS 6.0 встроенный рабочий процесс ASP.NET отключен. На рис. 1-3 показана диаграмма обработки, соот-ветствующая модели процесса IIS 6.0. Рис. 1-3. Модель процесса IIS 6.0
6 Часть I Внутренние механизмы ASP.NET Для получения запросов и отправки клиенту ответов рабочий процесс использу-ет драйвер http.sys. Этот процесс выполняется от имени учетной записи NETWORK SERVICE, имеющей минимальное число разрешений - их ровно столько, сколько необходимо для осуществления его функций. Примечание За дополнительной информацией о процедуре формирования результи-рующей страницы вы можете обратиться к главе 3 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Здесь же я сосредоточусь лишь на одной особенности данной процедуры - этапе динамической компиляции. Конвейер ASP.NET Модель процесса ASP. NET определяет путь исходного запроса от принявшего его IIS до экземпляра CLR и далее до точки выполнения этого запроса. Внутри CLR запрос про ходит через целый конвейер компонентов, извлекающих содержимое запрошен-ного ре сурса, а затем формирующих ответ, который должен быть отправлен браузеру, и воз вра щающих его Web-серверу. Управляемые модули, входящие в состав конвейера ASP.NET, могут читать и редактировать запрос, считывать и создавать cookie и даже управ лять переадресацией браузера. В конце конвейера запрос превращается в эк-зем пляр класса, представляющего запрошенную страницу. Этот класс и генерирует результат, пересылаемый браузеру. В ASP.NET 2.0 данный процесс существенно переработан, и сейчас в нем задейс-твовано несколько новых компонентов, большинство из которых разработчики могут в той или иной степени настраивать. Каждый запрос ресурса .aspx обрабатывается конвейером модулей, представленных на рис. 1-2 и 1-3. Цель конвейера - найти откомпилированный и загруженный в па-мять класс, полностью представляющий запрошенную страницу. Если такой класс не найден, его исходный код создается на лету и компилируется, а результат загружается в AppDomain, где выполняется приложение ASP.NET. Конвейер HTTP представляет собой расширяемую цепочку управляемых объектов, действующую по классическому конвейерному принципу. Компоненты конвейера перечислены в табл. 1-1. Табл. 1-1. Компоненты конвейера HTTP Компонент Описание HttpApplicationFactory Экземпляр данного класса отвечает за возврат действительного объекта HttpApplication, который может обработать запрос. Объект HttpApplicationFactory поддерживает пул объектов HttpApplication и, когда к нему производится обращение, выясняет, имеется ли уже для виртуальной папки, к которой обращен запрос, AppDomain. Если да, то есть приложение уже выполняется, объект HttpApplicationFactory выбирает из поддерживаемого им пула объект HttpApplication и передает ему запрос. Если в пуле нет ни одного свободного объекта HttpApplication (предположим, все они заняты обработкой других запросов), создается новый такой объект HttpApplication Каждое выполняющееся приложение ASP.NET представлено динами-чески создаваемым классом, наследующим HttpApplication. Исходный код этого класса формируется на основе содержимого файла global.asax. Объект HttpApplication выясняет, какой класс ассоциирован с типом запрошенного ресурса (обычно этим ресурсом является страница ASP.NET, Web-сервис или, возможно, пользовательский элемент уп-равления), и использует соответствующую фабрику обработчиков HTTP для получения объекта, способного предоставить данный ресурс
Модель компиляции ASP.NET Глава 1 7 Компонент Описание HTTP modules Объект HttpApplication поддерживает список специальных объектов - модулей HTTP, которые могут фильтровать и даже модифицировать содержимое запросов. Зарегистрированные модули вызываются в разные моменты обработки запроса, проходящего через конвейер. Встроенные модули HTTP отвечают за аутентификацию Forms, кэширование выходных ресурсов, управление состоянием сеанса и профилями пользователей PageHandlerFactory Объект PageHandlerFactory (фабрика обработчиков страниц) создает объект, представляющий конкретную запрошенную страницу. Аналогичные объекты-фабрики делают то же самое для других типов запрашиваемых ресурсов, таких как Web-сервисы или пользователь-ские обработчики HTTP IHttpHandler Объект-страница, созданный фабрикой страниц, наследует класс System.Web.UI.Page (или производный от него), реализующий интерфейс IHttpHandler. Последним действием, выполняемым исполняющей средой ASP.NET, является вызов для объекта-страницы метода ProcessRequest интерфейса IHttpHandler. Этот вызов заставляет объект выполнить пользовательский код и сгенерировать разметку для клиента Общая схема действия конвейера HTTP представлена на рис. 1-4. Рис. 1-4. Обработка страницы конвейером HTTP Табл. 1-1. (окончание)
8 Часть I Внутренние механизмы ASP.NET Каждое Web-приложение выполняется в отдельном домене приложения и имеет собственный объект класса HttpRuntime. Этот объект создает для запроса HTTP-контекст, инициализирует кэш и монитор файловой системы, используемый для детектирования изменений в файлах приложений. Рабочий процесс (aspnet_wp.exe или aspnet_isapi внутри w3wp.exe) активизирует конвейер HTTP, для чего создает новый экземпляр класса HttpRuntime и вызывает его метод ProcessRequest. Как уже упоминалось, цель HTTP-конвейера - найти в текущем домене прило же-ния управляемый класс, представляющий запрошенный ресурс ASP.NET. Для страниц этот класс прямо или косвенно наследует класс Page, а его имя соответствует опре-деленному соглашению об именовании. Так, класс страницы, имеющей имя xxx.aspx, по умолчанию называется ASP.xxx_aspx. Если же для данной страницы в директи-ве @Page задан атрибут ClassName, тогда именем класса будет ASP.имя_класса, где имя_класса - это значение атрибута ClassName. Если такой класс в текущем домене приложения имеется, создается экземпляр этого класса и вызываются методы его интерфейса IHttpHandler. В противном случае класс динамически создается объек-том - фабрикой обработчиков. Как вы увидите далее, ASP.NET точно знает, существует ли класс страницы и где он находится (данную информацию система считывает из временных файлов). Примечание Динамическое создание класса страницы происходит при первом обращении к ней после развертывания. Этот класс совместно используется всеми сеансами, и только тот пользователь, который первым начнет работу с приложением, почувствует задержку, вызванную компиляцией. Впоследствии страница будет подвергаться перекомпиляции только после внесения изменений в ее исходный код (или в исходный код ресурсов, от которых она зависит, таких, как эталонная страница). Но и этой первой задержки можно избежать, если развертывать сайт заранее откомпилированным. Если страница предкомпилирована, динамическое ее создание не требуется. Чуть ниже я подробнее остановлюсь на этой теме. Теперь мы подробно рассмотрим механизм динамического создания и компиляции класса страницы. Фабрика обработчиков страниц Объект HttpApplication извлекает из файла machine.config имя класса-обработчика, обслуживающего запросы ресурсов конкретного типа. Следующий фрагмент кода демонстрирует стандартную установку, связывающую класс PageHandlerFactory с ре-сурсами .aspx. Подобные соответствия определены для ресурсов . asmx (Web-сервис) и .ashx (пользовательский обработчик HTTP). <httpHandlers> <add path="*.aspx" verb="*" type="System.Web.UI.PageHandlerFactory" validate="True" /> <add path="*.ashx" verb="*" type="System.Web.UI.SimpleHandlerFactory" validate="True" /> <add path="*. asmx" verb="*" type="System.Web.Services.Protocols.WebServiceHandlerFactory, System.Web.Services, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" validate="False" /> </httpHandlers> Класс PageHandlerFactory реализует интерфейс IHttpHandlerFactory, компоненты которого описаны в табл. 1-2.
Модель компиляции ASP.NET Глава 1 9 Табл. 1-2. Интерфейс IHttpHandlerFactory Метод Описание GetHandler Возвращает экземпляр реализующего интерфейс IHttpHandler класса, способного обслужить запрос. Для страниц это класс, наследующий Page. Аргументами данного метода являются глагол HTTP, "сырой" URL и контекст запроса ReleaseHandler Делает все необходимое для того, чтобы фабрика могла повторно использо-вать заданный экземпляр обработчика. Реализация этого метода, создаваемая по умолчанию для HTTP-обработчика страницы, просто возвращает значение типа void Обязанность фабрики обработчиков страниц - либо найти сборку, содержащую класс страницы, либо динамически создать эту сборку по требованию. Исходный код класса генерируется путем сканирования содержимого запрошенного файла .aspx и временно сохраняется в следующей папке ASP.NET: %SystemRoot%\Microsoft.NET\Framework\[версия]\Temporary ASP.NET Files В ASP.NET 1.x класс страницы наследует класс отделенного кода, созданный вами в Visual Studio, а в ASP.NET 2.0 он является расширенной и завершенной версией частичного класса из файла кода, созданного в Visual Studio .NET. Содержащееся в проекте частичное определение класса исполняющая среда ASP.NET динамически дополняет вторым частичным определением класса. Внимание! Модель отделенного кода из ASP.NET 1.x по-прежнему полностью подде-рживается исполняющей средой ASP.NET. К сожалению, она не поддерживается Visual Studio 2005. На рис. 1-5 приведена схема, показывающая, как генерируется исходный код класса динамической страницы. Рис. 1-5. ASP.NET генерирует исходный код динамического класса, который будет обслуживать запрос
10 Часть I Внутренние механизмы ASP.NET Далее класс компилируется и загружается в память для обслуживания запроса. Когда поступает новый запрос на предоставление той же страницы, класс уже готов к использованию, и его компиляция не требуется. (Он будет повторно создан и отком-пилирован только в случае, если изменится штамп времени исходного .aspx-файла.) Роль частичных классов Частичные классы - это новшество компиляторов .NET Framework 2.0. Теперь опре-деление класса можно разбивать на несколько файлов, в каждом из которых содер-жится допустимое и целостное с синтаксической точки зрения определение класса. Компилятор сам позаботится о слиянии частичных классов в обычный класс, который может быть откомпилирован в сборку. Частичные классы следует рассматривать как некое удобство для программиста, возможность, реализуемую на уровне исходного кода, а не как новую объектно-ори-ентированную функцию. Они позволяют сэкономить время на этапе разработки, дают возможность распределить работу над компонентом между несколькими людьми и предоставляют элегантный способ инкрементального наращивания функциональ-ности класса, достоинство которого состоит в том, что программисту не приходится корректировать существующие файлы, - для каждого нового добавления он может создавать новый файл. Частичные классы решают проблему уязвимости инструментально-генерируемого ко да. Если вам приходилось разрабатывать приложения в Visual Studio .NET 2003, то вам наверняка встречались фрагменты автоматически генерируемого этой системой ко-да, непонятные, полускрытые, предназначенные для конструкторов страниц. Этот код дополняет отделенные классы членами, которые необходимы для связи с сер верными элементами управления, размещенными в Web-форме. Непросто поддержи вать отделен-ные классы синхронизированными с Web-формой при ее изменении, если вы редакти-руете исходный .aspx-файл непосредственно в HTML-редакторе! Ре шением проблемы стало введение частичных классов. Теперь код, генерируемый инстру ментальными средствами, не будет мешать вам на этапе разработки. Когда при дет время компиляции, частичный класс отделенного кода будет дополнен всеми необ хо ди мы ми определениями членов, и этот добавленный код останется скрытым от разра ботчиков. Временные файлы ASP.NET Генерирование сборки для конкретного ресурса .aspx - процесс, происходящий в два этапа. Сначала создается файл класса, представляющий разметку .aspx-файла. Затем этот динамически сгенерированный класс компилируется в сборку, которая кэширу-ется в папке Temporary ASP.NET Files. Такая папка создается для каждой инсталли-рованной версии ASP.NET. Скрытые файлы и сборки В папке Temporary ASP.NET Files имеется по одной вложенной папке для каждого когда-либо выполнявшегося приложения. Имя вложенной папки совпадает с име-нем виртуального каталога приложения. Страницы, виртуальным контейнером кото-рых является корневая папка Web-сервера, содержатся в подпапке Root. Сборки отдельных страниц кэшируются во вложенных папках, в результате чего для каждого из приложений создается многоуровневое дерево папок. Ниже показан типичный путь к одной из сборок (выделенные полужирным шрифтом имена двух последних папок здесь вымышленные, но реалистичые): \Framework \[version]
Модель компиляции ASP.NET Глава 1 11 \Temporary ASP.NET Files \MyWebApp \3678b103 \e60405c7 Независимо от того, какой алгоритм используется для генерирования имен папок, в приложении ASP.NET полный путь к папке можно извлечь с помощью следующего простого кода: string tempAspNetDir = HttpRuntime.CodegenDir; То же самое относится и к местоположению динамической сборки. Как же испол-няющая среда ASP.NET узнает имя сборки для конкретной страницы .aspx? Для каждой обработанной страницы временная папка приложения содержит файл с таким именем: [страница].aspx.XXXXX.compiled Здесь страница - это имя .aspx-ресурса, а XXXXX - хэш-значение, полученное на основе пути, одинаковое для всех файлов из одной папки. Сборки, получаемые в результате компиляции исходных файлов страницы, помещаются в одну и ту же папку, хотя сами эти файлы могут находиться в разных местах. Чтобы избежать совпадения имен откомпилированных файлов (в случаях, когда в разных папках содержатся одноименные исходные файлы), система добавляет к ним хэш-значения. Исполняющая среда ASP.NET имеет собственный внутренний кэш хэш-значений, позволяющий ей быстро узнать хэш-значение имени любого ресурса. Ниже приведено содержимое файла .compiled. <preserve virtualPath="/Compilation/Test.aspx" hash="7421446ce" filehash="4d443b62d9942247" flags="10000" assembly="App_Web_g5u1sfqg" type="ASP.Test_aspx"> <filedeps> <filedep name="/Compilation/Test.aspx" /> <filedep name="/Compilation/Test.aspx.cs" /> </filedeps> </preserve> Примечание Синтаксис файлов .compiled не документирован и в будущем может быть изменен. Он демонстрируется здесь с чисто учебной целью, чтобы вы получили представ-ление о внутренней работе ASP.NET. Но, конечно же, не стоит создавать приложения, зависящие от подобных вещей. Узел <preserve> содержит ссылку на исходный файл (test.aspx), имя созданного на его основе класса (ASP.Test_aspx) и, самое важное, имя сборки, содержащей от-компилированную версию данного класса (App_Web_g5u1sfqg). В узле <filedeps> перечислены сопутствующие исходные файлы, используемые в процессе создания динамической сборки страницы. После того как обработчик HTTP идентифицирует имя класса, представляющего запрошенную страницу, он считывает из того же файла .compiled имя содержащей этот класс сборки. В случае если файл .compiled отсутствует либо указанная в нем сборка не найдена или устарела, производится разбор исходного кода, содержащегося в файле .aspx, и создается временный файл класса C# или Visual Basic .NET. Затем этот файл компилируется в новую сборку, имя которой генерируется случайным образом.
12 Часть I Внутренние механизмы ASP.NET Примечание В ASP.NET 2.0 имена динамически создаваемых сборок, представляющих страницы, всегда начинаются с префикса App_Web_. Другие динамически создаваемые сборки, представляющие темы, код приложений, ресурсы и файл global.asax, имеют иные префиксы. Отслеживание изменений страниц Сборки динамически откомпилированных страниц кэшируются и используются при обслуживании последующих запросов этих страниц. Однако после внесения изме-нений в файл .aspx соответствующая сборка становится недействительной, и при поступлении очередного запроса страница автоматически перекомпилируется. Со-ответствие между сборкой и исходным .aspx-файлом определяется в упоминавшемся выше файле .compiled. Внесение любых изменений в файлы, перечисленные в его разделе <filedeps> , также делает сборку недействительной. Для отслеживания таких изменений исполняющая среда ASP.NET использует инфраструктуру мониторинга файлов, действующую на базе системы файловых уведомлений Win32. Измененная страница перекомпилируется как единая сборка и загружается пов-торно. При этом ASP.NET гарантирует, что в ответ на следующий запрос будет пре-доставлена выходная информация, сгенерированная новой сборкой. По текущим за-просам, обслуживание которых уже начато, предоставляется старая версия страницы, генерируемая старой сборкой. Эти две сборки имеют разные имена (поскольку имена сборок генерируются случайным образом) и благополучно сосуществуют в одной папке и в одном домене приложения. Как ASP.NET заменяет сборки страниц Когда после обновления страницы для нее создается новая сборка, ASP.NET выясняет, можно ли удалить предыдущую. Если сборка содержит только класс страницы, про-изводится попытка ее удаления. Однако нередко оказывается, что сборка загружена и заблокирована (поскольку в данный момент используется), и удалить ее файл невоз-можно. В таком случае старая сборка переименовывается - к ее имени добавляется расширение .delete. (Microsoft Windows позволяет переименовывать исполняемые файлы, загруженные в память для выполнения, но не позволяет удалять их, пока они не будут освобождены.) Переименование сборки в данной ситуации не мешает ее использованию, поскольку ее образ уже загружен в память и его повторная загрузка никогда больше не понадобится. Файл фактически уже можно считать удаленным - все файлы с расширениями .delete при следующем обращении к каталогу удаляются в так называемом режиме очистки (sweep mode). Очистка каталога проходит не при любом обращении к нему, а только в случае перезапуска приложения или внесения изменений в его базовые файлы (global.asax или web.config). В ASP.NET для каждого приложения определяется максимальное число переком-пиляций (по умолчанию 15), задаваемое в файле конфигурации. Если оно превышено, приложение перезапускается. Перезапуск происходит следующим образом: выгружается AppDomain, и завершение работы приложения назначается на ближайшее время. Не забывайте, что единицей выгружаемого кода в CLR является не сборка, а домен прило-жения. Иными словами, невозможно выгрузить сборку, не выгрузив весь AppDomain. Внимание! Когда страница перекомпилируется, сборка, представляющая ее старую версию, остается в памяти до тех пор, пока не будет выгружен AppDomain. Не существует способа удалить ее из памяти, - это обусловлено базовым поведением общеязыковой среды. Во избежание переполнения памяти бесполезными сборками вследствие слишком большого числа перекомпиляций исполняемая среда ASP.NET периодически перезапускает приложение, не допуская превышения заданного максимального числа перекомпиляций от момента его запуска.
Модель компиляции ASP.NET Глава 1 13 Получение информации времени выполнения В окне, представленном на рис. 1-6 (файл showruntimeinfo.aspx из комплекта примеров книги), выводится некоторая информация времени выполнения о запущенных прило-жениях и доменах приложений. Полученная посредством свойств класса HttpRuntime, данная информация включает идентификатор, путь и виртуальный путь текущего домена приложения, а также другие полезные сведения, такие как имя каталога, куда ASP.NET помещает сгенерированные динамические сборки (CodegenDir), и каталога Bin приложения (BinDirectory). Рис. 1-6. Информация времени выполнения о текущей странице Еще в данном окне перечислены сборки, загруженные в данный момент в App-Domain. Нашей демонстрационной странице требуется 17 системных сборок, вклю-чая и специфические для данного приложения - global. asax и класс страницы. Это количество возрастает каждый раз, когда вы сохраняете файл .aspx, поскольку после обновления страницы загружается новая сборка, а старая остается в памяти до тех пор, пока не будет перезагружен весь домен приложения. Если вы несколько раз со-храните файл .aspx (открыв его и несколько раз нажав Ctrl+S), то увидите, что после 15 перекомпиляций идентификатор домена приложения изменится, а количество за-груженных сборок снова станет равным исходному их числу (в нашем примере - 17). Это число зависит от того, сколько ссылок на сборки содержат ваша страница. Скрытый код страницы Процесс компиляции страницы мы с вами исследуем на примере, используя для этого страницу test.aspx из папки Compilation. Вот что содержится в основном файле этой страницы: <%@Page Language="C#" AutoEventWireup="true" CodeFile="Test.aspx.cs" Inherits="Test" Debug="true" %> <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"> <html xmlns="http://www.w3.org/1999/xhtml" > <head runat="server">
14 Часть I Внутренние механизмы ASP.NET <title>Sample page</title> </head> <body> <form id="form1" runat="server"> <div> <h1>Enter some text and click.</h1> <h2><asp:Label ID="Today" runat="server" Text='<%# DateTime.Now %>' /></h2> <asp:TextBox ID="TextBox1" runat="server" Text="Type here" /> <asp:Button ID="Button1" runat="server" Text="Reverse" OnClick="ReverseText" /> <hr /> <asp:Label ID="Label1" runat="server" Text="[No info]" /> </div> </form> </body> </html> А вот содержимое ее файла кода: using System; using System.Web.UI; using System.Web.UI.WebControls; using System.Text; public partial class Test : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { DataBind(); } protected void ReverseText(object sender, EventArgs e) { string reverseText = Reverse(TextBox1.Text); Label1.Text = reverseText; } private string Reverse(string text) { if (text.Length == 1) return text; else { StringBuilder sb = new StringBuilder(); sb.Append(Reverse(text.Substring(1))); sb.Append(text.Substring(0, 1)); return sb.ToString(); } } } На данной странице имеется поле, куда пользователь должен ввести текст, и кноп-ка, активизирующая операцию записи этого текста в обратном порядке, выполняемую на сервере. Результат выводится в элементе управления Label, а еще один такой эле-мент служит для вывода текущего времени - при этом используется выражение связы-ва ния с данными. (За дополнительной информацией о таких выражениях вы можете обратиться к моей книге "Programming Microsoft ASP.NET 2.0: Core Reference".) В данном примере описаны две широко распространенные операции, выполняемые веб-страницами, - возврат формы и декларативное связывание данных.
Модель компиляции ASP.NET Глава 1 15 Файлы, вовлеченные в процесс Исходный код класса, генерируемый для страницы test.aspx, помещается во временную папку и после компиляции сразу же удаляется. При желании (с учебной целью) вы можете сделать его постоянным, установив в директиве @Page атрибут debug=true. Вызовите страницу и, когда она отобразится в браузере, откройте папку compilation, которая находится во временной папке ASP.NET (полный путь к ней показан на рис. 1-7), где хранятся создаваемые для страницы временные файлы. Рис. 1-7. Дерево каталогов временной папки приложения, исходный файл которого находится в папке compilation На рис. 1-8 представлен список временных файлов, созданных в процессе обслу-живания запроса страницы test.aspx. Заметьте, что на эксплуатационном компьютере (то есть том, на котором приложение эксплуатируется, а не отлаживается) некоторые из этих файлов после использования удаляются. Рис. 1-8. Временные файлы, созданные для обслуживания запроса страницы test.aspx В табл. 1-3 приведена подробная информация о каждом из файлов. Учтите, что xgpc4gcp - это случайным образом сгенерированный префикс. При каждой пере-компиляции страницы он будет меняться. Табл. 1-3. Важнейшие временные файлы страницы test.aspx Имя файла Описание hash.web Содержит сгенерированное для папки хэш-значение, которое бу дет использоваться при вычислении хэш-значений для отдельных ресурсов App_Web_test.aspx.xxx.dll Динамическая сборка, созданная для страницы с именем test.aspx. На месте обозначения xxx стоит хэш-значение, которое делает имя сборки страницы уникальным, даже если в других подката-логах приложения имеются одноименные страницы (см. след. стр.)
16 Часть I Внутренние механизмы ASP.NET Имя файла Описание Test.aspx.xxx.compiled XML-файл, содержащий информацию о зависимостях test.aspx от внешних файлов. Кроме того, файл .compiled связывает файл test.aspx с именем сборки, сгенерированным случайным образом xgpc4cgb.x.cs Исходный код класса C#, сгенерированный в результате разбора test.aspx, и все его зависимости. Для страницы, языком которой является Visual Basic .NET, это файл класса Visual Basic .NET. На месте обозначения x стоит 0-базированный индекс, исполь-зуемый для различения связанных составляющих файлов. Если в исходном коде страницы не установлен атрибут debug, данный файл удаляется xgpc4cgb.cmdline Текстовый файл, содержащий командную строку, используемую для компиляции указанного выше файла класса. Если в исходном коде страницы не установлен атрибут debug, данный файл удаляется xgpc4cgp.err Текстовый файл, содержащий весь вывод, направляемый компилятором в стандартный поток error. Если в исходном коде страницы не установлен атрибут debug, данный файл удаляется xgpc4cgb.out Текстовый файл, содержащий весь выходной текст, генерируемый компилятором Если вы заглянете во временную папку ASP.NET, то обнаружите там три файла xgpc4cgb.x.cs - на месте обозначения x в их именах стоят цифры от 0 до 2. Дан-ные файлы описаны в табл. 1-4. Их объединенное содержимое составляет код класса страницы test.aspx. Табл. 1-4. Важнейшие временные файлы страницы test.aspx Имя файла Класс Описание xgpc4cgb.0.cs (частичный) Test, ASP.test_aspx Содержит два класса: частичный класс Test, завершающий код, написанный для test.aspx ее автором, и класс обработчика страницы, используемый для обслуживания запроса test.aspx xgpc4cgb.1.cs (частичный) Test Класс из файла кода test.aspx.cs, созданного автором страницы xgpc4cgb.2.cs ASP.FastObjectFactory Класс-фабрика для внутреннего использования, помогающий обойтись без применения технологии рефлексии (.NET reflection) и ускорить процесс создания экземпляра класса обработчика страницы Содержимым файла xxx.1.cs является код частичного класса, связанного со стра-ницей ASP.NET. Этот частичный класс, имеющий имя Test, как указано в атрибуте Inherits директивы @Page, завершается динамически генерируемым частичным клас-сом, который содержит определения членов для каждого из серверных элементов управления. Вот как выглядит определение этого второго частичного класса: public partial class Test : IRequiresSessionState { protected Label Today; protected TextBox TextBox1; protected Button Button1; Табл. 1-3. (окончание)
Модель компиляции ASP.NET Глава 1 17 protected Label Label1; protected HtmlForm form1; protected DefaultProfile Profile { get {return (DefaultProfile) Context.Profile;} } protected HttpApplication ApplicationInstance { get {return (HttpApplication) Context.ApplicationInstance;} } } Полужирным шрифтом выделены объявления членов, соответствующих серверным элементам управления. Этот тот самый код, который в ASP.NET 1.x генерировался Visual Studio .NET 2003 и записывался в скрытые области. Нельзя не упомянуть и о классе FastObjectFactory. Вот его типичный код: namespace ASP { internal class FastObjectFactory { private FastObjectFactory() {} static object Create_ASP_Test_aspx() { return new ASP.Test_aspx(); } } } Данный класс содержит статический метод, создающий экземпляр класса обра-ботчика страницы строго типизированным способом с использованием раннего свя-зывания. Поскольку тип откомпилированной страницы становится известен лишь во время выполнения, единственной возможностью создания экземпляра класса является использование технологии рефлексии. Этот прием позволяет получить небольшой выигрыш в быстродействии на очень часто выполняемых операциях. Внимание! Код класса FastObjectFactory, приведенный с учебной целью, подвергнут некоторой редакции, так что если вы планируете использовать данную информацию при раз работке реальных приложений, обязательно проверьте каждую строку кода и убедитесь, что он работает в вашем контексте. Учтите также, что это внутренний код ASP.NET, а по-тому в следующих выпусках продукта он может быть изменен без предупреждения. Структура страницы Класс обработчика страницы, который создается для обслуживания запросов ресурса test.aspx, наследует класс, заданный в атрибуте Inherits файла разметки. В данном случае наследуемый класс имеет имя Test. Как уже упоминалось, это частичный класс, определенный в файле test.aspx.cs и наследующий, прямо или косвенно, класс Page. Определение класса Test ASP.NET завершает с помощью второго частичного класса, который генерирует сама. Обработчик страницы для ресурса test.aspx, наследующий класс Test, имеет фиксированное имя - ASP.Test_aspx. Рассмотрим его структуру: namespace ASP { public class Test_aspx : Test { private static bool __initialized; private static object __fileDependencies;
18 Часть I Внутренние механизмы ASP.NET public Test_aspx() { string[] dependencies; AppRelativeVirtualPath = "~/Test.aspx"; if (__initialized == false) { dependencies = new string[2]; dependencies[0] = "~/Test.aspx"; dependencies[1] = "~/Test.aspx.cs"; __fileDependencies = GetWrappedFileDependencies(dependencies); __initialized = true; } Server.ScriptTimeout = 30000000; } protected override void FrameworkInitialize() { base.FrameworkInitialize(); __BuildControlTree(this); AddWrappedFileDependencies(__fileDependencies); Request.ValidateInput(); } public override int GetTypeHashCode() { //Это статическое число генерируется во время //динамического генерирования кода данной страницы return 850224717; } } Данный класс имеет два статических свойства. В одном из них задается состояние инициализации класса, а в другом содержится список его файловых зависимостей. Эти два свойства инициализируются в конструкторе класса. Кроме того, в ASP.Test_aspx переопределены два метода базового класса Page, описанные в табл. 1-5. Табл. 1-5. Переопределяемые методы класса ASP.Test_aspx Метод Описание FrameworkInitialize Управляет созданием дерева элементов управления страницы GetTypeHashCode Возвращает хэш-код страницы, уникально идентифицирующий иерархию ее элементов управления. Данный метод не следует путать с GetHashCode, который все классы .NET Framework наследуют от System.Object. Оба метода возвращают значения, идентифицирующие содержимое объектов, однако метод GetHashCode более специализирован, он формирует результат на основе дерева элементов управления страницы. Данное число он генерирует на лету, когда формируется исходный код страницы В переопределенном методе FrameworkInitialize происходят два важных события. Во-первых, вызывается метод __BuildControlTree, который заполняет семейство Controls класса страницы, формируя таким образом дерево ее элементов управления. Код ме-тода __BuildControlTree, к которому мы еще вернемся, автоматически генерируется ASP.NET. Во-вторых, вызывается метод ValidateInput объекта Request, гарантирующий, что страница не станет обрабатывать никаких потенциально опасных данных, введен-ных пользователем. Однако учтите, что метод ValidateInput, управляемый атрибутом ValidateRequest директивы @Page, просто применяет ко всем входным данным некие стандартные регулярные выражения. Целиком полагаться на него в вопросе защиты приложения, конечно же, нельзя.
Модель компиляции ASP.NET Глава 1 19 Дерево элементов управления Метод __BuildControlTree является той точкой входа программного кода обработчика страницы, где происходит построение класса на основе ASPX-разметки. В нем исполь-зуется ссылка IParserAccessor на объект текущей страницы, позволяющая получить доступ ко всем вложенным объектам и добавить их в семейство Controls обрабаты-ваемой страницы. private void __BuildControlTree(Test_aspx __ctrl) { //Получает от страницы интерфейс синтаксического разбора IParserAccessor __parser = (IParserAccessor) __ctrl); //Формирует узел <head> и добавляет его в дерево HtmlHead __ctrl1 = __BuildControl__control2(); __parser.AddParsedSubObject(__ctrl1); //Строит поддерево для литерального выражения __parser.AddParsedSubObject(new LiteralControl("<body>")); //Формирует узел <form> и добавляет его в дерево HtmlForm __ctrl2 = __BuildControlform1(); __parser.AddParsedSubObject(__ctrl2); //Строит поддерево для литерального выражения __parser.AddParsedSubObject(new LiteralControl("</body></html>")); } Здесь обрабатывается содержимое тэга <head> для получения поддерева его эле-ментов управления, а затем то же самое проделывается для тэга <form> и всего его содержимого. Каждое литеральное выражение (например, <body>) обрабатывается как элемент управления. Весь тест, обнаруживаемый между двумя серверными уп-равляющими элементами, преобразуется в литеральный элемент управления и до-бавляется в дерево. Совет Имея в виду такое поведение обработчика страницы, следует избегать исполь-зования между серверными управляющими элементами пар "возврат каретки-перевод строки". Последовательность /r/n добавляется в генерируемое дерево в виде литераль-ного элемента управления. Данная последовательность не влияет на рендеринг HTML, она просто делает исходный код более читабельным, однако платой за это является некоторое снижение производительности во время выполнения. Для каждого серверного элемента управления генерируется процедура, подобная приведенной ниже, формирующей текстовое поле TextBox1: private TextBox __BuildControlTextBox1() { TextBox __ctrl = new TextBox(); this.TextBox1 = __ctrl; __ctrl.ApplyStyleSheetSkin(this); __ctrl.ID = "TextBox1"; __ctrl.Text = "Type here"; return __ctrl; } Данный код является результатом обработки следующей разметки: <asp:TextBox ID="TextBox1" runat="server" Text="Type here" />
20 Часть I Внутренние механизмы ASP.NET Build-метод тэга <form> вызывает build-методы всех содержащихся в форме эле-ментов управления. У этих методов фиксированные имена: __BuildControlимя, где имя - это идентификатор элемента управления. Для неименованных элементов ис-пользуется имя controlN. Обработчики событий и выражения связывания с данными Что если у элемента управления имеется обработчик события или выражение связы-вания с данными? Давайте для примера рассмотрим кнопку с обработчиком события Click. Генерируемый для нее код почти идентичен приведенному выше, с той разницей, что вместо класса TextBox используется класс Button, да еще добавлена следующая строка: __ctrl.Click += new EventHandler(this.ReverseText); Для выражений связывания с данными, имеющих вид <%# . %>, генерируется похожий код, только в этом случае используется событие DataBinding: __ctrl.DataBinding += new EventHandler(__DataBindingToday); Код обработчика этого события зависит от типа связываемого элемента управления и связываемых данных. В указанном относительно простом случае он выглядит так: public void __DataBindingToday(object sender, EventArgs e) { Label target = (Label) sender; target.Text = Convert.ToString(DateTime.Now, CultureInfo.CurrentCulture); } Появившиеся в ASP.NET 2.0 $-выражения обрабатываются иначе, поскольку они не имеют никакого отношения к процессу связывания с данными. Мы поговорим о них подробно в главе 5. Повторное использование динамически компилируемых классов страниц Теперь, разобравшись во внутренней структуре классов, создаваемых для обработки запросов .aspx-ресурсов, вы можете задуматься о возможности повторного использова-ния этих сборок для ускорения создания похожих страниц. Является ли динамически сгенерированный класс повторно используемым, и можно ли на его основе создавать другие похожие страницы подобно тому, как осуществляется визуальное наследование для Windows Forms? Если вы ждете ответа да или нет, то мой ответ - нет. Вы, конечно, можете создать копию динамической сборки и импортировать ее в папку Bin приложения, а затем изменить ссылку на родительский класс в файле кода страницы, которую вы хотите создать на основе существующей. Результат будет скомпилирован без существенных предупреждений, но, увы, не запустится, поскольку страницы ASP.NET должны иметь не более одного серверного тэга <head> и одного тэга <form>. Производный же класс просто добавит свои собственные форму и за-головок к существующим, создав таким образом недозволенные дубликаты. Можно, пожалуй, избежать этого, написав производный класс определенным образом. Од-нако вам не стоит прикладывать такие усилия, поскольку в ASP.NET 2.0 имеется такой замечательный механизм, как эталонные страницы, с помощью которого зна-чительно легче достичь того же результата. (Подробнее об эталонных страницах и доступных способах визуального наследования рассказывается в главе 6 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference"). Если какая-либо группа страниц или пользовательских элементов управления потребуется вам для другого Web-приложения, то подумайте о повторном использо-
Модель компиляции ASP.NET Глава 1 21 вании готовых сборок, а не исходного кода. Целесообразно применять такой подход при работе с большими приложениями, содержащими множество страниц и пользо-вательских элементов управления (например, файлов .ascx, о которых речь пойдет в главе 12), представляющих собой "закрытые" и не допускающие дальнейшего обнов-ления блоки пользовательского интерфейса. Вместо того чтобы копировать их исход-ный код, можно выполнить их предкомпиляцию, получив в результате библиотеку классов, отлично подходящую для многократного использования. Создайте в Visual Studio 2005 Web-проект, не включая в него global.asax и уделяя особое внимание содержимому, для которого требуется файл web.config. Чем меньше зависимостей будет у файлов вашего приложения, тем лучше. Затем опубликуйте приложение, используя команду меню Build\Publish. Из каталога, в который помещаются готовые файлы, скопируйте в каталог своего приложения сгенерированные сборки - и дело сделано. Можете обойтись и без Visual Studio, воспользовавшись утилитой MSBuild. В любом случае не забудьте установить флажок Fixed Names, чтобы сборки получили более удобочитаемые имена. Главное здесь то, что сборки, получаемые в результате динамической компи-ляции страниц, можно использовать сами по себе, но нельзя на их основе строить иерархии страниц, как при обычной объектно-ориентированной разработке. Предкомпиляция приложений По умолчанию каждый общедоступный ресурс сайта ASP.NET компилируется на лету при первом обращении к нему, и, естественно, в этот момент происходит некоторая задержка. Еще со времен ASP.NET 1.0 разработчики поднимали вопрос о предкомпи-ляции сайта. Такое решение имеет два преимущества: во-первых, устраняется задержка при первом обращении к странице, поскольку она уже откомпилирована, а во-вторых, нет необходимости копировать на Web-сервер исходный код. Предкомпиляция может осуществляться двумя способами: на месте (in-place) и для развертывания (deploy precompilation). В первом случае она выполняется на эксплуатационном компьютере, а во втором - на том компьютере, где разрабатывается приложение. После компи-ляции для развертывания сайт упаковывается - причем в инсталляционный пакет включаются только готовые сборки и необходимые статические ресурсы, - а затем развертывается на эксплуатационном компьютере (исходные файлы страниц на произ-водственный компьютер не переносятся). Таким образом, сайт, предкомпилированный для развертывания, подобен классическому исполняемому файлу Windows: он не подвергается динамическим изменениям и защищен от посягательств на интеллекту-альную собственность. Что касается предкомпиляции на месте, то она является просто способом подготовки всех ресурсов сайта к мгновенному использованию - такой сайт развертывается на эксплуатационном компьютере целиком, вместе со своим исходным кодом, и может подвергаться там дальнейшей доработке. Предкомпиляция на месте Предкомпиляция на месте - это просто один из способов повышения производитель-ности сайта. Вы развертываете приложение как обычно - используя FTP, утилиту xcopy или инсталляционный пакет. Развернув сайт на эксплуатационном сервере, вы предкомпилируете его и только затем открываете к нему доступ пользователям. Предкомпиляция гарантирует, что все динамические сборки будут созданы заранее и каждая страница будет мгновенно доступна пользователю уже при первом обращении к ней. Таким образом, предкомпиляция на месте повышает качество сайта в глазах конечных пользователей.
22 Часть I Внутренние механизмы ASP.NET Условия предкомпиляции на месте Для того чтобы сайт можно было предкомпилировать на месте, нужно чтобы он ра-ботал под управлением IIS и чтобы для языков программирования, которые исполь-зуются в файлах его страниц, на целевом компьютере имелись компиляторы .NET. Если хоть один из файлов откомпилировать не удалось, предкомпиляция сайта за-вершается неудачей. Модель предкомпиляции на месте позволяет дополнять сайт новыми страни-цами или новыми версиями существующих страниц в процессе его эксплуатации. Нет нужды говорить, что новые или модифицированные страницы загружаются без остановки и перекомпиляции сайта, а потому первый пользователь, обратившийся к такой странице, сталкивается с задержкой. Однако при перекомпиляции сайта обра-батываются только новые и модифицированные файлы, а остальные пропускаются. Таким образом, сокращается до минимума время, в течение которого перекомпили-руемый сайт остается недоступным. Утилита aspnet_compiler Чтобы выполнить предкомпиляцию сайта на месте, достаточно запустить пакетный компилятор, который последовательно откомпилирует все страницы сайта. Этой цели служит утилита aspnet_compiler.exe, способная осуществить предкомпиляцию любого типа. Вы найдете ее в папке %WINDOWS%\Microsoft.NET\Framework\[версия] Для того чтобы предкомпилировать сайт на месте, нужно выполнить приведен-ную ниже команду, заменив в ней аргумент /proaspnet20 именем виртуальной папки своего приложения: aspnet_compiler -v /proaspnet20 В табл. 1-6 перечислены ключи утилиты aspnet_compiler, имеющие отношение к компиляции на месте. Табл. 1-6. Ключи командной строки утилиты aspnet_compiler Ключ Описание -m Указывает полный путь к IIS-метабазе приложения. Этот ключ не может использоваться одновременно с ключами -v и -p -v Задает виртуальный путь к компилируемому приложению. Если задан также ключ -p, для поиска приложения используется физический путь. Если виртуальный путь не задан, считается, что приложение расположено на сайте, используемом по умолчанию, - W3SVC/1/Root -p Указывает физический путь к компилируемому приложению. Если данный ключ отсутствует, для поиска приложения используется метабаза IIS. Ключ -p должен применяться совместно с ключом -v -d Если задан данный ключ, в процессе компиляции выводится отладочная информация -c Если данный ключ присутствует, предкомпилируемое приложение строится заново - все ранее откомпилированные компоненты перекомпилируются -keyfile Задает физический путь к key-файлу сильных имен -keycontainer Указывает имя key-контейнера сильных имен -aptca Если данный ключ задан, будет разрешен вызов откомпилированных сборок частично доверенными (partially trusted) объектами -delaysign Если данный ключ присутствует, компилируемые сборки не будут полностью подписываться при создании
Модель компиляции ASP.NET Глава 1 23 Ключ Описание -fixednames Если данный ключ задан, компилируемым сборкам будут присвоены фиксированные имена Рассмотрим пример предкомпиляции на месте. Результаты предкомпиляции на месте После подачи указанной выше команды утилита aspnet_compiler запускается и рекур-сивно сканирует все страницы (для чего анализирует их зависимости), находящиеся в виртуальной папке, а также страницы дочерних приложений. Сгенерированные сбор-ки помещаются в каталог кода и остаются там для обслуживания запросов. На рис. 1-9 показана данная утилита во время заполнения каталога генерируемого кода. Рис. 1-9. Утилита aspnet_compiler в действии - сайт предкомпилируется на месте Удалите любую временную папку своего приложения, а затем запустите утилиту из командной строки - папка будет заполняться у вас на глазах, и когда утилита завершит свою работу, все динамические сборки будут сгенерированы. Заметьте, что утилите aspnet_compiler требуется доступ к серверу localhost и ад-министративные полномочия на том компьютере, где она создает сборки. Предкомпиляция для развертывания Предкомпиляция для развертывания преследует иные цели, чем предкомпиляция на месте. Концептуально ее задача - превратить приложение ASP.NET в закрытый исполняемый файл, который оберегает интеллектуальную собственность, скрывая исходный код (как разметку, так и классы). При такой компиляции генерируется представление сайта в виде набора файлов - статических, разметки и, конечно, сборок. Затем все это упаковывается в файл формата CAB, ZIP или MSI, из которого и будет развертываться приложение. Данная технология, как и описанная выше, позволяет избавить пользователя от задержек при первом обращении к страницам. Она имеет две разновидности, одна из которых предназначена для создания обновляемых сайтов, а другая - необновляемых. Табл. 1-6. (окончание)
24 Часть I Внутренние механизмы ASP.NET В обоих случаях используется одна и та же уже знакомая вам утилита aspnet_compiler. Те ее ключи, которые относятся к предкомпиляции для развертывания, описаны в табл. 1-7. Табл. 1-7. Дополнительные ключи командной строки утилиты aspnet_compiler Ключ Описание -u Если этот ключ задан, предкомпилируемое приложение будет обновляемым -f Указывает, что целевой каталог, если он уже существует, будет перезаписан и его содержимое будет утрачено targetDir Задает физический путь к папке, в которую будут помещены файлы откомпилированного приложения. Если этот ключ отсутствует, приложение предкомпилируется на месте Предкомпиляция, не допускающая последующего обновления Главным отличием процедур предкомпиляции на месте и предкомпиляции для раз-вертывания является то, что последняя может производиться на том компьютере, где ведется разработка, и в результате создается подлежащий развертыванию образ сайта в заданном целевом каталоге. Попробуйте выполнить такую команду: aspnet_compiler -v /ProAspNet20 c:\Deliverable Результат ее выполнения показан на рис. 1-10. Рис. 1-10. Сайт предкомпилирован и готов к развертыванию Вы увидите, что появился дополнительный маленький файл с именем precompiledapp.config и следующим содержимым: <precompiledApp version="2" updatable="false"/> Этот файл является маркером, информирующим исполняемую среду ASP.NET о том, что приложение предкомпилировано. На рисунке вы также видите, что файлы web.config и web.sitemap имеют разные даты. Дело в том, что такие статические фай-лы, как изображения, web.config или web.sitemap, не компилируются - они просто копируются в целевую папку. Внешне все выглядит так, будто структура сайта остается неизменной. Однако если копнуть глубже, обнаружится множество отличий. Во-первых, файлы .aspx пусты. 
Модель компиляции ASP.NET Глава 1 25 Точнее, в них находится строка текста с предупреждением о том, чтобы вы не удаляли эти файлы, несмотря на то что никакого важного текста они вроде бы не содержат. Страницы ASP.NET в предкомпилированном сайте представлены файлами-мар-керами, которые нельзя удалять. Это необходимые конечные точки, которые должны развертываться вместе с остальными файлами приложения. Однако их содержимое не будет ни анализироваться, ни обрабатываться. Поэтому при желании вы можете заменить содержащийся в них текст любым другим, перед тем как упакуете свой сайт для переноса на эксплуатационный компьютер. В папке Bin приложения также содержится не тот набор сборок, который входит в состав исходного проекта. Помимо сборок, на которые в приложении есть ссылки, тут имеется еще и по одной сборке App_Web_xxx на каждую страницу приложения. Таким образом, сайты, откомпилированные для развертывания без возможности последующего изменения, не чувствительны к изменениям входящих в их состав файлов. Если такой сайт потребуется модифицировать, нужно будет внести измене-ния в исходные файлы на рабочем компьютере, перекомпилировать там весь сайт и развернуть его заново. Единственное исключение составляет конфигурация сайта; файлы web.config и web.sitemap можно обновлять на эксплуатационном сервере без перекомпиляции сайта. Предкомпиляция с возможностью последующего обновления Добавив в команду запуска компилятора ключ -u, вы перекомпилируете сайт таким образом, чтобы впоследствии его содержимое можно было обновлять. В этом случае в файлы .aspx будут внесены небольшие изменения: компилятор удалит атрибут CodeFile и изменит атрибут Inherits. Все остальные файлы будут откомпилированы как обычно. Данный способ компиляции обеспечивает возможность вносить в откомпилированные страницы ASP.NET небольшие изменения. Например, можно изменять расположение элементов управления или их визуальные параметры - цвета, шрифты и т. п. Кроме того, разрешено добавлять на страницы новые элементы управления, но только такие, для которых не требуются обработчики событий или иной код. Программные файлы развертываются не в виде исходного кода, поэтому логику страниц без перекомпиляции и повторного развертывания изменить невозможно. Пользователи обновляемых сайтов не избавлены от задержек при первом обращении к измененной странице. Примечание В ASP.NET 2.0 модель предкомпиляции с возможностью последующего обновления почти идентична модели компиляции и развертывания из ASP.NET 1.1, где файлы .aspx развертывались в виде исходного кода, а все классы (включая классы отделенного кода) компилировались в сборки. Программная предкомпиляция Предкомпиляцию сайта можно выполнять и программным способом. Класс Client-BuildManager предоставляет API для запуска предкомпиляции приложения ASP.NET. Утилита aspnet_compiler просто создает экземпляр этого класса и использует для выполнения своей задачи его открытый интерфейс. Метод, который предназначен для запуска предкомпиляции, называется PrecompileApplication. Конструкторы класса позволяют задать виртуальный и физический каталоги исходного кода и целевой каталог для генерируемых файлов. Кроме того, один из конструкторов может принимать дополнительные параметры, такие как флаги пред-компиляции и атрибуты сильного имени. ClientBuildManagerParameter params = new ClientBuildManagerParameter(); params.PrecompilationFlags = PrecompilationFlags.Updatable |
26 Часть I Внутренние механизмы ASP.NET PrecompilationFlags.OverwriteTarget; ClientBuildManager cbm; cbm = new ClientBuildManager(vdir, sourceDir, targetDir, params); cbm.PrecompileApplication(); Перечислимый тип PrecompilationFlags определяется следующим образом: public enum PrecompilationFlags { AllowPartiallyTrustedCallers = 0x20, Clean = 8, CodeAnalysis = 0x10, Default = 0, DelaySign = 0x40, FixedNames = 0x80, ForceDebug = 4, OverwriteTarget = 2, Updatable = 1 } Все классы определены в пространстве имен System.Web.Compilation. Строительные блоки приложения ASP.NET Механизм компиляции ASP.NET включает два главных класса-менеджера и семейство компонентов, именуемых провайдерами компиляции (build providers). Этими двумя классами являются упомянутый выше ClientBuildManager и BuildManager. Класс ClientBuildManager действует как прокси между клиентским приложением, таким как Visual Studio, и серверной системой ASP.NET, которая непосредственно компилирует страницы и ресурсы. Класс BuildManager управляет процессом физи-ческой компиляции из окружения ASP.NET. Он создает и использует провайдеры компиляции, обрабатывающие конкретные ресурсы. Что касается провайдеров ком-пиляции, то каждый из них реализует объектную модель, необходимую для анализа файлов соответствующего типа и генерирования результирующего кода. За динамической компиляцией каждого класса C# или Visual Basic.NET в сборку, в какой бы папке приложения он не находился, всегда стоит провайдер компиляции. В частности, такие провайдеры руководят компиляцией страниц ASP.NET, тем и профилей. Вы можете определять и регистрировать пользовательские провайдеры компиляции, чтобы расширить набор типов файлов, которые может обрабатывать ASP.NET. О том, как разработать пользовательский провайдер компиляции, будет рассказано далее в этой главе. Теперь нам предстоит исследовать механизм компиляции ASP.NET и рассмотреть поддерживаемые варианты его конфигурации. Параметры компиляции Поведением среды компиляции ASP.NET управляет множество параметров, определя-емых в файле web.config. Все они сосредоточены в разделе <compilation> , состоящем из четырех подразделов, описанных в табл. 1-8. Прежде чем непосредственно перейти к изучению перечисленных подразделов, рассмотрим атрибуты самого раздела <compilation>. Атрибут Debug указывает, следует ли компилировать двоичные файлы retail и debug. По умолчанию он имеет значение false. В атрибуте DefaultLanguage задается язык программирования для тех случаев, когда он не указан явно. По умолчанию это Visual Basic .NET. Атрибуты Strict и Explicit управляют одноименными флагами компилятора Visual Basic. Наконец, в атрибуте 
Модель компиляции ASP.NET Глава 1 27 TempDirectory задается каталог для хранения временных файлов, создаваемых в про-цессе компиляции. Табл. 1-8. Подразделы раздела <compilation> Подраздел Описание <assemblies> Список сборок, которые могут использоваться при компиляции ресурса ASP.NET <codeSubDirectories> Список подкаталогов, содержащих файлы кода, подлежащие компиля-ции во время выполнения. Обычно это подпапки папки App_Code <buildProviders> Перечень всех зарегистрированных провайдеров компиляции (эта тема рассматривается далее) <expressionBuilders> Перечень всех зарегистрированных провайдеров выражений (о них будет рассказано в главе 5) Связанные сборки В разделе <assemblies> находится перечень сборок, автоматически связываемых с каж-дым компилируемым классом страницы. По умолчанию содержимое этого раздела таково: <assemblies> <add assembly="mscorlib" /> <add assembly="System, ..." /> <add assembly="System.Configuration, ..." /> <add assembly="System.Web, ..." /> <add assembly="System.Data, ..." /> <add assembly="System.Web.Services, ..." /> <add assembly="System.Xml, ..." /> <add assembly="System.Drawing, ..." /> <add assembly="System.EnterpriseServices, ..." /> <add assembly="System.Web.Mobile, ..." /> <add assembly="*" /> </assemblies> Последняя строка <add> указывает, что для приложения должны загружаться все сборки, найденные в папке /Bin. В файлах web.config, специфических для приложе-ния, этот список можно изменять по своему усмотрению, используя узлы <clear>, <remove> и <add>, позволяющие соответственно очистить предшествующий список сборок, удалить конкретную сборку или добавить ее. Пакетная компиляция ASP.NET стремится упаковать в одну откомпилированную сборку как можно больше страниц; однако существует заданный максимальный размер пакета, которого она не превышает. Пакетная компиляция является формой оптимизации, нацеленной на минимизацию количества сборок, загружаемых в приложение. При пакетной компиляции система по возможности группирует сборки распо-ложенных в одном каталоге страниц, для которых используется один язык. Такой подход применяется только к Web-каталогам, содержащим страницы, то есть файлы с расширениями .aspx и .ascx. Зарезервированные же каталоги, такие как App_Code, всегда автоматически компилируются в одну сборку. Страницы с ошибками, выяв-ленными во время синтаксического анализа, исключаются из процесса компиляции. 
28 Часть I Внутренние механизмы ASP.NET А когда ошибка происходит при компиляции страницы, такая страница не включается в финальную сборку. Управление пакетной системой осуществляется с помощью конфигурацион-ных директив, расположенных в разделе <compilation> конфигурационного файла (табл. 1-9). Табл. 1-9. Параметры пакетной компиляции Атрибут Описание batch Разрешает пакетную компиляцию. По умолчанию установлен в true batchTimeout Указывает длительность пакетной компиляции в секундах. Если компиляция не может быть завершена за заданное время, компилятор для текущей страницы переключается в режим единичной компиляции. В ASP.NET 2.0 такое поведение больше не поддерживается, а атрибут batchTimeout просто игнорируется maxBatchSize Определяет максимальное число группируемых страниц maxBatchGeneratedFileSize Задает для пакетной компиляции максимальный объединенный размер генерируемых файлов (в килобайтах) Очень важно правильно настроить параметры, содержащиеся в разделе <compilation> конфигурационного файла, - это избавит вас от необходимости иметь (и за-гружать), например, тысячу различных сборок для такого же количества страниц или одну огромную сборку с тысячей классов внутри. Заметьте, однако, что при выборе оптимальной конфигурации нужно учитывать не только размер и количество сборок, но также и время, которое будет затрачиваться на их перекомпиляцию при обновлении страниц. Некомпилируемые страницы В ASP.NET 2.0 некомпилируемыми (no-compile) называются страницы, которые никог-да не компилируются. Создается такая страница путем присваивания атрибуту CompilationMode директивы @Page значения Never. Каково же назначение таких страниц и чем они отличаются от статических HTML-страниц? Прежде всего тем, что такие страницы - не для каждого приложения. Их приме-нение позволяет повысить маштабируемость очень больших Web-сайтов, содержащих тысячи страниц. Создается некомпилируемая страница так же, как и любая другая страница ASP.NET, то есть она составляется из серверных элементов управления. Однако некомпилируемая страница не может иметь отделенного кода. Нельзя связать ее с файлом кода или включить серверный блок <script> прямо в нее. Единственной формой исполняемого кода, которая поддерживается для таких страниц, являются $-выражения. Из главы 5, где рассматриваются пользовательские $-выражения, вы узнаете, как определять их для некомпилируемых страниц. Некомпилируемые страницы обладают двумя важными достоинствами. В защи-щенной среде, такой как Microsoft SharePoint Services, их применение исключает возможность написания разработчиками потенциально ошибочного кода, который может вызвать в хост-среде проблемы и даже привести к ее сбою. А их применение в больших сайтах на компонентной основе позволяет избежать временных затрат, свя занных с компиляцией тысяч страниц. Следует отметить, что операционная сис-тема Windows ограничивает количество DLL, которые могут быть загружены для одного приложения. По достижении этого предела производительность значительно снижается. Некомпилируемые же страницы можно выгружать из памяти, а также 
Модель компиляции ASP.NET Глава 1 29 постранично удалять из памяти в процессе сборки мусора, что очень важно для круп-ных сайтов. В то время как страницы, хранящиеся в виде обычных сборок, не могут быть выгружены без освобождения всего AppDomain, некомпилируемый сайт теоре-тически может предоставить бесконечное число страниц, не перезагружая домены приложений. Таким образом, некомпилируемые страницы предназначены для повышения масш-табируемости, а не производительности. При их использовании последняя не только не повысится, но может даже немного снизиться. Известно, что страницы ASP.NET отличаются от обычных HTML-страниц тем, что подлежат компиляции. Но как же тогда работают некомпилируемые страницы ASP.NET? Фокус здесь в том, что для них не требуется создавать и сохранять на диске сборки. Класс, являющийся построителем элементов управления страницы сохраняется в памяти и повторно используется для создания страницы при каждом следующем запросе. Когда по той или иной причине кэш, где содержится построитель, требуется обновить, приложение перезагружается. Зарезервированные папки ASP.NET Для каждого приложения ASP.NET может быть создано несколько стандартных папок, назначение которых описано в табл. 1-10. Табл. 1-10. Зарезервированные папки ASP.NET Имя папки Типы файлов Содержимое Bin .dll Заранее созданные сборки, необходимые для работы приложения App_Browsers .browser Специфические для приложения файлы определения браузера, которые ASP.NET использует для идентификации типа браузера и определения его возможностей App_Code .cs, .vb, .xsd, пользовательские типы файлов Файлы исходного кода классов, подлежащие компиляции в составе приложения. ASP.NET компилирует код из данной папки при поступлении запроса страницы. Ссылки на этот код из приложения создаются автоматически App_Data .mdb, .mdf, .xml Файлы Microsoft Office Access и SQL Express, а также XML-файлы и другие хранилища данных App_GlobalResources .resx Файлы ресурсов, которые будут использоваться про-граммным способом при локализации приложения App_LocalResources .resx Файлы ресурсов для отдельных страниц App_Themes .skin, .css, .xsl, вспомогательные файлы Набор файлов, определяющих внешний вид страниц и элементов управления ASP.NET App_WebReferences .wsdl WSDL-файлы, необходимые для генерирования прокси-классов, и другие файлы, связанные с использованием Web-сервисов в приложении Папка Bin В папке Bin содержатся сборки, необходимые для элементов управления и компо-нентов приложения, а также прочий код, на который в нем имеются ссылки. Однако учтите, что все файлы .dll, найденные в этой папке, будут автоматически связаны с приложением. Если оставить здесь неиспользованные или устаревшие файлы, вы 
30 Часть I Внутренние механизмы ASP.NET рискуете получить исключение "ambiguous reference". Иными словами, если в двух разных сборках определены два одноименных класса (относящихся при этом к одному и тому же пространству имен), то исполняющая среда ASP.NET не может решить, какой из них использовать, и генерирует исключение. Это типичная ошибка, часто возникающая из-за того, что во время разработки переименовывается проект или сборка. Чтобы ее избежать, убедитесь, что в папке Bin нет никаких лишних сборок, или хотя бы просто удалите приведенную ниже строку из раздела <assemblies> кон-фигурационного файла: <add assembly="*" /> Из всех папок, перечисленных в табл. 1-10, только папка Bin используется также приложениями ASP.NET 1.x. Она является обязательной. Папка App_Browsers В этой необязательной папке содержатся файлы с расширением .browser. В таком файле описываются характеристики и возможности браузера, будь то браузер мо-бильного устройства или настольного компьютера. ASP.NET устанавливает большой набор файлов .browser в подпапку Config\Browsers своего инсталляционного ката-лога. Эти файлы совместно используются всеми приложениями. Что касается папки App_Browsers, то в нее вы помещаете только те файлы, которые специфичны для вашего приложения. Содержимое файла .browser компилируется на лету, и ASP.NET предоставляется актуальная информация о браузере. Рассмотрим ситуацию, в которой целесообразно создать пользовательский файл .browser. Представьте, что в приложении используется элемент управления, рендеринг которого для определенного браузера производится неэффективно. В таком случае вы можете создать подходящий файл .browser, и если страницу запросит именно этот браузер, то ASP.NET, руководствуясь содержимым данного файла, выберет для рендеринга "проблемного" элемента управления другой адаптер. Файл .browser может иметь, например, такое содержимое (будем считать, что browserID здесь соответствует одному из стандартных браузеров, распознаваемых ASP.NET): <browsers> <browser id="browserID"> <controlAdapters> <adapter controlType="Samples.CustomControl" adapterType="Samples.Adapters.CustomControlAdapter" /> </controlAdapters> </browser> </browsers> Эти инструкции просто указывают ASP.NET, что для данного браузера ренде-ринг элемента управления CustomControl должен осуществляться адаптером Custom-ControlAdapter. Папка App_Code В папке App_Code, расположенной непосредственно в корневой папке Web-приложе-ния, хранятся файлы всех классов, подлежащих динамической компиляции в составе приложения. Эти файлы классов автоматически связываются с приложением, и вам не нужно добавлять в файл страницы никаких явных директив или объявлений для создания зависимостей. Файлы классов, помещенные в папку App_Code, могут содер-жать любые распознаваемые ASP.NET компоненты - специализированные (custom) элементы управления, вспомогательные классы, провайдеры компиляции, бизнес-классы, пользовательские провайдеры, обработчики HTTP и т. д.
Модель компиляции ASP.NET Глава 1 31 Примечание Каждый раз, когда во время разработки в папку App_Code вносится то или иное изменение, происходит полная перекомпиляция приложения. Для большого приложения этот процесс довольно длительный, поэтому имеет смысл применить модульную организа-цию кода - разделить его на группы логически связанных между собой классов и каждую такую группу поместить в отдельную библиотеку классов. Как правило, вспомогательные классы, специфические для приложения, должны размещаться в папке App_Code. Во всех файлах классов, находящихся в папке App_Code, должен использоваться один и тот же язык. Если ваши файлы написаны на двух и более языках, создайте для каждого языка свой подкаталог и поместите туда соответствующие файлы, после чего для каждого из этих подкаталогов добавьте в файл web.config такую запись: <compilation> <codeSubDirectories> <add directoryName="VBFolder" /> </codeSubDirectories> </compilation> Если вы забудете зарегистрировать языковые подкаталоги в файле web.config, все файлы из папки App_Code и вложенных в нее папок будут скомпилированы в одну сборку. Приведенный выше конфигурационный сценарий описывает ситуацию, когда все файлы, написанные, скажем, на языке C#, находятся непосредственно в App_Code, а несколько файлов классов Visual Basic.NET перемещены в подкаталог VBFolder. Если подкаталога, указанного в <codeSubDirectories>, не существует, вы получите сообщение об ошибке компиляции. Файлы из корневой папки App_Code компилируются в сборку App_Code_xxx.dll, где xxx - случайным образом сгенерированная последовательность символов. Фай-лы, находящиеся в подкаталоге, компилируются в динамически создаваемую сборку App_SubCode_xxx_yyy.dll, где xxx - имя подкаталога, а yyy - случайная последова-тельность символов. Раздел <codeSubDirectories> может содержаться только в файле web.config, находящемся в корневой папке приложения. Строго именованная сборка создается путем помещения файла assemblyinfo.cs (или assemblyinfo.vb, в зависимости от того, на каком языке написано его содержи-мое) в папку App_Code или любую из ее вложенных папок. Файл конфигурации сборки может содержать ссылку на файл .snk, где находится ключ, необходимый для формирования строгого имени. Примечание Для того чтобы присвоить сборке строгое имя, необходимо вначале полу-чить два ключа - открытый и закрытый. Такую пару ключей можно сгенерировать с по-мощью утилиты Strong Name (sn.exe), входящей в состав SDK - последнюю вы най дете в папке, куда установлена .NET Framework. Файлы пар ключей обычно имеют расшире-ние .snk. Сохраните такой файл в папке приложения и добавьте ссылку на него в файл assemblyinfo.cs, как показано ниже: [assembly: AssemblyKeyFileAttribute(@"ваша_пара_ключей.snk")] Заметьте, что Visual Basic.NET ищет файл ключей в той папке, где содержится решение Visual Studio, тогда как компилятор C# ожидает найти его там, где находится двоичный файл. Учитывая это, либо подкорректируйте путь в указанной выше строке, либо помес-тите файл ключей в нужную папку. Во время следующей компиляции имя сборок изменится, и как только старый AppDomain запросит перезагрузку, старые сборки будут удалены. В папке App_Code могут содержаться не только файлы классов. В частности, здесь могут находиться автоматически обрабатываемые файлы XSD, содержащие схему 
32 Часть I Внутренние механизмы ASP.NET данных. Когда такой файл помещается в папку App_Code, компилятор генерирует на его основе типизированный класс DataSet, который становится доступным приложе-нию. В ASP.NET 1.x эта задача выполнялась мастером Visual Studio .NET, который, в свою очередь, использовал утилиту с интерфейсом командной строки xsd.exe. Примечание Когда вы регистрируете в файле web.config компонент (например, специа-лизированный серверный элемент управления или пользовательский обработчик HTTP), вас обычно просят указать имя сборки, содержащей его программный код. Какое же имя следует указать, если компонент определен в папке App_Code? В таком случае вы просто опускаете информацию о сборке и задаете только полное имя класса. Если сборка не задана, исполняющая среда ASP.NET пытается загрузить класс из уже загруженных сборок, включая и сборки, созданные для папки App_Code. Папка App_Data Папка App_Data предназначена для хранения локальных источников данных приложе-ния. Обычно источники данных содержатся в ней в виде файлов баз данных - таких как Microsoft Access или Microsoft SQL Server Express - или же файлов в формате XML, текстовом или другом формате, поддерживаемом приложением. Содержимое данной папки не обрабатывается ASP.NET. Папка App_Data - это то место, где про-вайдеры ASP.NET по умолчанию хранят свои данные. Примечание Используемой по умолчанию учетной записи ASP.NET предоставляется полный доступ к папке App_Data. Если вы решите сменить учетную запись ASP.NET, не забудьте предоставить новой учетной записи разрешения на чтение и запись содержимого данной папки. Папка App_GlobalResources Приложения ASP.NET, подобно любым другим приложениям, обычно используют те или иные ресурсы, что помимо прочего позволяет изолировать локализуемые части пользовательского интерфейса приложения. В общем случае ресурсом может счи-таться любой неисполняемый текст или двоичные данные, связанные с программой. Типичными ресурсами являются изображения, значки, текст, различные вспомогатель-ные файлы, но в принципе любой упорядоченный объект может считаться ресурсом. Ресурсы приложения хранятся вне него, и потому их можно перекомпилировать и заменять, не затрагивая приложение. Приложению ASP.NET необходима как минимум одна главная сборка, в кото-рой содержатся его нейтральные или используемые по умолчанию ресурсы, а также несколько вспомогательных сборок с локализованными ресурсами для тех культур, которые должны этим приложением поддерживаться. В ASP.NET 1.x процесс компиляции ресурсов в сборки несколько утомителен. Вы должны вручную откомпилировать XML-файлы ресурсов (имеющие расшире-ние .resx) в двоичные файлы с расширением .resources. Эти последние можно либо встраивать в исполняемые файлы .NET, либо компилировать как сопутствующие сборки (satellite assemblies). Для преобразования текстовых и XML-ресурсов в файлы .resources используется утилита Resource File Generator (resgen.exe). Для имен файлов ресурсов принято следующее соглашение: базовое_имя.культура.resources. Обычно базовым именем является имя приложения. Вот пример команды, генерирующей файл ресурсов для приложения ProAspNet20: resgen.exe ProAspNet20.resx ProAspNet20.it.resources Созданный файл .resources обычно интегрируют в сборку, но он может использо вать-ся и в качестве самостоятельного контейнера ресурсов. Интеграция файла ресурсов 
Модель компиляции ASP.NET Глава 1 33 в сборку выполняется с помощью утилиты Assembly Linker (al.exe). В команде ее вызова задается культура (в приведенном ниже примере - итальянская) и имя сборки: al /out:ProAspNet20.resources.dll /c:it /embed:ProAspNet20.it.resources Все сопутствующие сборки после компиляции получают одно и то же имя. Их нужно поместить в разные каталоги с именами, соответствующими их культурам. К счастью, с появлением ASP.NET 2.0 время сопутствующих сборок закончилось. Точнее, они все еще используются, но разработчикам больше не приходится с ними возиться благодаря введению зарезервированной папки App_GlobalResources. Все находящиеся в ней файлы .resx автоматически компилируются в сопутствую-щие сборки. Имя файла .resx содержит информацию о культуре, используемую ис-полняющей средой ASP.NET при генерировании сборки. Так, на основе следующего набора файлов: resources.resx, resources.it.resx и resources.fr.resx - генерируются, со-ответственно, нейтральная сборка и сопутствующие сборки для итальянской и фран-цузской культур. Нейтральная сборка - это ресурс, используемый приложением по умолчанию, когда не указана конкретная культура. Файлы ресурсов, находящиеся в папке App_GlobalResources, являются глобаль-ными по отношению к приложению, и на них можно ссылаться из любой страницы. Чтение ресурсов в ASP. NET 2.0 выполнять значительно проще, чем в ASP.NET 1.x: <asp:Label Runat="server" Text="<%$ Resources:файл_resx, имя_ресурса %>" /> Глобальные ресурсы можно связывать декларативно, используя новое $-выра-жение с именем Resources. (О $-выражениях подробно рассказывается в главе 5.) У данного выражения два параметра: имя исходного файла .resx без расширения и имя извлекаемого ресурса. Программный доступ к ресурсу осуществляется посредс-твом такого кода: HttpContext.GetGlobalResourceObject(файл_resx, имя_ресурса) Оба параметра строковые, а их назначение то же, что и в $-выражении. Более того, в реализации $-выражения Resources используется метод GetGlobalResourceObject. Папка App_LocalResources Вложенная папка с именем App_LocalResources располагается в папке, содержащей страницы ASP.NET. В ней находятся файлы .resx, имена которых совпадают с именами тех страниц, которые расположены уровнем выше в иерархии. Если, к примеру, в ро-дительской папке имеется файл test.aspx, в папке App_LocalResources вы, вероятно, найдете такие файлы ресурсов: test.aspx.resx, test.aspx.it.resx, test.aspx.fr.resx. Очевидно, что ресурсы, хранящиеся в этих файлах, доступны только из test.aspx. Как осуществляется доступ к собственным ресурсам страницы? В программном коде используется такой вызов: HttpContext.GetLocalResourceObject("/ProAspNet20/ResPage.aspx", "PageResource1.Title") Первый параметр определяет виртуальный путь к странице, а второй - имя ресур са. При декларативном доступе используется атрибут meta:ResourceKey. Вот пример: <asp:Button Runat="server" meta:resourcekey="ButtonResource1" /> Это объявление связывает уникальный ключ ресурса с заданным экземпляром кнопки. Локальный файл .resx будет содержать записи в форме префикс.имя, где префикс - ключ ресурса, а имя - имя свойства связанного элемента управления. Для того чтобы присвоить кнопке локализуемую надпись (свойство Text), вы просто создаете в файле ресурсов запись ButtonResource1.Text.
34 Часть I Внутренние механизмы ASP.NET В результате компиляции файлов ресурсов, находящихся в папках локальных и гло-бальных ресурсов, создаются классы для сопутствующих сборок. Таким образом, все, что нужно сделать разработчику, - это создать файлы .resx, а затем протестировать стра ницу. Остальное сделает система компиляции ASP.NET. Папка App_Themes В папке App_Themes определяются темы для элементов управления ASP.NET - каж-дая тема в своей подпапке. Тема представляет собой набор файлов с информацией о стилях. В ходе компиляции этих файлов получается класс, который, будучи вызван-ным страницей, программным путем устанавливает стили ее элементов управления. Папка App_Themes содержит файлы тем, локальных для приложения. Кроме того, при ложение может наследовать глобальные темы, определенные в следующей папке: %WINDOWS%\Microsoft.NET\Framework\[версия]\ASP.NETClientFiles\Themes С точки зрения компилятора между глобальными и локальными темами нет ника-кой разницы. Если тема с некоторым именем определена и локально для приложения, и глобально для серверного компьютера, преимущество отдается локальной теме. Папка App_WebReferences В Visual Studio .NET 2003 приложение ASP.NET, которому требуется доступ к Web-сервису, получает соответствующий файл .wsdl, используя диалоговое окно Add Web Reference. Однако одного лишь WSDL-документа (Web Service Description Language - язык описания Web-сервиса) недостаточно, для того чтобы страница получила доступ к описанному в нем сервису. Как известно, страница ASP.NET представляет собой не что иное, как управляемый класс, и взаимодействовать она может только с таким же управляемым классом. Поэтому Web-сервис упаковывается в прокси-класс. Последний создается Visual Studio с использованием утилиты с интерфейсом командной строки wsdl.exe. Этот прокси-класс содержит столько же методов, сколько Web-методов имеет-ся у Web-сервиса, который он представляет. А еще он включает в себя пользовательские типы данных, определенные открытым интерфейсом Web-сервиса. Реализация такой схемы не требует от разработчиков особых усилий, однако они оказываются в зависимости от Visual Studio, генерирующей прокси-класс. Не проще ли было бы поместить .wsdl-файл в специально отведенное место в дереве каталогов приложения и предоставить ASP.NET сделать остальное? Именно с этой целью и ис-пользуется папка App_WebReferences! ASP.NET анализирует файлы .wsdl, содержащие описание связанных Web-сер-ви сов, и генерирует на основе этих файлов прокси-классы, чтобы страницы могли выпол нять вызовы Web-сервисов с контролем типов. В папке App_WebReferences могут быть вложенные папки. Имя вложенной папки определяет пространство имен генери руемо го прокси-класса, а имя файла .wsdl определяет имя класса. Например, на основе файла samples.wsdl, находящегося в подпапке ProAspNet20, будет сгене-рирован прокси-класс ProAspNet20.Samples. Что касается динамически создаваемой сборки, то она получает имя App_WebReferences.xxx.dll, где xxx - случайная после-довательность символов. Провайдеры компиляции В ASP.NET 1.x лишь несколько типов файлов динамически компилируются в сборки: страница ASP.NET, пользовательские элементы управления, Web-сервисы ASP.NET, пользовательские обработчики HTTP. Этот список в ASP.NET 2.0 был кардинально расширен - в него входят почти все файлы, которые используются в приложении. 
Модель компиляции ASP.NET Глава 1 35 Наиболее часто используемые типы файлов теперь связаны с компонентами особого рода - провайдерами компиляции, которые взаимодействуют с инфраструктурой ASP.NET и формируют программное представление содержимого исходных файлов. Каждый провайдер умеет работать с файлами одного типа. Например, провайдер компиляции, зарегистрированный как обработчик файлов .aspx, анализирует разметку aspx-файла и генерирует класс в соответствии с правилами, которые мы рассмотрели в разделе "Скрытый код страницы ASP.NET". Этот класс затем преобразуется в сборку с определенной областью видимости. Разработчикам ASP.NET данная модель знакома. Однако новостью для них яв-ляется то, что в ASP.NET 2.0 она применяется к весьма широкому диапазону типов файлов, куда относятся файлы классов (.cs, .vb), ресурсов (.resx), описания Web-сер-висов (.wsdl), типизированных наборов данных (.xsd), тем и т. д. Определенные типы файлов подвергаются трансформации, только будучи помещенными в определенные зарезервированные папки. Этой трансформацией управляют встроенные провайдеры компиляции, имеющие ту же внутреннюю архитектуру и действующие по тому же принципу, что и провайдеры, формирующие страницы ASP.NET. Так что же такое провайдер компиляции Провайдером компиляции называется компонент, который интегрируется в систему компиляции ASP.NET и обеспечивает компиляцию файлов определенного типа. Он может автоматически сгенерировать необходимый прокси-класс, интерпретировав во время компиляции содержимое исходного файла. Провайдер компиляции генерирует компилируемый код и поддерживает его синхронизацию с исходным файлом; если в исходный файл вносятся изменения, провайдер компиляции снова его обрабатывает и обновляет все, что требуется обновить. Чтобы перевести обсуждение провайдеров компиляции в более конкретное русло, я предлагаю вашему вниманию следующую выдержку из используемого по умолчанию конфигурационного файла. Она демонстрирует стандартные связи между типами файлов и встроенными провайдерами компиляции. <compilation> <buildProviders> <add extension=".aspx" type="System.Web.Compilation.PageBuildProvider" /> <add extension=".ascx" type="System.Web.Compilation.UserControlBuildProvider" /> <add extension=".master" type="System.Web.Compilation.MasterPageBuildProvider" /> <add extension=". asmx" type="System.Web.Compilation.WebServiceBuildProvider" /> <add extension=".ashx" type="System.Web.Compilation.WebHandlerBuildProvider" /> <add extension=".resx" type="System.Web.Compilation.ResXBuildProvider" /> <add extension=".resources" type="System.Web.Compilation.ResourcesBuildProvider" /> <add extension=".wsdl" type="System.Web.Compilation.WsdlBuildProvider" /> <add extension=".xsd" type="System.Web.Compilation.XsdBuildProvider" /> <add extension=".js" type="System.Web.Compilation.ForceCopyBuildProvider" /> </buildProviders> </compilation>
36 Часть I Внутренние механизмы ASP.NET Все эти провайдеры компиляции являются закрытыми внутренними классами, определенными в пространстве имен System.Web.Compilation в составе сборки system.web. Данные классы происходят от одного общего корня - класса BuildProvider. (Детали будут приведены чуть ниже.) На рис. 1-11 показана концептуальная схема системы компиляции ASP.NET. Рис. 1-11. Концептуальная схема системы компиляции ASP.NET Хост-среда получает входные данные от внешних компонентов, которыми могут быть клиент (например, Visual Studio 2005 или утилита предкомпиляции), исполь-зующий API ClientBuildManager, или конвейер ASP.NET, и активизирует менеджер компиляции (build manager). Тот, в свою очередь, вызывает провайдер компиляции (build provider), отвечающий за ресурсы данного типа. Когда прокси-класс сгенери-рован, в де ло вступает построитель сборки (assembly builder), который компилиру-ет ресурс. Примечание Провайдеры компиляции являются важными составляющими инфраструкту-ры ASP.NET, но это не те компоненты, с которыми вам придется иметь дело ежедневно. Знать об их существовании и понимать, как они работают, необходимо, но сталкиваться с ними непосредственно вы не будете, разве что пожелаете изменить способ обработки файлов определенного типа в ASP.NET. Провайдеры компиляции могут также исполь-зоваться для некоторого усовершенствования исполняющей среды; как именно - вы узнаете из следующего раздела. Большинство стандартных провайдеров компиляции обрабатывают исходный файл и генерируют на его основе управляемый класс, который затем компилируется в сборку, область видимости которой - все приложение. Однако из этого правила есть несколько исключений. Мы говорили, что провайдеры компиляции используются в процессе компиляции, но сама она может быть инициирована двумя способами: автоматически для обслу-живания пользовательского запроса во время выполнения и по команде разработчика (в этом случае она называется предкомпиляцией). В любом случае провайдеру ком-пиляции передается исходный файл, который он обрабатывает. Дальнейшее зависит от логики провайдера. Файлы приложения, содержащие программный код на языках .NET (например, .cs или .vb), передаются соответствующим компиляторам и обраба-тываются, но не развертываются. Файлы, не связанные ни с одним компилятором или провайдером компиляции, игнорируются. Однако в случае предкомпиляции для развертывания они копируются как есть в целевую папку. У нас остались открытыми два вопроса: что происходит с файлами .js и как быть, если требуется исключить те или иные файлы из процесса развертывания. Ответы на эти вопросы вы найдете в двух следующих подразделах.
Модель компиляции ASP.NET Глава 1 37 Провайдер ForceCopyBuildProvider Будучи специально разработанным для файлов .js, этот провайдер обеспечива-ет их копирование в случае предкомпиляции для развертывания. Расширение .js принадлежит файлам кода на стандартном языке .NET - JScript. Согласно описанным выше правилам файлы JavaScript не должны были бы развертываться. Однако файлы .js часто являются клиентскими, а не серверными, и в таком случае их отсутствие нарушает работу приложения. Чтобы этого не происходило, расширение .js было связа-но с ForceCopyBuildProvider, и теперь файлы .js всегда копируются при развертывании Web-сайта с использованием команды Copy Web Site из Visual Studio 2005. Провайдер IgnoreFileBuildProvider Если ForceCopyBuildProvider всегда копирует свои файлы, то IgnoreFileBuildProvider, напротив, исключает файлы заданного типа из процесса компиляции и публикации. Он особенно полезен для файлов, используемых только во время разработки для тех или иных внутренних целей и не предназначенных для развертывания, - таких как документы Microsoft Office Word, диаграммы Microsoft Office Visio и т. п. Ниже приведен сценарий, который нужно включить в файл web.config, чтобы избежать компиляции файлов с расширением .doc. <compilation> <buildProviders> <add extension=".doc" type="System.Web.Compilation.IgnoreFileBuildProvider" /> </buildProviders> </compilation> IgnoreFileBuildProvider предотвращает развертывание заданных файлов в ходе Web-публикации или компиляции. Разработка пользовательских провайдеров компиляции Провайдеры компиляции участвуют в процессе компиляции всегда, чем бы этот про-цесс ни был инициирован, - Visual Studio 2005 или исполняющей средой ASP.NET. При желании вы можете создать собственный провайдер, обеспечив тем самым под-держку в ASP.NET пользовательской семантики. Классический пример - добавление в систему логики обработки файлов с задан-ным расширением, содержащих информацию о соответствии для одной или более таблиц базы данных. Далее рассказывается, как это можно сделать. Наш провайдер должен динамически генерировать строго типизированные классы, осуществляющие рендеринг столбцов таблицы. Он будет генерировать эти классы каждый раз при добавлении в проект нового файла описанного типа. Что особенно примечательно, провайдеры компиляции обеспечивают полную поддержку функции IntelliSense в Visual Studio 2005. Примечание Вы задумывались о том, каким чудом Visual Studio 2005 распо зна ет свойства элементов управления в классах отделенного кода страницы .aspx, реа ли зуя функцию Intelli-Sense? В ASP.NET 1.x Visual Studio .NET 2003 сама создавала в за щи щен ных областях кода члены, представляющие элементы управления, чтобы класс был завершенным и его можно было анализировать, используя технологию рефлексии. В ASP.NET 2.0 члены, представля-ющие серверные элементы управления, создаются во вре мя ком пиляции с использованием механизма частичных классов. Так как же функции IntelliSense удается справляться со своей задачей, когда вы работаете над файлами кода? Ответ прост: Visual Studio 2005 обращается к провайдеру компиляции, и тот генерирует дина ми ческий код класса со все-ми недостающими объявлениями. Результирующая сборка загружается в процесс Visual Studio 2005, после чего сгенерированный тип страницы сканируется с использованием механизма рефлексии для заполнения раскрывающихся списков Intelli Sense.
38 Часть I Внутренние механизмы ASP.NET Задача провайдера OrmBuildProvider Предположим, что вы формируете для своего Web-приложения слой доступа к дан-ным. Чем вы будете при этом пользоваться: объектами DataSet из ADO.NET или пользовательскими классами-коллекциями? Объекты DataSet уже готовы и обладают мощной функциональностью: они поддерживают сортировку, фильтрацию, отноше-ния... С другой стороны, разработав пользовательский класс-коллекцию, вы получите модель данных, лучше отражающую реальные сущности предметной области. К тому же пользовательские коллекции компактнее, но кодировать их приходится вручную. Несмотря на наличие в .NET Framework множества базовых классов, написание реа-листичной пользовательской коллекции - по-прежнему непростая задача, на решение которой потребуется время. В .NET Framework 2.0 были введены обобщения (generic), значительно упрощающие создание пользовательских коллекций. Теперь для этого достаточно следующего определения: public class CustomerCollection : Collection<Customer> { } В данном примере вам, конечно, необходимо будет определить класс Customer, зависящий от схемы некоторой таблицы базы данных. А как было бы замечательно, если бы можно было просто включить в Web-проект текстовый файл с описанием требуемых данных, и предоставить ASP.NET доделать остальное! В сущности, то же самое происходит с файлами .xsd или .resx. И те и другие являются XML-файлами, содержащими описания некоторых данных, и система компиляции ASP.NET успешно создает на их основе классы. Так что вам достаточно создать провайдер для обработки текстового файла (такого формата, как вы пожелаете) и разработать представление содержимого, которое может быть откомпилировано в сборку. Представлением содержимого исходного файла может быть обычный текст - оп-ределение одного или нескольких классов на языке, который используется в прило-жении. Может им также быть независимое от языка представление класса, созданное с использованием API CodeDOM (подробнее эта тема освещена далее). У базового класса BuildProvider имеется множество вспомогательных методов, облегчающих чте-ние содержимого исходного файла и построение результирующей сборки. Класс OrmBuildProvider, который я собираюсь создать, будет обрабатывать файлы .map, содержащие XML-описание таблицы базы данных, для которой необходим класс, представляющий сущность, и соответствующий класс-коллекция. Структура исходного файла .map Очевидно, что любые инвестиции в построение слоя доступа к данным на основе пользовательских коллекций имеют смысл только при условии, что для приложения в целом не будет перейден определенный порог сложности. Иными словами, для при-ложения, изначально задуманного простым, DataSet - именно то, что требуется. Но если бы существовал простой и быстрый способ создания для него коллекций, даже самый ленивый разработчик захотел бы с ними поэкспериментировать. Попробуем заполнить этот пробел, используя файлы .map и предназначенный для их обработки провайдер OrmBuildProvide. Примечание Можно много говорить об объектах DataSet, пользовательских коллекциях и о том, какая из этих структур больше подходит для разных ситуаций. Пользователь-ские коллекции и объекты DataSet не являются функционально эквивалентными, хотя это два решения одной задачи: представления данных и передачи их между слоями приложения. Пользовательские коллекции позволяют лучше представить реальные дан-ные, зато объек ты DataSet реализуют готовый набор ценных функций. Дополнительную информацию по данному вопросу вы найдете в следующей статье: http://msdn.microsoft. com/msdnmag/issues/05/08/CuttingEdge.
Модель компиляции ASP.NET Глава 1 39 Как уже было сказано, формат файла .map произволен, и не обязательно даже, чтобы это был XML. Однако я выбрал следующую XML-схему: <mappings namespace="ProAspNet20.Components"> <mapping connectionString="SERVER=.;DATABASE=northwind;UID=...;" tableName="Customers" className="Customer" selectCommand="SELECT companyname AS CompanyName, contactname AS Contact, country As Country FROM customers" allowPartialClass="true" allowCollectionClass="true" collectionClassName="CustomerCollection"> </mapping> </mappings> Узел <mappings> - это самый внешний контейнер, содержащий список узлов <mapping>, каждый из которых представляет соответствие между группой классов и таблицей базы данных. Все сгенерированные классы будут принадлежать к одному пространству имен, заданному в узле <mappings>. Атрибуты этого узла перечислены в табл. 1-11. Табл. 1-11. Атрибуты узла <mappings> Атрибут Описание allowCollectionClass Указывает, требуется ли класс-коллекция allowPartialClass Указывает, является ли класс, представляющий сущность, частичным className Имя создаваемого класса, представляющего сущность collectionClassName Имя класса, представляющего коллекцию сущностей connectionString Строка подключения для доступа к информации схемы selectCommand Команда, используемая для извлечения информации схемы; в ней пере-числены столбцы и имена членов класса, которым они соответствуют tableName Имя таблицы, на которой базируется класс, представляющий сущность Выбрав таблицу базы данных, вы извлекаете из нее группу столбцов посредством команды SELECT. Полученная информация используется для формирования класса .NET, который должен иметь столько членов, сколько столбцов было в запросе. Каж-дый член получает имя и тип столбца. Таким образом, класс становится представле-нием логической сущности - такой как сотрудник, клиент или продукт, - которой соответствовала таблица. Класс-сущность может быть определен как частичный и до-полнен необязательным классом-коллекцией или даже шлюзовым классом. В нашем примере создаются следующие классы. Employee - представляет логическую сущность из предметной области, имеет столько же членов, сколько столбцов было задано в команде SELECT. Имена членов совпадают с псевдонимами столбцов, заданными в предложениях AS. EmployeeCollection - коллекция объектов Employee. Как только файл .map будет помещен в папку App_Code, зарегистрированный провайдер возьмет его под свой контроль, прочитает содержимое и сгенерирует ди-намические классы. Посмотрим, как это происходит. 
40 Часть I Внутренние механизмы ASP.NET Примечание Вы можете расширить схему, содержащуюся в файле .map. Например, если вы пожелаете построить свой уровень данных в соответствии с шаблоном Data Mapper (DM), нужно будет доработать схему и провайдер компиляции и сгенерировать заглушку для шлюзового класса. Согласно шаблону DM в шлюзовом классе объединены методы, представляющие поведение сущностного класса. Шлюз - это одиночный класс, который может обслуживать много экземпляров сущностного класса. В большинстве случаев он реализуется в виде набора статических методов. Реализация провайдера компиляции Провайдер компиляции - это класс, производный от BuildProvider. В нем должен быть переопределен метод GenerateCode. Вот типичная структура этого класса: public class OrmBuildProvider : BuildProvider { public OrmBuildProvider() { } public override void GenerateCode(AssemblyBuilder ab) { //Получаем виртуальный путь к исходному файлу string fileName = base.VirtualPath; //Получаем дерево, представляющее генерируемый код CodeCompileUnit code = BuildCodeTree(fileName); //Формируем сборку, используя дерево кода ab.AddCodeCompileUnit(this, code); } } В полном соответствии со своим именем метод GenerateCode обрабатывает входной файл .map и генерирует один или более классов на основе собранной информации. Эти классы описываются в виде древообразной структуры в соответствии с моделью CodeDOM. Далее полученный код передается классу построителя сборки и компи-лируется. Как видите, переопределить метод GenerateCode очень просто: нужно всего лишь написать свою версию вспомогательного метода BuildCodeTree, генерирующего исходный код компилируемого класса на основе входного файла. Вот пример: private CodeCompileUnit BuildCodeTree(string fileName) { OrmDescriptor desc = ExtractInfo(fileName); return GenerateCodeDomTree(desc); } Данный метод выполняет свою задачу в два этапа: считывает информацию из фай-ла .map и генерирует дерево кода. Информация, прочитанная из файла, упаковывается в объект класса OrmDescriptor, определенного следующим образом: class OrmDescriptor { public string Namespace; public OrmTableDescriptor[] Descriptors; }class OrmTableDescriptor { public string ConnectionString;
Модель компиляции ASP.NET Глава 1 41 public string TableName; public string ClassName; public string SelectCommand; public bool IsPartial; public bool AllowCollectionClass; public string CollectionClassName; } Вспомогательный метод ExtractInfo использует API XMLDOM (XML Document Object Model - объектная модель XML-документа) для анализа файла .map и запол-нения объекта OrmDescriptor. OrmDescriptor ExtractInfo(string fileName) { //Загружаем документ XmlDocument doc = new XmlDocument(); using (Stream file = VirtualPathProvider.OpenFile(fileName)) { //Подумайте о том, чтобы использовать здесь функцию //чтения с проверкой для повышения производительности //и контроля схемы загружаемого документа doc.Load(file); } //Получаем информацию из атрибута namespace XmlNode root = doc.DocumentElement; string ns = root.Attributes["namespace"].Value; //Обходим узлы <mapping> XmlNodeList mappings = doc.SelectNodes("mappings/mapping"); OrmTableDescriptor[] descriptors; descriptors = new OrmTableDescriptor[mappings.Count]; for(int i=0; i<descriptors.Length; i++) { XmlNode mapping = mappings[i]; OrmTableDescriptor t = new OrmTableDescriptor(); descriptors[i] = t; t.ConnectionString = mapping.Attributes["connectionString"].Value; t.ClassName = mapping.Attributes["className"].Value; t.TableName = mapping.Attributes["tableName"].Value; t.SelectCommand = mapping.Attributes["selectCommand"].Value; bool isPartial = false; Boolean.TryParse( mapping.Attributes["allowPartialClass"].Value,out isPartial); t.IsPartial = isPartial; bool allowCollection = false; Boolean.TryParse( mapping.Attributes["allowCollectionClass"].Value, out allowCollection)) t.AllowCollectionClass = allowCollection; if (allowCollection) { string coll = mapping.Attributes["collectionClassName"].Value; t.CollectionClassName = coll; } }
42 Часть I Внутренние механизмы ASP.NET //Упаковываем всю информацию и возвращаем созданный объект OrmDescriptor desc = new OrmDescriptor(); desc.Namespace = ns; desc.Descriptors = descriptors; return desc; } Существуют два способа генерирования исходного кода класса. Первый из них заключается в выполнении конкатенации строк текста, представляющих инструкции определенного языка программирования. Второй способ демонстрируется в следу-ющем подразделе. Он основан на использовании независимой от языка програм-мирования объектной модели CodeDOM. Это значительно более сложное решение, требующее знания довольно необычного и очень абстрактного API. С рассмотрения этого способа мы и начнем. Объектная модель CodeDOM Название CodeDOM расшифровывается как Code Document Object Model - объект-ная модель документа, содержащего программный код. Так называется API .NET Frame work, предназначенный для генерирования программного кода. API CodeDOM, интенсивно используемый встроенными провайдерами компиляции ASP.NET, опреде-лен в пространстве имен System.CodeDom. В его состав входит широкий набор классов, использующихся для формирования графа кода на языке Visual Basic.NET или C#. Вначале с помощью API CodeDOM вы строите иерархию элементов будущего кода, описывая таким образом его структуру, а затем даете внутренним классам CodeDOM указание сгенерировать этот код на выбранном вами языке. Классы System.CodeDom позволяют указать тип каждой из инструкций формируемого кода и ее параметры. Когда очередь доходит до генерирования кода, абстрактное описание переводит-ся в реальный синтаксис. В .NET Framework 2.0 API CodeDOM был расширен за счет средств поддержки новых языковых конструкций, таких как частичные классы и обобщения. В упоминавшейся выше процедуре GenerateCodeDomTree CodeDOM используется для построения классов сущности и коллекции. Класс сущности у нас частичный (в общем случае это не обязательно), с несколькими членами-свойствами. Что каса-ется класса коллекции, то это основанный на обобщении список классов-сущностей. Следующий код показывает, как построить данное дерево: CodeCompileUnit GenerateCodeDomTree(OrmDescriptor desc) { CodeCompileUnit code = new CodeCompileUnit(); //Импортируем нужные пространства имен CodeNamespaceImport import; import = new CodeNamespaceImport("System.Collections.Generic"); //Создаем пространство имен и добавляем его в блок кода CodeNamespace ns = new CodeNamespace(desc.Namespace); ns.Imports.Add(import); code.Namespaces.Add(ns); //Перебираем в цикле соответствия и добавляем классы for (int i = 0; i < desc.Descriptors.Length; i++) { //Получаем дескриптор текущего соответствия OrmTableDescriptor t = desc.Descriptors[i];
Модель компиляции ASP.NET Глава 1 43 //Создаем класс, представляющий таблицу CodeTypeDeclaration cls = new CodeTypeDeclaration(t.ClassName); cls.IsPartial = t.IsPartial; ns.Types.Add(cls); //Перебираем в цикле столбцы выбранной таблицы и добавляем члены SqlDataAdapter adapter = new SqlDataAdapter( t.SelectCommand, t.ConnectionString); DataTable dt = new DataTable(); adapter.FillSchema(dt, SchemaType.Mapped); for(int j=0; j<dt.Columns.Count; j++) { DataColumn column = dt.Columns[j]; string colName = column.ColumnName; Type colType = column.DataType; string fieldName = "_" + colName.ToLower(); ////Добавляем свойство для каждого столбца ////Добавляем private-поле для хранения данных CodeMemberField fld = new CodeMemberField(colType, fieldName); cls.Members.Add(fld); //Добавляем объявление свойства и аксессоры get/set CodeMemberProperty prop = new CodeMemberProperty(); prop.Name = column.ColumnName; prop.Type = new CodeTypeReference(column.DataType); prop.Attributes = MemberAttributes.Public; //Определяем codeDOM-ссылку для private-поля свойства CodeFieldReferenceExpression fldRef; fldRef = new CodeFieldReferenceExpression(); fldRef.TargetObject = new CodeThisReferenceExpression(); fldRef.FieldName = fieldName; //Get CodeMethodReturnStatement ret; ret = new CodeMethodReturnStatement(fldRef); prop.GetStatements.Add(ret); //Set CodeAssignStatement assign = new CodeAssignStatement(); assign.Left = fldRef; assign.Right = new CodePropertySetValueReferenceExpression(); prop.SetStatements.Add(assign); cls.Members.Add(prop); } //Если нужно, создаем класс-коллекцию if (t.AllowCollectionClass) { string collName = t.CollectionClassName; CodeTypeDeclaration coll = new CodeTypeDeclaration(collName); CodeTypeReference type = new CodeTypeReference("List", CodeTypeReferenceOptions.GenericTypeParameter);
44 Часть I Внутренние механизмы ASP.NET type.TypeArguments.Add(t.ClassName); coll.BaseTypes.Add(type); ns.Types.Add(coll); } } } Наиболее интересной частью этого кода является генерирование класса-коллекции на основе обобщений. Если имя класса-сущности - Customer, тогда результирующий код будет таким: public class CustomerCollection : List<Customer> {} Сначала создается объект CodeTypeDeclaration с именем класса-коллекции. Затем создается CodeDOM-ссылка на тип - класс CodeTypeReference. В приведенном выше коде типом является List<T>. Как известно, когда в объявлении используется обоб-щенный тип, он нуждается в аргументе, то есть вместо T необходимо задать реаль-ный тип, в данном случае - Customer. Он задается через коллекцию TypeArguments. Наконец, результирующий тип List<Customer> устанавливается в качестве базового типа определяемой коллекции. Теперь давайте поместим описанный выше файл .map в папку App_Code и пос-мотрим, что произойдет. Примечание Что следует использовать при создании обобщенных классов-коллекций: List<T> или Collection<T>? Разница невелика и заключается она лишь в отличии базовых интерфейсов - IList и ICollection. Общее правило: List<T> используется для внутренних членов класса, а Collection<T> - для его открытых членов. Сводим все вместе Чтобы включить файлы .map в игру, нужно подкорректировать файл web.con fig, до-бавив в его раздел <buildProviders> такую запись: <buildProviders> <add extension=".map" type="Samples.OrmBuildProvider,OrmBuildProvider" /> </buildProviders> Атрибут extension определяет расширение исходного файла, а в атрибуте type задается имя класса и информация о сборке. Заметьте, что пользовательские фай-лы, такие как файлы .map, можно размещать только в папке App_Code. Когда в эту папку добавляется новый файл, приложение автоматически перезапускается. Файл компилируется, и результат загружается в AppDomain. Временные исходные файлы создаются в подпапке Sources_App_Code той папки, куда помещаются генерируемые файлы исходного кода. На рис. 1-12 показано содержимое этой папки и сгенерированный файл C#, где определены класс-сущность и соответствующая коллекция. Для использования динамически созданных классов в коде страниц достаточно импортировать пространство имен, заданное в узле <mappings>. Ниже приведен при-мер. Разработчику не нужно самостоятельно писать классы сущности и коллекции, но он может использовать коллекции в слое доступа к данным своего приложения и в операциях связывания. public CustomerCollection GetCustomers() { SqlDataAdapter adapter = new SqlDataAdapter(
Модель компиляции ASP.NET Глава 1 45 "SELECT companyname, contactname, country FROM customers", "SERVER=...;DATABASE=...;UID=..."); DataTable dt = new DataTable(); adapter.Fill(dt); CustomerCollection coll = new CustomerCollection(); foreach (DataRow row in dt.Rows) { Customer c = new Customer(); c.CompanyName = (string) row[0]; c.Contact = (string) row[1]; c.Country = (string) row[2]; coll.Add(c); } return coll; } Если вы велели провайдеру компиляции создать частичный класс-сущность, то мо жете расширить этот класс в своем проекте. Вот как производится добавление к клас су Customer метода ToString: public partial class Customer { public override string ToString() { return String.Format("{0} ({1})", this.CompanyName, this.Country); } } Интересно, что хотя проект не содержит статического определения частичного класса Customer, система может его найти, если в папке App_Code присутствует файл .map. Использование объекта TextWriter Мы рассмотрели процесс генерирования класса на основании содержимого дескрип-торного файла с использованием объектной модели CodeDOM, но это не единственная возможность. Ту же задачу можно выполнить путем самой обыкновенной конкате-нации строк. В таком случае переопределенный метод GenerateCode будет выглядеть несколько иначе: public override void GenerateCode(AssemblyBuilder ab) { TextWriter tw = ab.CreateCodeFile(this); if (tw == null) return; try { //Анализ файла и генерирование кода на его основе string code = ParseFileAndCreateCode(base.VirtualPath); tw.Write(code); } catch { throw new ApplicationException("Can't build class"); } finally { tw.Close(); } } string ParseFileAndCreateCode(string fileName) {
46 Часть I Внутренние механизмы ASP.NET StringBuilder sb = new StringBuilder(); sb.Append("public class Customer {"); return sb.ToString(); } Конечно, такое решение привязывает вас к конкретному языку программирова-ния, но реализуется оно несравненно быстрее. API CodeDOM считается в высшей степени абстрактным, и про граммировать, используя этот API, сложно; кроме того, решение на его основе потребляет больше памяти. С точки зрения читабельности кода ни одно из двух решений не совершенно: основанное на CodeDOM не читабельно по причине чрезмерной абстрактности, а основанное на текстовом выводе - из-за того, что генерируемый код перемежается в нем кодом генерирующим (поэтому его сложно модифицировать и сопровождать). Так что выбор, в конечном счете, зависит от ваших личных предпочтений. Примечание Провайдеры компиляции являются компонентами, специфичными для ASP.NET 2.0. В проектах Windows Forms они не поддерживаются. Однако вы можете напи-сать для MSBuild пользовательскую задачу, позволяющую осуществить предварительное преобразование, аналогичное тому, которое выполняется провайдерами компиляции. Подробно о пользовательских задачах MSBuild рассказывается в следующей статье: http://msdn.microsoft.com/msdnmag/issues/06/02/CuttingEdge. Провайдеры виртуального пути До появления ASP.NET 2.0 исходный код страницы ASP.NET мог находиться только в файле .aspx, инсталлированном на сервере в заданной папке. При этом между ресур-сами .aspx и файлами на диске должно было соблюдаться отношение один-к-одному. В ASP.NET 2.0 используется механизм провайдера виртуального пути, позволяю-щий виртуализировать группы файлов и даже структуру каталогов. Благодаря ему Web-контент может быть абстрагирован от реальной структуры файловой системы. Разработанные для нужд SharePoint провайдеры виртуального пути пригодились разработчикам приложений ASP.NET. Зарегистрировав соответствующий провай-дер пути, вы можете, к примеру, извлекать исходный код страниц для ASP.NET из базы данных. (Не правда ли, что-то знакомое? Именно так действовал до сих пор SharePoint и будет действовать впредь, тем более что следующая версия этого про-дукта будет базироваться на ASP.NET 2.0.) Структура провайдера виртуального пути Провайдер виртуального пути (virtual path provider, VPP) - это класс, производ-ный от VirtualPathProvider и реализующий виртуальную файловую систему Web-приложения. В такой виртуальной файловой системе для хранения файлов и папок обычно используется пользовательский контейнер, отличный от файловой системы компьютера. В ней может храниться большинство файлов, вовлеченных в обработку запроса, полученного ASP.NET. Список включает страницы ASP.NET, темы, эталон-ные страницы, пользовательские элементы управления, пользовательские ресурсы, обрабатываемые провайдером компиляции, и статические Web-ресурсы, такие как HTML-страницы и изображения. Однако VPP не может хранить и предоставлять глобальные ресурсы, такие как global.asax и web.config, а также содержимое зарезервированных папок - Bin, App_Code, App_Data, App_GlobalResources, App_LocalResources. В табл. 1-12 перечислены члены класса VirtualPathProvider, которые вы можете переопределить в пользователь-ском компоненте VPP.
Модель компиляции ASP.NET Глава 1 47 Табл. 1-12. Члены класса VirtualPathProvider Член Описание CombineVirtualPaths Объединяет базовый путь с относительным, возвращая полный путь к виртуальному ресурсу DirectoryExists Указывает, существует ли в виртуальной файловой системе заданная папка FileExists Указывает, существует ли в виртуальной файловой системе заданный файл GetCacheDependency Создает зависимость кэша на основе заданных виртуальных путей GetCacheKey Возвращает ключ кэша для использования с заданным виртуальным путем GetDirectory Возвращает ссылку на производный от VirtualDirectory класс, представляющий виртуальный каталог запрошенного ресурса GetFile Возвращает ссылку на производный от VirtualFile класс, представляющий виртуальный каталог запрошенного ресурса GetFileHash Возвращает хэш-значение заданного виртуального пути Previous Защищенное свойство; возвращает ссылку на зарегистрированный ранее объект VPP для разрешения запроса ресурса с помощью одного из двух VPP: зарегистрированного либо используемого по умолчанию При написании пользовательского VPP важно переопределить методы GetFile и GetDirectory, а также правильно использовать свойство Previous. Вот пример: public override VirtualFile GetFile(string virtualPath) { if (IsPathVirtual(virtualPath)) return new YourVirtualFile(virtualPath, this); else return Previous.GetFile(virtualPath); } Здесь IsPathVirtual - виртуальная функция, выясняющая, способен ли ваш VPP разрешить заданный виртуальный путь. Если нет, запрос передается следующему VPP в цепочке ASP.NET. При отсутствии вызова Previous запрос может оказаться не обработанным. private bool IsPathVirtual(string virtualPath) { //Например, сравниваем виртуальный путь //с информацией из вашего хранилища данных } За дополнительной информацией и образцами кода обратитесь к онлайновой до-кументации MSDN. Структура класса VirtualFile Механизм провайдеров виртуального пути действует следующим образом. Получив запрос, ASP.NET выясняет, имеется ли среди зарегистрированных у нее VPP такой, который может обработать данный URL. Если да, этот VPP получает возможность вернуть ASP.NET соответствующий исходный файл. VPP возвращает исходный код в виде объекта класса, производного от VirtualFile. В табл. 1-13 перечислены члены класса VirtualFile, которые можно переопределять.
48 Часть I Внутренние механизмы ASP.NET Табл. 1-13. Члены класса VirtualFile Член Описание IsDirectory Указывает, представляет ли данный объект виртуальный ресурс, который должен интерпретироваться как файл Name Возвращает отображаемое имя виртуального файла VirtualPath Возвращает путь к виртуальному файлу Open Возвращает поток для доступа к содержимому запрошенного ресурса; данный поток может использоваться только для чтения Главная задача, стоящая перед вами при написании пользовательского виртуаль-ного класса, - переопределить метод Open, чтобы он возвращал предназначенный только для чтения поток, открывающий доступ к содержимому виртуального ресурса. В методе Open вы используете виртуальный путь в качестве ключа для доступа к хра-нилищу данных и извлекаете из этого хранилища исходный код. За дополнительной информацией и образцами кода обращайтесь к онлайновой документации MSDN. Регистрация провайдера виртуального пути В отличие от большинства прочих провайдеров провайдер виртуального пути регис-трируется не в файле web.config. Его можно зарегистрировать либо в обработчике глобального события Application_Start, либо путем добавления статического метода AppInitialize к какому-нибудь классу, файл которого установлен в папке App_Code. Вот пример класса, который вы можете поместить в папку App_Code, чтобы заре-гистрировать VPP: public static class AppStart { public static void AppInitialize() { //Добавляем в цепочку новый VPP MyPathProvider vpp = new MyPathProvider(); HostingEnvironment.RegisterVirtualPathProvider(vpp); } } Имя класса, в котором производится регистрация, является произвольным, но сигнатура AppInitialize фиксирована. Если в нескольких разных классах, хранящих-ся в App_Code, имеются статические методы с таким именем, вы получите ошибку компиляции. Внимание! Важно, чтобы провайдер виртуального пути был зарегистрирован до того, как начнется синтаксический анализ или компиляция страниц. В случае регистрации провайдера в другом месте приложения (например, в web.config) или в другой точке его жизненного цикла результаты могут оказаться неожиданными. Нет никаких синтаксических требований, которые помешали бы вам зарегистрировать VPP, скажем, в обработчике события Page_Load. Однако если зарегистрировать VPP после того, как будет сгенери-рована сборка страницы, у вас не останется возможности аннулировать связь между страницей и данной сборкой. В результате при обработке запроса данной страницы VPP вызван не будет. Можно зарегистрировать VPP в событии страницы, но только той, ко-торая, во-первых, сама не должна обслуживаться данным VPP, а во-вторых, вызывается до любых страниц, обслуживаемых VPP. Очевидно, что такая ситуация нетипична.
Модель компиляции ASP.NET Глава 1 49 Заключение ASP.NET всегда компилировала некоторые типы файлов, и в первую очередь страницы .aspx, на лету. Файлы страниц автоматически компилируются по требованию, то есть при первом обращении к ним. Любые изменения, вносимые в исходный код динами-чески компилируемого файла, сразу же делают недействительной соответствующую сборку, которая автоматически создается заново. Данный механизм очень упрощает разработку приложений, поскольку программисту достаточно лишь сохранить файл и обновить открытую в браузере страницу, чтобы изменения вступили в силу. Внешне ASP.NET 2.0 функционирует так же, как и раньше, однако внутренние ме-ханизмы этой системы подверглись значительной переработке. В частности, введена новая расширяемая модель компиляции, обеспечивающая автоматическую обработ-ку файлов множества разных типов. Ключевым элементом этой модели являются провайдеры, отвечающие за компиляцию файлов определенных типов. Встроенные провайдеры компилируют такие файлы, как страницы ASP.NET, эталонные страницы, файлы тем, ресурсы и схемы XSD. Если же вам потребуется компилировать файлы неподдерживаемого системой типа, можно разработать пользовательский провайдер компиляции и связать его с этим типом файлов. На применении провайдеров ком-пиляции основана замечательная функция IntelliSense из Visual Studio 2005. С их же помощью осуществляется предкомпиляция сайтов, которую больше не нужно явно выполнять в IDE Visual Studio. Только факты Запрос ресурса .aspx, то есть страницы ASP.NET, передается управляемому классу, реализующему интерфейс IHttpHandler. Если этот класс не найден, он создается динамически. Динамическая компиляция страницы выполняется в два этапа: сначала произво-дится разбор файла .aspx, в результате которого формируется файл класса, а затем этот класс компилируется в сборку. Данная модель, которая в ASP.NET 1.x приме-нялась только к нескольким предопределенным типам файлов, была переработана и теперь может поддерживать пользовательские типы файлов. Провайдеры компиляции - это системные компоненты, которые осуществляют разбор файлов с заданным расширением и возвращают класс, подлежащий компи-ляции. Для формирования дерева кода такой провайдер, как правило, использует API CodeDOM. Вы можете написать пользовательский провайдер, который будет генерировать классы на основе текстового описания объектов. В ASP.NET 2.0 есть несколько зарезервированных папок, где содержатся ресурсы определенных типов, в частности файлы классов, ресурсы страниц и WSDL-до-кументы. В ASP.NET 2.0 сайт может предкомпилироваться одним из двух способов: на месте или для развертывания. В первом случае устраняется задержка, происходящая при первом обращении к странице, а во втором генерируется образ сайта, содержащий только сборки, соответствующие файлам .aspx, - и никакого исходного кода или разметки. 
Глава 2 Обработчики и модули HTTP В предыдущей главе, посвященной модели компиляции ASP.NET, я упоминал о моду-лях и обработчиках HTTP как о базовых элементах архитектуры Microsoft ASP.NET. Обработчики и модули HTTP - важнейшие строительные блоки Web-платформы Microsoft .NET. Все запросы управляемых ресурсов ASP.NET выполняются обработчи-ком HTTP и проходят через конвейер модулей HTTP, в результате чего формируется HTML-код для браузера. Обработчик HTTP - это компонент, на который возложена ответственность за обслуживание запроса. Он представляет собой экземпляр класса, реализующего ин-терфейс IHttpHandler. Метод ProcessRequest этого интерфейса является центральной консолью, управляющей обработкой запроса. Например, класс Page - базовый класс, производными от которого являются все страницы ASP.NET времени выполнения, - реализует интерфейс IHttpHandler, метод ProcessRequest которого отвечает за загрузку и сохранение состояния просмотра, а также за генерирование событий, таких как Init, Load, PreRender и им подобных. ASP.NET отображает каждый входящий HTTP-запрос на конкретный обработчик HTTP. Компонент особого рода, называемый фабрикой обработчиков HTTP (HTTP handler factory), предоставляет инфраструктуру для создания физического экземпляра обработчика, который будет обслуживать запрос. Например, класс PageHandlerFactory анализирует исходный код запрошенного ресурса .aspx и возвращает откомпилирован-ный экземпляр класса, представляющего страницу. Обработчик HTTP предназначен для обработки одного или нескольких расширений URL. Областью действия обра-ботчика может быть конкретное приложение или весь компьютер, то есть он может обрабатывать файлы с назначенными ему расширениями в контексте либо текущего приложения, либо всех приложений, установленных на компьютере. Назначение об-работчику области действия осуществляется путем внесения изменений в глобальный файл machine.config или локальный файл web.config, в зависимости от того, какую область действия вы выбираете. Модули HTTP - это классы, реализующие интерфейс IHttpModule и обрабатываю-щие события времени выполнения. Существует два типа событий, с которыми может иметь дело такой модуль. Это события, генерируемые объектом HttpApplication (в том числе асинхронные), и события, генерируемые другими модулями HTTP. Например, SessionStateModule - это один из встроенных модулей ASP.NET, предоставляющих приложениям сервисы, связанные с состоянием сеанса. Модуль SessionStateModule генерирует события End и Start, которые могут обрабатываться другими модулями с использованием общеизвестных сигнатур Session_End и Session_Start. Обработчики и модули HTTP выполняют те же функции, что и расширения и фильт-ры ISAPI соответственно, но их программная модель проще. ASP.NET позволяет со-зда вать пользовательские обработчики и модули. Прежде чем мы углубимся в этот довольно сложный аспект Web-программирования, предлагаю вам обзор модели рас-
Обработчики и модули HTTP Глава 2 51 ширения Internet Information Server (IIS), определяющей, что могут и чего не могут делать модули и обработчики HTTP. Примечание Протокол, посредством которого IIS взаимодействует с внешними компо-нентами, называется ISAPI (Internet Server Application Programming Interface - интерфейс программирования приложений сервера Интернета). Модель ISAPI основана на исполь-зовании неуправляемых библиотек динамической компоновки (DLL) Microsoft Win32, экс-портирующих несколько функций. Данная модель будет значительно расширена в IIS 7.0 и согласована с моделью расширения ASP.NET, основанной на обработчиках и модулях HTTP. Чуть позже я вернусь к этой теме. Краткий обзор API расширения IIS Web-сервер - это серверное приложение, с которым можно взаимодействовать пос-редством группы протоколов Интернета, таких как HTTP, FTP, NNTP и SMTP. Не является исключением и IIS - Web-сервер, входящий в состав операционной системы Windows. Обычно Web-сервер предоставляет API для расширения и настройки своих фун-кций. Первым таким расширением в истории программирования был CGI (Common Gateway Interface - общий шлюзовой интерфейс). Модуль CGI - это отдельное приложение, запускаемое Web-сервером для обслуживания запроса. В настоящее время модули CGI используются в Web-приложениях крайне редко, поскольку для обработки каждого поступающего HTTP-запроса создается новый процесс, в рам-ках которого выполняется отдельный экземпляр CGI-модуля. Очевидно, что такой подход не годится для больших Web-сайтов и создает серьезные проблемы с масш-табируемостью. IIS поддерживает приложения CGI, но эта его функция использу-ется нечасто - разве только в тех случаях, когда необходимо обеспечить обратную совместимость. В современных версиях Web-серверов реализована альтернативная и более эффективная модель расширения. В IIS эта альтернативная модель приняла форму интерфейса ISAPI. Модель ISAPI При использовании модели ISAPI Web-сервер не создает новый процесс для каждого входящего запроса. Вместо этого IIS загружает в свой собственный процесс так назы-ваемый компонент ISAPI, реализованный в виде DLL Win32, а затем вызывает для обслуживания запроса известную точку входа этой DLL. Компонент ISAPI остается загруженным в память IIS до тех пор, пока последний не завершит свою работу, и мо-жет обслуживать все последующие запросы. Недостатком такой модели является то, что, поскольку все компоненты загружаются в процесс Web-сервера, единственный ошибочный компонент может нарушить работу всего сервера и всех установленных на нем приложений. Поэтому, начиная с IIS 4.0, для решения данной проблемы были приняты некоторые контрмеры. С выходом IIS 6.0 появилась дополнительная воз-можность задавать для каждого устанавливаемого приложения свой уровень защиты, выбирая один из трех вариантов: низкий, средний или высокий. Если выбрать низкий уровень защиты, приложение (и его расширения) будет выполняться в процессе Web-сервера ( inetinfo.exe). При среднем уровне защиты при-ложения объединяются в пулы, выполняющиеся в отдельных экземплярах другого рабочего процесса (dllhost.exe). Если же выбран высокий уровень защиты, то приложе-ние, которому он назначен, выполняется в отдельном рабочем процессе ( dllhost.exe). По умолчанию в IIS 6.0 Web-приложения объединяются в пулы, и вам необходимо решить, следует присоединить новое приложение к существующему пулу или нужно создать новый.
52 Часть I Внутренние механизмы ASP.NET Для всех приложений из одного пула задаются одни и те же параметры выполне-ния и безопасности, а также используется один и тот же рабочий процесс - w3wp.exe. На рис. 2-1 показано диалоговое окно из IIS 6.0 и Microsoft Windows Server 2003, где осуществляется выбор пула для инсталлируемого Web-приложения. Рис. 2-1. Выбор пула для инсталлируемого Web-приложения в IIS 6.0 и Microsoft Windows Server 2003 ASP.NET как расширение ISAPI У модели ISAPI имеется еще один существенный недостаток, а именно модель про-граммирования. Как уже было сказано, компонент ISAPI представляет собой отком-пилированный код - DLL Win32. Он анализирует запрос, производит необходимую обработку и формирует результирующий HTML-документ, помещая его в выходной поток. Код этого компонента пишется на языке C или C++; он должен быть многопо-точным, причем процесс его написания требует от разработчика большой вниматель-ности, поскольку последствия ошибок или сбоев во время выполнения отражаются на приложениях. Microsoft попыталась инкапсулировать логику ISAPI в MFC (Microsoft Foundation Classes), и хотя эти усилия весьма похвальны, толку от них оказалось немного. При использовании MFC получается гораздо больше кода, чем считается приемлемым для высокопроизводительных Web-сайтов, и, что еще хуже, в результирующей DLL происходят утечки памяти (известные и хорошо документированные). Система Active Server Pages (ASP), предшественница ASP.NET, является приме-ром хорошо выполненного расширения ISAPI. Реализована она в форме DLL ISAPI (с именем asp.dll), зарегистрированной как обработчик запросов HTTP с расширени-ем .asp. Внутренний код этой DLL анализирует код запрошенного ресурса, выполняет встроенный код сценария и формирует страницу для браузера. В IIS 6.0 и более поздних версиях любая функциональность, надстроенная поверх IIS, должна быть запрограммирована согласно правилам, установленным моделью ISAPI. Не являются исключением ASP и ASP.NET. В настоящее время вся платфор-ма ASP.NET тесно взаимодействует с IIS, но не является ее частью. Связь между IIS и исполняющей средой ASP.NET обеспечивает ISAPI-компонент aspnet_isapi.dll. При поступлении запроса на получение ресурса с расширением .aspx IIS передает управление библиотеке aspnet_isapi.dll, которая, в свою очередь, передает запрос кон вейеру ASP.NET внутрь экземпляра CLR.
Обработчики и модули HTTP Глава 2 53 Сейчас, когда готовится к печати эта книга, существует возможность написания DLL Win32 лишь с предопределенным набором точек входа. В IIS 7.0 данное требо-вание должно измениться. Структура компонентов ISAPI Расширение ISAPI вызывается через URL, оканчивающийся именем DLL, которая реализует данную функцию, например: http://www.contoso.com/apps/hello.dll Данная DLL должна экспортировать две функции: GetExtensionVersion и HttpExtensionProc. Функция GetExtensionVersion устанавливает версию и имя серверного расширения ISAPI. Она вызывается один раз, сразу после загрузки расширения, и может использоваться для инициализации любых необходимых переменных. Если она успешно справляется со своей задачей, то возвращает значение true. В случае ошибки, когда она возвращает false, Web-сервер отменяет загрузку DLL и записывает в системный журнал соответствующее сообщение. Ядро компонента ISAPI представлено функцией HttpExtensionProc. Она получает базовую HTTP-информацию, относящуюся к запросу (например, строку запроса и заголовки), выполняет ожидаемое действие и подготавливает ответ для отправки браузеру. Примечание Программная модель ISAPI является более низкоуровневой, чем, скажем, ASP или ASP.NET, и в ней отсутствуют такие программные абстракции, как состояние сеанса. Программная модель ISAPI состоит из компонентов двух типов - расширений ISAPI и фильтров ISAPI. Расширения ISAPI Расширения ISAPI являются альтернативой приложениям CGI, поскольку это ком-поненты, выполняющиеся внутри процесса IIS. Как уже упоминалось, расширение ISAPI представляет собой DLL, которая загружается в память, выделенную для IIS или другого хост-приложения. А поскольку это DLL, в каждый конкретный момент времени достаточно, чтобы в памяти присутствовал только один ее экземпляр. Однако расширение ISAPI должно быть многопоточным, чтобы множественные клиентские запросы могли обрабатываться одновременно. Расширение ISAPI во многом работает подобно странице ASP или ASP.NET: оно принимает информацию об HTTP-запросе и подготавливает ответ. Поскольку расширение ISAPI представляет собой откомпилированный код, при любом изменении оно нуждается в перекомпиляции и повторной загрузке. Если DLL загружена в память Web-сервера, последний должен быть остановлен. Однако если DLL работает в отдельном процессе, остановке подлежит только этот процесс. Конеч-но, когда используется внешний процесс, расширение функционирует не так быстро, как внутри процесса Web-сервера, но зато не угрожает стабильности IIS. Фильтры ISAPI Фильтрами ISAPI называются компоненты, которые перехватывают определенные серверные события до того, как их обработает сервер. После своей загрузки фильтр указывает, какие события он будет перехватывать. Когда происходит одно из них, фильтр обрабатывает его сам либо передает другим фильтрам. Фильтры ISAPI можно использовать, например, для реализации пользовательско-го механизма аутентификации или автоматического перенаправления запросов на основе заголовков HTTP, переданных клиентом. В механизме IIS фильтры являются 
54 Часть I Внутренние механизмы ASP.NET важной деталью, которая требует тщательного исполнения. Обычно они очень полез-ны, однако если написать фильтр недостаточно тщательно, он может снизить произ-водительность системы. Работают фильтры только в процессе сервера. Но начиная с IIS 5.0 появилась возможность загружать их либо для всего Web-сервера, либо для конкретных Web-сайтов. Фильтры ISAPI могут выполнять такие задачи, как реализация пользовательских схем аутентификации, шифрования, протоколирования и анализа запросов. Воз-можность анализировать и, если требуется, модифицировать входящие и исходящие потоки данных делает фильтры ISAPI очень гибким и мощным средством. Однако указанные возможности являются и причиной их потенциального недостатка: если фильтр написан не очень тщательно, его использование приводит к снижению про-изводительности сервера. Ожидаемые изменения в IIS 7.0 ASP.NET 1.0 была самодостаточной, абсолютно новой исполняющей средой, рабо-тающей поверх IIS. После одновременного выхода ASP.NET 1.1 и IIS 6.0 серверная платформа Web-приложений и платформа их разработки сблизились и стали совмес-тно использовать некоторые функции, такие как повторное применение процессов и кэширование вывода. С появлением ASP.NET 2.0 в этом плане ничего не изменилось, но выпуск IIS 7.0 изменит многое. Унифицированная исполняющая среда В определенном смысле IIS 7.0 представляет собой унификацию платформ ASP.NET и IIS. Обработчики и модули HTTP, исполняющий конвейер, конфигурационные файлы станут составляющими элементами единой среды. Весь внутренний конвейер IIS будет составлен из отдельных, индивидуально конфигурируемых компонентов. В файл web.config добавится новый раздел, предназначенный для конфигурирования среды IIS. Иными словами, все должно быть так, как если бы исполняющая среда ASP.NET была расширена и вобрала в себя либо заменила собой окружающую среду Web-сер-вера. Трудно сказать, все ли будет именно так в действительности, но некоторые зна-комые вам концепции и инструменты ASP.NET станут доступными в IIS 7.0 на уровне Web-сервера. И тогда вы сможете, к примеру, использовать аутентификацию Forms для контроля доступа к любым ресурсам сервера, а не только к ресурсам ASP.NET. Управляемые расширения и фильтры ISAPI В настоящее время, если вы хотите получить контроль над входящими запросами IIS, у вас нет иного выбора, как написать DLL на C или C++, используя MFC или, возможно, ActiveX Template Library (ATL). Более дружественные к пользователю об-работчики и модули HTTP - это компоненты ASP.NET, и они способны обрабатывать только ее ресурсы, причем лишь после того, как запрос будет аутентифицирован IIS и передан ASP.NET. В IIS 7.0 вы сможете писать обработчики и модули HTTP для фильтрации любых запросов и, используя код .NET, реализовывать дополнительные функции для любых ресурсов Web-сервера. Точнее, вы будете писать обработчики и модули HTTP так же, как делали это для ASP.NET, с тем отличием, что у вас теперь появится возмож-ность регистрировать их для любых типов файлов. Нет нужды говорить, что, хотя расширения ISAPI старого типа будут по-прежнему поддерживаться, неуправляемые расширения и фильтры со временем уйдут в прошлое.
Обработчики и модули HTTP Глава 2 55 Написание обработчиков HTTP ASP.NET поставляется с небольшим набором встроенных обработчиков HTTP. Здесь есть обработчик для страниц ASP.NET, для Web-сервисов .NET и еще один для об-служивания запросов .NET Remoting к удаленным объектам, для которых IIS служит хост-средой. Также определены вспомогательные обработчики - для просмотра дан-ных трассировки отдельных страниц Web-приложения (trace.axd) и для блокирования запросов запрещенных ресурсов, таких как файлы .config или .asax. В ASP.NET 2.0 вы также найдете обработчик (webresource.axd), предназначенный для вставки в страницы ресурсов сборки и кода сценариев. Ко встроенным обработчикам Web-ресурсов мы вернемся в главе 9. Если вам понадобится, чтобы ASP.NET обрабатывала определенные запросы нестандартным образом, вы всегда сможете написать соответствующий обработчик HTTP. Список полезных действий, которые можно выполнять с помощью обработ-чиков, ограничен только вашим воображением. Хорошо написанные обработчики позволяют создавать страницы, обладающие поистине любой функциональностью. Например, можно создать счетчик щелчков, организовать поддержку манипуляций с изображением, включая их динамическое генерирование и серверное кэширова-ние, или воспрепятствовать нежелательным обращениям к определенным изобра-жениям. Примечание Обработчик HTTP может работать как синхронно, так и асинхронно. При синхронном режиме работы он не завершается до тех пор, пока не закончится обработка запроса. Асинхронный же обработчик инициирует потенциально длительный процесс и немедленно завершает свою работу. Типичной реализацией асинхронных обработчиков являются асинхронные страницы, о которых будет рассказано в главе 5. Далее мы рас-смотрим механизм работы асинхронных обработчиков, частным случаем которых можно считать упомянутые асинхронные страницы. Обычные расширения и фильтры ISAPI нуждаются в регистрации в метабазе IIS. В отличие от них обработчики HTTP регистрируются в файле web.config, причем только в том случае, когда обработчик должен участвовать в обработке Web-запроса в составе конвейера HTTP. Однако обработчик, подобно расширению ISAPI, может быть вызван прямо через URL. Как уже упоминалось, после выхода IIS 7.0 будет действовать только регистрационная модель web.config, хотя у вас по-прежнему останется возможность прямо вызывать обработчик через URL. Сначала я расска-жу о регистрируемых обработчиках, а затем покажу, как их можно вызывать без регистрации. Интерфейс IHttpHandler Вы уже готовы приступить к программированию обработчиков HTTP? Прекрасно. Первым делом вам нужно познакомиться с интерфейсом IHttpHandler. Обработчик HTTP - это просто управляемый класс, реализующий данный интерфейс. Точнее, синхронный обработчик реализует интерфейс IHttpHandler, а асинхронный - интер-фейс IHttpAsyncHandler. Начнем с синхронных обработчиков. Контракт интерфейса IHttpHandler определяет действия, которые обработчик дол-жен осуществить для синхронного выполнения HTTP-запроса. Члены интерфейса IHttpHandler Интерфейс IHttpHandler определяет всего два члена: ProcessRequest и IsReusab le (табл. 2-1). ProcessRequest является методом, а IsReusable - свойством типа Bo olean.
56 Часть I Внутренние механизмы ASP.NET Табл. 2-1. Члены интерфейса IHttpHandler Член Описание IsReusable Это свойство возвращает значение типа Boolean, указывающее, может ли в следующем запросе использоваться текущий экземпляр обработчика HTTP ProcessRequest Данный метод выполняет HTTP-запрос Свойство IsReusable класса Page возвращает значение false, указывающее на то, что для обслуживания запроса страницы требуется новый экземпляр обработчика HTTP. Обычно вы возвращаете из этого метода значение false всегда, когда требует-ся произвести более или менее существенную обработку в зависимости от полезной нагрузки запроса. Обработчики, используемые как простые барьеры, фильтрующие определенные запросы, могут устанавливать свойство IsReusable в true, чтобы сэкономить несколько циклов процессора. Я вернусь к этой теме чуть позже, когда будет рассматриваться конкретный пример. У метода ProcessRequest следующая сигнатура: void ProcessRequest(HttpContext context); Он принимает контекст запроса и обеспечивает его выполнение. В случае при-менения синхронного обработчика к моменту возврата из данного метода выходные данные готовы к отправке клиенту. Очень простой обработчик HTTP Итак, обработчик HTTP - это просто класс, реализующий интерфейс IHttpHandler. Результат выполнения запроса формируется методом ProcessRequest, что демонстри-рует следующий код: using System.Web; namespace ProAspNet20.Advanced.CS.Components { public class SimpleHandler : IHttpHandler { //Переопределение метода ProcessRequest public void ProcessRequest(HttpContext context) { context.Response.Write("<H1>Hello, I'm an HTTP handler</H1>"); } //Переопределение свойства IsReusable public bool IsReusable { get { return true; } } } } Для вызова обработчика необходима точка входа. В данном контексте точкой входа обработчика является не что иное, как конечная точка HTTP, то есть общедоступный URL. Этот URL должен быть уникальным именем, чтобы IIS и исполняющая среда ASP.NET могли идентифицировать по нему обработчик. При регистрации соответствие между обработчиком HTTP и ресурсом Web-сервера задается в файле web.config: <configuration> <system.web>
Обработчики и модули HTTP Глава 2 57 <httpHandlers> <add verb="*" path="myHandler.aspx" type="ProAspNet20.Advanced.CS.Components.SimpleHandler" /> </httpHandlers> </system.web> </configuration> В разделе <httpHandlers> перечисляются обработчики, доступные для текуще-го приложения. Приведенные установки указывают, что SimpleHandler отвечает за обработку любых входящих запросов для конечной точки с именем myHandler.aspx. Заметьте, что URL myHandler.aspx не обязательно должен быть реальным именем физического ресурса, находящегося на сервере, - это просто публичный идентифи-катор ресурса. В атрибуте type задаются класс и сборка, содержащие обработчик. Его канонический формат - тип[,сборка]. Информацию о сборке можно опустить, если компонент определен в папке App_Code или другой зарезервированной папке. Примечание Если вставить приведенный фрагмент кода в файл machine.config, компо-нент SimpleHandler будет зарегистрирован как вызываемый из любых Web-приложений, установленных на серверном компьютере. Введя в браузере URL myHandler.aspx, вы получите результат, показанный на рис. 2-2. Рис. 2-2. Пример обработчика HTTP, отвечающего на запросы ресурса myHandler.aspx Описанная технология - это простейший и самый быстрый способ включить обработчик HTTP в работу, но вам следует узнать еще кое-что о регистрации обра-ботчиков; к тому же существует и много других возможностей, которые вы можете найти полезными. Так что теперь давайте рассмотрим более сложный пример обра-ботчика HTTP. Обработчик HTTP для быстрого создания отчетов При относительной простоте программной модели обработчики HTTP способны вза-имодействовать с низкоуровневыми сервисами запросов и ответов IIS. В предыдущем примере мы возвращали из обработчика константный текст и никак не использовали информацию запроса. В следующем примере мы сконфигурируем обработчик таким образом, чтобы он перехватывал и обрабатывал только запросы конкретного типа и генерировал выходную информацию на основе содержимого запрошенного ресурса. Мы будем создавать обработчик HTTP для пользовательских ресурсов .sqlx. Файл SQLX - это XML-документ, представляющий SQL-запрос. Обработчик будет считывать информацию о запросе, выполнять его и возвращать результирующий набор данных, отформатированный в виде таблицы. На рис. 2-3 показан ожидае-мый вывод.
58 Часть I Внутренние механизмы ASP.NET Рис. 2-3. Пользовательский обработчик HTTP в действии Для начала проанализируем исходный код класса IHttpHandler. Внимание! Данный пример - просто демонстрация способа обработки пользовательского XML-файла с пользовательским расширением и выполнения задачи чуть более сложной, чем вывод сообщения "hello world". Не принимайте его за реалистичный прототип при-ложения для доступа к данным Microsoft SQL Server через Web. Построение обработчика SQL-запросов Наш обработчик HTTP должен вступать в игру, когда пользователь запросит ресурс .sqlx. Предположим, что данный аспект его работы уже настроен, и сконцентриру-емся на том, как он будет выполнять SQL-запрос и представлять результаты в виде таблицы. Для выполнения запроса нужны как минимум строка подключения и текст SQL-инструкции. Типичное содержимое файла .sqlx приведено ниже. <queries> <query connString="DATABASE=northwind;SERVER=localhost;UID=...;"> SELECT firstname, lastname, country FROM employees </query> <query connString="DATABASE=northwind;SERVER=localhost;UID=...;"> SELECT companyname FROM customers WHERE country='Italy' </query> </queries> XML-документ состоит из набора узлов <query>. Каждый из них имеет атрибут, задающий строку подключения, и содержит текст запроса. Метод ProcessRequest извлекает указанную информацию, после чего выполняет запрос и генерирует выходной HTML-текст. class SqlxData { public string ConnectionString; public string QueryText; }public class QueryHandler : IHttpHandler { public void ProcessRequest(HttpContext context)
Обработчики и модули HTTP Глава 2 59 { //Анализируем файл SQLX SqlxData[] data = ParseFile(context); //Формируем выходной HTML-документ StringCollection htmlColl = CreateOutput(data); //Выводим данные context.Response.Write("<html><head><title>"); context.Response.Write("QueryHandler Output"); context.Response.Write("</title></head><body>"); foreach (string html in htmlColl) { context.Response.Write(html); context.Response.Write("<hr />"); } context.Response.Write("</body></html>"); } //Переопределяем свойство IsReusable public bool IsReusable { get { return false; } } } Вспомогательная функция ParseFile анализирует исходный код файла .sqlx и для каждого обнаруженного в нем запроса создает экземпляр класса SqlxData. private SqlxData[] ParseFile(HttpContext context) { XmlDocument doc = new XmlDocument(); string file = context.Request.Path; using (Stream file = VirtualPathProvider.OpenFile(file)) { doc.Load(file); } //Обходим узлы <mapping> XmlNodeList mappings = doc.SelectNodes("queries/query"); SqlxData[] descriptors = new SqlxData[mappings.Count]; for (int i=0; i < descriptors.Length; i++) { XmlNode mapping = mappings[i]; SqlxData query = new SqlxData(); descriptors[i] = query; try { query.ConnectionString = mapping.Attributes["connString"].Value; query.QueryText = mapping.InnerText; } catch { context.Response.Write("Error parsing the input file."); } } return descriptors; }
60 Часть I Внутренние механизмы ASP.NET Объект нашего внутреннего класса SqlxData содержит строку подключения и текст SQL-инструкции. Эта информация передается функции CreateOutput, которая выпол-няет SQL-инструкцию и генерирует результирующую таблицу. private StringCollection CreateOutput(SqlxData[] descriptors) { StringCollection coll = new StringCollection(); foreach (SqlxData data in descriptors) { //Выполняем запрос DataTable dt = new DataTable(); SqlDataAdapter adapter = new SqlDataAdapter(data.QueryText, data.ConnectionString); adapter.Fill(dt); //Подготавливаем таблицу DataGrid grid = new DataGrid(); grid.DataSource = dt; grid.DataBind(); //Формируем HTML string html = Utils.RenderControlAsString(grid); coll.Add(html); } return coll; } После выполнения запроса данный метод заполняет динамически созданный эле-мент управления DataGrid. В страницах ASP.NET рендеринг этого элемента управ-ления, как и любого другого, выполняется в виде HTML. Однако это происходит с использованием особого HTTP-обработчика, отвечающего за ресурсы .aspx. Для ресурсов же нашего типа, то есть .sqlx, данную функциональность нам приходится ре-ализовывать самостоятельно. Впрочем, получить HTML-код для Web-элемента очень просто - достаточно вызвать метод RenderControl объекта HtmlTextWriter. Именно это и делает вспомогательный метод RenderControlAsString: static class Utils { public static string RenderControlAsString(Control ctl) { StringWriter sw = new StringWriter(); HtmlTextWriter writer = new HtmlTextWriter(sw); ctl.RenderControl(writer); return sw.ToString(); } } Примечание В обработчике HTTP, которому требуется доступ к состоянию сеанса, должен быть реализован интерфейс IRequiresSessionState. Подобно INamingContainer, он является интерфейсом-маркером, не требующим реализации методов. Заметьте, интер-фейс IRequiresSessionState указывает на то, что обработчику HTTP требуется возможность читать и записывать информацию о состоянии сеанса. Если достаточно доступа только для чтения, используйте вместо него интерфейс IReadOnlySessionState. Регистрация обработчика Обработчик HTTP - это класс, и перед использованием он должен быть откомпи-лирован в сборку, которую следует установить в папку Bin приложения. Если вы 
Обработчики и модули HTTP Глава 2 61 планируете сделать этот обработчик доступным всем приложениям, скопируйте его в глобальный кэш сборок (GAC). Следующий ваш шаг - регистрация обработчика в конкретном приложении или же во всех приложениях, функционирующих на данном Web-сервере. Регистрация производится в конфигурационном файле. <system.web> <httpHandlers> <add verb="*" path="*.sqlx" type= "ProAspNet20.CS.Components.QueryHandler,ProAspCompLib" /> </httpHandlers> </system.web> Информация о новом обработчике добавляется в раздел <httpHandlers> локального или глобального файла web.config. Для данного раздела поддерживаются три опера-ции: <add>, <remove> и <clear>. Операцию <add> вы используете для добавления нового обработчика HTTP с областью действия, соответствующей области действия файла .config. Операция <remove> служит для удаления конкретного обработчика, а операция <clear> позволяет в одночасье избавиться от всех зарегистрированных обработчиков. Для добавления нового обработчика нужно установить три атрибута: verb, path и type; они описаны в табл. 2-2. Табл. 2-2. Атрибуты, необходимые для регистрации обработчика HTTP Атрибут Описание verb Список поддерживаемых глаголов HTTP, например: GET, PUT, POST. Допускается использование символа подстановки *, обозначающего все глаголы path Символ подстановки или строковый URL, указывающий на ресурсы, с которыми будет работать обработчик, например: *.aspx type Имя класса и имя сборки, разделенные запятой. ASP.NET ищет DLL сборки сначала в папке Bin приложения, а затем в глобальном кэше сборок системы Все эти атрибуты являются обязательными. Поддерживается также один необяза-тельный атрибут - validate. Когда он установлен в false, ASP.NET пытается как можно дольше не загружать сборку обработчика. Иными словами, сборка загружается только тогда, когда поступает запрос, требующий участия данного обработчика. ASP.NET не пытается предварительно загрузить сборку, которая пока не требуется, и таким образом проявление связанных с ней ошибок и других проблем откладыва-ется до последнего момента. Если бы сборка загружалась заранее, логика выполне-ния могла бы быть не готовой к потенциальным ошибкам и стабильность системы оказалась бы под угрозой. Итак, вы правильно установили и зарегистрировали обработчик HTTP, но если прямо сейчас запросить ресурс, результат окажется не тем, которого вы ожидали. Объясняется это тем, что пока для обработки ресурсов .sqlx мы сконфигурировали только ASP.NET, а IIS все еще ничего о них не знает! Запрос ресурса .sqlx сначала попадает к IIS. Если вы не зарегистрировали рас ши ре-ние ISAPI, которое должно обрабатывать такие ресурсы, IIS будет интерпретировать его как статический и выполнит запрос сам, отправив вам исходный код файла. До ба вочный шаг, состоящий в регистрации расширения .sqlx в метабазе IIS, про-демонстрирован на рис. 2-4. Показанное на рисунке диалоговое окно открывается из IIS Manager командой отобра жения свойств приложения с последующим выбором вкладки Web Site. Вам нужно будет добавить расширение .sqlx и выбрать для него в качестве расширения ISAPI файл aspnet_isapi.dll. Тогда все запросы ресурсов .sqlx будут перенаправляться 
62 Часть I Внутренние механизмы ASP.NET ASP.NET и обрабатываться нашим обработчиком. Только убедитесь, что вы выбрали файл aspnet_isapi.dll из папки той версии ASP.NET, которую планируете использовать. Рис. 2-4. Регистрация расширения .sqlx в метабазе IIS Внимание! В Microsoft Visual Studio 2005 при тестировании демонстрационного ресур са .sqlx путем задействования локального встроенного Web-сервера не обязательно ре ги-стри ровать тип ресурсов .sqlx в IIS. Ведь вы не используете IIS! Иными словами, при наличии локального Web-сервера вам нет нужды возиться с IIS: незачем регистрировать пользовательские ресурсы до тех пор, пока вы не перенесете приложение на эксплуа та-ционный сервер. Если Web-приложение работает с ресурсами какого-то типа, который вы не хотите делать публично доступным через Web, можете дать указание IIS не отображать такие файлы. Для этого перенаправьте запросы ресурсов данного типа aspnet_isapi и свя-жите соответствующее расширение с одним из встроенных обработчиков - классом HttpForbiddenHandler: <add verb="*" path="*.xyz" type="System.Web.HttpForbiddenHandler" /> После этого любая попытка получить доступ к ресурсу .xyz будет сопровождаться сообщением об ошибке. Инсталляция вашего обработчика как ресурса ASHX Альтернативный способ определения обработчика HTTP предполагает использова-ние файла .ashx. Такой обработчик активизируется при получении запроса ресурса .ashx. Связь между обработчиком и ресурсом .ashx устанавливается в самом файле ресурса с помощью специальной директивы @WebHandler. С нее должны начинаться все файлы .ashx: <%@WebHandler Language="C#" Class="Namespace.MyHandler" %> При получении HTTP-запроса с указанием URL, соответствующего ресурсу .ashx, автоматически вызывается класс MyHandler. Ниже приведен пример содержимо-го файла .ashx. Как видите, это просто файл класса, в который добавлена директива @WebHandler: <%@WebHandler Language="C#" Class="MyHandler" %> using System.Web; public class MyHandler : IHttpHandler {
Обработчики и модули HTTP Глава 2 63 public void ProcessRequest (HttpContext context) { context.Response.ContentType = "text/plain"; context.Response.Write("Hello World"); } public bool IsReusable { get { return false; } } } Когда для реализации обработчика HTTP используется ресурс .ashx, никакой настройки для его инсталляции не требуется. В частности, вам не нужно вносить изменения в файл web.config, добавляя в него новый раздел <httpHandlers> , как это делается для других обработчиков. Просто поместите исходный файл в требуемый каталог, - и дело сделано. Подобно Web-сервисам, исходный файл будет загружен и откомпилирован по требованию. Поскольку для ресурсов .ashx ASP.NET сама добав-ляет в метабазу IIS специальную запись, вам даже не понадобится вносить изменения в конфигурацию Web-сервера. Ресурсы с расширением .ashx обрабатываются классом SimpleHandleFactory. Это класс-фабрика обработчиков HTTP, а не просто обработчик. О фабриках обработчиков HTTP мы поговорим немного позже. Класс SimpleHandleFactory ищет в начале файла директиву @WebHandler, из кото-рой узнает имя класса обработчика HTTP, экземпляр которого должен быть создан, как только будет откомпилирован исходный код. Внимание! Обработчики HTTP можно создавать в виде обычных файлов классов, компили руе мых в сборки, или же в виде ресурсов .ashx. Особых аргументов в пользу того или ино го подхода не существует; единственное различие заключается в том, что ресурсы .ashx, подобно обычным страницам ASP.NET, компилируются на лету, по первому запросу. Обработчики HTTP и страницы ASP.NET Обработчик HTTP целесообразно создавать в том случае, когда некая специ-фическая для приложения логика должна выполняться быстрее, чем обычные Web-страницы. В любом случае обработчик возвращает обычный HTTP-ответ, в котором указан тип контента, и содержится тело страницы. Выполнение запроса ресурса .ashx или любого другого запроса, обслуживаемого обработчиком HTTP, производится быстрее, чем выполнение запроса ресурса .aspx. Пользовательский обработчик действует быстрее потому, что при этом не генерируются никакие промежуточные события (такие как Init или Load), не производятся действия, связанные с управлением состоянием, и не задействуется механизм обратной свя-зи. Проще говоря, запрос пользовательского обработчика HTTP подобен запросу ресурса .aspx, при обработке которого выполняется только этап рендеринга. Кроме того, поиск подходящего обработчика HTTP для обслуживания запроса страницы может занять немного больше времени, поскольку производится промежуточное обращение к фабрике обработчиков страницы. Не забывайте, что страница ASP.NET - это просто обработчик HTTP. Правда, он довольно сложный, но базовый механизм именно таков. И если пользователь-ские обработчики HTTP, как правило, быстрее обычных страниц, то это потому, что они, минуя все промежуточные этапы, сразу же приступают к формированию результата. В качестве примера представьте, что вы хотите вывести изображение, 
64 Часть I Внутренние механизмы ASP.NET хранящееся в базе данных (эту тему мы подробно рассмотрим в главе 9). Для этого вам необходимо связать элемент управления Image с URL, соответствующим тре-буемому MIME-типу. Должен ли этот URL указывать на страницу? Можно сделать и так, но если написать обработчик HTTP, ваш код будет работать быстрее. Страница ASP.NET - сложный объект, представленный специализирован-ным и сложным обработчиком HTTP - классом Page. Когда речь идет о предо-став лении пользовательских ресурсов, следует убедиться, что применяется под-ходящий обработчик, содержащий только необходимую логику. Например, для выполнения запроса к базе данных и вывода изображения, которое в ней хранится, вам не нужна логика управления состоянием и возврата формы, как не нужно и генерировать события для приложения. Что предпочесть: ресурс .ashx или пользовательское расширение? Выбор за-висит от того, какую функцию вы собираетесь реализовать. Решение на основе ресурса .ashx подходит для относительно простых задач, когда требуется несколь-ко па раметров (или вообще ни одного), для передачи которых достаточно строки запроса. Пользовательское расширение предпочтительнее, когда речь идет об об-работке пользовательского документа, содержащего большой объем информации со сложной, не плоской организацией. Обработчик для просмотрщика изображений Проанализируем другой сценарий, с пользовательскими обработчиками HTTP. До сих пор мы имели дело с пользовательскими ресурсами и встроенным расширением .ashx и узнали, как важно регистрировать пользовательские расширения в IIS. Для ускорения обработки IIS лично предоставляет некоторые ресурсы, типичные для Web-приложений, не обращаясь к расширениям ISAPI. К числу таких ресурсов относятся статические файлы, в частности изображения и HTML. Что будет, если за-просить файл формата GIF или JPG прямо из адресной строки браузера? IIS извлечет заданный ресурс, установит для него в буфере ответа подходящий тип содержимого и запишет в этот буфер байты файла. В результате вы увидите изображение в окне браузера. Пока все нормально. Но что если вы укажете в запросе виртуальную папку, содержащую изображения? В таком случае IIS не сможет классифицировать содержимое папки и вернет список файлов, как показано на рис. 2-5. Рис. 2-5. Стандартное IIS-представление папки
Обработчики и модули HTTP Глава 2 65 Думается в таком случае лучше было бы организовать предварительный просмотр содержимого папки. Проектирование обработчика HTTP Нам требуется создать расширение, фильтрующее содержимое папки, извлекающее изображения и представляющее их в табличном виде. Для того чтобы реализовать данную задачу на уровне IIS, придется писать неуправляемое расширение ISAPI или же ждать выпуска IIS 7.0. Альтернативное решение заключается в том, чтобы написать управляемый обработчик HTTP для ASP.NET и убедить IIS обращаться к ASP.NET, когда будет запрошена папка с изображениями. Идея состоит в том, чтобы связать просмотрщик изображений с конкретной конеч-ной точкой - скажем, view.axd. Как упоминалось ранее в этой главе, фиксированные конечные точки обработчиков HTTP не обязательно должны соответствовать сущес-твующим, установленным на сервере ресурсам. Конечная точка может выглядеть как URL файла, находящегося в некоторой папке на сервере, например: http://www.contoso.com/images/misc/view.axd Обработчик получит данный URL, выделит имя папки и извлечет все имеющиеся в ней изображения, при этом наличие самого файла view.axd не потребуется. Примечание В ASP.NET расширение .axd обычно используется для конечных точек, указывающих на определенный сервис. Типичные примеры - Trace.axd, выполняющий трассировку, и WebResource.axd, служащий для вставки ресурсов и сценариев. В час-тности, обработчик Trace.axd реализует такую же логику, какая описывается в данном разделе. Его имя добавляется к URL, и он трассирует все запросы страниц текущего приложения. Реализация обработчика HTTP Наш просмотрщик изображений должен возвращать страницу с многострочной таб-лицей, содержащей все имеющиеся в папке изображения. Вот какова структура его класса: class PictureViewerInfo { public PictureViewerInfo() { DisplayWidth = 200; ColumnCount = 3; } public int DisplayWidth; public int ColumnCount; public string FolderName; }public class PictureViewerHandler : IHttpHandler { //Переопределяем метод ProcessRequest public void ProcessRequest(HttpContext context) { PictureViewerInfo info = GetFolderInfo(context); string html = CreateOutput(info); //Выводим данные context.Response.Write("<html><head><title>"); context.Response.Write("Picture Web Viewer");
66 Часть I Внутренние механизмы ASP.NET context.Response.Write("</title></head><body>"); context.Response.Write(html); context.Response.Write("</body></html>"); } //Переопределяем свойство IsReusable public bool IsReusable { get { return false; } } } Выделить путь к папке просто: достаточно отрезать от URL строку view.axd, а за-тем все завершающие символы косой черты (прямой или обратной). После этого следует определить, какому реальному пути на сервере соответствует полученный виртуальный URL, и извлечь содержимое файлов, используя API .NET Framework, предназначенный для работы с файлами и папками. private ArrayList GetAllImages(string path) { string[] fileTypes = { "*.bmp", "*.gif", "*.jpg", "*.png" }; ArrayList images = new ArrayList(); DirectoryInfo di = new DirectoryInfo(path); foreach (string ext in fileTypes) { FileInfo[] files = di.GetFiles(ext); if (files.Length > 0) images.AddRange(files); } return images; } Класс DirectoryInfo предоставляет несколько полезных функций для работы с за-данной папкой. Например, метод GetFiles выбирает все файлы, соответствующие опре деленному шаблону. Каждый файл инкапсулируется в объект FileInfo. Метод GetFiles не поддерживает множественных шаблонов поиска; чтобы отобрать файлы несколь ких ти пов, нужно по очереди найти файлы каждого из них и объединить результаты в структуре типа ArrayList или ей подобной. Когда полный список содержащихся в папке изображений получен, остается лишь сформировать выходные данные. Они должны быть оформлены в виде таблицы с фик-си рованным числом столбцов и переменным числом строк, вмещающей все найденные изображения. Для каждого файла изображения с помощью элемента управления Image создается новый тэг <img>. Его атрибуту width присваивается фиксированное значение (скажем, 200 пикселов), вынуждающее большинство современных браузеров соответствующим образом масштабировать изображение. Затем выводимое на страни-це изображение превращается в якорь, для которого задается URL исходного файла. В результате, когда пользователь щелкает на изображении, страница обновляется, и на ней то же изображение выводится в натуральную величину. string CreateOutputForFolder(PictureViewerInfo info) { ArrayList images = GetAllImages(info.FolderName); Table t = new Table();
Обработчики и модули HTTP Глава 2 67 int index = 0; bool moreImages = true; while (moreImages) { TableRow row = new TableRow(); t.Rows.Add(row); for (int i = 0; i < info.ColumnCount; i++) { TableCell cell = new TableCell(); row.Cells.Add(cell); //Создаем изображение Image img = new Image(); FileInfo fi = (FileInfo)images[index]; img.ImageUrl = fi.Name; img.Width = Unit.Pixel(info.DisplayWidth); //Превращаем изображение в якорь, чтобы после щелчка //на нем оно выводилось в натуральную величину HtmlAnchor a = new HtmlAnchor(); a.HRef = fi.Name; a.Controls.Add(img); cell.Controls.Add(a); //Проверяем, остались ли еще изображения для вывода index++; moreImages = (index < images.Count); if (!moreImages) break; } } } Возможно, вы хотели бы, чтобы этот обработчик принимал необязательные па-раметры строки запроса, такие как ширина столбцов и их количество. Эти значения упаковываются в экземпляр вспомогательного класса PictureViewerInfo вместе с име-нем просматриваемой папки. Приведем код, обрабатывающий строку HTTP-запроса и извлекающий из нее параметры, если таковые имеются: PictureViewerInfo info = new PictureViewerInfo(); object p1 = context.Request.Params["Width"]; object p2 = context.Request.Params["Cols"]; if (p1 != null) Int32.TryParse((string)p1, out info.DisplayWidth); if (p2 != null) Int32.TryParse((string)p2, out info.ColumnCount); На рис. 2-6 описываемый обработчик показан в действии. Зарегистрировать обработчик очень просто - вам нужно всего лишь добавить в файл web.config следующий сценарий: <add verb="*" path="view.axd" type="ProAspNet20.CS.Components.PictureViewerHandler,ProAspCompLib" />
68 Часть I Внутренние механизмы ASP.NET Если же поместить сборку в GAC, а конфигурационный сценарий перенести в machine.config, регистрация будет распространяться на все установленные на компьюте ре приложения. Рис. 2-6. Просмотрщик изображений в действии (число и ширина столбцов фиксированы) Более сложные технологии создания обработчиков HTTP В обычном обработчике HTTP львиную долю всей работы выполняет метод Process-Request. Второй член интерфейса IHttpHandler - свойство IsReusable - используется только при определенных обстоятельствах. С его помощью фабрика обработчиков HTTP выясняет, может ли данный его экземпляр использоваться для обслуживания нескольких запросов. Булево значение, возвращаемое свойством IsReusable, определяет также возмож-ность пулинга объекта-обработчика. Для объектов HttpApplication (данный класс также реализует интерфейс IHttpHandler), вызванных для обслуживания запроса, оно равно true, а для обработчиков, представляющих страницу Web Forms, - безусловно, false. Если запрограммировать свойство IsReusable так, чтобы оно возвращало true, обработчик не будет выгружаться из памяти после использования. Во всех рассмотренных случаях при обработке запроса не нужно было выбирать между несколькими обработчиками. Но если обработчик HTTP не идентифициру-ется однозначно, приходится прибегать к помощи специального объекта - фабрики обработчиков HTTP. Фабрика обработчиков HTTP HTTP-запрос может ассоциироваться либо непосредственно с обработчиком HTTP, либо с фабрикой обработчиков. Фабрика обработчиков HTTP - это класс, реали-зующий интерфейс IHttpHandlerFactory и отвечающий за возврат обработчика для обслуживания определенного запроса. Хорошим примером такой фабрики является класс SimpleHandlerFactory. Данная фабрика ставится в соответствие запросам, в ко-торых указываются ресурсы .ashx. Когда поступает такой запрос, фабрика выбирает подходящий обработчик, руководствуясь директивой @WebHandler, содержащейся в исходном файле. В .NET Framework фабрика обработчиков HTTP используется для выполнения некоторых задач, предшествующих передаче ресурса обработчику. Еще одним хоро-шим примером объекта-фабрики может служить внутренний класс PageHandlerFac
Обработчики и модули HTTP Глава 2 69 tory, отвечающий за обработку запросов страниц .aspx. В данном случае фабрика определяет имя используемого обработчика и, если это возможно, загружает его из существующей сборки. В классе-фабрике обработчиков HTTP должны быть реализованы два описанных в табл. 2-3 метода интерфейса IHttpHandlerFactory: GetHandler и ReleaseHandler. Табл. 2-3. Члены интерфейса IHttpHandlerFactory Метод Описание GetHandler Возвращает обработчик HTTP для обслуживания запроса ReleaseHandler Принимает существующий обработчик и освобождает его либо помещает в пул Сигнатура метода GetHandler такова: public virtual IHttpHandler GetHandler(HttpContext context, string requestType, string url, string pathTranslated); Аргумент requestType - это строка, содержащая слово GET или POST - глагол HTTP-запроса. Два последних аргумента представляют исходный URL запроса и соответствующий ему физический путь. Метод ReleaseHandler нужно обязательно переопределять в любом классе, реализующем интерфейс IHttpHandlerFactory; в боль-шинстве случаев его тело может оставаться пустым. Ниже приведен пример фабрики обработчиков HTTP, возвращающей разные обработчики в зависимости от того, какой глагол (GET или POST) использован в запросе: class MyHandlerFactory : IHttpHandlerFactory { public IHttpHandler GetHandler(HttpContext context, string requestType, String url, String pathTranslated) { if(context.Request.RequestType.ToLower() == "get") return (IHttpHandler) new MyGetHandler(); else if(context.Request.RequestType.ToLower() == "post") return (IHttpHandler) new MyPostHandler(); return null; } public void ReleaseHandler(IHttpHandler handler) { //Ничего делать не нужно } } Когда используется фабрика обработчиков, именно ее, а не обработчики, нужно регистрировать в конфигурационном файле ASP.NET. Если зарегистрировать конк-ретный обработчик, он и будет применяться для обслуживания запросов. Если же предпочтение отдано фабрике, то решение о том, какой из обработчиков больше подходит для конкретного запроса, будет динамически приниматься именно ею. Асинхронные обработчики Асинхронный обработчик HTTP - это класс, реализующий интерфейс IHttpAsync-Handler. Система активизирует его путем вызова метода BeginProcessRequest. Закон-чив свою работу, обработчик уведомляет об этом систему через функцию обратного 
70 Часть I Внутренние механизмы ASP.NET вызова, и та завершает его с помощью вызова EndProcessRequest. В .NET Framework асинхронный интерфейс реализуется единственным классом - HttpApplication. Члены интерфейса IHttpAsyncHandler описаны в табл. 2-4. Табл. 2-4. Члены интерфейса IHttpAsyncHandler Метод Описание BeginProcessRequest Запускает асинхронный обработчик HTTP EndProcessRequest Прекращает работу асинхронно вызванного обработчика Сигнатура метода BeginProcessRequest следующая: IAsyncResult BeginProcessRequest( HttpContext context, AsyncCallback cb, object extraData); В аргументе context передается ссылка на внутренние серверные объекты, исполь-зуемые при выполнении запроса. Объект AsyncCallback, служащий вторым аргумен-том, вызывается по завершении работы асинхронного метода. Третий аргумент может содержать любые данные, которые вы хотели бы передать обработчику. Примечание Объект AsyncCallback является делегатом, определяющим логику, которая необходима для завершения асинхронной операции. Делегат - это класс, содержащий ссылку на метод. У класса-делегата фиксированная сигнатура, и он может содержать ссылки только на те методы, которые ей соответствуют. Делегат эквивалентен типизи-рованному указателю на функцию. Таким образом, объект AsyncCallback - это просто код, выполняющийся, когда асинхронный обработчик завершает свою работу. Сигнатура делегата AsyncCallback такова: public delegate void AsyncCallback(IAsyncResult ar); Он использует интерфейс IAsyncResult для получения информации о состоянии асинхронной операции. Чтобы проиллюстрировать принцип действия асинхронных обработчиков, я приведу псевдокод для действий, выполняемых исполняющей средой ASP.NET, когда она имеет дело с асинхронным обработчиком. Вот как она вызывает метод BeginProcessRequest: //Связывает внутренний член класса HttpContext //с текущим экземпляром асинхронного обработчика context.AsyncAppHandler = asyncHandler; //Вызывает метод BeginProcessRequest //асинхронного обработчика asyncHandler.BeginProcessRequest(context, OnCompletionCallback, context); В аргументе context передается текущий экземпляр класса HttpContext, представ-ляющий контекст запроса. Ссылка на контекст HTTP передается и в третьем аргу-менте, представляющем пользовательские данные, необходимые обработчику для выполнения запроса. Параметр extraData из сигнатуры метода BeginProcessRequest используется для представления состояния асинхронной операции. Сам метод Begin-ProcessRequest возвращает объект класса HttpAsyncResult, реализующего интерфейс IAsyncResult. Последний содержит свойство AsyncState, которому присваивается зна-чение параметра extraData - в данном случае контекст HTTP.
Обработчики и модули HTTP Глава 2 71 OnCompletionCallback - это внутренний метод. Он автоматически вызывается для завершения асинхронной обработки запроса. Вот псевдокод, демонстрирующий работу закрытого метода класса HttpRuntime: //Данный метод должен иметь сигнатуру делегата AsyncCallback private void OnHandlerCompletion(IAsyncResult ar) { //В аргументе ar передается экземпляр класса HttpAsyncResult HttpContext context = (HttpContext) ar.AsyncState; //Извлекает экземпляр асинхронного обрабточика HTTP //и завершает обработку запроса IHttpAsyncHandler asyncHandler = context.AsyncAppHandler; asyncHandler.EndProcessRequest(ar); //Обработка запроса завершается как обычно } Обработчик завершения извлекает HTTP-контекст запроса посредством свойства AsyncState объекта IAsyncResult, который получает от системы. Как уже упоминалось, настоящим передаваемым объектом является экземпляр класса HttpAsyncResult - в любом случае это возвращаемое значение метода BeginProcessRequest. Обработчик завершения извлекает из контекста ссылку на асинхронный обработчик и вызывает его метод EndProcessRequest. void EndProcessRequest(IAsyncResult result); Метод EndProcessRequest принимает объект IAsyncResult, возвращенный из вызова BeginProcessRequest. Реализованный в классе HttpApplication метод EndProcessRequest не делает ничего особенного - разве что выбрасывает исключение, если происходит ошибка. Реализация асинхронного обработчика Асинхронные обработчики удобно использовать в ситуациях, когда процедура фор-мирования разметки длительна или сложна, например, при необходимости вызвать хранимые процедуры базы данных или Web-сервисы. В таких случаях отвечающий за обработку запроса поток ASP.NET вынужден дожидаться завершения операции. Поскольку данный поток является важным членом пула потоков ASP.NET, подобные длительные процедуры отрицательно сказываются на производительности сервера. Вот тут и приходят на выручку асинхронные обработчики. Идея заключается в том, чтобы обработка запроса начиналась в потоке из пула, но этот поток тут же освобождался. В методе BeginProcessRequest вы обычно созда-ете собственный поток и инициируете выполнение длительной операции. Сам этот метод не дожидается завершения операции, а немедленно заканчивает свою работу, в результате чего поток возвращается в пул. Тут есть множество мелких деталей, которые я опущу. Отмечу лишь, что следу-ет старательно избегать размножения потоков. Лучше всего создать пользователь-ский пул потоков. Кроме того, подумайте о том, как сигнализировать о завершении длительной операции. Чаще всего для этой цели создают пользовательский класс, реализующий интерфейс IAsyncResult, и возвращают его объект из BeginProcessRequest. Данный объект содержит встроенный синхронизационный объект - обычно 
72 Часть I Внутренние механизмы ASP.NET ManualResetEvent, - которому пользовательский поток, выполняющий длительную операцию, просигнализирует о ее завершении. Очевидно, что создание асинхронных обработчиков - процесс не простой, и он явно не для новичков. Вполне вероятно, что вас больше интересуют асинхронные страницы, где тот же механизм применяется по отношению к ресурсам .aspx. В этом случае "длительной операцией" является метод ProcessRequest класса Page. (Понятно, что конфигурирование страницы как асинхронной имеет смысл только в том случае, когда она выполняет такие операции ввода-вывода, которые потенциально являются длительными.) В ASP.NET 2.0 предусмотрены специальные средства поддержки асинхронных страниц, значительно упрощающие их создание. Соответствующий API мы рассмот-рим в главе 5. Написание модулей HTTP Итак, мы выяснили, что ASP.NET выполняется в процессе IIS как расширение ISAPI. Входящие запросы ресурсов ASP.NET передаются ее рабочему процессу и обраба-тываются в контексте общеязыковой среды. В IIS версий 5.0 и 6.0 данный рабочий процесс выполняется отдельно от IIS, поэтому в случае сбоя одного из приложений ASP.NET весь сервер из строя не выходит. (В IIS 6.0 передача запроса от Web-сервера рабочему процессу выполняется менее опосредованно и быстрее.) ASP.NET управляет пулом объектов HttpApplication, представляющих выполня-ющиеся приложения, и для каждого поступающего запроса выбирает из этого пула конкретный объект. Как рассказывалось в главе 1, это объекты класса, определенного в файле global.asax, или базового класса HttpApplication, если файла global.asax не су-ществует. Задача объекта HttpApplication в отношении обработки запроса заключается в передаче его обработчику HTTP. По пути от объекта HttpApplication к конечному обработчику HTTP запрос может пройти через конвейер моделей HTTP. Модуль HTTP - это класс .NET Framework, реализующий интерфейс IHttpModule. Отметим, что модули HTTP, фильтрующие "сырые" данные запроса, конфигурируются для каждого приложения в отдельности в файле web.config. Все приложения ASP.NET наследуют группу системных модулей HTTP, сконфигурированную в файле machine.config. В общем случае модуль HTTP может выполнять пред-и постобработку запроса, он перехватывает и обрабатывает системные события, а также события, сгенериро-ванные другими модулями. Вы можете писать и регистрировать собственные модули, встраивая их в конвейер исполняющей среды ASP.NET, с тем чтобы они обрабатывали системные события и генерировали собственные события. Интерфейс IHttpModule В интерфейсе IHttpModule определено всего два метода: Init и Dispose. Первый иници-ализирует модуль и подготавливает его к обработке запроса. Здесь вы подписываетесь на получение уведомлений на интересующие вас события. Метод Dispose освобождает используемые модулем ресурсы (все, кроме памяти!). Типичные задачи, выполняе-мые в методе Dispose, - это закрытие подключений к базе данных и дескрипторов файлов. У методов интерфейса IHttpModule следующие сигнатуры: void Init(HttpApplication app); void Dispose();
Обработчики и модули HTTP Глава 2 73 Метод Init получает ссылку на объект HttpApplication, обслуживающий запрос. Ее можно использовать для подключения к системным событиям. У объекта HttpApplication есть свойство Context, обеспечивающее доступ ко внутренним свойствам приложения ASP.NET, таким как Response, Request, Session и т. п. События, которые могут перехватываться и обрабатываться модулями HTTP, перечислены в табл. 2-5. Табл. 2-5. События HttpApplication Событие Когда происходит AcquireRequestState, PostAcquireRequestState Обработчик, выполняющий запрос, получил информацию о связанном с ним состоянии. Событие PostAcquireRequestState в ASP.NET 1.x недоступно AuthenticateRequest, PostAuthenticateRequest Модуль защиты идентифицировал пользователя. Событие PostAuthenticateRequest в ASP.NET 1.x недоступно AuthorizeRequest, PostAuthorizeRequest Модуль защиты проверил авторизацию пользователя. Событие PostAuthorizeRequest в ASP.NET 1.x недоступно BeginRequest Конвейер HTTP начал обработку запроса Disposed Объект HttpApplication уничтожен в результате вызова метода Dispose EndRequest Последнее событие в цепочке выполнения конвейера HTTP Error Выброшено необработанное исключение PostMapRequestHandler Найден обработчик HTTP, который будет обслуживать запрос. Данное событие в ASP.NET 1.x недоступно PostRequestHandlerExecute Обработчик HTTP завершил выполнение запроса. К этому моменту текст ответа сгенерирован PreRequestHandlerExecute Происходит непосредственно перед запуском обработчика HTTP PreSendRequestContent Происходит непосредственно перед тем, как исполняющая среда ASP.NET отправит ответ клиенту PreSendRequestHeaders Происходит непосредственно перед тем, как исполняющая среда ASP.NET отправит клиенту заголовки HTTP ReleaseRequestState, PostReleaseRequestState Обработчик сформировал информацию о состоянии, связанную с текущим запросом. Событие PostReleaseRequestState в ASP.NET 1.x недоступно ResolveRequestCache, PostResolveRequestCache Исполняющая среда ASP.NET выполнила запрос с использовани-ем кэша вывода. Событие PostResolveRequestCache в ASP.NET 1.x недоступно UpdateRequestCache, PostUpdateRequestCache Исполняющая среда ASP.NET сохранила ответ на текущий вопрос в кэше вывода для использования при обслуживании последующих запросов. Событие PostUpdateRequestCache в ASP.NET 1.x недоступно Все эти события генерируются объектом HttpApplication, который модуль HTTP получает в качестве аргумента метода Init. Пользовательский модуль HTTP Давайте напишем относительно простой пользовательский модуль с именем Marker, добавляющий в начало и конец каждой страницы приложения определенную 
74 Часть I Внутренние механизмы ASP.NET сигнатуру. Приведенный ниже код демонстрирует схему класса, который нам пред-стоит создать. using System; using System.Web; namespace ProAspNet20.CS.Components { public class MarkerModule : IHttpModule { public void Init(HttpApplication app) { //Регистрируем обработчики событий конвейера } public void Dispose() { //Здесь ничего делать не нужно } } } Метод Init вызывается классом HttpApplication для загрузки модуля. В этом методе обычно нужно всего лишь зарегистрировать свои обработчики событий. Что касается метода Dispose, то, как правило, он и вовсе пустой. Сердцем модуля HTTP являются определяемые вами обработчики событий. Подписка на события Наш демонстрационный модуль Marker регистрирует обработчики двух событий конвейера: BeginRequest и EndRequest. Когда начинается обработка запроса, первым объекта HttpApplication достигает событие BeginRequest. Что касается события End-Request, то оно сигнализирует о том, что обработка запроса завершается и у вас ос-тается последняя возможность вмешаться. Обработав эти два события, вы можете записать в выходной поток пользовательский текст до или после того, как свой текст туда запишет обработчик HTTP - класс, производный от Page. Ниже приведена реализация методов Init и Dispose для нашего демонстрационного модуля. public void Init(HttpApplication app) { //Регистрируем обработчики событий конвейера app.BeginRequest += new EventHandler(OnBeginRequest); app.EndRequest += new EventHandler(OnEndRequest); }public void Dispose() {} Обработчики событий BeginRequest и EndRequest имеют сходную структуру. Каж-дый из них получает от отправителя события ссылку на текущий объект HttpApplication и через него извлекает контекст HTTP. Далее они работают с объектом Response, записывая туда текст или пользовательский заголовок. public void OnBeginRequest(object sender, EventArgs e) { HttpApplication app = (HttpApplication) sender; HttpContext ctx = app.Context; //Дополнительный код 
Обработчики и модули HTTP Глава 2 75 //Добавляем пользовательский заголовок в ответ HTTP //PageHeaderText - это константная строка, //объявленная в другом месте ctx.Response.AppendHeader("Author", "DinoE"); ctx.Response.Write(PageHeaderText); }public void OnEndRequest(object sender, EventArgs e) { //Получаем доступ к контексту HTTP HttpApplication app = (HttpApplication) sender; HttpContext ctx = app.Context; //Дополнительный код //Добавляем пользовательский код //PageFooterText - это константная строка, //объявленная в другом месте ctx.Response.Write(PageFooterText); } Обработчик OnBeginRequest записывает в выходной поток стандартный текст за-головка страницы, а за ним пользовательский заголовок HTTP. А обработчик OnEnd-Request просто добавляет на страницу нижний колонтитул. Результат работы данного модуля HTTP представлен на рис. 2-7. Рис. 2-7. HTTP-модуль Marker добавляет заголовок и нижний колонтитул на каждую страницу приложения Примечание Утилита IEWatch 2.0, которую вы видите на рисунке, это надстройка для Microsoft Internet Explorer, позволяющая анализировать запросы HTTP/HTTPS и исходный код HTML. Вы можете загрузить ее по адресу http://www.iewatch.com. В окне утилиты IEWatch 2.0, расположенном в нижней части показанной на рисун-ке страницы, отражаются все заголовки HTTP, отправленные и полученные браузером. В правой части этого окна выделен добавленный нами пользовательский заголовок.
76 Часть I Внутренние механизмы ASP.NET Регистрация в конфигурационном файле Новый модуль HTTP регистрируется путем добавления записи в раздел <httpModules> конфигурационного файла. Общий синтаксис данного раздела очень похож на тот, посредством которого регистрируются обработчики HTTP. Для добавления нового модуля используется узел <add>, где задаются атрибуты name и type. Первый из них содержит публичное имя модуля, которое будет использоваться для его извлечения из коллекции Modules объекта HttpApplication. Если модуль генерирует пользователь-ские события, данное имя также служит префиксом имен обработчиков этих событий в файле global.asax. <system.web> <httpModules> <add name="Marker" type= "ProAspNet20.CS.Components.MarkerModule,ProAspCompLib" /> </httpModules> </system.web> Атрибут type - это обычная строка с разделителем-запятой, содержащая имена класса и соответствующей сборки. Установки можно задавать в конфигурационном файле приложения или компьютера. В первом случае зарегистрированный вами мо-дуль будет обрабатывать страницы одного приложения, во втором - всех приложений, установленных на данном компьютере. Порядок вызова модулей определяется порядком их регистрации в конфи гу-рационном файле. Вы можете удалить системный модуль и заменить его вашим соб ственным, реализующим аналогичную функциональность. В таком случае в файл web.config приложения вам нужно будет добавить узел <remove> - для удаления модуля, используемого по умолчанию, и узел <add> - для добавления своего моду-ля. Если же вы захотите полностью переопределить для своего приложения порядок модулей HTTP, удалите все используемые по умолчанию модули с помощью узла <clear>, а затем перерегистрируйте их в требуемом порядке. Доступ к другим модулям HTTP Рассмотренный выше пример показывает, как осуществляется подключение к событи-ям конвейера HTTP, то есть к событиям, генерируемым объектом HttpApplication. А как насчет событий, генерируемых другими модулями? У объекта HttpApplication имеется свойство Modules, возвращающее коллекцию модулей текущего приложения. Свойство Modules имеет тип HttpModuleCollection. Данный класс-коллекция яв-ляется производным от абстрактного класса NameObjectCollectionBase - коллекции пар строка-объект. Строка определяет публичное имя модуля, а объект представ-ляет экземпляр модуля. Для доступа к модулю, управляющему состоянием сеанса, используется такой код: SessionStateModule sess = app.Modules["Session"]; sess.Start += new EventHandler(OnSessionStart); Как упоминалось выше, события, генерируемые модулями HTTP, можно обраба-тывать в файле global.asax, присваивая обработчикам имена, соответствующие согла-шению ИмяМодуля_ИмяСобытия. Имя модуля - это одна из установок, задаваемых при регистрации модуля HTTP.
Обработчики и модули HTTP Глава 2 77 Обновление страницы Рассмотрим ситуацию, когда наличие возможности отфильтровать запрос до того, как он поступит обработчику HTTP, позволяет реализовать функцию, которую иначе реализовать просто невозможно. У механизма возврата формы имеется один сущес-твенный недостаток: если пользователь обновляет текущую страницу, то при этом всегда повторяется действие, совершенное на сервере последним. Если в результате выполнения предыдущей операции возврата формы в базу данных была добавлена новая запись, в следующий раз приложение попытается вставить идентичную запись, в результате чего будет сгенерировано исключение. Этот эффект существовал в Web-программировании изначально, он появился отнюдь не в ASP.NET. Для реализации неповторяемых действий необходимы некоторые контрмеры - критические серверные операции должны быть реализованы как идемпотентные. В алгебре идемпотентной называется операция, результат которой не меняется, сколько бы раз ее ни выполняли. Для примера рассмотрим следующую SQL-команду: DELETE FROM employees WHERE employeeid=9 Вы можете выполнить ее хоть 1000 раз подряд, но только одна запись будет удале-на из базы данных - та, которая соответствует критерию, заданному в предложении WHERE. Теперь возьмем такую команду: INSERT INTO employees VALUES (...) При каждом ее выполнении в базу данных будет добавляться новая запись - по крайней мере при условии, что таблица вовсе не имеет уникальных столбцов либо что они содержат ключи, генерируемые автоматически. В том же случае, когда структура таблицы требует наличия уникального явно задаваемого ключа, при попытке повтор-ного выполнения данной команды будет сгенерировано исключение SQL. Хотя рассмотренный нами сценарий обычно реализуется на уровне доступа к дан-ным, он иллюстрирует общую проблему большинства Web-приложений. Поэтому остается открытым вопрос: как определить, были ли данные страницы возвращены в результате явного действия пользователя или просто потому, что он нажал F5 либо щелкнул кнопку обновления страницы на панели инструментов? Что стоит за таким способом обновления страницы Обновление страницы - это внутренняя операция браузера, и он не генерирует о ней никаких внешних уведомлений, ни в форме событий, ни в форме обратных вызовов. Говоря техническим языком, данная операция есть не что иное, как повторение пос-леднего запроса. Браузер кэширует последний выполненный им запрос и в ответ на команду пользователя обновить страницу повторно направляет этот запрос серверу. Ни один из известных мне браузеров не уведомляет сервер о том, что производится обновление страницы, но даже если таковой имеется, подобное поведение не является стандартным. Таким образом, у серверного кода (ASP.NET, классического ASP или DLL ISAPI) нет никакой возможности отличить запрос обновления от обычного запроса страницы или возврата формы. Для того чтобы помочь ASP.NET правильно обновлять страницы, необходимо разработать механизм, делающий два идентичных запроса различными. Все известные браузеры реализуют обновление страницы как повторную отправку последнего HTTP-запроса. Чтобы копия отличалась от оригинала, специальный сер-вис должен добавлять дополнительные параметры, а страница ASP.NET должна их распознавать.
78 Часть I Внутренние механизмы ASP.NET Предлагаю ввести дополнительные требования. Решение не должно полагаться на состояние сеанса и не должно использовать много серверной памяти. Обзор решения В основу решения данной задачи положена следующая идея: каждому запросу на-значается числовой маркер, и модуль HTTP отслеживает маркеры запросов страниц. Если маркер текущего запроса меньше, чем маркер предыдущего, это может означать только одно: такой запрос уже выполнялся, а значит, имеет место обновление страни-цы. Компонентами решения являются модуль HTTP, выполняющий предварительную проверку номеров маркеров, и пользовательский класс страницы, автоматически гене-рирующий маркер для запрошенной страницы. Для реализации решения необходимо, во-первых, зарегистрировать модуль HTTP, а во-вторых, модифицировать базовый класс отделенного кода каждой страницы приложения. Модуль HTTP располагается в центре исполняющей среды HTTP и проверя-ет каждый запрос ресурсов данного приложения. Когда страница запрашивается в первый раз (не при возврате формы), маркера она еще не имеет. Модуль HTTP генерирует для нее маркер и сохраняет его в коллекции Items объекта HttpContext. Кроме того, модуль инициализирует нулем внутренний счетчик, в котором хранится маркер последней обработанной страницы. После этого при каждом новом запросе страницы модуль сравнивает значение счетчика с маркером страницы. Если маркер новее, запрос считается обычным возвратом формы. В противном случае он интер-претируется как обновление страницы. В табл. 2-6 перечислены возможные сценарии и соответствующие им действия. Табл. 2-6. Сценарии и действия Сценарий Действие Страница не имеет маркера Не обновление Счетчик последнего маркера устанавливается в 0. Генерируется маркер, который будет использован для следующего запроса текущей страницы, и сохраняется в коллекции Items Страница имеет маркер Имеет место обновление страницы, если ее маркер меньше последнего присвоенного Счетчику последнего маркера присваивается маркер, связанный со страницей. Генерируется маркер, который будет использован для следующего запроса текущей страницы, и сохраняется в коллекции Items Для того чтобы каждый запрос, за исключением первого, получал правильный маркер, требуется некоторая помощь со стороны класса страницы, для чего мы мо-дифицируем класс ее отделенного кода. Класс страницы получает от модуля HTTP очередной маркер и сохраняет его в скрытом поле, путешествующем вместе со стра-ницей, а также получает информацию о том, является ли данный запрос запросом на обновление. В качестве дополнительного сервиса класс отделенного кода предостав-ляет булево свойство IsRefreshed, чтобы разработчик мог узнать, чем является запрос страницы - обновлением или обычным возвратом формы. Внимание! Благодаря коллекции Items класса HttpContext модули HTTP могут передавать информацию страницам, а также обработчикам HTTP, ответственным за непосредственное выполнение запроса. Модуль HTTP, который мы здесь реализуем, добавляет в коллекцию Items два элемента. Один из них содержит информацию для страницы о том, является ли текущий запрос запросом на обновление; второй содержит следующий маркер страницы. Запрограммировав модуль таким образом, чтобы он передавал странице следующий мар кер, мы тем самым упростили класс страницы, перенеся основную нагрузку на модуль HTTP.
Обработчики и модули HTTP Глава 2 79 Реализация решения В описанном мною решении осталось несколько открытых вопросов. Во-первых, где лучше сохранять информацию о состоянии, которая нам необходима? Во-вторых, как модуль HTTP будет различать запросы одной и той же страницы от одного и того же клиента, если он вызываться для каждого входящего запроса? Как передавать информацию этой странице? Насколько интеллектуальной она должна быть? Очевидно, что на каждый из вопросов вы можете ответить иначе, чем это сделал я в данном примере. Могу лишь сказать, что мне не известны коммерческие продукты или библиотеки, решающие описанную здесь проблему. За последние годы я написал несколько статей на эту тему и разговаривал с разными группами пользователей. Предлагаемая ниже версия кода вобрала в себя наиболее ценные предложения из всех собранных мною. Одно из них, как уже было сказано, заключалось в том, чтобы переместить как можно больше кода в модуль HTTP. Итак, вот код, реализующий модуль HTTP: public class RefreshModule : IHttpModule { public void Init(HttpApplication app) { app.BeginRequest += new EventHandler(OnAcquireRequestState); } public void Dispose() { } void OnAcquireRequestState(object sender, EventArgs e) { HttpApplication app = (HttpApplication) sender; HttpContext ctx = app.Context; RefreshAction.Check(ctx); return; } } Модуль перехватывает событие BeginRequest и завершается вызовом метода Check вспомогательного класса RefreshAction. public class RefreshAction { static Hashtable requestHistory = null; //Здесь определяются другие строковые константы public static void Check(HttpContext ctx) { //Инициализация слота маркеров EnsureRefreshTicket(ctx); //Считываем из Session маркер последнего запроса, //полученного за данный сеанс int lastTicket = GetLastRefreshTicket(ctx); //Считываем из скрытого поля маркер текущего запроса int thisTicket = GetCurrentRefreshTicket(ctx, lastTicket); //Сравниваем маркеры if (thisTicket > lastTicket ||
80 Часть I Внутренние механизмы ASP.NET (thisTicket==lastTicket && thisTicket==0)) { UpdateLastRefreshTicket(ctx, thisTicket); ctx.Items[PageRefreshEntry] = false; } else ctx.Items[PageRefreshEntry] = true; } //Инициализирует внутренний источник данных static void EnsureRefreshTicket(HttpContext ctx) { if (requestHistory == null) requestHistory = new Hashtable(); } //Возвращает маркер последнего выполненного запроса с данным URL static int GetLastRefreshTicket(HttpContext ctx) { //Извлекаем и возвращаем последний маркер if (!requestHistory.ContainsKey(ctx.Request.Path)) return 0; else return (int) requestHistory[ctx.Request.Path]; } //Возвращает маркер, ассоциированный со страницей static int GetCurrentRefreshTicket(HttpContext ctx, int lastTicket) { int ticket; object o = ctx.Request[CurrentRefreshTicketEntry]; if (o == null) ticket = lastTicket; else ticket = Convert.ToInt32(o); ctx.Items[RefreshAction.NextPageTicketEntry] = ticket + 1; return ticket; } //Сохраняет маркер последнего выполненного запроса с данным URL static void UpdateLastRefreshTicket(HttpContext ctx, int ticket) { requestHistory[ctx.Request.Path] = ticket; } } Примечание Для установки маркера последнего выполненного запроса используется свойство Item, а не метод Add, потому что Item перезаписывает существующие элементы. Если элемент уже присутствует в коллекции, метод Add ничего не делает. Помимо модуля HTTP вам необходимо создать класс страницы, который будет использоваться в качестве базового для страниц, которым требуется идентифициро-вать операции обновления. Вот код этого класса: //Поместите его в пользовательское пространство имен public class Page : System.Web.UI.Page
Обработчики и модули HTTP Глава 2 81 { public bool IsRefreshed { get { HttpContext ctx = HttpContext.Current; object o = ctx.Items[RefreshAction.PageRefreshEntry]; if (o == null) return false; return (bool) o; } } //Обработчик события PreRenderComplete protected override void OnPreRenderComplete(EventArgs e) { base.OnPreRenderComplete(e); SaveRefreshState(); } //Создает скрытое поле для хранения маркера текущего запроса private void SaveRefreshState() { HttpContext ctx = HttpContext.Current; int ticket = (int) ctx.Items[RefreshAction.NextPageTicketEntry]; ClientScript.RegisterHiddenField( RefreshAction.CurrentRefreshTicketEntry, ticket.ToString()); } } В классе страницы из нашего примера определено новое открытое булево свойство IsRefreshed, которое вы можете использовать в своем коде подобно свойствам IsPostBack и IsCallback. Кроме того, в этом классе переопределяется обработчик OnPreRenderComplete - теперь он добавляет на страницу скрытое поле для хранения маркера запроса. Как уже упоминалось, этот маркер страница получает от модуля HTTP, который хранит его в специально предназначенном для этой цели элементе (с произвольным именем) коллекции Items. На рис. 2-8 наше решение показано в действии. Рассмотрим исходный код стра-ницы, продемонстрированной в качестве примера. public partial class TestRefresh : ProAspNet20.CS.Components.Page { protected void AddContactButton_Click(object sender, EventArgs e) { Msg.InnerText = "Added"; if (!this.IsRefreshed) AddRecord(FName.Text, LName.Text); else Msg.InnerText = "Page refreshed"; BindData(); } } Обратившись к свойству IsRefreshed, вы получаете информацию, позволяющую решить, что делать в ответ на полученный запрос возврата формы. В приведенном коде метод AddRecord не вызывается в том случае, если пользователь просто обновил страницу. Нет нужды говорить, что свойство IsRefreshed имеется только у страниц, 
82 Часть I Внутренние механизмы ASP.NET создаваемых на основе приведенного здесь пользовательского класса. Этот класс до-полнен не только новым свойством, но и кодом, добавляющим на страницу скрытое поле, являющееся одним из ключевых звеньев нашего механизма. Рис. 2-8. Страница не повторяет операцию, когда пользователь обновляет ее в окне браузера Заключение Обработчики и модули HTTP - это строительные блоки платформы ASP.NET. В ее состав входит несколько предопределенных обработчиков и модулей HTTP, но вы можете писать и то и другое самостоятельно. Обработчики быстрее обычных веб-страниц и могут применяться в любых ситуациях, не требующих использования логики управления состоянием и обработки событий возврата формы. Например, для динамического генерирования изображений на сервере обработчик HTTP подходит лучше страницы. Все, что происходит за сценой исполняющей среды ASP.NET, делается при участии обработчиков HTTP. Когда вы вызываете Web-страницу или метод Web-сервиса, в иг-ру вступает соответствующий обработчик, обслуживающий ваш запрос. На высшем уровне абстракции поведение обработчика HTTP очень напоминает поведение рас-ширения ISAPI. Но между ними имеется одно существенное различие: обработчики HTTP являются компонентами .NET, а следовательно, выполняются общеязыковой средой и ей подконтрольны. Хостинг для CLR, в свою очередь, предоставляет рабочий процесс. Расширение ISAPI, с другой стороны, является библиотекой Win32, которая может существовать внутри процесса IIS. В модели процесса ASP.NET компонент aspnet_isapi является настоящим расширением ISAPI, он реализует модель расши-рения ISAPI-типа, в которой обработчики HTTP играют роль расширений ISAPI в мире IIS. Данная модель изменится в IIS 7.0, где управляемые модули и расширения HTTP будут распознаваться и средой IIS. Модули HTTP являются для фильтров ISAPI тем же, чем обработчики HTTP для ISAPI-расширений, они идеально подходят для выполнения многих низкоуровневых задач, требующих тесной интеграции и взаимодействия по принципу "запрос-ответ". Модули являются своего рода перехватчиками, стоящими на пути следования пакета HTTP от Web-сервера к исполняющей среде ASP.NET и в обратном направлении. Наконец, модули HTTP обладают возможностью чтения и записи, способны филь-тровать и модифицировать содержимое как входящих, так и исходящих запросов.
Обработчики и модули HTTP Глава 2 83 В этой и предыдущей главах мы не раз упоминали о конфигурационных файлах. Пожалуй, самое время подробнее рассмотреть файл web.config и его довольно богатую схему. Именно это станет темой следующей главы. Только факты Обработчики и модули HTTP похожи на классические расширения и фильтры ISAPI, но являются управляемыми компонентами и реализуют более простую и менее подверженную ошибкам программную модель. Обработчик HTTP - это компонент ASP.NET, ответственный за выполнение за-проса. А страница ASP.NET - это, в конечном счете, не что иное, как экземпляр обработчика HTTP. Обработчики HTTP суть классы, реализующие интерфейс IHttpHandler и отвеча-ющие за выполнение запроса. Модули HTTP - это классы, реализующие интерфейс IHttpModule и обрабатыва-ющие события уровня приложения. Каждый пользовательский обработчик или модуль HTTP необходимо зарегистри-ровать в файле web.config, областью действия которого является одно приложение или весь сервер. 
Глава 3 Конфигурация ASP.NET В Microsoft .NET Framework параметры системы хранятся в файлах формата XML, и в таких же файлах предлагается хранить параметры приложений. Для этой цели в системе определена универсальная и весьма богатая конфигурационная схема. А по-скольку в распоряжение разработчиков предоставлен основанный на этой схеме API для доступа к конфигурационным файлам, ею пользуются все разработчики, не же-лающие самостоятельно программировать соответствующие операции, и, таким об-разом, данную схему можно считать стандартной. В соответствии с указанной схемой конфигурация приложения имеет иерархическую структуру - ASP.NET обеспечивает возможность наследования и переопределения установок на нескольких уровнях: компьютера, приложения или отдельного его каталога. Конфигурационные файлы обычно создаются в автономном режиме, причем, как правило, еще в процессе разработки приложения. Они развертываются вместе с при-ложением и в любое время могут быть изменены администраторами. Изменения в этих критичных для приложения файлах отслеживаются исполняющей средой ASP.NET, и происходит автоматическая перекомпиляция всех страниц, затронутых этими из-менениями. Страницы ASP.NET могут пользоваться классами из пространства имен System.Configuration для чтения конфигурационных файлов, а в ASP.NET 2.0 - также и для их записи. Данная глава посвящена исследованию конфигурационного механизма ASP.NET. Мы обсудим процесс настройки исполняющей среды ASP.NET и рассмотрим весь комплекс установок, задаваемых для отдельных приложений. Конфигурационная иерархия ASP.NET Конфигурационные файлы - это обычные XML-файлы, строго соответствующие за-данной схеме. Cхема определяет полный перечень установок, которые могут задаваться в файлах конфигурации компьютера, системы безопасности и приложения. Корневым узлом любого конфигурационного файла является узел <configuration> . В остальном содержимое файла зависит от его назначения и хранящейся в нем информации. Конфигурационная информация в ASP.NET, как уже было сказано, имеет иерархи-ческую структуру. Одна ее часть хранится в файле machine.config, расположенном на верхнем уровне иерархии и содержащем информацию, относящуюся к компьютеру в целом, другая - в файлах web.config, которые служат узлами иерархического дерева; заданные в них установки в зависимости от местонахождения этих файлов относятся ко всем установленным на данном компьютере приложениям ASP.NET, отдельному приложению или группе его страниц, хранящихся в одной папке. С помощью установок, задаваемых в файлах machine.config и web.config, можно де-кларативно ограничивать доступ к определенным папкам и управлять функциониро-ванием системы и приложений. Для примера ниже приведен текст файла web.config. 
Конфигурация ASP.NET Глава 3 85 Заданные в нем установки запрещают доступ к папке, в которой находится этот файл, всем пользователям, кроме администратора: <configuration> <system.web> <authorization> <allow users="YourDomain\Administrator" /> <deny users="*" /> </authorization> </system.web> </configuration> Чтобы применить те же ограничения к другой папке, достаточно добавить в ее файл web.config строки, выделенные полужирным шрифтом. Внимание! ASP.NET защищает конфигурационные файлы от прямого доступа через Web, предписывая IIS блокировать попытки доступа браузеров к этим файлам. Браузер, запросивший файл .config (то есть указавший его URL), получает сообщение об ошибке "HTTP access 403 Forbidden". Интересно, что данный запрет реализуется посредством специального обработчика, рассмотренным в предыдущей главе способом. Конфигурационные файлы Синтаксис файлов web. config и machine.config одинаков - оба они являются XML-файлами и базируются на одной и той же схеме. Исполняющая среда ASP.NET обра-батывает конфигурационную информацию иерархически, начиная от корня, являю-щегося общим для всех приложений компьютера, - файла machine.config. Спускаясь затем вниз по дереву конфигурации, она находит файлы web.config, размещенные в различных папках конкретных приложений. Примечание Файл machine.config расположен в инсталляционной папке ASP.NET; путь к нему следующий: %Windows%\Microsoft.NET\Framework\[версия]\CONFIG. Заглянув в ука-зан ную папку, вы обнаружите там три похожих файла: machine.config, machine.config.de fault и machine.config.comments. Последние два помещены туда с учебной целью - в них со держатся описания конфигурационных разделов и указаны значения их атрибутов по умол чанию. Для повышения производительности из файла machine.config удалено все лиш нее: в нем содержатся лишь те установки, которые отличаются от используемых по умолчанию. Дерево конфигурационных файлов Когда приложение ASP.NET начинает свою работу, всем конфигурационным пара-метрам присваиваются значения по умолчанию, заданные в файле machine.config. Эти установки могут быть переопределены в первую очередь в файле web.config, расположенном в корневой папке приложения. Разрешается также добавлять в файл web.config новые параметры, которые являются специфическими для приложения. Теоретически в файле web.config можно с помощью специальных инструкций удалить все установки исходной конфигурации компьютера и заменить их новыми. Однако на практике необходимость полного переконфигурирования ASP.NET для отдельного приложения возникает редко. Есть у вас также возможность создать дополнительные файлы web.config и по-местить их в любые из вложенных папок приложения. Содержащиеся в таком файле установки будут применены ко всем ресурсам, хранящимся в его папке и всех ее под-папках любого уровня вложенности. На рис. 3-1 показано, как ASP.NET обрабатывает установки системы и приложений для каждой страницы сайта.
86 Часть I Внутренние механизмы ASP.NET Рис. 3-1. Иерархическая структура конфигурационной информации ASP.NET Конфигурирование файла machine.config - административная задача, которая должна выполняться на сервере в автономном режиме при развертывании прило-жения или в ходе очередной процедуры обслуживания. Приложениям необходима возможность чтения из файлов web.config - их собственного хранилища конфигу-рационной информации. Из этих файлов приложение считывает такие данные, как строки подключения к базам данных, URL элементов пользовательского интерфейса, а также сведения о том, какие компоненты программного обеспечения должны быть активизированы, и какие - деактивизированы. Внимание! В ASP.NET 2.0 к иерархии, представленной на рис. 3-1, добавлен еще один уровень - файл web.config всего сайта. Этот файл находится в той же папке, что и machine.config. При обработке обоих файлов их содержимое объединяется. Таким обра-зом, вам просто предоставляется возможность разделить содержимое machine.config на две части. Попробуйте использовать данный файл web.config для хранения глобальных установок сайта. Чтение и запись конфигурационных файлов Запись информации в файлы machine.config и web.config из приложения производит-ся в редчайших случаях. Когда требуется сохранить на сервере некоторые данные, 
Конфигурация ASP.NET Глава 3 87 например пользовательский профиль, лучше применить API для работы с пользова-тельскими профилями и провайдер профилей. Если все же существует необходимость записи в конфигурационные файлы, это, скорее всего, означает, что приложение спроек тировано неудачно. Примечание За дополнительной информацией об API, предназначенном для работы с пользовательскими профилями обратитесь к главе 5 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). В следующей главе настоящей книги мы рассмотрим пользовательские провайдеры и еще раз обратимся к теме пользова-тельских профилей. В ASP.NET версии 2.0 появился полноценный API ввода-вывода для работы с кон-фигурационными файлами. В его состав входит набор классов, представляющих все разделы и узлы конфигурационной схемы и содержащих методы для их чтения и записи. Система отслеживает изменения, вносимые в файлы web.config, и делает не действи-тель ными все динамические сборки приложения, на которые распространяется дей-ствие измененного файла. При очередном обращении к соответствующим страницам происходит их перекомпиляция с учетом изменений конфигурации. Так, если вы модифицируете файл web.config, областью действия которого является весь сайт, все страницы всех приложений будут перекомпилированы. Очевидно, что частая перекомпиляция отрицательно сказывается на производи-тельности сайта, в особенности если он достаточно велик. По этой причине для дан-ных пользовательских профилей - наиболее часто используемых данных из тех, что требуют постоянного хранения, - необходим собственный сервис хранения, каковым и является упомянутый выше провайдер профилей. Конфигурационная схема Как уже упоминалось, корневым элементом всех конфигурационных файлов является элемент <configuration>. В табл. 3-1 перечислены важнейшие его дочерние элементы первого уровня. Каждый из них, в свою очередь, также имеет дочерние элементы, со-ставляющие группу однотипных установок. Например, элемент <system.web> может содержать тэг <authorization>, предназначенный для хранения информации о поль-зователях, которым разрешен доступ к приложению ASP.NET. Табл. 3-1. Важнейшие дочерние элементы узла <configuration> Раздел Содержимое <appSettings> Пользовательские параметры приложения <configSections> Конфигурационные разделы, предназначенные для пользователь-ских установок. Если данный элемент присутствует, он должен быть первым дочерним элементом узла <configuration> <connectionStrings> Список предопределенных строк подключения, предназначенных для использования приложением. В ASP.NET 1.x данный раздел не поддерживается <configProtectedData> Зашифрованные данные из зашифрованных разделов. В ASP.NET 1.x данный раздел не поддерживается <runtime> Установки времени выполнения; с их помощью конфигурируется процесс связывания сборок и такие функции времени выполнения, как зондирование и переадресация сборки (см. след. стр.)
88 Часть I Внутренние механизмы ASP.NET Раздел Содержимое <startup> Инициализационные установки; определяют, какую версию CLR следует использовать <system.diagnostics> Элементы, задающие ключи трассировки и определяющие компо-ненты-слушатели, которые собирают, сохраняют и маршрутизиру-ют сообщения <system.net> Сетевые установки; указывают, как .NET Framework должна подключаться к Интернету, в том числе задают прокси-сервер, используемый по умолчанию, модули аутентификации и параметры подключения <system.runtime.remoting> Установки .NET remoting; конфигурируют клиентское и серверное приложения, в которых используется технология .NET remoting <system.web> Специфические для ASP.NET установки, управляющие всеми аспектами поведения приложения ASP.NET Поскольку нас интересуют приложения ASP.NET, наиболее подробно мы рас-смот рим раздел <system.web> , а также изучим разделы <connectionStrings> и <config-ProtectedData>. Но хотя эти разделы представляют для разработчика приложений ASP.NET, время от времени вы будете обращаться и к другим разделам конфигура-ционных файлов. Например, подразделами из <configSections> вы будете пользоваться для груп-пировки информации, размещенной в оставшейся части документа. Если для вашего приложения потребуются пользовательские конфигурационные разделы, вы размес-тите их в разделе <appSettings>, предварительно определив их структуру в разделе <configSections>. С разделом <system.diagnostics> вам придется иметь дело в случае применения пользовательского слушателя трассировки (trace listener), записывающего результаты своей работы в файл, определяемый приложением. Узел <runtime> исполь-зуется в ситуациях, когда необходимо задать особые правила зондирования сборок. Если же ваше приложение ASP.NET осуществляет вызовы удаленных компонентов, вам придется модифицировать содержимое раздела <system.runtime.remoting>. Разделы и их группы Разделы конфигурационного файла должны объявляться в разделе <configSections>. В следующем примере продемонстрировано, как объявляется раздел <system.web> в файле machine.config: <configSections> <sectionGroup name="system.web" type="System.Web.Configuration.SystemWebSectionGroup, ..."> <section name="authentication" type="System.Web.Configuration.AuthenticationSection, ..." allowDefinition="MachineToApplication" /> </sectionGroup> </configSections> У элемента <sectionGroup> единственное назначение - сгруппировать несколько дочерних разделов, создав для них нечто вроде пространства имен: в каждой груп-пе имена разделов должны быть уникальными, но в разных группах они могут сов-падать. Элемент <section> имеет два атрибута: name и type. В первом задается имя объяв ляемого раздела, а во втором - имя управляемого класса, который считывает Табл. 3-1. (окончание)
Конфигурация ASP.NET Глава 3 89 данный раздел из конфигурационного файла и выполняет разбор его содержимого. Значением атрибута type является строка с разделенными запятой именем класса и полным именем содержащей его сборки. Кроме того, у элемента <section> есть два необязательных атрибута: allowDefinition и allowLocation. В атрибуте allowDefinition задаются конфигурационные файлы, в которых будет использоваться данный раздел. Допустимые значения этого атрибута перечислены в табл. 3-2. Табл. 3-2. Значения атрибута allowDefinition Значение Описание Everywhere Данный раздел может использоваться в любом конфигурационном файле (значение по умолчанию) MachineOnly Раздел может использоваться только в файле machine.config MachineToApplication Допускается использование раздела в файле machine.config и в файле web.config, принадлежащем приложению, но не в файлах web.config, находящихся в подкаталогах виртуального каталога приложения Атрибут allowLocation определяет, может ли раздел располагаться внутри раздела <location>. Раздел <location> файла machine.config позволяет применять заданные установки уровня компьютера только к ресурсам, путь к которому в нем определен. (Подробнее о разделе <location> речь пойдет чуть ниже.) Для многих разделов конфигурационных файлов определены три стандартных элемента - <add>, <remove> и <clear>. Вам они уже знакомы: первый добавляет в раздел новую установку, второй удаляет заданную установку, а третий удаляет все установки, заданные ранее в этом разделе. Чаще всего элементы <remove> и <clear> используют при работе с иерархией конфигурационных файлов. Например, с помо-щью эле мента <remove> дочернего файла web.config удаляют установки, определен-ные на более высоком уровне иерархии. Элементы <remove> и <clear> не влияют на реальные данные, хранящиеся в кон-фигурационном файле. При удалении раздела соответствующие данные из файла не удаляются - они стираются лишь в дереве установок, которое ASP.NET строит для приложения в памяти. Примечание Разделы являются необходимым синтаксическим элементом конфигураци-онных файлов. Однако нет нужды объявлять разделы во всех файлах web.config своего приложения. При обработке конфигурационных файлов ASP.NET строит конфигурационное де рево, начиная с корневого файла machine.config. Поскольку все стандартные разделы уже объявлены в файле machine.config, устанавливаемом вместе с .NET Framework, до-статочно объявить только пользовательские разделы вашего приложения. Имейте в виду, что в тех случаях, когда объявление раздела отсутствует в <configSections> или структура раздела не соответствует его объявлению, выбрасывается исключение. Начнем исследование конфигурационной схемы с изучения раздела <location>. Раздел <location> Раздел <location> используется в двух различных ситуациях, но с одной и той же целью. Он дает возможность применять к разным частям приложения различ-ные установки. Как правило, с его помощью назначают индивидуальные установ-ки либо подкаталогам приложения, либо приложениям, установленным на одном компьютере. Так, раздел <location> файла web.config, находящегося в корневом каталоге прило-жения, позволяет назначить индивидуальные установки подкаталогам этого каталога. 
90 Часть I Внутренние механизмы ASP.NET Вместо того чтобы создавать дочерние файлы web.config, вы можете ограничиться одним таким файлом в корневом каталоге и в нем задать установки для каждого из подкаталогов. Одноименный раздел файла machine.config или web.config, находящегося в корне-вом каталоге сайта, позволяет задавать индивидуальные установки конфигурирова-ния компьютера для каждого из приложений. Внимание! Обратите внимание на различие между файлом web.config из корневого каталога приложения и одноименным файлом из корневого каталога сайта. Первый ис-пользуется для адаптации параметров ASP.NET к нуждам конкретного приложения, тогда как второй представляет собой нечто вроде приложения к файлу machine.config из того же каталога, и его можно рассматривать как дополнительный уровень персонализации параметров. Раздел <location>, определенный в этом втором файле, может быть связан с любым приложением, установленным на компьютере; при отсутствии атрибута path установки из данного раздела применяются ко всем имеющимся приложениям. Централизованное конфигурирование У раздела <location> два атрибута: path и allowOverride. Атрибут path представляет виртуальный путь, к которому применяются установки данного раздела. В следую-щем примере показано, как он действует. Приведенный код взят из файла web.config. Обратите внимание: имя папки должно быть относительным и не должно начинаться с прямой или обратной косой черты либо точки. <configuration> <system.web> <!--Здесь располагаются установки, заданные для конкретного приложения. --> </system.web> <location path="Reserved"> <system.web> <!--Здесь располагаются установки, заданные для папки /Reserved. --> </system.web> </location> </configuration> Особенность описанного подхода состоит в том, что у вас имеется единственный, файл web.config, обеспечивающий централизованное хранение установок, но при этом вы можете конфигурировать каждый подкаталог отдельно. Отсутствие необходимости поддерживать несколько файлов web.config является безусловным преимуществом, однако данный подход имеет и неприятные побочные эффекты, которые со време-нем могут стать довольно ощутимыми. В частности, при любом изменении единого конфигурационного файла происходит перекомпиляция всех страниц приложения; если же файлов web.config несколько, компилируются только те страницы, которых коснулись изменения. Примечание Когда у раздела <location> отсутствует атрибут path, заданные в нем уста-новки применяются ко всем вложенным папкам приложения либо ко всем установленным приложениям - в зависимости от того, где находится данный раздел: в файле web.config корневого каталога приложения или в файле web.config либо machine.config корневого каталога сайта. Глобальные установки компьютера Если вы хотите централизованно хранить индивидуальные установки каждого из работающих на сервере приложений, разместите соответствующие разделы <location> в файле machine.config или machine.config, находящемся в корневом каталоге сайта. 
Конфигурация ASP.NET Глава 3 91 Имени конфигурируемого приложения, задаваемому в атрибуте path, должно предшес-твовать имя сайта (как оно определено в IIS), которое вы можете узнать, заглянув в IIS Manager. Ниже приведен сценарий, ассоциированный с приложением ProAspNet20, которое функционирует на используемом по умолчанию Web-сайте (рис. 3-2). <location path="Default Web Site/ProAspNet20"> <system.web> <!--Здесь располагаются установки Web-сайта --> </system.web> </location> Рис. 3-2. Используемый по умолчанию Web-сайт на сервере, работающем под управлением IIS Разработка приложения ASP.NET обычно осуществляется не на эксплуатационном, а на рабочем компьютере, где имеются собственные копии файлов machine.config и web.config сайта. Однако, развернув приложение на эксплуатационном сервере, вы, скорее всего, не сможете в точности воспроизвести на нем установки рабочего ком-пьютера. В частности, если этот сервер принадлежит провайдеру интернет-услуг, то последний, скорее всего, откажется модифицировать текущие параметры сайта, руководствуясь соображениями безопасности, а также тем, что новые настройки мо-гут не подойти для других установленных на сервере приложений. Но аналогичные ограничения может наложить и администратор сервера вашего предприятия. Никакой проблемы, однако, в этом нет - все необходимые глобальные установки можно поместить в файл web.config, расположенный в корневом каталоге приложения. Если же окажется, что провайдер или администратор вашего сайта заблокировал мно-гие элементы конфигурации, запретив их переопределение, создайте для приложения раздел <location> в файле machine.config или web.config. (О том, как осуществляется блокирование установок, я расскажу чуть позже.) По возможности старайтесь реплицировать необходимые изменения в файле web. config приложения, чтобы сделать приложение максимально самодостаточным. Регистрируя компоненты (скажем, провайдер HTTP) в разделе <location> файла machine.config, убедитесь, что используемая сборка строго именована и установлена в GAC. (О строго именованных сборках вкратце рассказывалось в главе 1.) В конфи-гурационном сценарии необходимо указать полное имя сборки. Ниже показано, как зарегистрировать в файле machine.config обработчик HTTP view.axd для приложения ProAspNet20. <location path="Default Web site/proaspnet20"> <system.web> <httpHandlers> <add verb="*" path="view.axd"
92 Часть I Внутренние механизмы ASP.NET type="ProAspNet20.CS.Components.PictureViewerHandler, ProAspCompLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=54943ebb40058fcb" /> </httpHandlers> </system.web> </location> Заметьте, что дополнительная информация в сильном имени может быть разной. Подробнее об обработчике view.axd рассказывалось в главе 2. Немодифицируемые установки Атрибут allowOverride раздела <location> позволяет блокировать определенные уста-новки на уровне компьютера или отдельного приложения. Поместив такие установки в раздел <location>, атрибут allowOverride которого установлен в false, вы предписываете конфигурационной системе ASP.NET генерировать исключение в случае попытки их изменения на более низком уровне иерархии конфигурационных файлов. <location path="Default Web Site/ProAspNet20" allowOverride="false"> <system.web> <!--These settings cannot be overridden --> </system.web> </location> Таким образом администраторы получают контроль над параметрами сервера, обеспечивающего хостинг для ASP.NET. Когда на производственный сервер устанав-ливается новое приложение, для его правильной работы нередко требуется внести изменения в конфигурацию этого сервера. Обновить файл machine.config нетрудно, если данное приложение на сервере единственное либо вы имеете возможность кон-фигурировать все остальные установленные на нем приложения. Однако если вы пользуетесь услугами платного хостинга приложений, администратор сервера может заблокировать некоторые глобальные установки, чтобы предотвратить их изменение приложениями, обеспечив таким образом целостность хост-среды и гарантировав всем приложениям одинаковые условия работы. Примечание По умолчанию в раздел <location> можно включать почти все предопре-деленные разделы, кроме <runtime>, <mscorlib>, <system.runtime.remoting> и <startup>. Однако вы можете запретить включение в раздел <location> любого раздела с помощью атрибута allowLocation. Это атрибут раздела <section>, определяющий возможность на-стройки раздела для конкретного пути. Установите его в false, и раздел нельзя будет использовать в разделе <location>. Раздел <system.web> В разделе <system.web> содержатся все конфигурационные элементы, управляющие исполняющей средой и поведением приложений ASP.NET. В табл. 3-3 перечислены все поддерживаемые элементы первого уровня и указано, на каких уровнях их можно переопределять. Табл. 3-3. Разделы, которые можно использовать в разделе <system.web> Раздел Уровни переопределения Содержимое <anonymousIdentification> Компьютер, приложение Правила идентификации неаутентифициро-ванных пользователей. В ASP.NET 1.x данный раздел не поддерживается <authentication> Компьютер, приложение Настройки механизма аутентификации
Конфигурация ASP.NET Глава 3 93 Раздел Уровни переопределения Содержимое <authorization> Везде Список авторизированных пользователей <browserCaps> Везде Список известных функций браузера <clientTarget> Везде Список предопределенных клиентов <compilation> Везде Параметры пакетной компиляции (см. главу 1) <customErrors> Компьютер, приложение Установки пользовательских страниц с сообщениями об ошибках <deployment> Везде Способ развертывания приложения. В ASP.NET 1.x данный раздел не поддержи-вается <deviceFilters> Везде Список известных функций мобильного брау-зера (см. главу 9). В ASP.NET 1.0 данный раздел не поддерживается <globalization> Везде Параметры локализации приложения <healthMonitoring> Компьютер, приложение Настройки приложения для мониторинга состояния. В ASP.NET 1.x данный раздел не поддерживается <hostingEnvironment> Компьютер, приложение Настройки поведения хост-среды приложения. В ASP.NET 1.x данный раздел не поддерживается <httpCookies> Везде Свойства cookie, используемых приложением ASP.NET. В ASP.NET 1.x данный раздел не поддерживается <httpHandlers> Везде Список зарегистрированных обработчиков HTTP (см. главу 2) <httpModules> Везде Список зарегистрированных модулей HTTP (см. главу 2) <httpRuntime> Везде Параметры исполняющей среды HTTP <identity> Везде Включение поддержки имперсонализации <machineKey> Везде Ключ шифрования для данных, требующих защиты <membership> Компьютер, приложение Параметры аутентификации пользователей через членство в ASP.NET. В ASP.NET 1.x данный раздел не поддерживается <mobileControls> Везде Список ориентированных на конкретные устройства адаптеров классов для элементов управления (см. главу 8). В ASP.NET 1.0 данный раздел не поддерживается <pages> Везде Функции элементов управления страниц ASP.NET <processModel> Компьютер Конфигурация модели процесса <profile> Компьютер, приложение Параметры модели данных пользовательского профиля. В ASP.NET 1.x данный раздел не поддерживается <protocols> Компьютер, приложение Протоколы, которые могут использоваться Web-сервисом ASP.NET. В ASP.NET 1.x данный раздел не поддерживается Табл. 3-3. (продолжение) (см. след. стр.)
94 Часть I Внутренние механизмы ASP.NET Раздел Уровни переопределения Содержимое <roleManager> Компьютер, приложение Параметры управления ролями. В ASP.NET 1.x данный раздел не поддерживается <securityPolicy> Компьютер, приложение Допустимые уровни доверия <sessionState> Компьютер, приложение Конфигурация объекта Session <siteMap> Компьютер, приложение Параметры поддержки навигационной инфраструктуры (см. главу 10). В ASP.NET 1.x данный раздел не поддерживается <trace> Везде Конфигурация системы трассировки <trust> Компьютер, приложение Уровень доверия по умолчанию <webControls> Везде Местоположение клиентских сценариев <webParts> Везде Параметры Web-разделов (см. главу 7). В ASP.NET 1.x данный раздел не поддерживается <webServices> Везде Конфигурация Web-сервисов <xhtmlConformance> Везде Параметры совместимости с XHTML. В ASP.NET 1.x данный раздел не поддерживается Для каждого из элементов, перечисленных в табл. 3-3, определена собственная схема, а также атрибуты и перечисления, используемые для извлечения значений. В дополнение к разделам, перечисленным в табл. 3-3, группа <system.web> содер-жит подгруппу с именем <Caching>. В табл. 3-4 описаны соответствующие дочерние элементы. Табл. 3-4. Разделы, которые могут присутствовать в разделе <Caching> Раздел Уровни переопределения Содержимое <cache> Компьютер, приложение Параметры глобального кэша для приложения ASP.NET. В ASP.NET 1.x данный раздел не поддерживается <outputCache> Компьютер, приложение Параметры выходного кэша для приложения ASP.NET. В ASP.NET 1.x данный раздел не поддерживается <outputCacheSettings> Компьютер, приложение Профили кэширования. В ASP.NET 1.x данный раздел не поддерживается <sqlCacheDependency> Компьютер, приложение Настройки зависимостей кэша SQL для прило-жения ASP.NET. В ASP.NET 1.x данный раздел не поддерживается Далее мы рассмотрим некоторые из перечисленных разделов. Полное описание содержимого раздела <system.web> вы найдете в документации MSDN. Примечание Некоторые из перечисленных в табл. 3-3 и 3-4 разделов подробно описы-ваются в других главах книги, поэтому здесь мы о них говорить не будем. Кроме того, отдельные разделы, такие как <sessionState>, <authentication> и <membership>, описаны в соответствующих главах моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Табл. 3-3. (окончание)
Конфигурация ASP.NET Глава 3 95 Раздел <anonymousIdentification> Анонимная идентификация - это новая функция ASP.NET, дающая возможность на-значить предопределенную учетную запись тем пользователям, которые подключились к приложению анонимно. Анонимная идентификация не имеет никакого отношения ни к анонимному пользователю, определяемому на уровне IIS, ни к механизму аутен-тификации ASP.NET. Данная функция разработана для программистов, использую-щих API пользовательского профиля, с целью упростить написание кода приложений, с которыми могут работать как аутентифицированные, так и неаутентифицированные пользователи. В разделе <anonymousIdentification> настраиваются параметры анонимной иден-тификации. Вот его общая схема: <anonymousIdentification enabled="[true | false]" cookieless="[UseUri | UseCookies | AutoDetect | UseDeviceProfile]" cookieName="" cookiePath="" cookieProtection="[None | Validation | Encryption | All]" cookieRequireSSL="[true | false]" cookieSlidingExpiration="[true | false]" cookieTimeout="[DD.HH:MM:SS]" domain="cookie domain" /> При анонимной идентификации создается билет - с использованием или без ис-пользования cookie, - который связывается с входящим запросом. Данная функция включается либо отключается посредством атрибута enabled. Атрибут cookieless инс-труктирует ASP.NET в отношении использования cookie; его допустимые значения описаны в табл. 3-5. Табл. 3-5. Допустимые значения атрибута cookieless Значение Описание AutoDetect Использовать cookie, если их поддержка в браузере включена. В противном случае прибегнуть к механизму, не требующему их использования UseCookie Всегда использовать cookie, независимо от возможностей браузера UseDeviceProfile Использовать cookie, если браузер их поддерживает, в противном случае прибегнуть к механизму, не требующему их использования. Когда задана эта установка, система не выясняет, включена ли поддержка cookie на самом деле. Данная установка активна по умолчанию UseUri Никогда не использовать cookie, независимо от возможностей и установок браузера Остальные атрибуты используются при условии, что cookie для текущего сеанса бу-дет создан. В них вы указываете имя cookie (по умолчанию это .ASPXANONYMOUS), путь, домен, способ защиты, срок службы и таймаут, а также то, следует ли исполь-зовать для передачи cookie протокол Secure Sockets Layer (SSL). Раздел <authentication> В разделе <authentication> можно сконфигурировать Web-сайт для различных ти-пов аутентификации пользователя - Forms, Microsoft Passport и аутентификации, 
96 Часть I Внутренние механизмы ASP.NET которой управляет IIS. Для данного раздела определены два взаимоисключающих подраздела - <forms> и <passport>, - а также атрибут mode, где задается режим аутен тификации, запрашиваемый приложением. Допустимые значения атрибута mode перечислены в табл. 3-6. Табл. 3-6. Поддерживаемые режимы аутентификации Значение Описание Forms Информация, необходимая для входа на сайт, вводится посредством пользовательской формы Passport Используется аутентификационный сервис Microsoft Passport None ASP.NET не должна производить аутентификацию, то есть имеет место одна из двух ситуаций: либо к приложению могут подключаться только аноним-ные пользователи, либо приложение имеет свой собственный встроенный механизм аутентификации Windows Используются аутентификационные сервисы IIS: basic, digest, NTLM\Kerberos либо certificates. Этот режим действует по умолчанию При использовании аутентификации Forms есть возможность задать несколько до-полнительных параметров, таких как name, loginURL, protection и cookieless. В табл. 3-7 перечислены атрибуты элемента <forms>. Табл. 3-7. Атрибуты элемента <forms> Атрибут Описание cookieless Определяет, следует ли хранить аутентификационные билеты в cookie, и как именно. Допустимые значения - те же, что перечислены в табл. 3-5. В ASP.NET 1.x данный атрибут не поддерживается defaultUrl URL, по которому следует перенаправить пользователя после аутентификации. По умолчанию это default.aspx. В ASP.NET 1.x данный атрибут не поддерживается domain Доменное имя для исходящих аутентификационных cookie. В ASP.NET 1.x данный атрибут не поддерживается enableCrossApp-Redirects Указывает, должен ли пользователь быть аутентфицирован внешним при-ложением, если аутентификация производится без использования cookie. Если cookie используются, данная установка игнорируется; при этом всегда возможна аутентификация, распространяющаяся на несколько приложений (cross-application authentication) loginUrl URL, по которому будет перенаправлен запрос подключения, если действительный аутентификационный cookie не найден name Имя cookie, используемого для аутентификации. По умолчанию это .ASPXAUTH path Путь к аутентификационным cookie, используемым приложением. Значение по умолчанию - косая черта (/). Заметьте, что некоторые браузеры чувствительны к регистру и не вернут вам cookie, если вы не зададите путь с точностью до регистра символов protection Указывает, как приложение будет защищать аутентификационные cookie. Допустимые значения: All, Encryption, Validation и None. Значение по умолчанию - All requireSSL Указывает, необходимо ли для передачи аутентификационного cookie SSL-подключение. Значение по умолчанию - false. Если данный атрибут имеет значение true, ASP.NET устанавливает свойство Secure аутентификационно-го объекта cookie таким образом, чтобы браузер не возвращал данный cookie при отсутствии SSL-соединения. В ASP.NET 1.0 не поддерживается
Конфигурация ASP.NET Глава 3 97 Атрибут Описание slidingExpiration Указывает, является ли срок службы cookie скользящим. По умолчанию имеет значение false, то есть срок службы cookie фиксирован и начинается с момента его первого использования. Этот срок задается в атрибуте timeout. В ASP.NET 1.0 данный атрибут не поддерживается timeout Задает время, в минутах, по истечении которого аутентификационный cookie считается устаревшим. Значение по умолчанию - 30 Заметьте, что описание атрибутов, относящихся к использованию cookie, приве-денное в табл. 3-7, применимо и к другим подобным атрибутам из раздела <anonymous-Identification>. Примечание Данный раздел подробно описан в главе 15 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Раздел <authorization> Раздел <authorization> используется для определения декларативного фильтра, уп-равляющего доступом к ресурсам приложения. В разделе <authorization> содержатся два подраздела с именами <allow> и <deny>, посредством которых можно разрешать или запрещать доступ отдельным пользователям. Оба элемента имеют три атрибу-та - users, roles и verbs, - которым присваиваются разделенные запятыми списки идентификаторов, как в следующем примере: <authorization> <allow users="разделенный запятыми список пользователей" roles="разделенный запятыми список ролей" verbs="разделенный запятыми список глаголов" /> <deny users="разделенный запятыми список пользователей" roles="разделенный запятыми список ролей" verbs="разделенный запятыми список глаголов" /> </authorization> Элемент <allow> авторизирует доступ пользователей, имена которых присутствуют в списке users, а также тех, которым назначена любая из ролей, заданных в списке roles. При этом авторизированным пользователям разрешено выполнять только глаголы HTTP (например, POST или GET), указанные в списке verbs. Что касается элемента <deny>, то он, напротив, запрещает перечисленным пользо-вателям выполнять заданные действия. По умолчанию всем пользователям открывается полный доступ к ресурсам приложения. При задании имени пользователя разрешается использовать два символа подстановки: звездочку (*), представляющую всех пользо-вателей, и вопросительный знак (?), представляющий анонимного пользователя. Примечание Данный раздел подробно описан в главе 15 моей книги "Programming Micro soft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Раздел <browserCaps> В разделе <browserCaps> перечисляются характеристики и возможности поддержи-ваемых браузеров, включая - в версии 1.1 .NET Framework - браузеры мобильных устройств. Раздел <browserCaps> тесно связан с классом HttpBrowserCapabilities, а в версии 1.1 также с классом MobileCapabilities, которые помогают исполняющей среде ASP.NET собирать техническую информацию о браузере, работающем на клиент-ском компьютере. Приложение ASP.NET идентифицирует браузер по свойству Browser Табл. 3-7. (окончание)
98 Часть I Внутренние механизмы ASP.NET внутреннего объекта Request. Данный объект вначале просматривает информацию из заголовка агента пользователя (user-agent), входящего в состав HTTP-запроса, а затем сопоставляет эту информацию с содержимым раздела <browserCaps>. Если соответствие найдено, создается экземпляр класса HttpBrowserCapabilities и заполня-ется имеющейся информацией. Затем приложению открывается доступ к созданному объекту через свойство Browser. В разделе <browserCaps> перечислено немалое количество коммерческих браузе ров с описанием их характеристик, таких как наличие поддержки cookie, таб лиц, фреймов и модели XML DOM, поддерживаемые языки сценариев и операцион ная система. Данный элемент может быть объявлен на любом уровне приложения, что позволяет определять требуемый уровень поддержки браузеров для каждого кон крет ного при-ложения. Список доступных браузеров можно обновлять, добавляя но вые брау зеры и корректируя параметры имеющихся, чтобы отразить их текущие воз мож ности. Внимание! Использование раздела <browserCaps> для определения браузеров считается в ASP.NET 2.0 устаревшим методом, хотя и полностью поддерживается. Информация из этого элемента объединяется с информацией из соответствующего файла .browser, расположенного в папке systemroot\Microsoft.NET\Framework\[версия]\CONFIG\Browsers, а также из файлов .browser, находящихся в папках App_Browsers уровня приложения. В "чистых" приложениях ASP.NET следует использовать только файлы .browser. Раздел <caching> В разделе <caching> для приложений ASP.NET задаются параметры кэширова-ния. Он содержит четыре дочерних раздела: cache, outputCache, outputCacheSettings и sqlCacheDependency. Первый из них, <cache>, содержит несколько базовых параметров кэширования. Его атрибуты percentagePhysicalMemoryUsedLimit и privateBytesLimit определяют мак-симальный объем памяти (в процентах и байтах), которая может быть занята, прежде чем начнется удаление из кэша устаревших данных. Ниже приведена схема указанно-го раздела со стандартными значениями. <cache disableMemoryCollection = "false" disableExpiration = "false" privateBytesLimit = "0" percentagePhysicalMemoryUsedLimit = "89" privateBytesPollTime = "00:02:00" /> По умолчанию интервал времени между периодически выполняемыми операция-ми анализа использования памяти составляет 2 мин. Заметьте, что, установив атрибут disableExpiration, вы можете отключить автоматическую сборку мусора - функцию кэша ASP.NET, являющуюся его характерной особенностью. В разделе <outputCache> задаются параметры кэширования страниц, называемого также кэшированием вывода (output caching). Вот его схема с используемыми по умолчанию значениями: <outputCache enableOutputCache = "true" enableFragmentCache = "true" sendCacheControlHeader = "true" omitVaryStar = "false"> </outputCache> Если кэширование страниц или кэширование фрагментов (fragment caching) деклара-тивно отключено, ни страницы, ни пользовательские элементы управления не кэширу-
Конфигурация ASP.NET Глава 3 99 ются, какими бы ни были программные установки. Атрибут sendCacheControlHeader указывает, должен ли модуль кэширования страниц по умолчанию отправлять в ответе браузеру заголовок cache-control:private; атрибут omitVaryStar включает и отключает отправку заголовка Vary: * . В разделе <outputCacheSettings> содержатся группы параметров кэширования, применяемых к страницам посредством директивы @OutputCache. Здесь имеется только один дочерний раздел - <outputCacheProfiles>, где определяются так назы-ваемые профили кэширования страниц (output cache profile), представляющие собой просто именованные группы установок. Вот пример: <outputCacheSettings> <outputCacheProfiles> <add name="ServerOnly" duration="60" varyByCustom="browser" /> </outputCacheProfiles> </outputCacheSettings> Профиль ServerOnly определяет, что страницу нужно кэшировать в течение 60 с и разрешает хранение разных версий страницы для браузеров разных типов. Вот пол-ная схема раздела <outputCacheProfiles>: <outputCacheProfiles> <add name = "" enabled = "true" duration = "-1" location = "" sqlDependency = "" varyByCustom = "" varyByControl = "" varyByHeader = "" varyByParam = "" noStore = "false"/> </outputCacheProfiles> Наконец, в разделе <sqlCacheDependency> содержатся параметры, используемые классом SqlCacheDependency при кэшировании информации из баз данных SQL Server 7.0 или SQL Server 2000. Данный класс реализует в ASP.NET 2.0 функцию за-висимости от базы данных - пользовательской зависимости, согласно которой кэ-шированные данные таблиц базы данных удаляются, когда в эти таблицы вносятся изменения. С определенной периодичностью он опрашивает таблицы, чтобы узнать, какие из них были изменены. <sqlCacheDependency enabled="true" pollTime="1000"> <databases> <add name="Northwind" connectionStringName="LocalNWind" /> </databases> </sqlCacheDependency> Атрибут pollTime задает период опроса (в миллисекундах). В приведенном примере таблицы, подлежащие мониторингу, должны опрашиваться каждую секунду. Ссылка на базу данных, подлежащую мониторингу, содержится в разделе <databases>. Его атрибут name - это не имя базы данных, а всего лишь имя зависимости. Базу данных, а точнее строку подключения к ней, идентифицирует атрибут connectionStringName, указывающий на запись из раздела <connectionStrings> файла web.config. Что касается 
100 Часть I Внутренние механизмы ASP.NET перечня подлежащих мониторингу таблиц, то он зависит от результата работы ути-литы aspnet_regsql.exe, о которой речь пойдет далее в этой главе. Установки, заданные в разделе <sqlCacheDependency>, не производят никакого эффекта, если вы используете класс SqlCacheDependency совместно с механизмом уведомления об изменении исходных данных запроса (query notifications) из SQL Server 2005. Раздел <clientTarget> В разделе <clientTarget> определяются псевдонимы тех агентов пользователей, ко-торые могут задаваться в свойстве ClientTarget как целевые для страниц ASP.NET. Иными словами, раздел <clientTarget> содержит допустимые значения свойства ClientTarget класса Page. По умолчанию определены следующие псевдонимы: ie5, ie4, uplevel и downlevel. Первые два соответствуют Internet Explorer 5.5 и Internet Explorer 4.0. Заметьте, что в ASP.NET под браузером высшего уровня (uplevel) подра-зумевается Internet Explorer 4.0 - первый браузер, поддерживающий динамический HTML, - а браузер низшего уровня (downlevel) в настоящее время не определен. <clientTarget> <add alias="ie5" userAgent="Mozilla/4.0 (compatible; MSIE 5.5; ...)"/> <add alias="ie4" userAgent="Mozilla/4.0 (compatible; MSIE 4.0; ...)"/> <add alias="uplevel" userAgent="Mozilla/4.0 (compatible; MSIE 4.0; ...)/> <add alias="downlevel" userAgent="Unknown"/> </clientTarget> Имейте в виду, что присвоение свойству ClientTarget одного из значений, перечис-ленных в разделе <clientTarget>, заставляет объект HttpBrowserCapabilities страницы возвращать информацию о возможностях заданного браузера, а не клиента, напра-вившего текущий запрос. Раздел <customErrors> В разделе <customErrors> для приложения ASP.NET определяется политика обра бо-т ки ошибок. По умолчанию когда на странице происходит ошибка, локальный хост видит стандартную страницу ASP.NET с детальной информацией об ошибке, а уда-ленный клиент - либо пользовательскую страницу с сообщением об ошибке, либо предопределенную страницу ASP.NET, если пользовательская страница не задана. Поведением ASP.NET в случае возникновения ошибки управляет атрибут Mode. Он может быть установлен в On, Off или RemoteOnly (значение по умолчанию). Если значением атрибута Mode является On, пользовательская страница с сообщением об ошибке выводится и локально, и удаленно; если же он имеет значения Off, никакая специализированная обработка ошибок не производится и все пользователи получают стандартную страницу с ASP.NET с сообщением об ошибке исполняющей среды или компилятора и данными трассировки стека. Есть два базовых способа уведомления об ошибках: используется одна универ-сальная страница или разрабатываются индивидуальные страницы для разных типов ошибок. Универсальная пользовательская страница с сообщением об ошибке задается в атрибуте defaultRedirect элемента <customErrors>. Данная установка игнорируется, если атрибут Mode установлен в Off. <customErrors defaultRedirect="Errors/appGenericErr.aspx" mode="On"> <error statusCode="404" redirect="Errors/notfound.aspx" /> <error statusCode="500" redirect="Errors/internal.aspx" /> </customErrors>
Конфигурация ASP.NET Глава 3 101 В разделе <customErrors> можно разместить необходимое количество дочерних элементов <error>, связав с их помощью пользовательские страницы с конкретными кодами ошибок. Некоторые коды ошибок, такие как 403, могут выдаваться непос-редственно IIS и никогда не поступают в ASP.NET. У тэга <error> два необязатель-ных атрибута: redirect и statusCode. В атрибуте redirect указывается URL страницы, а в ат рибуте statusCode задается код состояния HTTP, интерпретируемый как ошибка. Если активен пользовательский режим, но ни одна специфическая для конкретного типа ошибок страница не определена, выполняется переадресация на универсальную пользовательскую страницу. Если же и она не задана, выводится стандартная страница ASP.NET с сообщением об ошибке. Раздел <deployment> В разделе <deployment> задается режим развертывания приложения. Данный раздел имеет единственный атрибут, retail, булева типа, указывающий, с какой целью будет производиться развертывание приложения - для эксплуатации (значение true) или тестирования (false). Когда атрибут retail установлен в true, ASP.NET автоматически отключает некоторые конфигурационные установки, такие как трассировка вывода, пользовательские сообщения об ошибках и отладочные функции. Когда же атрибут retail установлен в false, приложение автоматически развертывается для тестирования. В ASP.NET 1.x приходилось вручную отключать те функции, которые предназначе-ны для поддержки разработки и тестирования и могут замедлить работу приложения при его эксплуатации. В ASP.NET 2.0 для этого достаточно добавить приведенную ниже строку в развертываемый файл web.config. <deployment retail="true" /> Раздел <globalization> В разделе <globalization> содержатся параметры приложений ASP.NET, позволяю-щие формировать запросы и ответы с применением подходящей для пользователя кодировки и с учетом его культуры. Атрибуты раздела <globalization> приведены в табл. 3-8. Табл. 3-8. Атрибуты раздела <globalization> Атрибут Описание requestEncoding Предполагаемая кодировка страниц, данных, полученных при возврате формы, и строк запросов. По умолчанию UTF-8 responseEncoding Кодировка содержимого в ответах. По умолчанию UTF-8 fileEncoding Кодировка файлов ресурсов ASP.NET (.aspx, .asmx и .asax). Файлы Unicode и UTF-8 содержат префикс, идентифицирующий порядок байтов, и поэтому распознаются независимо от значения данного атрибута culture Культура, используемая при обработке запросов uiCulture Имя культуры, которое будет использоваться при поиске культурозависимых ресурсов во время выполнения Заметьте, что когда в запросе задан атрибут Accept-Charset, его значение имеет приоритет перед используемым по умолчанию значением атрибута requestEncoding. Если удалить из конфигурационных файлов все установки, связанные с кодировками, ASP.NET по умолчанию будет использовать локализационные установки сервера. 
102 Часть I Внутренние механизмы ASP.NET В большинстве случаев атрибуты requestEncoding и responseEncoding имеют одно и то же значение. В атрибутах culture и uiCulture разрешается задавать только имена культур, от-личных от нейтральной, такие как en-US, en-AU и it-IT. Имя культуры состоит из двух элементов - названия языка и названия страны, и в данном случае должны за даваться оба. Раздел <healthMonitoring> В ASP.NET 2.0 реализована системная функция мониторинга рабочего состояния (health monitoring), позволяющая обслуживающему персоналу наблюдать за состоя-нием развернутых приложений и фиксировать важные события, связанные с произво-дительностью, сбои и аномалии. В случае тех или иных отклонений в работе системы или приложений подсистема мониторинга рабочего состояния генерирует соответс-твующие события, которые обрабатываются специализированными провайдерами. Вот общая схема раздела <healthMonitoring>, управляющего данным процессом: <healthMonitoring enabled="true|false" heartbeatInterval="HH:MM:SS"> <bufferModes>...</bufferModes> <providers>...</providers> <eventMappings>...</eventMappings> <profiles>...</profiles> <rules>...</rules> </healthMonitoring> Атрибут enabled указывает, включен ли мониторинг состояния. По умолчанию он имеет значение true. В атрибуте heartbeatInterval задается частота генерирования события heartbeat, служащего таймером для периодического сбора информации о состоянии. Это одно из событий, которые может детектировать система мониторинга. Другие события служат для отслеживания необработанных исключений, обработки запросов, жизненного цикла приложений, а также успешных и завершившихся не-удачей операций аудита. Дочерние разделы, перечисленные в табл. 3-9, позволяют конфигурировать систему в целом. Табл. 3-9. Разделы настройки мониторинга состояния Элемент Описание bufferModes Используется совместно с провайдерами событий Microsoft SQL Server и Web (со встроенной функцией уведомления по электронной почте) и позволяет определить, как часто следует генерировать события для провайдера, а также задать размер промежуточного буфера eventMappings Ставит в соответствие классам событий дружественные имена событий. Этот элемент используется для регистрации пользовательских типов событий profiles Определяет наборы параметров, используемых при конфигурировании событий providers Указывает, какие провайдеры мониторинга состояния будут обрабатывать события. Предопределенные провайдеры записывают информацию в таб-лицу SQL Server и журнал событий, а также отправляют уведомления по электронной почте. Данный элемент используется для регистрации пользовательских провайдеров rules Задает соответствие между провайдерами и событиями
Конфигурация ASP.NET Глава 3 103 Интервал для события heartbeat по умолчанию равен 0, то есть данное событие не генерируется. Раздел <hostingEnvironment> Раздел <hostingEnvironment> содержит конфигурационные установки, управляющие поведением хост-среды приложения. Как видно из следующего фрагмента кода, раздел имеет три атрибута: idleTimeout, shadowCopyBinAssemblies и shutdownTimeout. <hostingEnvironment idleTimeout="HH:MM:SS" shadowCopyBinAssemblies="true|false" shutdownTimeout="number"/> Атрибут idleTimeout определяет, сколько минут следует ждать, прежде чем вы-грузить неактивное приложение. По умолчанию он имеет значение Infinite, то есть неактивные приложения не выгружаются автоматически. Заметьте, что "неактивное" не значит "не отвечающее", - приложение считается неактивным, если с ним не ра-ботает ни один пользователь, и обычно это еще не причина для его выгрузки. Атри-бут shadowCopyBinAssemblies указывает, следует ли выполнять теневое копирование сборок приложения из папки Bin в папку ASP.NET, предназначенную для временных файлов данного приложения. По умолчанию shadowCopyBinAssemblies=true. Что ка-сается атрибута shutdownTimeout, то в нем задается время ожидания в секундах перед закрытием приложения (по умолчанию shutdownTimeout=30). Примечание Теневое копирование - это интенсивно используемая ASP.NET фун-кция .NET Framework. Когда она включена для конкретного приложения, его сбор-ки ко пи руются во внутренний кэш-каталог ASP.NET и оттуда загружаются в домен приложения. Таким образом, исходные файлы никогда не блокируются, и их можно сво-бодно изменять. Тене вое копирование включается для всех доменов приложений, созда-ваемых ASP.NET 1.x. В ASP.NET 2.0 данную функцию можно контролировать посредством атрибута shadowCopyBinAssemblies. Раздел <httpCookies> Раздел <httpCookies> служит для конфигурирования свойств cookie-файлов, исполь-зуемых приложениями ASP.NET. Вот общая схема этого раздела: <httpCookies domain="string" httpOnlyCookies="true|false" requireSSL="true|false" /> В атрибуте domain для cookie задается используемый по умолчанию домен Ин-тернета; по умолчанию данному атрибуту присваивается пустая строка. Атрибут requireSSL по умолчанию имеет значение false. Если же он равен true, для всех cookie требуется SSL. Атрибут httpOnlyCookies позволяет ASP.NET снабдить cookie дополни-тельным атрибутом HttpOnly, помогающим предотвратить угрозу похищения cookie посторонними сайтами. Когда браузер, поддерживающий данную функцию (такой, как Internet Explorer 6.0 SP1), получает cookie с атрибутом HttpOnly равным true, он делает данный cookie недоступным для клиентских сценариев. Установить данный атри бут просто: достаточно добавить строку ;HttpOnly к пути всех cookie, отправля-емых браузеру с ответом. В ASP.NET 1.x вы можете сделать это самостоятельно. Внимание! Есть как минимум две причины, по которым атрибут HttpOnly не является серебряной пулей, останавливающей межсайтовые атаки, совершаемые посредством сценариев. Первая и главная из них заключается в том, что лишь немногие современные браузеры его поддерживают. Ну а кроме того, любое средство сетевого мониторинга (например, Fiddler, доступное по адресу http://www.fiddlertool.com) может легко его обна-ружить и удалить.
104 Часть I Внутренние механизмы ASP.NET Любые установки, заданные в разделе <httpCookies>, могут быть перезаписаны классами, создающими cookie в ASP.NET. Раздел <httpRuntime> Раздел <httpRuntime> предназначен для настройки некоторых параметров конвейера ASP.NET. Интересно, что данный раздел можно размещать на любом уровне, включая и подкаталоги. Таким образом достигается исключительная гибкость и предельная детализация настройки исполняющей среды. Атрибуты раздела <httpRuntime> пере-числены в табл. 3-10. Табл. 3-10. Атрибуты для настройки исполняющей среды ASP.NET Атрибут Описание apartmentThreading Включает апартаментную потоковую модель для совместимости с классической ASP.NET. По умолчанию равен false. В ASP.NET 1.x данный атрибут не поддерживается appRequestQueueLimit Максимальное количество запросов, которые приложение может поставить в очередь, прежде чем выдаст ошибку 503 "Server Too Busy". По умолчанию имеет значение 100 в ASP.NET 1.x и 5000 в ASP.NET 2.0 delayNotificationTimeout Таймаут для отложенных уведомлений. По умолчанию 5 с. В ASP.NET 1.x данный атрибут не поддерживается enable Указывает, поддерживает ли AppDomain входящие запросы. По умолчанию имеет значение true enableHeaderChecking Указывает, будет ли ASP.NET проверять заголовок запроса, чтобы узнать, не имела ли места атака типа injection (подстановка злонамеренного кода). Если обнаружена такая атака, ASP.NET отвечает ошибкой. По умолчанию этот атрибут имеет значение true. В ASP.NET 1.x данный атрибут не поддерживается enableKernelOutputCache Активизирует кэш http.sys в IIS 6.0 и более поздних версий. По умолчанию имеет значение true. В ASP.NET 1.0 данный атрибут не поддерживается enableVersionHeader Указывает, что в каждом ответе должен выводиться заголовок с номером версии ASP.NET. По умолчанию имеет значение true. Используется Microsoft Visual Studio 2005. Для производствен-ных сайтов может быть отключен. В ASP.NET 1.0 данный атрибут не поддерживается executionTimeout Максимальная длительность выполнения запроса в секундах до его автоматического таймаута ASP.NET. По умолчанию имеет значение 90 в ASP.NET 1.x и 110 в ASP.NET 2.0 maxRequestLength Задает максимальный размер Web-запроса в килобайтах. Запросы длиной более 4 Мбайт не принимаются никогда minLocalRequestFreeThreads Минимальное количество свободных потоков, необходимое для того, чтобы система разрешила выполнение новых локальных запросов. По умолчанию 4 minFreeThreads Минимальное количество свободных потоков, необходимое для того, чтобы система разрешила выполнение новых Web-запросов. По умолчанию 8 requestLengthDiskThreshold Лимит буферизации входного потока в байтах. Не должен превышать значения атрибута maxRequestLength. По умолчанию равен 256 байт. В ASP.NET 1.x данный атрибут не поддерживается
Конфигурация ASP.NET Глава 3 105 Атрибут Описание requireRootedSaveAsPath Указывает, должен ли параметр, в котором передается имя фай-ла, метода SaveAs объекта Request содержать абсолютный путь. В ASP.NET 1.x данный атрибут не поддерживается sendCacheControlHeader Указывает, следует ли передавать заголовок, управляющий кэшированием на стороне клиента. В ASP.NET 1.x данный атрибут не поддерживается shutDownTimeout Количество минут, отведенное рабочему процессу для закрытия. По истечении этого времени ASP.NET закрывает рабочий процесс. В ASP.NET 1.x данный атрибут не поддерживается useFullyQualifiedRedirectUrl Указывает, должны ли строки переадресации клиента быть автоматически конвертированы в полностью квалифицирован-ные URL (true) или использоваться в том виде, в каком они заданы в исходном коде страницы (false). Значением по умолчанию является false waitChangeNotification, maxWaitChangeNotification Минимальное и максимальное время ожидания в секундах (по умолчанию 0) перед перезагрузкой AppDomain после уведомления об изменении файла. В ASP.NET 1.x данный атрибут не поддерживается Заметьте, что ASP.NET не будет обрабатывать запрос, если в пуле потоков нет достаточного числа свободных потоков. В такой ситуации запрос ставится в очередь приложения, где он находится, пока не освободится число потоков, заданное в атрибу-те appRequestQueueLimit. Однако почему же по умолчанию ASP.NET необходимо для выполнения запроса сразу восемь свободных потоков? Эти потоки предоставляются в распоряжение исходящих запросов (например, запросов на загрузку связанных изображений, таблиц стилей и пользовательских элементов управления) на случай, если ими будут порождены дочерние запросы. Еще несколько потоков (по умолчанию четыре) резервируется для дочерних за просов, поступающих через локальный хост. Если запрос был сгенерирован ло-кально - то есть IP-адресом клиента является 127.0.0.1 или этот адрес совпадает с адресом сервера, - поток для его выполнения выбирается из пула потоков, заре-зервированных для локальных вызовов. Часто локальные запросы - это дочерние запросы, порождаемые, например, когда страница ASP.NET вызывает Web-сервис, функционирующий на том же сервере. В такой ситуации нет необходимости исполь-зовать два потока из пула для обслуживания двух взаимосвязанных запросов, один из которых ожидает завершения другого. Используя дополнительный пул потоков, вы тем самым назначаете локальным запросам более высокий приоритет и уменьшаете риск взаимоблокировок. Раздел <identity> Установки из раздела <identity> управляют идентификацией пользователей приложе-ний ASP.NET. Раздел имеет три атрибута: impersonate, userName и password. Главным из них является impersonate. По умолчанию он устанавливается в false, и, соответственно, приложение не выполняет имперсонализацию пользователей. <identity impersonate="true" /> Когда значением атрибута impersonate является true, ASP.NET обслуживает за-просы либо от имени текущего пользователя Windows, либо от имени пользователя, определяемого атрибутами userName и password. Табл. 3-10. (окончание)
106 Часть I Внутренние механизмы ASP.NET Внимание! Имя и пароль пользователя хранятся в конфигурационном файле в виде чистого текста. Хотя IIS никогда не выполняет запросы на предоставление конфигура-ционных файлов, файл web.config может быть прочитан иными средствами. Поэтому следует продумать способ защиты содержимого раздела <identity>. В ASP.NET 1.x можно использовать следующее соглашение: userName="registry:HKLM\Software\AspNetProcess,Name" password="registry:HKLM\Software\AspNetProcess,Pswd" Здесь Name и Pswd - два элемента реестра с произвольными именами, расположенные в заданном узле. Содержимое обоих элементов хранится в формате REG_BINARY и за-шифровано с использованием функций шифрования DPAPI (Data Protection API - про-граммный интерфейс защиты данных). Для записи данных в реестр используется утилита aspnet_setreg.exe с интерфейсом командной строки. Что касается ASP.NET 2.0, то эта система поддерживает шифрование разделов с исполь-зованием технологии XML Encryption, так что вам достаточно просто зашифровать таким образом раздел <identity>. Подробнее я остановлюсь на этом чуть позже. Раздел <machineKey> В разделе <machineKey>, поддерживаемом как на уровне компьютера, так и на уровне приложения, задаются ключи для шифрования и дешифрации аутентификационных билетов форм и данных состояния представления. Вот схема этого раздела: <machineKey validationKey="AutoGenerate|value[,IsolateApps]" decryptionKey="AutoGenerate|value[,IsolateApps]" validation="[SHA1|MD5|3DES|AES]" decryption="[Auto|AES|3DES]" /> В атрибутах validationKey и decryptionKey задаются ключи шифрования и дешиф-рации. Ключ шифрования - это символьная последовательность длиной от 40 до 128 символов. Атрибут validation определяет тип шифрования, используемого для проверки данных. Допустимые значения: SHA1 (по умолчанию), MD5, AES и 3DES. Наконец, в атрибуте decryption задается тип алгоритма хэширования (AES либо 3DES), используемого при дешифрации данных. По умолчанию данный атрибут установлен в Auto, то есть ASP.NET сама выбирает алгоритм дешифрации, основываясь на зада-ваемых по умолчанию конфигурационных установках. Атрибутам validationKey и decryptionKey по умолчанию присвоена установка Auto-Generate,IsolateApps. Это означает, что ключи генерируются автоматически во время установки и хранятся в Local Security Authority (LSA) - защищенной подсистеме Windows NT-базированных операционных систем, в которой хранится информация обо всех аспектах локальной защиты системы. Модификатор IsolateApps предписывает ASP.NET генерировать для каждого приложения уникальный ключ. Параметры из раздела <machineKey> - это критический элемент приложений, хостами которых являются группы компьютеров, такие как Web-фермы или отказо-устойчивые кластеры. Все компьютеры в сети должны иметь одинаковые парамет-ры <machineKey>. Возможно, вы даже захотите установить атрибуты validationKey и decryptionKey вручную, чтобы обеспечить согласованность конфигураций. Раздел <membership> Раздел <membership> содержит параметры, управляющие аутентификацией пользо ва-телей, выполняемой с применением API членства ASP.NET. Вот схема данного раз дела: <membership defaultProvider="provider name"
Конфигурация ASP.NET Глава 3 107 userIsOnlineTimeWindow="number of minutes" hashAlgorithmType="SHA1"> <providers> </providers> </membership> Атрибут defaultProvider содержит имя используемого по умолчанию провай де-ра членства - по умолчанию это AspNetSqlMembershipProvider. Атрибут userIs Online-TimeWindow указывает, как долго пользователь может бездействовать и все еще счи-таться подключенным. По умолчанию этот интервал равняется 15 мин. В атрибуте hashAlgorithmType задается название алгоритма шифрования, используемого для хэ-ширования значений пароля. <membership> <providers> <add name="MyProvider" type="Samples.MyMembershipProvider" connectionStringName="MyConnString" enablePasswordRetrieval="false" enablePasswordReset="true" requiresQuestionAndAnswer="true" passwordFormat="Hashed" /> </providers> </membership> В дочернем разделе <providers> перечисляются все зарегистрированные провайде-ры членства. Этот раздел применяется для добавления пользовательских провайдеров. У каждого провайдера имеется собственный набор атрибутов. Раздел <pages> В разделе <pages> задаются используемые по умолчанию значения многих атрибутов директивы @Page и декларативно конфигурируется окружение Web-страницы време-ни выполнения. В табл. 3-11 перечислены поддерживаемые атрибуты. Табл. 3-11. Атрибуты, используемые при конфигурировании страниц ASP.NET Атрибут Описание asyncTimeout Период ожидания (в секундах) завершения обработчиком асинхронной операции. По умолчанию 45 с. В ASP.NET 1.x данный атрибут не поддерживается autoEventWireup Указывает, должны ли события страницы автоматически назначаться обработчикам с соответствующими именами (например, Page_Load). По умолчанию имеет значение true Buffer Указывает, включена ли буферизация ответов. По умолчанию имеет значение true compilationMode Указывает, должны ли страница ASP.NET либо элемент управления компилироваться во время выполнения. Допустимые значения: Never, Auto и Always (по умолчанию). Auto означает, что ASP.NET не будет компилировать страницу, если это возможно. В ASP.NET 1.x данный атрибут не поддерживается enableSessionState Указывает, доступно ли состояние сеанса. По умолчанию имеет значение true; допустимы также значения false и ReadOnly. Состояние сеанса недоступно, если данный атрибут установлен в false, и доступно только для чтения, если он установлен в ReadOnly (см. след. стр.)
108 Часть I Внутренние механизмы ASP.NET Атрибут Описание enableViewState Указывает, доступно ли состояние представления. По умолчанию имеет значение true enableViewStateMac Указывает, должно ли состояние представления проверяться на предмет наличия злонамеренных изменений при каждом возврате страницы. По умолчанию имеет значение true maintainScrollPosition-OnPostBack Если данный атрибут равен true, после возврата формы положение прокрутки страницы сохраняется. В ASP.NET 1.x данный атрибут не поддерживается masterPageFile Эталонная страница для тех страниц, на которые распространяется область действия данного конфигурационного файла. В ASP.NET 1.x данный атрибут не поддерживается maxPageStateFieldLength Максимальная длина поля состояния представления. Отрицатель-ное значение указывает на то, что верхняя граница длины не задана. Если объем данных состояния представления превышает заданный максимум, содержимое отправляется частями. В ASP.NET 1.x данный атрибут не поддерживается pageBaseType Базовый класс отделенного кода, наследуемый страницей .aspx по умолчанию, то есть в случае, когда класс отделенного кода явно не задан. Используемым по умолчанию классом является System.Web.UI.Page. Имя нового класса должно включать информацию о сборке pageParserFilterType Тип класса фильтра, применяемого синтаксическим анализатором ASP.NET для определения допустимости использования элемента на странице. В ASP.NET 1.x данный атрибут не поддерживается smartNavigation Определяет, включена ли интеллектуальная навигация. По умолча-нию имеет значение false. В настоящее время вместо него предлага-ется использовать атрибут maintainScrollPositionOnPostBack styleSheetTheme Имя темы таблицы стилей, используемой для страниц, на которые распространяется область действия данного конфигурационного файла. В ASP.NET 1.x данный атрибут не поддерживается theme Имя темы, используемой для страниц, на которые распространяется область действия данного конфигурационного файла. В ASP.NET 1.x данный атрибут не поддерживается userControlBaseType Класс отделенного кода .ascx, наследуемый пользовательскими элементами управления по умолчанию. Используемым по умолча-нию классом является System.Web.UI.UserControl. Имя нового класса должно включать информацию о сборке validateRequest Указывает, что ASP.NET должна проверять все введенные данные, поступающие от браузера, на предмет потенциальной опасности для серверной системы. По умолчанию имеет значение true. В ASP.NET 1.0 данный атрибут не поддерживается viewStateEncryptionMode Режим шифрования состояния представления. Допустимыми значе-ниями являются Always, Never и Auto. Установка Auto означает, что состояние представления шифруется, только тогда, когда элемент управления запрашивает данную функцию. В ASP.NET 1.x данный атрибут не поддерживается Атрибут pageBaseType является очень мощной установкой, используемой, когда все страницы приложения должны наследоваться от одного класса отделенного кода. В таком случае вместо того чтобы модифицировать все страницы, вы задаете необхо-димые установки в файле web.config на желаемом уровне (компьютер, приложение, подкаталог). Табл. 3-11. (окончание)
Конфигурация ASP.NET Глава 3 109 Очень интересен атрибут maxPageStateFieldLength. Одной из проблем, с которыми сталкиваются разработчики, является слишком большой объем данных состояния представления - браузер просто не в состоянии передавать и принимать столько ин-формации для одного поля. В результате данные состояния представления обрезаются, вследствие чего в работе приложения происходит сбой. Эта ситуация особенно типич-на для маленьких простых Web-браузеров, таких как Microsoft WebTV или браузеры карманных компьютеров (КПК). Для решения проблемы в ASP.NET 1.x приходится, что называется брать быка за рога: разрабатывать пользовательский класс страницы и переопределять в нем методы чтения и записи состояния представления таким образом, чтобы класс держал эту информацию на сервере. В ASP.NET 2.0 есть более простой способ - воспользоваться атрибутом maxPageStateFieldLength. Когда объем данных состояния представления превышает предел, заданный в указанном атрибуте, ASP.NET автоматически разделяет эти данные на блоки и пересылает их, используя несколько скрытых полей. Например, если установить maxPageStateFieldLength рав-ным 5, страница будет содержать следующий HTML-код: <input type="hidden" id="__VIEWSTATEFIELDCOUNT" value="..." /> <input type="hidden" id="__VIEWSTATE" value="/wEPD" /> <input type="hidden" id="__VIEWSTATE1" value="wUKLT" /> <input type="hidden" id="__VIEWSTATE2" value="I2MjI" /> Результирующий размер страницы (в байтах) будет даже немного большим, однако операция ее отображения по крайней мере никогда не завершится неудачей из-за того, что недостаточно мощный браузер обрезал данные состояния представления. Раздел <processModel> В разделе <processModel> конфигурируется модель процесса ASP.NET, иными сло-вами, настраивается процедура обработки запроса в конвейере HTTP. Атрибуты раз дела <processModel> считываются неуправляемым кодом - ISAPI-расширением aspnet_isapi.dll. Поэтому для того чтобы изменения вступили в силу, нужно перезапус-тить IIS. По той же причине невозможно переопределение этих атрибутов в разделе <processModel> файла web.config. Данный раздел может присутствовать только в файле machine.config, а воздействует он на все приложения ASP.NET, выполняющиеся на данном сервере. Ниже приведена схема раздела <processModel>. <processModel enable="true|false" timeout="hrs:mins:secs|Infinite" idleTimeout="hrs:mins:secs|Infinite" shutdownTimeout="hrs:mins:secs|Infinite" requestLimit="num|Infinite" requestQueueLimit="num|Infinite" restartQueueLimit="num|Infinite" memoryLimit="percent" webGarden="true|false" cpuMask="num" userName="username" password="password" logLevel="All|None|Errors" clientConnectedCheck="hrs:mins:secs|Infinite" comAuthenticationLevel="Default|None|Connect|Call| Pkt|PktIntegrity|PktPrivacy" comImpersonationLevel="Default|Anonymous|Identify| Impersonate|Delegate"
110 Часть I Внутренние механизмы ASP.NET responseDeadlockInterval="hrs:mins:secs|Infinite" responseRestartDeadlockInterval="hrs:mins:secs|Infinite" autoConfig="true|false" maxWorkerThreads="num" maxIoThreads="num" minWorkerThreads="num" minIoThreads="num" serverErrorMessageFile="" pingFrequency="Infinite" pingTimeout="Infinite" maxAppDomains="2000" /> Когда ASP.NET работает под управлением IIS 6.0 в его собственном режиме, ис-пользуется модель процесса IIS 6.0, и большинство атрибутов раздела <processModel> игнорируется. Для конфигурирования идентификации процессов, сборки мусора и других параметров модели процесса в IIS 6.0 нужно настроить рабочий процесс при-ложения с помощью IIS Manager. Чтобы открыть соответствующее диалоговое окно, показанное на рис. 3-3, щелкните правой кнопкой мыши свойства пула приложений, к которому принадлежит ваше приложение. Рис. 3-3. Конфигурирование модели процесса при использовании стандартной модели процесса IIS 6.0 В табл. 3-12 описаны те атрибуты раздела <processModel>, которые действуют и в случае применения собственной модели процесса IIS 6.0. Табл. 3-12. Конфигурирование модели процесса ASP.NET Атрибут Описание autoConfig Указывает, что для достижения оптимальной производительности ASP.NET должна автоматически конфигурировать некоторые критические атрибуты. По умолчанию имеет значение true. За дополнительной информацией об атрибутах и их предлагаемых значениях обратитесь к статье 821268 из Microsoft Knowledge Base maxIoThreads Максимальное число потоков ввода-вывода на ЦПУ в пуле потоков. По умолчанию имеет значение 20 (что соответствует 20 - N потокам на компьютере с двадцатью центральными процессорами)
Конфигурация ASP.NET Глава 3 111 Атрибут Описание maxWorkerThreads Минимальное число рабочих потоков на ЦПУ в пуле потоков. По умолчанию имеет значение 20 (что соответствует 20 - N потокам на компьютере с двадцатью центральными процессорами) minIoThreads Максимальное число потоков ввода-вывода на процесс на одном ЦПУ. По умолчанию имеет значение 1 minWorkerThreads Максимальное число рабочих потоков на процесс на одном ЦПУ. По умолчанию имеет значение 1 requestQueueLimit Максимальное количество запросов, которые процесс ASP.NET мо-жет поставить в очередь, прежде чем оно выдаст ошибку 503 Server Too Busy. По умолчанию имеет значение 5000 responseDeadlockInterval Интервал времени, по истечении которого процесс с ожидающими в очереди запросами, не вернувший ответ, считается попавшим в ситуацию взаимоблокировки и принудительно завершается. По умолчанию составляет 3 мин Заметьте, что интервалы времени обычно задаются в форме ЧЧ:ММ:СС. Например, строка 00:00:05 интерпретируется как 5 с. Слово Infinite обозначает, в зависимости от контекста, бесконечное время или же бесконечное число. Внимание! При использовании модели процесса IIS 5.0 в режиме эмуляции либо в слу чае, когда приложение работает на компьютере с Windows 2000 Server, обратитесь к онлайно-вой документации MSDN за дополнительной информацией об атрибутах, не включенных в табл. 3-12. Заметьте, однако, что выполнение ASP.NET в режиме эмуляции в IIS 6.0 - не очень хорошая идея с точки зрения производительности. Если вы ищете способ повыше-ния производительности приложений ASP.NET, обратитесь к главе 6 онлайновой книги Improving .NET Application Performance and Scalability, которая находится на сайте Microsoft в разделе Patterns & Practices по адресу http://msdn.microsoft.com/library/enus/dnpag/html/scalenetchapt06.asp. Раздел <profile> Раздел <profile> применяется для конфигурирования функции поддержки пользо-вательских профилей, введенной в ASP.NET 2.0. Каждому пользователю может быть назначен набор свойств, значения которых загружаются и автоматически сохраняются системой в начале и конце обработки запроса. Всю работу по вводу-выводу берет на себя специализированный провайдер профилей, работающий с определенным хранилищем данных. Например, вызываемый по умолчанию провайдер профилей использует файл AspNetDb.mdf и SQL Server 2005 Express. Раздел <profile> имеет следующую схему: <profile enabled="true|false" inherits="fully qualified type reference" automaticSaveEnabled="true|false" defaultProvider="provider name"> <properties>...</properties> <providers>...</providers> </profile> Атрибут enabled указывает, включен ли механизм пользовательских профилей. По умолчанию данный атрибут имеет значение true, то есть профили используются. Табл. 3-12. (окончание)
112 Часть I Внутренние механизмы ASP.NET Набор свойств, ассоциируемых с каждым аутентифицированным пользователем, опре-деляется дочерним элементом <properties>: <profile> <properties> <add name="BackColor" type="string" /> <add name="ForeColor" type="string" /> </properties> </profile> В табл. 3-13 перечислены атрибуты свойства, которые можно задавать в разделе <profile>. Табл. 3-13. Атрибуты свойства профиля пользователя Атрибут Описание allowAnonymous Разрешает хранение значений для анонимных пользователей. По умолчанию имеет значение false customProviderData Данные для провайдера пользовательских профилей defaultValue Значение свойства по умолчанию name Имя свойства provider Имя провайдера, используемого для чтения и записи значения свойства readOnly Указывает, является ли свойство доступным только для чтения. По умолчанию имеет значение false serializeAs Способ преобразования значения свойства в последовательную форму. Допустимые значения: Xml, Binary, String и ProviderSpecific type .NET Framework-тип свойства. По умолчанию это объект типа string Все перечисленные свойства упаковываются в динамически создаваемый класс, а пользовательскому коду они доступны через свойство Profile объекта HttpContext. В атрибуте Inherits можно задать базовый класс, наследуемый динамически создаваемым классом профиля. Атрибут automaticSaveEnabled определяет, будет ли пользовательский профиль автоматически сохраняться по завершении выполнения страницы ASP.NET. (По умолчанию он имеет значение true.) Заметьте, что профиль сохраняется, только если отвечающий за него модуль HTTP обнаруживает, что он модифицирован. В разделе <providers> перечисляются все доступные провайдеры профилей. Вы бу-дете регистрировать здесь пользовательские провайдеры. В атрибуте defaultProvider за-дается провайдер, выбранный в настоящий момент для использования страницами. Раздел <roleManager> В разделе <roleManager> задаются установки управления ролями для приложения ASP.NET 2.0. Управление ролями осуществляется двумя компонентами: модулем HTTP, перехватывающим входящие запросы, и провайдером ролей, извлекающим и записы-вающим информацию о ролях для аутентифицированного пользователя. Провайдер действует как прокси хранилища данных, в котором содержится информация о ро-лях. Все доступные провайдеры перечислены в дочернем разделе <providers>. Если вы установите новый провайдер, информацию о нем нужно будет сюда добавить. Используемый по умолчанию провайдер задается в атрибуте defaultProvider. Общая схема данного раздела такова: <roleManager cacheRolesInCookie="true|false" cookieName="name"
Конфигурация ASP.NET Глава 3 113 cookiePath="/" cookieProtection="All|Encryption|Validation|None" cookieRequireSSL="true|false " cookieSlidingExpiration="true|false " cookieTimeout="number of minutes" createPersistentCookie="true|false" defaultProvider="provider name" domain="cookie domain"> enabled="true|false" maxCachedResults="maximum number of role names cached" <providers>...</providers> </roleManager> Как правило, получив от текущего провайдера информацию о ролях, модуль HTTP создает cookie, где кэширует данную информацию для будущих запросов. Именно с этой его функцией связаны все перечисленные выше атрибуты, в именах которых присутствует слово cookie. По умолчанию данный cookie имеет имя .ASPXROLES. Раздел <securityPolicy> В разделе <securityPolicy> задается соответствие между уровнями безопасности (на-зываемыми также уровнями доверия) и файлами политики. Он содержит один или более элемент <trustLevel> с атрибутами name и policyFile. Данный раздел можно конфигурировать на уровне приложения, но не на уровне подкаталогов. Можно также использовать его для расширения схемы защиты, задавая собственные именованные уровни доверия и ставя им в соответствие пользовательские файлы политики защиты. Ниже приведен фрагмент файла web.config, помещаемого в корневой каталог сайта при установке ASP.NET 2.0. <securityPolicy> <trustLevel name="Full" policyFile="internal" /> <trustLevel name="High" policyFile="web_hightrust.config" /> <trustLevel name="Medium" policyFile="web_mediumtrust.config" /> <trustLevel name="Low" policyFile="web_lowtrust.config" /> <trustLevel name="Minimal" policyFile="web_minimaltrust.config" /> </securityPolicy> Во всех версиях .NET Framework атрибуту name можно присваивать значения Full, High и Low. В версии 1.1 и более поздних допускаются также установки Minimal и Medium. Каждое имя идентифицирует определенный уровень доверия, установки которого хранятся в соответствующем файле политики. Файлы политики безопаснос-ти - это XML-файлы, расположенные в той же папке, что и machine.config. Исключение составляет уровень доверия Full, для которого файл политики не требуется. Для данного уровня ASP.NET не добавляет никаких параметров защиты, и содержимое атрибута policyFile просто игнорируется. Раздел <sessionPageState> В разделе <sessionPageState> можно указать, как следует использовать состояние сеанса для хранения данных состояния представления на малых устройствах, имею-щих ограничения на размер страницы или ширину полосы пропускания. Например, элементы управления ASP.NET для мобильных устройств обычно для хранения состо-яния представления используют состояние сеанса. Но как в таком случае поступать с запросами браузера на перемещение к следующей и предыдущей странице? Это не проблема, когда каждая страница содержит внедренную информацию о ее состоя-нии представления. Однако если состояние представления хранится на сервере, вам 
114 Часть I Внутренние механизмы ASP.NET нужно обеспечить его сохранение по крайней мере для нескольких ранее запрошенных страниц. Скольких конкретно? Это значение задается в разделе <sessionPageState> следующим образом: <sessionPageState historySize="9" /> Данный раздел имеет единственный атрибут - historySize, - которому по умолча-нию присваивается значение 9. Он используется только для элементов управления ASP.NET, предназначенных для мобильных устройств. Раздел <sessionState> В разделе <sessionState> хранятся те параметры текущего приложения, которые свя-заны с состоянием сеанса. Они определяют поведение и детали реализации объекта ASP.NET Session. Данный объект может работать в разных режимах, обеспечивая соб-людение требований конкретного приложения к производительности, устойчивости и надежности хранения данных. В табл. 3-14 приводится список атрибутов раздела <sessionState>. Единственным обязательным атрибутом является mode. Некоторые атрибуты взаимоисключающие. Табл. 3-14. Атрибуты, связанные с состоянием сеанса Атрибут Описание allowCustomSqlDatabase Если данный атрибут равен true, разрешается задавать пользова-тельскую базу данных SQL Server для хранения данных сеанса, вместо используемой по умолчанию базы данных ASPState. В ASP.NET 1.x этот атрибут не поддерживается cookieless Определяет, как следует передавать клиенту идентификатор сеанса. Допустимые значения перечислены в табл. 3-5 cookieName Имя cookie, если для хранения идентификаторов сеансов исполь-зуются cookie. В ASP.NET 1.x данный атрибут не поддерживается customProvider Имя пользовательского провайдера состояния сеанса, используе-мого для сохранения и восстановления данных состояния сеанса. В ASP.NET 1.x этот атрибут не поддерживается mode Определяет режим реализации состояния сеанса. Допустимыми значениями являются Off, InProc, Custom, StateServer и SQLServer. Когда данный атрибут установлен в Off, управление состоянием сеанса отключено и объект Session недоступен приложению. InProc - рабочий режим по умолчанию, в нем данные состояния сеанса хранятся локально в памяти Web-сервера. Они также могут храниться на удаленном сервере (установка StateServer) или в базе данных SQL Server (SQLServer). В ASP.NET 2.0 опция Custom указывает, что приложением используется пользовательское хранилище данных partitionResolverType Определяет тип и сборку компонента partition resolver, предостав-ляющего информацию о подключении, когда используется режим реализации состояния сеанса SQLServer или StateServer. Если partition resolver успешно загружен, атрибуты sqlConnectionString и stateConnectionString игнорируются. В ASP.NET 1.x данный атрибут не поддерживается regenerateExpiredSessionId Если данный атрибут установлен в true, при получении запроса с устаревшим идентификатором сеанса генерируется новый иден-тификатор; если же этот атрибут равен false, действие устаревшего атрибута возобновляется. В ASP.NET 1.x данный атрибут не поддерживается 
Конфигурация ASP.NET Глава 3 115 Атрибут Описание sessionIDManagerType По умолчанию имеет значение Null. Если данный атрибут установлен, он идентифицирует компонент, используемый в качестве генератора идентификаторов сеанса. В ASP.NET 1.x данный атрибут не поддерживается sqlCommandTimeout Время (в секундах) в течение которого SQL-команда может оставаться бездействующей, прежде чем она будет отменена. По умолчанию имеет значение 30 sqlConnectionString Строка подключения к базе данных SQL Server, в которой хранятся данные состояния сеанса. Используется, когда атрибут mode имеет значение SQLServer stateConnectionString Имя сервера и порт для сохранения данных состояния сеанса. Используется, когда атрибут mode имеет значение SQLServer stateNetworkTimeout Время (в секундах) в течение которого сетевое подключение TCP/IP между Web-сервером и сервером состояния может оставаться бездействующим, прежде чем запрос будет отменен. По умолчанию имеет значение 10 timeout Время (в минутах) в течение которого сеанс может оставаться бездействующим, прежде чем он будет прекращен. По умолчанию имеет значение 20 useHostingIdentity Указывает, что учетная запись процесса ASP.NET будет имперсо на лизи рована для доступа к пользовательскому провайдеру состояния или провайдеру SQLServer, сконфигу-рированному для использования интегрированной защиты. По умолчанию имеет значение true. В ASP.NET 1.x данный атрибут не поддерживается В дочернем разделе <providers> перечисляются пользовательские провайдеры хранения состояния сеанса. Механизм работы с состоянием сеанса ASP.NET спроек-тирован таким образом, что данные состояния сеанса легко можно сохранять как в па-мяти Web-сервера, так и в базе данных SQL Server или других внешних хранилищах. Провайдер хранения - это компонент, управляющий хранением данных состояния сеанса и сохраняющий их в альтернативном хранилище (например, в базе данных Oracle) и в альтернативном формате. Строка подключения для режима SQLServer по умолчанию такова: data source=127.0.0.1;Integrated Security=SSPI Как видите, она не содержит имени базы данных, которым по умолчанию является AspState. Вы создаете эту базу данных перед выпуском приложения, используя либо сценарии T-SQL, либо утилиту с интерфейсом командной строки aspnet_regsql. Для режима StateServer по умолчанию используется следующая строка подклю-чения: tcpip=127.0.0.1:42424 IP-адрес и порт вы можете изменить по своему усмотрению. Заметьте, однако, что для изменения номера порта недостаточно записать его в конфигурационный файл - необходимо также отредактировать запись Port в следующем разделе реестра: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\aspnet_state\Parameters Табл. 3-14. (окончание)
116 Часть I Внутренние механизмы ASP.NET Раздел <siteMap> В разделе <siteMap> конфигурируется система навигации сайта. Схема этого раздела такова: <siteMap enabled="true|false" defaultProvider="provider name"> <providers>...</providers> </siteMap> Функция навигации реализуется с использованием провайдеров карты сайта - компонентов, возвращающих информацию о структуре сайта. В состав ASP.NET входит один такой предопределенный провайдер - класс AspNetXmlSiteMapProvider. Исполь-зуемый по умолчанию провайдер задается в атрибуте defaultProvider. Все доступные провайдеры, включая пользовательские, перечисляются в подразделе <providers>. Раздел <trace> Трассировкой приложения называется мониторинг поведения приложения в процессе его эксплуатации. Чтобы трассировка была возможна, приложение должно обладать способностью отправки информативных сообщений о своем состоянии. В разделе <trace> определяются параметры трассировки приложения. Эти атрибуты описаны в табл. 3-15. Табл. 3-15. Атрибуты, управляющие трассировкой приложения Атрибут Описание enabled Определяет, включена ли трассировка приложения. По умолчанию имеет значение false. Для того чтобы можно было пользоваться ути-литой Trace Viewer (trace.axd) или некоторыми другими функциями, трассировка должна быть включена localOnly Если данный атрибут имеет значение true, утилита Trace Viewer доступна только на локальном хосте; в противном случае она доступна и в удаленном режиме. По умолчанию имеет значение true. Заметьте, что trace.axd является одним из используемых по умолчанию обработчиков HTTP, зарегистрированных при инсталляции pageOutput Определяет, должны ли результаты трассировки выводиться в конце каждой страницы. Если данный атрибут имеет значение false, они доступны только через Trace Viewer. По умолчанию атрибут имеет значение false. Независимо от этой глобальной установки можно включать трассировку отдельных страниц, используя атрибут Trace директивы @Page requestLimit Определяет максимальное количество результатов трассировки, сохраняемых на сервере и затем доступных с помощью утилиты trace.axd. По умолчанию имеет значение 10. Максимально допустимое значение - 10 000 traceMode Определяет критерий сортировки результатов трассировки перед их отображением. Допустимые значения: SortByTime (значение по умол-чанию) и SortByCategory. Сортировка по времени означает, что записи будут отображаться в том порядке, в каком они генерировались. Что касается сортировки по категориям, то в этом случае используются пользовательские имена, указанные в тексте трассировочных файлов writeToDiagnosticsTrace Определяет, должны ли сообщения трассировки, получаемые заре-гистрированными слушателями, перенаправляться диагностической трассировочной инфраструктуре. По умолчанию имеет значение false. В ASP.NET 1.x данный атрибут не поддерживается
Конфигурация ASP.NET Глава 3 117 В .NET Framework для поддержки трассировки предусмотрен унифицированный абстрактный API, в реализации которого используются специализированные драйве-ры, осуществляющие непосредственный вывод сообщений. Эти драйверы называются слушателями трассировки. Они перенаправляют результаты трассировки туда, куда вы укажете, - обычно в файл журнала или выходной поток. Слушатели определяются в разделе <system.diagnostics>. Когда атрибут writeToDiagnosticsTrace имеет значение true, любые сгенерированные ASP.NET сообщения направляются всем зарегистриро-ванным слушателям. Раздел <trust> В разделе <trust> настраивается уровень доверия, на котором будет работать прило-жение, и определяются ограничения защиты, связанные с доступом к коду приложе-ния. По умолчанию все работающие на Web-сервере приложения ASP.NET облачены полным доверием, и им позволяется делать все, что дозволено их учетной записи. Общеязыковая среда не создает "песочницу" для кода. Поэтому любые ограничения защиты, установленные для приложения (например, запрет создания файлов или записи в реестр) являются не признаком ограничения доверия, а просто результатом того, что оно выполняется от имени непривилегированной учетной записи, как всякое другое приложение ASP.NET. Раздел <trust> используется в том случае, если приложение нужно запускать не с полным доверием. В следующем примере демонстрируются используемые по умол-чанию установки раздела <trust> в файле machine.config. <trust level="Full" originUrl="" /> Допустимыми значениями атрибута level являются все элементы <trustLevel>, определенные в разделе <securityPolicy>. Имя атрибута originUrl вводит пользователя в заблуждение относительно его на-значения. На самом деле если вы его установите, приложению будет предоставлено разрешение на доступ к ресурсу, находящемуся по заданному URL, через HTTP с использованием класса Socket либо WebRequest. Разумеется, разрешение на доступ через Web предоставляется только в том случае, если оно поддерживается для уровня доверия, заданного в разделе <trust>. Для уровня Medium и более высоких уровней такая возможность поддерживается. В ASP.NET 2.0 определен еще один атрибут раздела <trust> - processRequestIn-ApplicationTrust булева типа, по умолчанию имеющий значение true. Это значение ука-зывает, что запросы страницы должны автоматически ограничиваться разрешениями, заданными в файле политики доверия, связанном с приложением. Если же данный атрибут содержит значение false, существует вероятность, что запрос страницы будет выполняться с более широкими привилегиями, чем указано в политике доверия. Примечание Раздел <trust> может использоваться только на уровнях компьютера и при-ложения - но не из соображений безопасности, а по техническим причинам. Приложение ASP.NET работает в собственном домене приложения, и его уровень доверия определя-ется параметрами защиты, заданными для этого домена. Хотя установки защиты могут относиться к определенным фрагментам кода, AppDomain - это самый низкий уровень, к которому может применяться политика защиты. Если бы общеязыковая среда поддержи-вала большую детализацию уровней защиты, то можно было бы независимо определять уровни доверия для разных частей приложения ASP.NET. В следующем сценарии продемонстрировано, как можно задать уровень доверия Medium для всех установленных на сервере приложений. Этот сценарий взят из фай-ла web.config, находящегося в корневом каталоге сайта. Когда атрибут allowOverride 
118 Часть I Внутренние механизмы ASP.NET установлен в false, уровень доверия блокируется и его нельзя модифицировать на уровне приложения, то есть в файле web.config, находящемся в корневом каталоге этого приложения. <location allowOverride="false"> <system.web> <trust level="Medium" originUrl="" /> </system.web> </location> Добавив следующий сценарий, вы снимете блокировку для конкретного прило-жения, установленного на данном компьютере: <location allowOverride="true" path="Default Web Site/ProAspNet20"> <system.web> <trust level="Medium" originUrl="" /> </system.web> </location> Раздел <urlMappings> В разделе <urlMappings> содержится список соответствий между URL и реальными конечными точками приложений. Вот маленький пример, стоящий тысячи слов: <urlMappings enabled="true"> <add url="~/main.aspx" mappedUrl="~/default.aspx?tab=main" /> </urlMappings> Атрибут url содержит URL, который пользователи вводят у себя в браузерах, а ат рибут mappedUrl - тот URL, который в результате передается приложению. Оба URL задаются относительно корневого каталога приложения. Помимо узлов <add> в разделе <urlMappings> могут использоваться узлы <remove> и <clear>. Примечание В ASP.NET 2.0 раздел <urlMappings> является декларативным эквивалентом метода RewritePath класса RewritePath. Раздел <webControls> У раздела <webControls> имеется единственный атрибут - clientScriptsLocation, - за-дающий путь к файлам клиентских сценариев по умолчанию. Эти файлы включаются в состав кода HTML, сгенерированного для страниц .aspx, когда этим страницам тре-буется клиентская функциональность, такая, как интеллектуальная навигация или клиентская проверка условий для элементов управления. <webControls clientScriptsLocation="/aspnet_client/{0}/{1}/" /> Приведенная строка демонстрирует стандартное содержимое раздела <webControls>. Содержимое атрибута clientScriptsLocation, дополненное надлежащим образом, представляет собой URL, используемый для включения сценариев. При инстал ляции ASP.NET в корневом каталоге Web-сервера автоматически создается подкаталог aspnet_client. Два параметра в строке представляют подкаталоги, имена которых в бу-дущих версиях ASP.NET могут изменяться. В первый параметр всегда подставляется system_web, а во второй - имя подкаталога, зависящее от версии .NET Framework. В ASP.NET 2.0, в отличие от предыдущих версий, данный каталог не используется для хранения файлов клиентских сценариев. Эти файлы встраиваются в сборку system.web в ка честве ресурсов и включаются в страницы обработчиком HTTP webresource.axd. Вы можете хранить в указанной папке файлы сценариев, используемых создава-емыми вами специализированными элементами управления ASP.NET.
Конфигурация ASP.NET Глава 3 119 Раздел <webServices> В разделе <webServices> задаются параметры Web-сервисов ASP.NET. Он содержит несколько подразделов для настройки поддерживаемых протоколов, необходимых расширений SOAP, страницы справки Web-сервисов и многого другого. Атрибутов этот раздел не имеет. Поддерживаемые подразделы перечислены в табл. 3-16. Табл. 3-16. Подразделы для конфигурирования Web-сервисов Подраздел Описание conformanceWarnings Определяет набор профилей WS-I, которые будут использоваться для проверки Web-сервисов. В ASP.NET 1.x данный атрибут не поддерживается Protocols Содержит перечень поддерживаемых ASP.NET прото-колов передачи, которые она может использовать для дешифрации запросов клиентов Web-сервисов serviceDescriptionFormatExtensionTypes Задает дополнительные классы-расширения, которые должны использоваться при генерировании описаний Web-сервисов soapExtensionImporterTypes Регистрирует SOAP-расширения, используемые для получения описаний Web-сервисов для создания прокси-классов soapExtensionReflectorTypes Регистрирует SOAP-расширения, используемые для генерирования описаний Web-сервисов soapExtensionTypes Регистрирует SOAP-расширения, используемые со всеми Web-сервисами soapServerProtocolFactoryType Определяет объект, соответствующий протоколу, используемому для вызова Web-сервиса. В ASP.NET 1.x данный атрибут не поддерживается wsdlHelpGenerator Указывает страницу .aspx, генерирующую страницу справки Web-сервиса, отображаемую, когда Web-сер-вис .asmx запрашивается через локальный браузер По умолчанию Web-сервис ASP.NET поддерживает следующие протоколы. <protocols> <add name="HttpSoap12" /> <add name="HttpSoap" /> <add name="HttpPostLocalhost" /> <add name="Documentation" /> </protocols> Начиная с версии 1.1 из соображений безопасности из ASP.NET были исключе-ны встроенные средства поддержки протоколов HTTP-POST и HTTP-GET. Если вы пожелаете использовать их для упрощения разработки и тестирования, добавьте следующий сценарий: <protocols> <add name="HttpPost" /> <add name="HttpGet" /> </protocols> Протокол Documentation - это главный компонент, обеспечивающий исполняющей среде ASP.NET возможность вывода страницы справки, когда пользователь указывает в браузере ресурс .asmx. Если отключить этот протокол, при попытке пользователя 
120 Часть I Внутренние механизмы ASP.NET перейти по адресу Web-сервиса страница справки генерироваться не будет, а вместо нее ASP.NET станет отображать сообщение об ошибке Requested Format Is Unrecognized. Если вы захотите отображать страницу справки, изменив ее структуру и содержимое, модифицируйте атрибут href элемента <wsdlHelpGenerator>: <webServices> <wsdlHelpGenerator href="YourNewGeneratorPage.aspx" /> </webServices> Страницу справки можно модифицировать как для всех функционирующих на компьютере Web-сервисов, так и для одного конкретного Web-сервиса. Раздел <xhtmlConformance> В ASP.NET 2.0 раздел <xhtmlConformance> определяет для приложения режим ренде-ринга XHTML. По умолчанию для страниц и элементов управления действует режим XHTML 1.0 Transitional. Он также является используемым по умолчанию для всех новых страниц, создаваемых в Visual Studio 2005. Задавая способ рендеринга в разделе <xhtmlConformance>, вы выбираете один из трех вариантов: XHTML 1.0 Transitional, XHTML1.0 Strict или унаследованный (legacy): <xhtmlConformance mode="Transitional|Legacy|Strict"/> Если выбрана опция Legacy, рендеринг страниц и элементов управления выпол-няется так же, как в ASP.NET 1.x. Другие разделы верхнего уровня Описанными составляющими раздела <system.web> не исчерпывается список конфи-гурационных элементов, которые могут быть полезны разработчику ASP.NET. Вам следует знать по крайней мере еще о трех важных разделах и уметь ими пользоваться. Раздел <appSettings> В разделе <appSettings> хранятся пользовательские конфигурационные данные при-ложения, такие, как пути к файлам, URL, которые имеют то или иное значение для приложения, и другая информация. <configuration> <appSettings> <add key="StockPickerWebServiceUrl" value="..." /> </appSettings> </configuration> Синтаксис раздела <appSettings> таков: <appSettings> <add key="..." value="..." /> <remove key="..." /> <clear /> </appSettings> С помощью элемента <add> к существующему списку добавляется новая установка, ко торая имеет значение и идентифицируется уникальным ключом. Элемент <remove> служит для удаления заданной установки, а воспользовавшись элементом <clear>, можно удалить все установки, определенные ранее в разделе <appSettings>. В ASP.NET 1.x данный раздел обычно используется для хранения строк подклю-чения к базам данных. Однако в ASP.NET 2.0 для этой цели введен специализиро-ванный раздел.
Конфигурация ASP.NET Глава 3 121 Следует избегать хранения в разделе <appSettings> информации, связанной с отдель ными пользователями. В ASP.NET 1.x для работы с ней используется спе-циализированное решение на основе базы данных, а в ASP.NET 2.0 - API пользова-тельского профиля. Имейте также в виду, что любые данные, которые вы хотите хранить в разделе <appSettings>, можно записать во внешний файл, связав его с данным разделом пос-редством атрибута file. <appSettings file="myfile.config" /> Содержимое файла, заданного в атрибуте file, считывается и интерпретируется так, словно оно непосредственно находится в разделе <appSettings> файла web.config. Заметьте, что корневым элементом в данном файле должен быть <appSettings>. Примечание Изменения во внешнем файле не обнаруживаются системой до тех пор, пока приложение не будет перезапущено, тогда как изменения в разделе <appSettings> файла web.config отслеживаются в реальном времени. Раздел <connectionStrings> В .NET Framework 2.0 введен новый раздел конфигурации, специально предназна-ченный для хранения строк подключения. Этот раздел имеет имя <connectionStrings>, его схема приведена ниже: <connectionStrings> <add name="NWind" connectionString="SERVER=...;DATABASE=...;UID=...;PWD=...;" providerName="System.Data.SqlClient" /> </connectionStrings> Содержимым данного раздела можно манипулировать посредством узлов <add>, <remove> и <clear>. Каждая строка подключения идентифицируется именем, назна-ченным ей в атрибуте name. Параметры подключения задаются в атрибуте connection-String. Что касается атрибута providerName, то он указывает, какой провайдер ADO.NET следует использовать для подключения. В ASP.NET 2.0 имена подключений используются также для связи строки подклю-чения с другими разделами конфигурационного файла - как правило, с подразделом <providers> разделов <membership> и <profile>. Раздел <configProtectedData> В ASP.NET 2.0 была введена система защиты важных данных, хранящихся в конфигу-рационных файлах. Она позволяет зашифровать любые разделы конфигурационных файлов, используя стандартную технологию XML encryption. Данная технология (о которой вы можете прочитать по адресу http://www.w3.org/TR/xmlenc-core) пред-назначена для шифрования данных с представлением результатов в XML-формате. До выхода ASP.NET 2.0 защита важнейших разделов конфигурационных файлов осу-ществлялась посредством машинно-зависимого шифрования в реестре. Такой подход вынуждал разработчиков пользоваться для защиты секретных данных, таких как стро ки подключения, мандаты и ключи шифрования, отдельной утилитой. В .NET Framework 2.0 шифрование конфигурационных разделов не является обя-зательным, и вы можете включать и отключать его на уровне отдельных разделов по своему выбору, пользуясь специальной утилитой с интерфейсом командной строки, о которой я расскажу чуть позже. У вас есть возможность задавать тип шифрования, выбирая соответствующий про-вайдер из списка имеющихся провайдеров шифрования. В составе .NET Framework 2.0 
122 Часть I Внутренние механизмы ASP.NET их два: DPAPIProtectedConfigurationProvider и RSAProtectedConfigurationProvider. Пер-вый применяется для шифрования и дешифрации данных Windows DPAPI (Data Protection API - API защиты данных), а второй, используемый по умолчанию, - алго-ритм RSA. Шифрование поддерживается для большинства разделов, обрабатываемых управляемой конфигурационной системой. Однако сам раздел <configProtectedData> не может быть защищен, поскольку для описания поведения системы шифрования требуются установки в форме чистого текста. Подобным же образом разделы, счи-тываемые общеязыковой средой из кода Win32 или из управляемых специальным образом синтаксических анализаторов XML, не могут быть защищены данной сис-темой, поскольку для анализа их конфигурации не используются обработчики. Ска-занное относится как минимум к следующим разделам: <processModel>, <runtime>, <mscorlib>, <startup> и <system.runtime.remoting>. Управление конфигурационными данными Администраторы и разработчики могут управлять конфигурационными данными как программным способом с использованием специализированного API, так и вручную посредством утилит с интерфейсом командной строки, редакторов XML и, возможно, MMC-оснастки ASP.NET. Рассмотрим обе эти возможности. Использование конфигурационного API В составе ASP.NET 2.0 имеется мощный API для управления конфигурациями, в со-став которого входят функции, обеспечивающие чтение и запись конфигурационных файлов приложения, а также навигацию по этим файлам. Наборы конфигурационных установок представлены в программе строго типизированными объектами, которыми очень легко манипулировать. Соответствующие классы - по одному на каждый раздел схемы - определены в пространстве имен System.Configuration. Когда программа модифицирует ту или иную установку, API автоматически вно-сит изменения в соответствующий конфигурационный файл. При этом он способен работать с установками не только локальных, но и удаленных приложений. Пользо-вательские конфигурационные разделы также доступны посредством данного API. Извлечение установок Web-конфигурации Для доступа к конфигурационным файлам ASP.NET используется класс WebConfigurationManager. Он является предпочтительным средством работы с конфигураци-онными файлами, связанными с Web-приложениями. В следующем примере показа-но, как извлекается информация об обработчиках HTTP, используемых в текущем приложении. void Button1_Click(object sender, EventArgs e) { string name = @"system.web/httpHandlers"; Configuration cfg = WebConfigurationManager.OpenWebConfiguration("/"); HttpHandlersSection hdlrs = (HttpHandlersSection)cfg.GetSection(name); EnumerateHandlers(hdlrs, ListBox1); }void EnumerateHandlers(HttpHandlersSection section, ListBox ctl) { foreach (HttpHandlerAction h in section.Handlers) ctl.Items.Add(h.Path); }
Конфигурация ASP.NET Глава 3 123 Вы открываете конфигурационный файл с помощью метода OpenWebConfiguration, указав в его аргументе, на каком уровне вы хотите прочитать информацию. Если задать null или /, данные о конфигурации будут считываться из корневого каталога сайта. Когда требуется информация уровня компьютера, следует прибегнуть к методу OpenMachineConfiguration. Метод OpenWebConfiguration возвращает объект Configuration. Вызвав его метод GetSection, вы сможете извлечь содержимое заданного раздела. Например, для полу-чения сведений об обработчиках HTTP вызов выполняется так: HttpHandlersSection section; section = (HttpHandlersSection) cfg.GetSection(@"system.web/httpHandlers"); Класс каждого раздела имеет индивидуальный интерфейс, представляющий соот-ветствующие атрибуты и дочерние разделы. На рис. 3-4 показан результат выполнения приведенного выше кода. Рис. 3-4. Извлечение списка обработчиков HTTP, используемых в приложении На рисунке вы видите два списка. В первом содержатся все обработчики, видимые на уровне сайта, а во втором - те, что зарегистрированы на уровне приложения. Три дополнительных обработчика, указанных в верхней части второго списка, попали туда благодаря следующему сценарию из файла web.config, находящегося в корневом каталоге приложения: <httpHandlers> <add verb="*" path="myHandler.aspx" type="..." /> <add verb="*" path="*.sqlx" type="..." /> <add verb="*" path="view.axd" type="..." /> </httpHandlers> Для доступа к конфигурационным данным на уровне приложения вы передаете URL этого приложения методу OpenWebConfiguration: string path = Request.CurrentExecutionFilePath; Configuration cfg = WebConfigurationManager.OpenWebConfiguration(path); Содержимое других разделов извлекается точно так же, только нужно задать тре-буемые имена разделов и использовать соответствующие классы. Извлечение установок приложения Класс WebConfigurationManager предназначен для работы с установками, специфи-ческими для приложений ASP.NET. Однако, как уже упоминалось, большинство при ложений ASP.NET нуждаются в доступе к данным разделов, расположенных 
124 Часть I Внутренние механизмы ASP.NET вне элемента <system.web>. Классическими примерами являются <appSettings> и <connectionString>. Для доступа к подобным разделам обычно используется класс ConfigurationManager. Однако и WebConfigurationManager содержит два полезных открытых свойства, посредством которых осуществляется доступ к коллекциям App-Settings и ConnectionStrings. Эти свойства реализованы следующим образом: public static NameValueCollection AppSettings { get {return ConfigurationManager.AppSettings;} }public static NameValueCollection ConnectionStrings { get {return ConfigurationManager.ConnectionStrings;} } Как видите, для доступа к установкам приложения и строкам подключения мож-но по своему выбору использовать коллекции AppSettings и ConnectionStrings класса WebConfigurationManager либо класса ConfigurationManager. Вот, например, как вы-полняется чтение зарегистрированной строки подключения с именем Northwind: WebConfigurationManager.ConnectionStrings["Northwind"].ConnectionString Для доступа к значению, хранящемуся в разделе <appSettings>, используется та-кое выражение: WebConfigurationManager.AppSettings["StockPickerWebServiceUrl"] На тот случай, если вам потребуется информация из других разделов, располо-женных вне <system.web>, класс ConfigurationManager предоставляет метод Open-MachineConfiguration, открывающий доступ к дереву конфигурационных данных. Вот, например, код, извлекающий поддерживаемые префиксы протоколов для Web-запросов (https, http, ftp и т. п.): string name = @"system.net/webRequestModules"; Configuration cfg = ConfigurationManager.OpenMachineConfiguration(); WebRequestModulesSection section; section = (WebRequestModulesSection) cfg.GetSection(name); foreach (WebRequestModuleElement m in section.WebRequestModules) ListBox3.Items.Add(m.Prefix); Обновление установок приложения Для представления содержимого конфигурационного дерева в приложениях исполь-зуется разновидность модели DOM (Document Object Model - объектная модель документа). Это содержимое можно модифицировать в памяти, а по окончании со-хранить с помощью метода Save соответствующего класса Configuration. Следующий пример показывает, как программным путем добавить в текущее приложение новый обработчик HTTP: string name = @"system.web/httpHandlers"; string path = "/proaspnetadv"; Configuration cfg = WebConfigurationManager.OpenWebConfiguration(path); HttpHandlersSection section; section = (HttpHandlersSection)appConfig.GetSection(name); HttpHandlerAction newHandler = new HttpHandlerAction("*.xyz", "System.Web.HttpForbiddenHandler", "*"); section.Handlers.Add(newHandler); cfg.Save();
Конфигурация ASP.NET Глава 3 125 Новый обработчик конфигурирует систему таким образом, чтобы она блокирова-ла запросы файлов с расширением .xyz. При этом модифицируется файл web.config приложения: <httpHandlers> <add path="*.xyz" verb="*" type="System.Web.HttpForbiddenHandler" /> </httpHandlers> На рис. 3-5 показано, что происходит после этого при вводе запроса ресурса .xyz, когда данный запрещающий обработчик активен. Рис. 3-5. Ресурсы с расширением .xyz больше не предоставляются Для того чтобы возобновить предоставление ресурсов с расширением .xyz, необ-ходимо удалить ранее добавленный обработчик. Это можно сделать программным способом: string name = @"system.web/httpHandlers"; string path = "/proaspnetadv"; Configuration cfg = WebConfigurationManager.OpenWebConfiguration(path); HttpHandlersSection section; section = (HttpHandlersSection)cfg.GetSection(name); section.Handlers.Remove("*", "*.xyz"); appConfig.Save(); Теперь любые запросы ресурсов .xyz снова будут выполняться, и останется лишь вероятность того, что пользователь получит более привычное сообщение Resource Not Found. Шифрование раздела За указанными выше (при описании раздела <protectedData> ) исключениями все разделы конфигурационного файла можно шифровать как программным способом, используя конфигурационный API, так и в автономном режиме посредством утилиты с интерфейсом командной строки. Начнем со второй возможности. Для шифрования вы будете пользоваться новейшей версией популярного сис-темного средства aspnet_regiis.exe. Ниже приведен пример его использования для 
126 Часть I Внутренние механизмы ASP.NET шифрования строк подключения приложения /ProAspNetAdv. Заметьте, что имена разделов чувствительны к регистру. aspnet_regiis.exe -pe connectionStrings -app /ProAspNetAdv После выполнения данной команды в файл web.config будут внесены изменения. В разделе <connectionStrings> появится дочерний раздел <EncryptedData> , где и бу-дет храниться зашифрованное содержимое. Если вы откроете данный файл после шифрования, то увидите примерно такой сценарий: <configuration> <connectionStrings configProtectionProvider="RsaProtectedConfigurationProvider"> <EncryptedData ...> <CipherData> <CipherValue>cQyofWFQ... =</CipherValue> </CipherData> </EncryptedData> </connectionStrings> </configuration> Для восстановления файла web.config к его исходному состоянию нужно выполнить команду, аналогичную приведенной выше, но вместо ключа -pe применить ключ -pd. Описанная технология хороша тем, что шифрование абсолютно прозрачно для приложения, в работе которого ничего не меняется. Для программного шифрования и дешифрации разделов используются методы ProtectSection и UnprotectSection объекта SectionInformation. Вот так выполняется шиф-рование: string name = "connectionStrings"; string path = "/proaspnetadv"; string provider = "RsaProtectedConfigurationProvider"; Configuration cfg = WebConfigurationManager.OpenWebConfiguration(path); ConnectionStringsSection section; section = (ConnectionStringsSection) cfg.GetSection(name); section.SectionInformation.ProtectSection(provider); cfg.Save(); Следующий вызов метода UnprotectSection снимает защиту: section.SectionInformation.UnprotectSection(); Заметьте, что для сохранения изменений, как и в предыдущих случаях, следует вызвать метод Save объекта Configuration. Выбор провайдера шифрования Страница с зашифрованными разделами прекрасно работает до тех пор, пока вы запускаете ее на локальном сервере Web, встроенном в Visual Studio 2005. Но при попытке доступа к этой же странице, помещенной в виртуальную папку IIS, вы по-лучите ошибку конфигурации провайдера RSA. Почему так происходит? Для работы провайдера, выполняющего RSA-шифрование, - а именно он исполь-зуется по умолчанию, когда вы шифруете данные посредством утилиты с интерфей-сом командной строки - необходим контейнер ключей. Используемый по умолчанию контейнер ключей создается при инсталляции ASP.NET и носит имя NetFrameWork
Конфигурация ASP.NET Глава 3 127 ConfigurationKey. С помощью утилиты aspnet_regiis.exe с интерфейсом командной строки можно создавать новые контейнеры ключей, удалять их и редактировать. Важно, однако, чтобы контейнер был создан до использования провайдера конфигура-ции, защищенной по методу RSA. Причем контейнер должен не только существовать, но и быть ассоциирован с учетной записью пользователя, от имени которого к нему производится обращение. Системной учетной записи (от имени которой выполня-ется локальный Web-сервер) назначен такой контейнер, но учетная запись ASP.NET на вашем Web-сервере может его не иметь. Если предположить, что вы выполняете ASP.NET с учетной записью NETWORK SERVICE (используемой по умолчанию на компьютерах с Windows Server 2003), то для обеспечения данному пользователю возможности доступа к контейнеру необходимо выполнить следующую команду: aspnet_regiis.exe -pa "NetFrameworkConfigurationKey" "NT AUTHORITY\NETWORK SERVICE" Важно задать полное имя учетной записи, как в приведенном примере. Запомните, что предоставлять доступ к контейнеру ключей необходимо только при использова-нии RSA-провайдера. Провайдеры RSA и DPAPI прекрасно подходят для шифрования важных данных, нуждающихся в защите. Провайдер DPAPI существенно упрощает процесс управ-ления ключами - они генерируются на основе данных о компьютере и доступны всем процессам, которые на этом компьютере выполняются. Но по этой же причине провайдер DPAPI не идеален для защиты разделов на Web-ферме, где один и тот же файл web.config копируется на несколько серверов. В такой ситуации вам придется либо вручную зашифровать данный файл на каждом из серверов, либо скопировать на все серверы один и тот же контейнер ключей. Для этого нужно создать контейнер ключей для приложения, экспортировать его в файл XML, а потом импортировать на каждый сервер, где потребуется расшифровывать файл web.config. Контейнер генери-руется следующей командой (в данном случае использование утилиты с интерфейсом командной строки обязательно): aspnet_regiis.exe -pc YourContainerName -exp Затем вы экспортируете контейнер ключей в XML-файл: aspnet_regiis.exe -px YourContainerName YourXmlFile.xml Далее копируете XML-файл на каждый сервер и импортируете его следующим образом: aspnet_regiis.exe -pi YourContainerName YourXmlFile.xml В заключение нужно предоставить учетной записи ASP.NET разрешение на доступ к контейнеру. Создание пользовательских конфигурационных разделов Предопределенная XML-схема конфигурационных сайтов подходит для большинства случаев, но иногда для сохранения сложной структурированной информации ее не-обходимо дополнить. В такой ситуации у вас будут две альтернативы: либо вместо того чтобы пользоваться стандартным конфигурационным файлом, создать обыкно-венный XML-файл с подходящей вам схемой; либо записать данные в стандартный конфигурационный файл приложения, но создать собственный обработчик раздела для их чтения. Создание нового раздела (плюс, возможно, новой группы разделов) предпола-гает редактирование файла web.config для его (ее) регистрации. При регистрации 
128 Часть I Внутренние механизмы ASP.NET раздела вы задаете его обработчик, то есть программный компонент, который будет отвечать за превращение содержимого раздела в данные, подходящие для обработки. В зависимости от того, какие данные вы собираетесь хранить в этом разделе, можно воспользоваться одним из существующих обработчиков либо создать собственный. В ASP.NET 1.x в качестве обработчика конфигурационного раздела использовался класс, реализующий интерфейс IConfigurationSectionHandler. У этого интерфейса всего один метод - Create, - принимающий в качестве входного параметра поддерево XML-документа в текстовом виде и возвращающий объект, содержащий результаты его синтаксического разбора. В ASP.NET 2.0 обработчиком конфигурационного раздела также является класс, производный от класса ConfigurationSection. В классе обработ-чика определяются открытые свойства, соответствующие атрибутам XML-элемента. Этим свойствам назначается специальный атрибут с именем ConfigurationProperty. Следующий пример показывает, как создать обработчик нового раздела <MyPages> с единственным атрибутом - pageBackColor. public class MyPagesSection : ConfigurationSection { private static readonly ConfigurationProperty propPageBackColor = null; static MyPagesSection() { MyPagesSection.propPageBackColor = new ConfigurationProperty( "PageBackColor", typeof(string), "yellow", ConfigurationPropertyOptions.IsRequired); } [ConfigurationProperty("pageBackColor")] public string PageBackColor { get { return (string) base[MyPagesSection.propPageBackColor]; } set { base[MyPagesSection.propPageBackColor] = value; } } } Соответствие между свойством и атрибутом раздела устанавливается посредством атрибута ConfigurationProperty. В параметре конструктора атрибута свойства задается имя атрибута раздела, которому это свойство соответствует. Для правильной работы пользовательский раздел должен быть зарегистрирован. Вот как это делается: <configuration> <configSections> <section name="myPages" type="ProAspNet20.Components.MyPagesSection, ProAspCompLib" />
Конфигурация ASP.NET Глава 3 129 </configSections> <configuration> Атрибут type элемента <section> определяет класс, который будет использоваться для чтения и записи содержимого регистрируемого раздела. В нашем примере для работы с разделом <myPages> используется класс MyPagesSection, входящий в состав заданной сборки. Если эта сборка строго типизирована и находится в глобальном кэше сборок, следует указать ее полное имя. Применение средств управления В состав ASP.NET 2.0 входит широкий спектр средств управления, которые можно использовать для конфигурирования приложений. В дополнение к Web Site Administration Tool, интегрированному во все версии Visual Studio 2005, к вашим услугам оснастка для MMC и набор утилит с интерфейсом командной строки. Все эти средства считывают конфигурационные файлы и вносят в них изменения. MMC-оснастка ASP.NET Оснастка ASP.NET для Microsoft Management Console содержит специальную стра-ницу свойств, которую IIS Manager отображает при выборе в контекстном меню при-ложения ASP.NET команды Properties. Эта страница показана на рис. 3-6. Рис. 3-6. MMC-оснастка ASP.NET Данная оснастка позволяет изменять версию ASP.NET для любого приложения IIS, а также просматривать и изменять многие типичные установки. Чтобы вывести на экран диалоговое окно, показанное на рисунке, выполните следующие действия. 1. Выберите Administrative Tools/Internet Information Services и откройте MMC-консоль IIS, то есть IIS Manager. 2. Выделите приложение, которое вы собираетесь конфигурировать, и выберите в ме-ню Action либо контекстном меню команду Properties. 3. В окне свойств откройте вкладку ASP.NET. Кнопка Edit Configuration открывает еще одно диалоговое окно (рис. 3-7), где мож-но выбирать установки из разных функциональных областей (управление состоянием, аутентификация, приложение и т. п.). Для модификации установок предоставляется удобный редактор.
130 Часть I Внутренние механизмы ASP.NET Рис. 3-7. Конфигурирование установок приложения ASP.NET, связанных с состоянием сеанса, в оснастке MMC Как только вы щелкнете кнопку Apply, внесенные в редакторе изменения будут записаны в файл web.config. Web Site Administration Tool На рис. 3-8 показан интерфейс утилиты Web Site Administration Tool (WSAT). В ее окне отображаются три вкладки (не считая вкладки Home), представляющие разные области администрирования: защита, установки приложения, провайдеры. Рис. 3-8. Утилита Web Site Administration Tool из Visual Studio 2005
Конфигурация ASP.NET Глава 3 131 WSAT - это независимое приложение, устанавливаемое с Visual Studio 2005 и ASP.NET 2.0. Однако из соображений безопасности оно не открыто для общего доступа через IIS. Представленный на рисунке интерфейс доступен при работе над проектом или приложением Visual Studio 2005. Для того чтобы открыть его из проекта ASP.NET, выберите в меню Website команду ASP.NET Configuration. Вкладка Security утилиты WSAT позволяет управлять всеми параметрами защиты приложения. Вы можете выбрать метод аутентификации, определить пользователей, их пароли, роли и группы пользователей, а также правила управления доступом к определенным частям приложения. Мастер проведет вас по всем этапам создания отдельных пользователей и ролей. На вкладке Application удобно редактировать содержимое раздела <appSettings> файла web.config. Кроме прочего, здесь можно конфигурировать страницы сообщений об ошибках, параметры отладки и электронной почты. Если вы захотите сменить провайдер определенной функции ASP.NET, восполь-зуйтесь вкладкой Provider. Здесь же можно зарегистрировать новый провайдер. Дополнение WSAT пользовательскими вкладками Административная утилита WSAT поставляется с полным исходным кодом, и поэто-му ее функции можно расширять. Исходный код находится в папке %WINDOWS%\Microsoft.NET\Framework\[version]\ASP.NETWebAdminFiles Для расширения функций утилиты WSAT следует добавить в ее окно новую вклад-ку и внести небольшие изменения в существующие вкладки. Давайте посмотрим, как создается вкладка для добавления, удаления и редактирования информации об обработчиках HTTP (рис. 3-9). Рис. 3-9. Пользовательская вкладка в окне утилиты WSAT
132 Часть I Внутренние механизмы ASP.NET Первым делом нужно создать новую вкладку. Для этого добавим в корневой ка-талог утилиты новый подкаталог и назовем его Handlers. В него поместим страницу ASP.NET с именем manageHandlers.aspx и следующей схемой: <%@Page masterPageFile="~/WebAdmin.master" inherits="System.Web.Administration.HandlersPage" %> <%@MasterType virtualPath="~/WebAdmin.master" %> <%@Import Namespace="System.Web.Configuration" %> <script runat="server" language="CS"> public void Page_Load() {}</script> <asp:content runat="server" contentplaceholderid="titleBar"> <asp:literal runat="server" text="<%$ Resources:ConfigureHandlers %>"/> </asp:content> <asp:content runat="server" contentplaceholderid="content"> </asp:content> Страница manageHandlers.aspx основана на той же эталонной странице, что и остальные страницы утилиты WSAT. Выводимый на ней текст считывается из локального файла ресурсов (manageHandlers.aspx.resx), который вам нужно создать в папке App_LocalResources (о специализированных папках ASP.NET я рассказы-вал в главе 1). Далее заполним тело страницы элементами управления и кодом, чтобы получился результат, показанный на рис. 3-9. Вот код базового класса страницы: public class HandlersPage : WebAdminPage { protected override void OnInit(EventArgs e) { NavigationBar.SetSelectedIndex(4); base.OnInit(e); } } "Волшебное число" 4 в приведенном коде является индексом вкладки в прило-жении WSAT. Оно указывает, что в окне будет выделена пятая вкладка - добавлен-ная нами. Это единственное изменение, которое вам нужно внести в базовый класс WebAdminPage. У данного класса имеется также открытое свойство ApplicationPath, которому присваивается путь к конфигурируемому приложению. Данная строка важна для программного доступа к конфигурационному дереву. Для того чтобы связать новую страницу с остальной инфраструктурой программы WSAT, нужно внести изменения в файлы default.aspx и navigationBar.ascx, расположен-ные в корневом каталоге программы. Default.aspx - это начальная страница WSAT; на ней, как видно на рис. 3-10, расположены ссылки на вкладки. Они отформатированы в виде таблицы HTML. Вам необходимо добавить в эту таблицу новую строку: <tr class="gridRowStyle8"> <td> <a id="ProviderLink" href="handlers/chooseHandlers.aspx">
Конфигурация ASP.NET Глава 3 133 <asp:literal runat="server" text="<%$ Resources: HandlersConfig %>"/></a> </td> <td> <asp:literal runat="server" text="<%$ Resources: EnablesHandlers %>"/> </td> </tr> В таблице используется текст из файла ресурсов страницы. Поэтому нужно также внести изменения в файл default.aspx.resx, расположенный в папке App_LocalResources программы WSAT. Пользовательский элемент управления navigationBar создает вкладки, считывая соответствующую информацию из массива. Для добавления еще одной вкладки нуж но модифицировать исходный код, дополнив массив соответствующим элементом. Примечание Если вы захотите модифицировать программу WSAT, не забудьте вначале создать резервную копию всего ее каталога. Рис. 3-10. Новая начальная страница программы WSAT Утилиты с интерфейсом командной строки Разработчики приложений ASP.NET 2.0 часто пользуются двумя утилитами с интер-фейсом командной строки - aspnet_regsql и aspnet_regiis. Обе они устанавливаются в папку %WINDOWS%\Microsoft.NET\Framework\[версия] Утилита aspnet_regsql.exe конфигурирует ряд сервисов, управляющих состоянием сеанса, членством, пользовательскими профилями и кэшем SQL - это те сервисы, ко-торые могут использовать базу данных SQL Server. Каждый из них требует, чтобы база данных была определенным образом сконфигурирована: для нее должны быть опреде-лены необходимые разрешения, и она должна быть заранее заполнена необходимыми данными. Утилиту aspnet_regsql.exe можно использовать либо в режиме командной строки, либо посредством мастера. Если вы предпочитаете работать с интерфейсом 
134 Часть I Внутренние механизмы ASP.NET мастера, запустите утилиту без параметров. В противном случае запросите список поддерживаемых ключей командной строки такой командой: aspnet_regsql -? Утилита aspnet_regiis.exe используется для установки и деинсталляции определен-ных версий ASP.NET. Можно также использовать ее для шифрования конфигу ра-ционных разделов, но только в ASP.NET 2.0. Заметьте, что каждая версия ASP.NET включает свою версию aspnet_regiis. Рассмотрим некоторые типичные случаи ее применения. aspnet_regiis -s W3SVC/1/ROOT/имя_приложения Данная команда конфигурирует приложение IIS для работы с определенной вер-сией ASP.NET, поддерживаемой утилитой aspnet_regiis. Приложение следует иден-тифицировать его полным путем, заданным в метабазе IIS. aspnet_regiis -lv Эта команда выводит список всех версий ASP.NET, установленных на данном компьютере. aspnet_regiis -i Данная команда инсталлирует версию ASP.NET, поддерживаемую утилитой. Заключение Приложение ASP.NET имеет много конфигурационных параметров. Соответствующие установки можно задавать, переопределять, дополнять или ограничивать на разных уровнях. Конфигурация ASP.NET является иерархической и позволяет задавать на каждом уровне детализации (компьютера, Web-сайта, приложения и даже отдельной папки) свои конфигурационные установки. При развертывании приложений ASP.NET конфигурационные файлы требуют, пожалуй, наибольшего внимания. И хотя подготовка инсталляционной программы никогда еще не выполнялась так просто, как в Visual Studio .NET (если не учиты-вать продукты сторонних производителей), репликация установок среды разработки по-прежнему остается нетривиальной задачей. Приложения ASP.NET могут развер-тываться не только на единственном компьютере, принадлежащем владельцу сайта, но и на Web-ферме или у интернет-провайдера, - в таких случаях требуется особая стратегия в отношении файлов machine.config и web.config. Тем не менее развертыва-ние приложений ASP.NET выполняется быстрее и эффективнее, чем раньше. Только факты Конфигурационная система ASP.NET строит в памяти дерево конфигурационных данных и использует его при управлении выполнением приложений. Схема конфигурационных файлов является расширяемой и одинакова для всех типов приложений .NET Framework. В любой конфигурационный файл можно добавлять пользовательские разделы. Каждый раздел ассоциируется с особым программным компонентом - обработчиком раздела, - отвечающим за синтакси-ческий разбор XML-данных и возврат данных, подходящих для обработки. В файле machine. config содержатся установки уровня компьютера, совмест-но используемые всеми приложениями, установленными на данном серверном компьютере. 
Конфигурация ASP.NET Глава 3 135 В разделе <system.web> объединяются все установки, относящиеся к приложению ASP.NET, - связанные с состоянием сеанса, компиляцией, защитой, обработчика-ми HTTP и т. д. Любой раздел конфигурационного файла может быть зашифрован с использова-нием технологии XML encryption. Однако шифрование не является обязательным и полностью прозрачно для кода приложения. Строки подключения хранятся в специально предназначенном для них разделе, благодаря чему решается старая проблема Web-приложений. Вы имеете возможность редактировать конфигурацию ASP.NET программным способом, используя специальный API, предназначенный для управления ASP. NET, а также посредством различных утилит, к числу которых относятся WSAT, оснастка MMC и утилиты с интерфейсом командной строки. 
Глава 4 Создание пользовательских провайдеров ASP.NET Модель провайдеров - один из самых мощных и интригующих элементов ASP.NET 2.0. Основанная на классических принципах объектно-ориентированного программирова-ния, таких как наследование и полиморфизм, эта модель дает разработчикам возмож-ность заменять и совершенствовать встроенные компоненты ASP.NET, а также делать заменяемыми и настраиваемыми компоненты собственных приложений. Когда та или иная функция системы, такая, например, как управление членством, состоянием или пользовательскими профилями, реализована в виде провайдера, это означает, что для нее определен стандартный API, не зависящий от ее внутренней реализации. Такое решение превращает эту функцию в заменяемый компонент, смена которого прозрачна для системы и приложений. Разработчику приложений достаточно изучить ее стандартный API и пользоваться им независимо от того, как реализованы внутренние особенности этой функции. Для каждой из стандартных функций ASP.NET, реализующих модель провайдера, в этой системе имеется один или несколько стандартных провайдеров, один из которых является используемым по умолчанию. Настраивая среду выполнения приложения ASP.NET при помощи конфигурационных файлов, вы можете выбрать для каждой функ-ции системы тот провайдер, который лучше подходит для нужд данного приложения. Более того, ASP.NET позволяет разрабатывать собственные провайдеры стандарт-ных функций системы. Для этой цели в ней определен набор базовых провайдерных классов, от которых можно производить собственные классы, переопределяя в них те или иные методы. Если, к примеру, вы захотите изменить схему данных, исполь-зуемую для хранения информации о предпочтениях пользователей, и сохранять эти данные, скажем, в базе данных Oracle или DB2, причем в зашифрованном виде, а не в виде открытого текста - вам достаточно будет написать собственный провайдер пользовательских профилей. Однако область применения модели провайдеров не ограничивается встроенными сервисами ASP.NET. На ней может быть основан и пользовательский сервис приложе-ния - в таком случае под маской его открытого интерфейса, ничем не отличающегося от интерфейса любого другого сервиса, будет скрываться настраиваемый компонент. Применение модели провайдеров при разработке собственного приложения - это простой, элегантный и эффективный способ сделать некоторые его части заменяе-мыми и настраиваемыми. Я подробно опишу структуру провайдеров ASP.NET, а затем продемонстрирую, как можно создать собственный провайдер для хранения информации пользователь-ского профиля. Примечание В этой главе будет приведен только один пример написания пользова-тельского провайдера для встроенного сервиса ASP.NET - сервиса пользовательских про филей. Более углубленный обзор данной темы и дополнительные примеры вы найдете в до кументе "ASP.NET 2.0 Providers", доступном по адресу http://msdn.microsoft.com/asp.net/downloads/providers/.
Создание пользовательских провайдеров ASP.NET Глава 4 137 Схема модели провайдеров Инфраструктура провайдеров в ASP.NET спроектирована таким образом, чтобы раз-работчики могли расширять и заменять некоторые стандартные функциональные компоненты системы, в частности модуль управления пользовательскими профилями, членством и т. д. Общая схема модели провайдеров показана на рис. 4-1. Рис. 4-1. Общая схема модели провайдеров ASP.NET Основной код ASP.NET подключается к сервису, например, пользовательского профиля, для выполнения определенной операции, скажем, загрузки сведений о пред-почтениях пользователя. Этим сервисом является компонент, реализующий хорошо известный интерфейс. Обмен данными с основным кодом, который знает только имя и местоположение компонента, происходит полиморфически. Компонент, пре-доставляющий сервис, то есть провайдер, может быть заменен другим компонентом, выполняющим аналогичные функции, - либо поставляемым вместе с ASP.NET, либо созданным разработчиком или сторонним производителем. Не кажется ли вам эта схема знакомой? Что-то такое вы уже слышали, не так ли? Не удивительно - ведь решение не ново, и аналогичные схемы применяются при раз-работке программного обеспечения уже давным-давно. Давайте рассмотрим отдельные архитектурные принципы, которые вы (возможно, неосознанно) уже использовали при работе с провайдерами ASP.NET. Примечание И ASP.NET, и Microsoft Windows Forms основаны на модели провайдеров, правда, примененной к разным, практически не пересекающимся, областям. В ASP.NET эта модель используется в таких важнейших сервисах, как сервисы членства и персона-лизации, но не используется для управления параметрами приложения. В Windows Forms, напротив, она применяется только для хранения установок, связанных с пользователем и приложением. Архитектурные модели Модель провайдеров позволяет разработчикам ASP.NET, изучив единственный API, программировать сервисы независимо от того, как конкретный сервис взаимодей-ствует с остальной частью системы и с различными уровнями хранения данных. Это 
138 Часть I Внутренние механизмы ASP.NET возможно благодаря применению в ASP.NET популярной архитектурной модели, именуемой поведением. Примечание Существует бессчетное количество книг, периодических изданий и сайтов, где описываются разные архитектурные модели, как в контексте .NET и ASP.NET, так и в общем контексте разработки программного обеспечения. При таком обилии инфор-мации главная трудность заключается в том, чтобы найти тот источник, который вам требуется, а именно содержащий необходимые сведения и написанный на доступном для вас уровне. Когда речь идет об архитектурных моделях, я предпочитаю сайт http://www. dofactory.com. Модель "поведение" Согласно данной модели необходимое внешнее поведение программного компонента может быть реализовано с использованием различных взаимозаменяемых алгоритмов. Такое поведение реализуется в виде стандартного API, известного всем приложени-ям, в которых используется данный компонент, и не зависит от выбора конкретного алгоритма. При этом для каждого приложения выбирается тот алгоритм, который в наибольшей степени отвечает его нуждам. В применении к сервисам ASP.NET, таким как сервис управления пользователь-скими профилями, реализация данной модели позволяет изолировать от страницы код чтения и записи данных о предпочтениях пользователя, инкапсулировав этот код в заменяемом компоненте, и предоставить странице требуемые функции посредством стандартного, неизменного API. Наиболее примечательной особенностью модели "поведение" является то, что она описывает абстрактный способ представления объектом или целой подсистемой их функций вовне, благодаря чему клиент имеет возможность отключить одну стан-дартную реализацию и подключить другую. Именно так обстоит дело в ASP.NET со многими сервисами, в том числе сервисами членства, ролей, состояния, пользователь-ских профилей и навигации по сайту. Таким образом, в модели провайдеров ASP.NET воплощена модель "поведение". Модель "адаптер" Будучи реализованной в исполняющей среде, модель "поведение" дает разработчи-кам ASP.NET возможность заменять базовый алгоритм, сохраняя общее поведение приложения и системы. Однако у модели провайдеров есть и другие заслуживающие упоминания преимущества. Представьте себе, что вы вырабатываете собственную стратегию замены определенного сервиса - пусть это, опять-таки, будет сервис уп-равления пользовательскими профилями. Какой код вы собираетесь написать для пользовательского провайдера? Может быть, вас просто не устраивает используемый по умолчанию слой хранения и вы хотите, скажем, заменить его собственной таблицей базы данных. Или, возможно, вы решили не возиться с базами данных и использовать обыкновенный XML-файл либо даже системный реестр. В любом случае вы просто пишете новый код, соответс-твующий вашим требованиям. Но что если перед вами стоит другая задача - перенести существующее прило-жение на платформу ASP.NET 2.0? Возможно, у вас уже есть некоторый подходящий код - например, созданная ранее подсистема персонализации. Тогда вы либо выбро-сите весь этот код (несмотря на затраченное время и деньги), либо адаптируете его к новой модели, предлагаемой ASP.NET 2.0 для данного сервиса. Сделать это вам поможет другая популярная модель, под названием адаптер.
Создание пользовательских провайдеров ASP.NET Глава 4 139 Целью адаптерной модели является снабжение класса А интерфейсом Б, понятным клиенту В. Вы заключаете существующий код в оболочку - новый провайдерный класс, бесшовно интегрируемый в существующую архитектуру ASP.NET 2.0. Таким образом вы можете, например, изменить внутреннюю реализацию API персонализа-ции ASP.NET, чтобы он, при неизменном высокоуровневом интерфейсе, работал с дру-гим хранилищем данных да еще и повторно использовал существующий код. Модель "фабрика" Как было продемонстрировано в главе 3, в определенных местах конфигурационного дерева можно регистрировать пользовательские провайдеры различных сервисов ASP.NET и указывать, какой из провайдеров будет использоваться по умолчанию. Экземпляр класса этого провайдера исполняющая среда ASP.NET создает во время выполнения. В результате для страницы ASP.NET создается объект, о котором ей заранее ничего не было известно. Такая модель называется фабрикой. Детали реализации В ASP.NET 2.0 каждый провайдер представляет собой класс, наследующий некий базовый класс, но переопределяющий его поведение. Для создания собственного провайдера заданного сервиса вы определяете новый класс, наследующий базовый класс, определенный для провайдера этого типа. Все провайдеры поддерживаемых сервисов являются производными от одного базового класса с именем ProviderBase (рис. 4-2). Рис. 4-2. Иерархия классов провайдеров ASP.NET Провайдер ASP.NET состоит из трех элементов - базового класса, конфигурацион-ного слоя и слоя хранения. Базовый класс реализует основные функции провайдера, главным образом в виде абстрактных методов, которые вы можете переопределять. Конфигурационный слой предоставляет информацию, используемую для идентифи-кации провайдера и необходимую ASP.NET для создания его экземпляра. Наконец, слой хранения - это физическое хранилище данных, используемое провайдером для сохранения тех или иных данных приложения. Им может быть таблица базы данных, XML-файл или любой другой подходящий контейнер.
140 Часть I Внутренние механизмы ASP.NET Базовый класс Базовый класс провайдеров реализует ключевые функции, обещанные интерфейсом сервиса. Например, базовый класс сервиса пользовательского профиля определяет два метода: GetPropertyValues и SetPropertyValues (см. рис. 4-2). Первый должен возвращать значения, составляющие текущий профиль пользователя, а второй сохранять заданные в запросе новые значения профиля. Клиенту - странице ASP.NET - не нужно ничего знать о подробностях реализации провайдера. Как уже упоминалось, базовые классы всех провайдеров наследует один и тот же класс ProviderBase. Этот класс содержит переопределяемый метод Initialize, посредс-твом которого исполняющая среда передает провайдеру необходимые установки, прочитанные из конфигурационного файла. Каждый сервис, основанный на модели провайдеров, имеет собственный, более специализированный базовый класс, обычно непосредственно наследующий ProviderBase. Вам следует иметь в виду, что схема, приведенная на рис. 4-2, несколько упрощена. Класс ProfileProvider не произведен не-посредственно от ProviderBase. Он наследует SettingsProvider, который, в свою очередь, наследует ProviderBase. Мы еще вернемся к этому вопросу в данной главе. Конфигурационный слой Каждому поддерживаемому типу провайдеров назначается раздел конфигурационного файла, где задается провайдер, используемый для реализации данной функции по умолчанию, и перечисляются все доступные ее провайдеры. (О конфигурационных файлах подробно рассказывалось в главе 3.) Если провайдер имеет открытые свойства, их используемые по умолчанию значения можно задавать посредством атрибутов. Содержимое раздела конфигурационного файла передается в качестве аргумента методу Initialize класса ProviderBase - единственному методу, общему для всех про-вайдеров. В этом методе каждый провайдер использует полученную информацию для инициализации своего состояния. Слой хранения Всем провайдерам нужно записывать информацию в постоянную память и считывать ее оттуда. Во многих случаях два провайдера одного типа отличаются только тем, где они хранят свои данные. Информация о хранилище содержится в атрибутах провай-дера в разделе <providers>. Например, провайдер SqlProfileProvider, представленный на рис. 4-2, - это предопределенный провайдер профилей, использующий для хране-ния своих данных таблицу Microsoft SQL Server 2005 Express с именем aspnetdb.mdf. Далее в этой главе мы создадим пользовательский провайдер, работающий с другой таблицей и схемой. Подобный провайдер часто приходится создавать при переносе кода, написанного для ASP.NET 1.x, на платформу ASP.NET 2.0. Заметьте: провайдер может выполнять свою работу лишь при наличии необходи-мой инфраструктуры - базы данных, таблицы, отношений, файлов. Ее подготовка обычно осуществляется во время разработки. Примечание Провайдеры - новый элемент ASP.NET 2.0. Однако концепция, положенная в основу модели провайдеров, не нова и широко используется. Вы можете применить ее и для усовершенствования сервисов, предоставляемых приложениями ASP.NET 1.x. В ASP.NET 1.x нет системных сервисов, основанных на модели провайдеров, однако пользовательские сервисы, реализуемые для приложений ASP.NET 1.x, могут быть раз-работаны таким образом, чтобы они поддерживали настройку с использованием провай-деров. Дополнительную информацию по этому вопросу и примеры кода вы найдете по адресу http://msdn.microsoft.com/asp.net/beta2/providers.
Создание пользовательских провайдеров ASP.NET Глава 4 141 Встроенные провайдеры ASP.NET Модель провайдеров используется в ASP.NET для выполнения целого ряда задач, среди которых наиболее важными являются следующие: реализация механизма чтения-записи для работы с пользовательскими профилями; создание пользовательского репозитария учетных записей пользователей, подде-рживающего необходимые операции, такие как проверка существования пользо-вателя, добавление и удаление пользователей, изменение паролей; создание пользовательского репозитария для ролей пользователей; определение карты сайта; введение новых типов хранилищ для данных состояния сеанса. Список сервисов провайдерного типа и соответствующих классов, доступных в ASP.NET 2.0, приведен в табл. 4-1. Табл. 4-1. Базовые классы провайдеров ASP.NET Сервис Базовый класс Описание Членство и учетные записи пользователей MembershipProvider Базовый класс провайдеров членства, используемых для управления учетны-ми записями пользователей Персонализация Web Parts PersonalizationProvider Базовый класс провайдеров, управля-ющих персонализацией компонентов Web Parts Пользовательские профили ProfileProvider Базовый класс провайдеров персонали-зации, используемых для сохранения и восстановления информации пользо-вательских профилей Защищенный конфи-гурационный раздел ProtectedConfigurationProvider Базовый класс провайдеров шифрова-ния, используемых для шифрования ин-формации в конфигурационных файлах Управление ролями RoleProvider Базовый класс провайдеров ролей, используемых для управления инфор-мацией о ролях пользователей Управление состоянием сеанса SessionStateStoreProviderBase Базовый класс провайдеров состояния сеанса, используемых для сохранения и восстановления данных состояния Карта сайта и навигация SiteMapProvider Базовый класс провайдеров карты сайта, осуществляющих управление ее информацией События Web и мони торинг состояния сис темы и приложения WebEventProvider Базовый класс провайдеров мони то рин-га состояния системы и приложе ния, обрабатывающих системные события Классы, перечисленные в табл. 4-1, содержат абстрактные методы, отражающие все настраиваемые аспекты представляемых ими функций. Возьмем, к примеру, провай-деры пользовательских профилей. В составе класса ProfileProvider имеются методы GetPropertyValues и SetPropertyValues. При этом сам класс ProfileProvider является абстрактным и в программном коде никогда не используется. Приложения работают с классами конкретных провайдеров, производными от ProfileProvider, такими как SqlProfileProvider. Сказанное верно и в отношении провайдеров других типов. 
142 Часть I Внутренние механизмы ASP.NET Если вы намереваетесь написать пользовательский провайдер для замены одного из стандартных провайдеров ASP.NET 2.0, то вам нужно создать класс, производный от одного из перечисленных в таблице. Рассмотрим эти базовые классы подробнее. Сервис членства Провайдер членства определяет контракт, реализуемый ASP.NET для предоставления приложениям сервиса членства. В этом контракте предусмотрены методы для провер-ки учетных записей пользователей, изменения и сброса паролей, а также создания, поиска и удаления учетных записей. Помимо проверки учетных записей и управления ими провайдер членства вы-полняет дополнительные функции, связанные с управлением паролями. Вы можете определить минимальную длину пароля, количество обязательных знаков препинания, формат хэш-значений и даже регулярное выражение для проверки допустимости па-ролей. Кроме того, предусмотрена возможность включения и отключения функций сброса и восстановления паролей, а также связывания этих функций со встроенной реализацией протокола "вопрос-ответ". Наконец, провайдер обеспечивает защиту от подбора паролей: пользователям разрешено предпринимать лишь ограниченное количество попыток ввода пароля за определенный промежуток времени. Внимание! Все методы и свойства, составляющие контракт провайдера, помечаются как абстрактные. Это означает, что данные члены должны быть реализованы пользователь-скими провайдерами; однако некоторые провайдеры могут содержать пустые реализации отдельных членов или выбрасывать исключение "not supported". Сказанное верно для всех типов провайдеров. Базовым классом провайдеров членства является класс MembershipProvider. В соста-ве ASP.NET имеются два предопределенных провайдера членства: SqlMembershipProvider и ActiveDirectoryMembershipProvider. Они оба определены в пространстве имен System.Web.Security. Провайдер SqlMembershipProvider Функциями провайдера SqlMembershipProvider являются сохранение информации о членстве в специальных таблицах базы данных aspnetdb.mdf SQL Server 2005 Express и чтение оттуда этой информации. Указанную базу данных можно создать, запустив из командной строки утилиту aspnet_regsql.exe (см. главу 3). В качестве альтернативы можно использовать инструмент Web Site Administration Tool (WSAT), доступный в Microsoft Visual Studio 2005 через меню Website. Созданная вами база данных aspnetdb будет содержать как минимум следую-щие таблицы: aspnet_Applications, aspnet_Membership, aspnet_SchemaVersions и asp net_Users. Убедитесь, что учетной записи рабочего процесса ASP.NET (обычно это NT AUTHORITY/NETWORK SERVICE) предоставлен полный доступ к базе данных aspnetdb. Совет Изменив строку подключения в файле web.config приложения, можно сделать так, чтобы SqlMembershipProvider работал с базой данных SQL Server 2000 или SQL Server 2005 - при условии, что схема ее таблиц останется прежней. SQL Server 2005 Express рекомендуется использовать для маленьких приложений на сайтах, предназначаемых для Интернета, а также в тех случаях, когда просто хочется поэкспериментировать. Это верно в отношении любых провайдеров, использующих базу данных aspnetdb.mdf.
Создание пользовательских провайдеров ASP.NET Глава 4 143 База данных aspnetdb Базой данных aspnetdb. mdf пользуются все встроенные провайдеры ASP.NET 2.0, работающие с SQL Server. Как прикладному программисту вам не нужно детально знать внутреннюю структуру этой базы данных, поскольку встроенные провайдеры делают ее абсолютно прозрачной. Однако краткий обзор ее таблиц все же будет по-лезен - он станет источником вдохновения, если однажды вы задумаете написать альтернативу встроенной системе хранения. На рис. 4-3 представлена схема базы данных aspnetdb.mdf в Server Explorer. Для доступа к элементам, которые вы здесь видите, достаточно дважды щелкнуть файл в Solution Explorer. Рис. 4-3. Содержимое базы данных aspnetdb Таблицы базы данных aspnetdb перечислены в табл. 4-2. Большинство из них свя-заны с конкретными провайдерами. Табл. 4-2. Таблицы базы данных aspnetdb Таблица Содержимое aspnet_Applications Перечень приложений, использующих базу данных aspnet_Membership Информация о членстве пользователей приложений; перечень пользователей хранится в таблице aspnet_Users, а перечень приложений - в таблице aspnet_Applications aspnet_Paths Пути к страницам, использующим Web Parts aspnet_PersonalizationAllUsers Информация о структуре страниц приложений, использующих Web Parts, относящаяся ко всем пользователям. Пути к страницам находятся в таблице aspnet_Paths aspnet_PersonalizationPerUser Относящаяся к конкретным пользователям информация о структуре страниц приложений, использующих Web Parts. Пути к страницам находятся в таблице aspnet_Paths, а пользователи перечислены в таблице aspnet_Users aspnet_Profile Данные профиля для каждого из пользователей. Пользователи определены в таблице aspnet_Users и распределены по прило-жениям, перечисленным в таблице aspnet_Applications aspnet_Roles Список всех доступных ролей aspnet_SchemaVersions Информация о версиях схемы таблиц, поддерживаемых каждой функцией (см. след. стр.)
144 Часть I Внутренние механизмы ASP.NET Таблица Содержимое aspnet_Users Перечень всех зарегистрированных пользователей. Данная таблица совместно используется всеми провайдерами, кото-рым требуется информация о пользователях aspnet_UsersInRoles Информация о соответствии между пользователями и ролями aspnet_WebEvent_Events Сведения о запротоколированных событиях Web Как видите, некоторые таблицы являются общими для всех провайдеров или их части. Например, имена пользователей, хранящиеся в таблице aspnet_Users, считы-ваются всеми провайдерами, так или иначе связанными с пользователями - про-вайдерами членства, профилей, ролей, персонализации Web Parts. Для примера рас-смотрим, что произойдет при добавлении нового пользователя посредством провай-дера членства. Сначала этот провайдер создаст в таблице aspnet_Users новую запись (с GUID и именем пользователя), а затем добавит соответствующую запись в таблицу aspnet_Membership, куда запишет информацию о членстве пользователя (такую как адрес электронной почты, пароль и различные установки). Каждый встроенный провайдер, базирующийся на SQL Server, поддерживает оп-ределенные версии схемы. В таблице aspnet_SchemaVersions содержится по одной записи для каждого сервиса, реализуемого в форме провайдера (членства, профилей и т. д.), со строковым столбцом, в котором указывается поддерживаемая версия схемы (1.0, 1.1, 2.0 и т. д.), и булевым столбцом, где указано, является ли схема, определен-ная в этой записи, текущей. Сервису может соответствовать несколько записей этой таблицы, если разным версиям его провайдеров требуются разные схемы таблиц базы данных. Код встроенных провайдеров проверяет версию схемы перед выдачей первой SQL-команды, а затем выбрасывает исключение, если схема не соответствует его ожиданиям. Примечание Функция работы с версиями схемы поддерживается всеми встроенными провайдерами ASP.NET, использующими базы данных aspnetdb.mdf. Если вы напишете пользовательский провайдер, то, возможно, захотите реализовать аналогичную функцию для своего хранилища. Приведенную в этом подразделе информацию следует также при-нять во внимание, если по какой-то причине вам придется создавать пользовательский провайдер, использующий в качестве хранилища данных aspnetdb.mdf. Примером может служить сервис работы с картой сайта - единственный, для которого нет провайдера, использующего SQL Server. Но, разумеется, это просто пример. Провайдер ActiveDirectoryMembershipProvider Провайдер ActiveDirectoryMembershipProvider управляет хранением информации о членстве в Active Directory и Active Directory Application Mode (ADAM). При его использовании в файле web.config нужно задать строку подключения и учетную запись пользователя, необходимые для получения доступа к серверу Active Directory. Если вы не зададите учетную запись в файле web.config, Active Directory будет использовать учетную запись рабочего процесса ASP.NET. Но в любом случае позаботьтесь о том, чтобы учетная запись имела в Active Directory необходимые разрешения. Заметьте, что любые установки защиты, задаваемые на уровне провайдера Active Directory, обязательно должны сверяться с установками самой Active Directo ry. Напри-мер, Active Directory принимает только такие пароли, которые содержат более шести символов и включают небуквенные знаки. Теоретически можно скон фи гурировать провайдер Active Directory так, чтобы он принимал, скажем, шестисимвольные па-роли. Однако, устанавливая пароль для определенной учетной записи, провайдер Табл. 4-2. (окончание)
Создание пользовательских провайдеров ASP.NET Глава 4 145 вначале сверит его со своими установками, а затем передаст Active Directory. Если пароль не будет соответствовать требованиям Active Directory, операция завершится неудачей. Таким образом, в любом случае будет применяться более строгая политика безопасности. Заметьте, что провайдер Active Directory, согласно своему контракту, поддерживает блокировку учетных записей. Он отслеживает количество неудачных попыток ввода пароля, предпринятых за определенный период времени, и блокирует пользователя, если тот пытается ввести пароль большее число раз. Блокировка учетной записи препятствует получению пользователем доступа к приложениям, защищенным Active Directory - мощной системой управления членством. Однако учетная запись такого пользователя остается действующей в Active Directory, и он по-прежнему может ис-пользовать ее для входа в Windows. Active Directory в нескольких доменах Провайдер ActiveDirectoryMembershipProvider можно использовать и в том случае, когда в сети определено несколько доменов, причем, что интересно, в его работе ровным сче-том ничего не меняется. Фокус заключается в том, что в раздел <membership> файла web.config вносится несколько записей, аутентифицирующих каждого пользователя для соответствующего контроллера домена. Предположим, у вас имеются два домена, для каждого из которых в разделе <connectionStrings> задана строка подключения, указывающая на определенную базу данных. <connectionStrings> <add name="TestDomain1ConnString" connectionString="LDAP://TestDomain1.com/CN=Users,DC=..." /> <add name="TestDomain2ConnString" connectionString="LDAP://TestDomain2.com/CN=Users,DC=..." /> </connectionStrings> В таком случае, используя приведенный ниже код, вы определяете для каждого домена свой экземпляр провайдера Active Directory. В каждой записи задается имя строки подключения и, возможно, имя учетной записи пользователя, имеющего раз-решения администратора. Нет нужды говорить, что вы можете зашифровать раздел <providers>, если в нем будут содержаться пароли. <providers> <add name="TestDomain1" type="System.Web.Security.ActiveDirectoryMembershipProvider, ..." connectionStringName="TestDomain1ConnString" connectionUsername="TestDomain1\Admin" connectionPassword="..." /> <add name="TestDomain2" type="System.Web.Security.ActiveDirectoryMembershipProvider, ..." connectionStringName="TestDomain2ConnString" connectionUsername="TestDomain2\Admin" connectionPassword="..." /> </providers> Вы спрашиваете, что произойдет, когда пользователь попытается подключиться к странице, защищенной провайдером членства Active Directory? Этому пользовате-лю необходимо будет указать домен и страницу входа. Вы можете либо добавить на страницу дополнительное текстовое поле для ввода имени домена, либо потребовать, чтобы пользователь вводил имя учетной записи в форме домен/имя_пользователя, 
146 Часть I Внутренние механизмы ASP.NET а затем выделять из него соответствующие части. Выяснив, к какому домену относится пользователь, вы изменяете код проверки, выполняемой на странице входа: //Эти переменные инициализируются содержимым //элементов управления страницы входа string userName = "..."; string pswd = "..."; string domainName = "..."; MembershipProvider domainProvider; if (domainName == "TestDomain1") domainProvider = Membership.Providers["TestDomain1"]; else if (domainName == "TestDomain2.test.com") domainProvider = Membership.Providers["TestDomain2"]; //Проверяем пользователя //в системе членства if (domainProvider.ValidateUser(userName, pswd) { }В каких случаях требуется замена провайдера Обычно пользовательский провайдер имеет смысл писать в том случае, если вы хотите хранить информацию о членстве в таблице SQL Server с другой схемой, в другой базе данных или же в другой СУБД, такой как Oracle или DB2. Кроме того, пользователь-ский провайдер пишется при интеграции существующего приложения ASP.NET 1.x в новое решение ASP.NET 2.0. А еще необходимость в пользовательской системе управления членством возникает в тех случаях, когда требуется выполнить аутентификацию посредством провайдера, не поддерживающего LDAP (Lightweight Directory Access Protocol - легковесный протокол доступа к каталогу), локального либо удаленного Web-сервиса или же поль-зовательского алгоритма. Сервис управления ролями Применяемая в ASP.NET модель ролей упрощает реализацию приложений, которым требуется авторизация пользователей. Сама по себе роль - всего лишь логический атрибут, присвоенный пользователю и указывающий на логическую роль этого поль-зователя в контексте приложения. Информация роли обычно присоединяется к иден-тификационному объекту, чтобы код приложения мог прочесть ее перед выполнением критических операций. В ASP.NET сервис управления ролями просто поддерживает связи между учетными записями пользователей и соответствующими ролями. Для выполнения операций ввода-вывода сервис управления ролями использует мо-дель провайдера и провайдерный компонент. Контракт интерфейса этого провайдера включает методы для создания и удаления ролей, назначения ролей пользователям и пользователей ролям, поиска пользователей, которым назначена определенная роль, и проверки существования ролей. Базовым классом провайдера ролей является RoleProvider. В ASP.NET 2.0 имеются три его реализации: SqlRoleProvider, WindowsTokenRoleProvider и AuthorizationStore-RoleProvider. Все они определены в пространстве имен System.Web.Security. Класс SqlRole Provider - используемый по умолчанию провайдер ролей - хранит связи меж-
Создание пользовательских провайдеров ASP.NET Глава 4 147 ду ролями и пользователями в упоминавшейся выше базе данных aspnetdb.mdf SQL Server 2005 Express. Примечание Вы имеете возможность просматривать и редактировать содержимое фай-ла aspnetdb.mdf, используя утилиту WSAT или Server Explorer из Visual Studio 2005. Провайдер WindowsTokenRoleProvider WindowsTokenRoleProvider - это провайдер ролей, использующий для получения сведений о пользователях информацию из системы групп безопасности Windows. Он предназначен в первую очередь для интранет-приложений ASP.NET, в которых применяется аутентификация Windows и запрещен анонимный доступ. Возвраща-емая провайдером информация о ролях пользователя основана на его членстве в определенной группе Windows. Данный провайдер нельзя использовать для созда-ния и удаления ролей. Не поддерживает он и модификацию связей между ролями и пользователями, поскольку данная функциональность реализуется в операционной системе Windows. Методов с непустой реализацией у класса WindowsTokenRoleProvider всего два - IsUserInRole и GetUsersInRole, унаследованные от абстрактного класса RoleProvider. Все остальные методы просто выбрасывают исключения. Провайдер AuthorizationStoreRoleProvider Провайдер AuthorizationStoreRoleProvider управляет хранением информации о ролях, предназначенной для менеджера авторизации AzMan. Поддерживаемый в Microsoft Windows Server 2003, Windows XP Professional и Windows 2000 Server менеджер AzMan является отдельно загружаемым компонентом Windows, позволяющий группи-ровать операции в форме заданий и авторизировать роли на выполнение этих зада-ний и (или) отдельных операций. Вместе с AzMan устанавливается оснастка MMC, используемая для управления ролями, задачами, операциями и пользователями. Информация о ролях содержится в специальном хранилище, которым может быть XML-файл, Active Directory или сервер ADAM. Простейшее хранилище AzMan со сконфигурированным заданием показано на рис. 4-4. Рис. 4-4. Хранилище политик AzMan со сконфигурированным заданием
148 Часть I Внутренние механизмы ASP.NET Посредством AzMan вы просто создаете абстрактные задания и операции и свя-зываете их с пользователями и ролями. После этого, используя API менеджера, вы можете проверять членство пользователей в ролях и даже выяснять, авторизирован ли определенный пользователь на выполнение данного задания или операции. В при-ложениях ASP.NET, используя провайдер ролей AuthorizationStoreRoleProvider, можно работать с хранилищем политик AzMan посредством его API управления ролями. Заметьте, однако, что AuthorizationStoreRoleProvider позволяет использовать только подмножество данного API. В частности, он разрешает управлять ролями, добавлять и удалять пользователей, выполняющих заданную роль, и проверять членство в ро-лях. Но провайдер не дает возможности проверить, авторизирован ли пользователь на выполнение определенного задания или операции. Если вдруг вам потребуется доступ к полному API AzMan, то придется работать с этой библиотекой из прило-жения ASP.NET, используя технологию COM Interop. Примечание За дополнительной информацией об AzMan обратитесь к статье, распо-ложенной по адресу http://msdn.microsoft.com/library/enus/dnpag2/html/paght000019.asp. За-грузить менеджер AzMan можно по адресу http://windowsupdate.microsoft.com, поскольку он входит в состав большинства пакетов обновления. Для использования провайдера AuthorizationStoreRoleProvider в приложении ASP.NET нужно задать строку подключения, указывающую на хранилище политик. Вот пример: <connectionString> <add name="LocalPolicyStore" connectionString="msxml://c:/mystore.xml" /> </connectionString> <system.web> <roleManager> <providers> <add name="RoleManagerAzManProvider" type="System.Web.Security.AuthorizationStoreRoleProvider, ... " connectionStringName="LocalPolicyStore" applicationName="AzManDemo" /> </providers> </roleManager> </system.web> Путь к XML-файлу необходимо снабдить префиксом msxml. Если вы собираетесь использовать Active Directory или ADAM, строка подключения должна быть соот-ветствующей. Сравнение API управления ролями ASP.NET и AzMan Есть ли у API менеджера AzMan какие-либо преимущества перед API провайдера ролей ASP.NET? Прежде всего, API AzMan обладает гораздо более широкими воз-можностями управления системными ролями и пользователями. Сфера применения AzMan не ограничена приложениями .NET или ASP.NET. Это COM-библиотека, пред-назначенная для нужд самых разнообразных приложений и платформ Windows. Кроме того, у AzMan имеется довольно важное преимущество перед провайдером ролей ASP.NET. Он реализует механизм более детального управления доступом на основе ролей с возможностью абстрагирования операций и заданий. Однако, для того чтобы воспользоваться преимуществами данного механизма, нужно либо применять собственный API AzMan, либо заключить его в оболочку в виде пользовательского провайдера ролей, расширяющего функции провайдера AuthorizationStoreRoleProvider.
Создание пользовательских провайдеров ASP.NET Глава 4 149 В каких случаях требуется замена провайдера Обычно пользовательский провайдер ролей создают, когда хотят задействовать дру-гое хранилище данных или же таблицу SQL Server с другой схемой. Часто эта схема отражает потребности приложения, переносимого на платформу ASP.NET 2.0. Кроме того, создание пользовательского провайдера ролей целесообразно в случае, когда функция управления ролями должна быть реализована в виде отдельного мо-дуля либо Web-сервиса или же когда для промежуточного слоя системы необходима более строгая защита на основе ролей. В последнем случае вы можете обнаружить, что наилучшим выбором является полный API AzMan или же аналогичный ему API. Интерфейс прикладного программирования AzMan интегрирован в ASP.NET, но, к со-жалению, не полностью. Вам нужно будет расширить провайдер AuthorizationStoreRole-Provider, добавив в него поддержку недостающих элементов этого API. Сервис пользовательских профилей Данный сервис позволяет авторизированным и анонимным пользователям сайта указывать свои предпочтения в отношении настраиваемых параметров приложения. Для его работы необходимо соблюдение нескольких условий. Во-первых, приложение должно предоставлять модель данных, то есть список атрибутов, которые пользовате-ли смогут устанавливать по своему желанию и которые приложение будет сохранять. Во-вторых, в приложении должна быть одна или несколько страниц, составляющих визуальный редактор, где пользователи будут задавать и редактировать свои пред-почтения. Наконец, должно быть по меньшей мере несколько страниц, отражающих текущие предпочтения пользователя. Посещая страницы, на которых задаются уста-новки профиля, пользователь должен чувствовать себя так, словно выбирает внешний вид элементов управления и темы в обычном приложении. Модель данных профиля определяется в файле web.config, где перечисляются свойства, которые приложение позволяет настраивать пользователям. Важно отметить, что областью действия этой модели данных является все приложение, а не его отдель-ные страницы. Во время обработки очередного запроса клиента в состав контекста HTTP входит объект профиля, содержащий информацию профиля текущего поль-зователя. Эти данные извлекаются из хранилища выбранным провайдером профиля. Когда обработка запроса завершается, тот же провайдер записывает изменившиеся данные профиля обратно в хранилище данных. Провайдер SqlProfileProvider Базовым классом провайдеров профиля является ProfileProvider. В ASP.NET имеется единственный встроенный провайдер - SqlProfileProvider, определенный в простран-стве имен System.Web.Profile. Для хранения данных профиля он использует таблицу базы данных aspnetdb.mdf SQL Server 2005 Express. Обязанность провайдера про-филя - считывать данные профиля из хранилища в начале выполнения запроса и за-писывать измененные значения обратно по завершении его выполнения. Таблица провайдера содержит по одной записи на каждого пользователя при ло-жения. Пользовательские установки представлены в виде последовательности зна-чений, в которой различаются текст и двоичные данные (рис. 4-5). В каких случаях требуется замена провайдера Обычно пользовательский провайдер профиля приходится писать в тех случаях, когда требуется хранить информацию профиля в таблице SQL Server с другой схемой или же в другой СУБД, такой как Oracle или DB2. Также пользовательский провайдер разрабатывают с целью интеграции существующей системы управления профилей в новое решение ASP.NET 2.0. Наконец, такой провайдер требуется, когда нужно 
150 Часть I Внутренние механизмы ASP.NET использовать иной тип хранилища данных (XML или, скажем, файл Access) либо когда необходимы не поддерживаемые стандартным провайдером функции, такие как сжатие или шифрование. Далее в этой главе будет описан пользовательский провайдер профилей, исполь-зующий в качестве хранилища данных пользовательскую таблицу SQL Server. Рис. 4-5. Пример содержимого таблицы aspnet_Profile базы данных aspnetdb Сервис состояния сеанса Управление состоянием сеанса - одна из основ ASP.NET. Для каждого сеанса рабо-ты пользователя с приложением система сохраняет коллекцию пар имя-значение, определяющих состояние сеанса, и предоставляет API чтения и записи этих данных, реализованный в виде популярного у программистов объекта Session. Сервис состоя-ния сеанса ASP.NET 2.0 полагается в своей работе на множество других компонентов, включая модуль HTTP, набор провайдеров и физические хранилища данных. Модуль HTTP предоставляет ASP.NET набор данных в форме набора пар имя- значение, образующих состояние сеанса конкретного пользователя. Когда обработка запроса завершается, модуль HTTP получает от ASP.NET модифицированное состо-яние сеанса и сохраняет его Провайдер состояния сеанса - это компонент, ответственный за предоставление данных, связанных с текущим сеансом. Вызываемый, когда при обработке запроса требуются данные состояния, он извлекает эти данные из заданного хранилища и воз-вращает их модулю. Будучи вызванным по окончании обработки запроса, провайдер записывает новые данные обратно в хранилище. Базовым классом провайдеров состояния сеанса является SessionStateStoreProvider-Base, определенный в пространстве имен System.Web.SessionState. В ASP.NET имеются 
Создание пользовательских провайдеров ASP.NET Глава 4 151 три предопределенных провайдера, хранящих данные в памяти рабочего процесса, на сервере состояния и в базе данных SQL Server. Примечание В ASP.NET 1.x аналогичная архитектура использовалась с другими, но по-хожими компонентами, которые назывались менеджерами состояния сеанса. Все они реализовывали общий интерфейс - IStateClientManager. В версии 2.0 этот интерфейс больше не поддерживается - он стал жертвой рефакторинга и введения модели про-вайдеров. Провайдер InProcSessionStateStore Используемый по умолчанию провайдер InProcSessionStateStore хранит данные в виде живых объектов в кэше ASP.NET. Поскольку эти данные доступны в любой момент, провайдер InProcSessionStateStore является наиболее быстрым среди своих собратьев. Однако чем больше данных состояния сеанса он хранит, тем больше потребляет памя-ти сервера, увеличивая тем самым риск снижения производительности. Используемая память принадлежит рабочему процессу aspnet_wp.exe, если используется модель процесса IIS 5.0, или w3wp.exe в случае использования модели процесса IIS 6.0. Только когда выбран данный провайдер, модуль HTTP может генерировать со-бытие Session_End, сигнализируя об окончании сеанса, чтобы приложения могли вы полнить необходимый код очистки. Провайдер OutOfProcSessionStateStore Провайдер состояния сеанса OutOfProcSessionStateStore хранит данные вне рабо-чего процесса ASP.NET. Если говорить конкретнее, он держит их в памяти сервиса Microsoft Windows NT, имя которого - aspnet_state.exe. По умолчанию этот сервис остановлен, и его нужно запускать вручную. Его исполняемый файл находится в ин-сталляционной папке ASP.NET: %WINDOWS%\Microsoft.NET\Framework\[версия] Сервис состояния сеанса является составной частью ASP.NET и устанавливается с нею вместе, так что вам не потребуется запускать отдельное инсталляционное при-ложение. Взаимодействие между модулем HTTP и сервером состояния осуществля-ется через порт TCP/IP, заданный в файле web.config (см. главу 3). Хранение данных состояния сеанса вне рабочего процесса ASP.NET обеспечи-вает им большее время жизни, а приложению - большую надежность. Отделив эти данные от страницы, вы без труда сможете масштабировать приложение, перенеся его в архитектуру Web-фермы или Web-сада. Кроме того, такое решение полностью устраняет риск периодической потери данных из-за повторного использования про-цессов ASP.NET. Однако следует учесть, что данное решение требует копирования значений состоя-ния сеанса из места их хранения в память AppDomain, где обрабатывается запрос. Для выполнения этой задачи необходим слой преобразования между последовательным и объектным форматами данных (сериализации-десериализации), что является одним из важнейших недостатков провайдеров состояния, хранящих данные вне процесса. Провайдер SqlSessionStateStore Хранение состояния сеанса во внешнем процессе, безусловно, делает все приложение ASP.NET более стабильным. Что бы ни случилось с рабочим процессом, состояние се-анса сохранится, оно останется доступным для дальнейшего использования. Если сер-вис будет приостановлен, данные сохранятся и автоматически восстановятся при его возобновлении. Однако при остановке сервиса или его аварийном завершении данные 
152 Часть I Внутренние механизмы ASP.NET будут утеряны. Поэтому в тех случаях, когда ключевым требованием к приложению является его надежность, следует использовать провайдер SqlSessionStateStore. Провайдер хранит данные состояния сеанса в базе данных SQL Server. Поэтому они сохраняются даже после аварийного завершения работы SQL Server, не говоря уж о сбое приложения или сервиса, но затраты, безусловно, велики. Вы можете хранить данные на любом компьютере, с которым у Web-сервера имеется связь и на котором выполняется SQL Server версии 7.0 или выше. Этот метод хранения данных сеанса отличается от метода, реализуемого провайдером OutOfProcSessionStateStore, лишь тем, что они используют различные хранилища. В частности, применяется тот же алгоритм преобразования данных между последовательным и объектным форматами, правда он из-за особенностей хранилища работает немного дольше. По умолчанию провайдером SqlSessionStateStore используется база данных ASPState, содержащая несколько хранимых процедур. Вам предоставляется возможность сде-лать выбор между временной и постоянной таблицей. При использовании временной таблицы в случае перезагрузки компьютера, на котором выполняется SQL Server, данные состояния сеанса утрачиваются. Вы можете выбрать и другую базу данных (отличную от ASPState), но ее внутренняя структура должна быть такой же. Сеансы представлены строками вспомогательной таблицы, а те из них, которые устарели, удаляются фоновым заданием. Конфигурирование провайдера SqlSessionStateStore производится в файле web.config. В каких случаях требуется замена провайдера Существует только одна веская причина для замены любого из предопределенных провайдеров состояния сеанса пользовательским провайдером - это необходимость в использовании СУБД, отличной от SQL Server. Есть и множество других аспектов работы провайдера состояния сеанса, которые вы, возможно, захотите изменить, на-пример, структуры, используемые им для физического хранения и возврата данных, но смена СУБД является наиболее интересным из них. Рассмотрим следующую ситуацию. У вас имеется приложение масштаба предприя-тия, использующее базу данных Oracle. Состояние сеанса должно сохраняться на деж но, поэтому решение с использованием базы данных - именно то, что вам нуж но. Но сто-ит ли устанавливать еще одну СУБД (SQL Server) только для того, чтобы хранить в ней данные состояния сеанса? Проще написать или приобрести пользовательский провайдер состояния сеанса, который будет вести себя подобно SqlSessionStateStore, но использовать вместо SQL Server базу данных Oracle. Совет При написании провайдера состояния сеанса вам могут пригодиться методы класса SessionStateUtility. Этот класс содержит методы для сериализации-десериализации элементов состояния сеанса, используемые при их записи в хранилище и чтении оттуда. Кроме того, класс содержит методы для извлечения словаря данных и добавления его в контекст HTTP и в свойство Session. Провайдер карты сайта Карта сайта - это иерархическая структура данных, представляющая внутреннюю структуру Web-сайта. Она полезна во многих ситуациях. Например, вы можете ис-пользовать ее для отображения местонахождения страницы сайта и ссылок на ее родительские страницы. Кроме того, в ASP.NET 2.0 карта сайта совместно с таким элементами управления, как TreeView и Menu, может использоваться для отображе-ния структуры сайта на его домашней странице. Мы вернемся к этой теме позднее, в главе 10. Но откуда же берется карта сайта?
Создание пользовательских провайдеров ASP.NET Глава 4 153 По умолчанию приложения ASP.NET считывают ее из XML-файла, который имеет имя web.sitemap, и находится в корневой папке приложения. Однако это лишь один из возможных вариантов. Сервис извлечения карты сайта реализуется в виде провайдера и имеет строгий контракт. Это означает, что вы можете написать собственный такой провайдер и хранить данные любым удобным для вашего приложения способом. Од-нако извлеченные из хранилища данные карты сайта провайдер обязан преобразовать в стандартный формат, понятный страницам и элементам управления ASP.NET. Базовым классом провайдеров карты сайта является SiteMapProvider. Опреде-ляемый им контракт требует, чтобы производные классы строили дерево объектов, представляющих узлы карты сайта, и предоставляли методы для поиска узлов в этом дереве. Каждый такой узел содержит отображаемое имя, URL, ссылку на родительский узел, список дочерних узлов и роли. Из провайдеров карты сайта может составляться иерархия. Данная возможность предусмотрена для ситуаций, когда разные области сайта поддерживаются разными командами, создавшими для них собственные карты и собственные их провайдеры. Контракт класса SiteMapProvider включает определенные ограничения защиты. Поддерживающие его провайдеры могут включать в список дочерних узлов каждого узла карты только те узлы, которые видимы текущему пользователю в соответствии с его ролями. Наконец, провайдеры карты сайта должны поддерживать возможность нахождения приложением текста карты, либо указывая RESX-файл, откуда каждый узел сможет загрузить отображаемый текст, либо применяя пользовательский механизм и предоставляя ASP.NET готовый текст. Например, провайдер может строить дерево, используя другие источники данных, в соответствии с культурой текущего потока. Примечание После загрузки в память карта сайта не обязательно остается неизменной - она может динамически меняться. Например, задав обработчик события SiteMapResolve провайдера, вы можете на лету добавлять, удалять и изменять узлы карты. Провайдер XmlSiteMapProvider Провайдер XmlSiteMapProvider является производным от промежуточного провайдер-ного класса StaticSiteMapProvider, который, в свою очередь, наследует SiteMapProvider. Он строит карту сайта на основе информации, прочитанной из XML-файла, имя ко торого задано в атрибуте siteMapFile в конфигурационном файле. Пример этой установки демонстрирует следующий фрагмент файла web.config: <siteMap> <providers> <add name="AspNetXmlSiteMapProvider" siteMapFile="web.sitemap" type="System.Web.XmlSiteMapProvider, System.Web, ... " /> </providers> </siteMap> По умолчанию файл web.sitemap, откуда XmlSiteMapProvider загружает данные, находится в корневой папке приложения, однако вы можете изменить его имя и место-расположение. Заметьте, однако, что расширение данного файла фиксировано - про-вайдер XmlSiteMapProvider распознает только файлы с расширением .sitemap. Также фиксирована и схема XML-файла, служащего источником информации карты сайта. Этот файл должен содержать единственный узел <siteMap>, за кото-рым может следовать любое количество вложенных узлов <siteMapNode>. Каждый из них соответствует экземпляру класса siteMapNode. Любой провайдер карты сайта 
154 Часть I Внутренние механизмы ASP.NET должен возвращать объект siteMapNode, являющийся корнем иерархии карты. Ниже приведен пример карты сайта: <siteMap> <siteMapNode title="Intro" url="intro.aspx" > <siteMapNode title="Acknowledgements" url="ack.aspx" /> <siteMapNode title="References" url="ref.aspx" /> </siteMapNode> <siteMapNode title="Samples" url="samples.aspx"> </siteMapNode> </siteMap> В классе siteMapNode определен ряд свойств, среди которых особую роль играет свойство Url, используемое провайдером XmlSiteMapProvider в качестве ключа - в лю-бом XML-файле .sitemap URL каждого узла должен быть уникальным в пределах данной карты сайта. Пользовательский провайдер карты сайта может применять для уникальной идентификации узлов другое свойство класса siteMapNode - Key. Значе-ния, присваиваемые свойству Key, в таком случае также должны быть уникальными в пределах карты сайта. XmlSiteMapProvider наблюдает за XML-файлом и динамически перестраивает карту, если администратор вносит в этот файл изменения. В каких случаях требуется замена провайдера Создавать пользовательский провайдер карты сайта имеет смысл в том случае, если XML-схема файлов .sitemap не соответствует вашим требованиям или если вы не хотите использовать такие файлы вовсе. В последнем случае подойдет хранилище данных любого типа, в том числе и база данных. Опять-таки, это решение рекомен-дуется для ситуаций, когда существующую инфраструктуру работы с картой сайта нужно перенести на платформу ASP.NET 2.0. Когда дело дойдет до разработки провайдера, обдумайте вариант наследования вместо SiteMapProvider класса StaticSiteMapProvider. Конечно, данный класс является абстрактным, но зато он реализует большинство виртуальных абстрактных методов родительского класса. Поэтому его наследование обычно немного упрощает задачу. Сервис обработки событий Web Система мониторинга состояния ASP.NET предоставляет приложению ряд пред-определенных и пользовательских событий, связанных с производительностью, бе-зопасностью, отказами и аномалиями. Работает она просто: генерирует события для зарегистрированных слушателей. А слушателями ее являются провайдеры событий Web. Провайдер событий Web обычно обрабатывает информацию, ассоциирован-ную с событием, которое связано со здоровьем системы, - он записывает данные об этом событии в постоянную память. Этими данными являются тип события, его код и описательное сообщение. События обычно интересуют провайдеров выборочно. Соответствие между провайдерами и важными для них событиями определяется в файле web.config (см. главу 3). Базовый класс провайдеров Web-событий называется WebEventProvider. Некоторые встроенные провайдеры являются производными от класса BufferedWebEventProvider. Оба класса определены в пространстве имен System.Web.Management.
Создание пользовательских провайдеров ASP.NET Глава 4 155 Провайдер EventLogWebEventProvider Провайдер EventLogWebEventProvider протоколирует события мониторинга состояния в журнале событий приложений Windows. Это единственный провайдер, для которого ряд событий задан по умолчанию. <rules> <add name="All Errors Default" eventName="All Errors" provider="EventLogProvider" ... /> <add name="Failure Audits Default" eventName="Failure Audits" provider="EventLogProvider" ... /> </rules> Как видно из приведенной выдержки из файла web.config сайта, провайдер Event-LogWebEventProvider отслеживает отказы и ошибки приложения и записывает инфор-мацию о них в журнал событий приложений Windows. Провайдер MailWebEventProvider MailWebEventProvider - это промежуточный, абстрактный класс, производный от промежуточного класса BufferedWebEventProvider. Классы, производные от Buffered-WebEventProvider, поддерживают внутреннюю очередь буферизации событий, которые будут сгенерированы позднее. Класс MailWebEventProvider реализует базовую фун-кциональность провайдера событий, отправляющего сообщения о них по электрон-ной почте. Производными от него являются два более специализированных класса: SimpleMailWebEventProvider и TemplatedMailWebEventProvider. Зарегистрированный как провайдер событий Web, SimpleMailWebEventProvider позволяет системе мониторинга здоровья отсылать уведомления о событиях по элект-ронной почте. Приведем сценарий, который регистрирует данный провайдер и задает дополнительные параметры генерируемых им сообщений: <providers> <add name="CriticalMailEventProvider" type="System.Web.Management.SimpleMailWebEventProvider, ..." from="admin@contoso.com" to="someone@contoso.com" bodyHeader="Warning!" bodyFooter="Please investigate ASAP." subjectPrefix="Action required." /> </providers> Одного только этого для регистрации провайдера недостаточно - необходимо еще явно определить связь между провайдером событий Web и одной или несколькими категориями событий. Следующий сценарий обеспечивает связь провайдера со всеми ошибками, которые будут происходить в приложении: <rules> <add name="All Errors by Email" eventName="All Errors" provider="CriticalMailEventProvider" /> </rules> Атрибут name содержит псевдоним, который должен быть уникальным в пределах приложения. По умолчанию с провайдером Event Log связывается событие All Errors. Учтите, однако, что если ваш сайт размещен на площадке интернет-провайдера, делать записи в журнале событий вам, скорее всего, не позволят.
156 Часть I Внутренние механизмы ASP.NET После добавления в файл web.config приведенного выше сценария вы начнете по лу-чать по электронной почте уведомления о каждой ошибке, а в журнал событий будут за-носиться соответствующие записи. Как указывалось в главе 3, узел <healthMonitoring> содержит узлы <rules> и <providers>. Строго говоря, для того чтобы началась отправка сообщений электронной почты, необходимо еще одно, последнее действие, поскольку элемент <add> в разделе про-вайдера событий Web не позволяет указать хост SMTP. Данная установка наследуется от раздела <mailSettings> конфигурационного файла. Приведем пример: <system.net> <mailSettings> <smtp deliveryMethod="network"> <network host="mail.contoso.com" /> </smtp> </mailSettings> </system.net> Два уведомления о необработанных исключениях страницы показаны на рис. 4-6. Рис. 4-6. Уведомления о событиях Web Формат сообщения, отправляемого провайдером SimpleMailWebEventProvider, из-менить нельзя. Если вы захотите создавать более сложные сообщения, используйте провайдер TemplatedMailWebEventProvider. Он имеет еще один атрибут, template, со-держащий ссылку на страницу ASP.NET. Вот пример такой страницы: <%@Page Language="C#" AutoEventWireup="true" Inherits="MyEmailTemplate" CodeFile="MyEmailTemplate.aspx.cs" %> <html> <body> <form id="form1" runat="server"> <asp:Label runat="server" ID="TheMailBody" /> </form>
Создание пользовательских провайдеров ASP.NET Глава 4 157 </body> </html> В файле кода можно прочитать всю доступную информацию о событии и сфор-мировать требуемый вывод: using System.Web.Management; public partial class MyEmailTemplate : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { //StringBuilder используется для буферизации разметки StringBuilder pageBody = new StringBuilder(); //Перебираем в цикле события, //указанные в текущем уведомлении WebBaseEventCollection events; events = TemplatedMailWebEventProvider.CurrentNotification.Events; foreach (WebBaseEvent e in events) { //Формируем вывод, используя объект WebBaseEvent } //Выводим сформированную страницу в виде текста TheMailBody.Text = pageBody.ToString(); } } CurrentNotification - единственный статический член класса TemplateMailWeb-EventProvider - возвращает набор событий из текущего уведомления. Он формирует экземпляр класса MailEventNotificationInfo, член Events которого представляет собой коллекцию объектов WebBaseEvent. Провайдер TraceWebEventProvider Провайдер TraceWebEventProvider отправляет перехваченные события мониторинга здоровья как трассировочные сообщения ASP.NET, которые можно просматривать с помощью утилиты trace.axd. Для активизации провайдера нужно внести изменения в разделы <providers> и <rules> конфигурационного файла: <trace enabled="true" /> Не забудьте также включить для ASP.NET функцию трассировки. Провайдер WmiWebEventProvider Провайдер WmiWebEventProvider перенаправляет перехваченные события системе Windows Management Instrumentation (WMI). Последняя, являясь компонентом опе-рационной системы Windows, позволяет администраторам и разработчикам управлять системной информацией и системными модулями. Например, с помощью WMI адми-нистратор может запросить состояния приложений и сетей, а разработчик - создать приложение, выполняющее мониторинг событий и протоколирующее инциденты и аномалии. В статье под номером 893664 из Knowledge Base приведен пример приложения - слушателя WMI, в котором для наблюдения за событиями WMI используются клас-сы из сборки System.Management. На рис. 4-7 это приложение показано в действии: 
158 Часть I Внутренние механизмы ASP.NET оно наблюдает за приложением ASP.NET, а для его конфигурирования используется следующий раздел конфигурационного файла: <rules> <add name="All Errors to WMI" eventName="All Errors" provider="WmiWebEventProvider" /> </rules> Рис. 4-7. Демонстрационное WMI-приложение, перехватывающие ошибки ASP.NET В каких случаях требуется замена провайдера В составе ASP.NET имеется достаточно много разных провайдеров событий Web. По-этому наиболее типичной, если не единственной причиной написания собственного провайдера является желание записывать информацию о событиях в другую базу данных SQL Server, использовать другую СУБД, например Oracle, или какой-нибудь другой механизм, скажем, Microsoft Message Queue (MSMQ). Можно даже создать провайдер, записывающий сведения о событиях в текстовый или XML-файл определенного формата, подходящего для обработки другими сервиса-ми вашего окружения. Но если вам нужно именно это, вспомните, что журнал событий Windows предоставляет несколько возможностей экспортирования информации, да и для таблицы SQL Server или хранилища WMI можно реализовать подобную фун-кцию. По моему мнению, лучше использовать один из предопределенных провайде-ров и разработать средство преобразования данных в нужный формат, работающее в автономном режиме. Сервис персонализации Web Parts Компоненты Web Parts из ASP.NET предоставляют инфраструктуру для создания Web-приложений с богатым и объемным контентом. Используя эти компоненты, мож-но разрабатывать сайты, позволяющие пользователю выбирать и получать только тот контент, который его интересует. Компоненты Web Parts являются контейнерами, они могут содержать контент самых разных типов. Их можно представлять себе как окно в хранилище информа-ции, доступной данной странице. Пользователь может закрывать, минимизировать и восстанавливать такое окно. Внутри компонента Web Part содержится обычный HTML - статический текст, ссылки, изображения и различные элементы управления, в том числе пользовательские. Объединив компоненты Web Parts с персонализацион-ным сервисом, разработчики могут легко создавать страницы и элементы управления, соответствующие индивидуальным нуждам пользователей. Подробно о технологии Web Parts я расскажу в главе 7.
Создание пользовательских провайдеров ASP.NET Глава 4 159 Содержимое и организация компонентов Web Parts определяются предпочтениями пользователей. Соответствующие установки являются критически важной информа-цией и сервис их хранения должен быть надежным. Персонализационный сервис Web Parts выполняет эту задачу в рамках модели провайдеров. Провайдер SqlPersonalizationProvider Базовым классом любого провайдера Web Parts является PersonalizationProvider - абстрактный класс, определенный в пространстве имен System.Web.UI.WebControls. WebParts. В ASP.NET имеется только один встроенный провайдер этого типа, а именно SqlPersonalizationProvider. Провайдер SqlPersonalizationProvider сохраняет данные в трех таблицах базы дан-ных aspnetdb. mdf. Каждая страница, вместе со своим путем, сохраняется в таблице aspnet_Paths. Затем создаются записи, связывающие пути и пользователей - по одной для каждой пары пользователь-путь. Установки конкретных пользователей записы-ваются в таблицу aspnet_PersonalizationPerUser, а общие установки хранятся в таблице aspnet_PersonalizationAllUsers. В каких случаях требуется замена провайдера Учитывая сложность данных, сохраняемых для компонентов Web Parts, о написании пользовательского провайдера стоит задумываться только в том случае, когда необхо-димо использовать другой сервер базы данных. Если же вы просто хотите использовать полноценную версию SQL Server вместо SQL Server 2005 Express, модифицируйте строку подключения в файле web.config, чтобы она указывала на базу данных SQL Server с такой же схемой. Имейте при этом в виду, что вы сами должны создать необходимую базу данных. Утилита aspnet_regsql имеет ключи, которые вам в этом помогут. За дополнительной информацией об указанной утилите обращайтесь к документации MSDN. Сервис защиты конфигурации Как упоминалось в главе 3, ASP.NET 2.0 позволяет защищать отдельные разделы файла web.config путем их шифрования. За шифрование отвечают специальные ком-поненты - провайдеры шифрования. Список доступных провайдеров вы найдете в подразделе <providers> раздела <protectedData>. Задача провайдера шифрования проста: зашифровать содержимое заданного раз-дела, используя определенную криптографическую систему, и вернуть результаты в XML-формате. Базой всех провайдеров шифрования является класс ProtectedConfigurationProvider, производный от ProviderBase. В состав ASP.NET входят два стандартных провайде-ра - один использует алгоритм RSA, а другой основан на Windows Data Protection API (DPAPI). Внутренняя структура провайдеров шифрования Провайдеру шифрования необходимы два метода, прототипы которых приведены ниже: public abstract class ProtectedConfigurationProvider : ProviderBase { public abstract XmlNode Decrypt(XmlNode encryptedNode); public abstract XmlNode Encrypt(XmlNode node); }
160 Часть I Внутренние механизмы ASP.NET Метод Encrypt получает объект XmlNode, представляющий конфигурационное под дерево, которое подлежит шифрованию, выполняет свою задачу и возвращает объект XmlNode, предназначенный для вставки в защищенный раздел. Весь процесс иллюстрирует следующий псевдокод: public override XmlNode Encrypt(XmlNode node) { //Шифруем контент узла string clearText = node.OuterXml; string encText = EncryptText(clearText); //Составляем возвращаемую XML-строку StringBuilder finalText = new StringBuilder(); finalText.Append("EncryptedData><CipherData><CipherValue>"); finalText.Append(encText); finalText.Append("</CipherValue></CipherData></EncryptedData>"); //Строим поддерево XML для вставки в файл web.config XmlDocument doc = new XmlDocument(); doc.PreserveWhitespace = true; doc.LoadXml(finalText.ToString()); return doc.DocumentElement; } Метод Decrypt выполняет обратную задачу: public override XmlNode Decrypt(XmlNode encryptedNode) { //Получаем зашифрованный текст и расшифровываем его string cipherValue = TraverseToNodeValue(encryptedNode); string clearText = this.DecryptText(cipherValue); //Строим поддерево XML для вставки в web.config XmlDocument doc = new XmlDocument(); doc.PreserveWhitespace = true; doc.LoadXml(clearText); return doc.DocumentElement; } Обратите внимание, что это именно псевдокод, он демонстрирует общую схему внутреннего поведения провайдера. Все детали шифрования-расшифровки, скрытые в подпрограммах, зависят от конкретного провайдера - провайдеры отличаются друг от друга тем, какой механизм шифрования реализует каждый из них. Провайдер RsaProtectedConfigurationProvider Данный провайдер выполняет шифрование по алгоритму RSA - одному из наиболее популярных алгоритмов шифрования с использованием пары ключей, открытого и секретного, часто называемых ассиметричными ключами. Секретный ключ, как и следует из его названия, держится в секрете, а открытый свободно распространяется. Алгоритм применяется следующим образом. Отправитель, используя открытый ключ получателя, шифрует и отправляет сообщение, а получатель расшифровывает его с помощью своего секретного ключа. Эти два ключа связаны между собой математичес-ки таким образом, что практически невозможно вычислить секретный ключ на основе открытого. Более того, для шифрования сообщения может использоваться только открытый ключ, а для его расшифровки - только секретный. Будучи встроенным 
Создание пользовательских провайдеров ASP.NET Глава 4 161 во многие популярные программные продукты, алгоритм RSA является стандартом шифрования де-факто. В .NET Framework класс-провайдер RSACryptoServiceProvider создает упомянутую пару ключей, когда вы вызываете используемый по умолчанию конструктор. Ключи могут либо сохраняться для применения в течение нескольких сеансов, либо исполь-зоваться только в течение одного сеанса. Для надежного хранения ключей необходи-мо иметь защищенный контейнер. Это обстоятельство представляет для провайдера RSA CryptoServiceProvider потенциальную проблему. Заглянем в файл machine.config, где перечислены встроенные провайдеры шифрования: <protectedData defaultProvider="RsaProtectedConfigurationProvider"> <providers> <add keyContainerName="NetFrameworkConfigurationKey" useMachineContainer="true" name="RsaProtectedConfigurationProvider" type="System.Configuration.RsaProtectedConfigurationProvider, System.Configuration, ..." /> </providers> </protectedData> Как видите, RsaProtectedConfigurationProvider является применяемым по умол-чанию. Он использует контейнер ключей с именем NetFrameworkConfigurationKey. Указанный контейнер создается и заполняется при инсталляции ASP.NET ассимет-ричными ключами, предназначенными для использования при шифровании данных конфигурации. Очень важно, чтобы этот контейнер существовал к моменту первого вызова провайдера RsaProtectedConfigurationProvider. Следует продумать еще один важный момент. Контейнер ключей должен не только существовать, но и быть связанным с пользовательской учетной записью, от имени которой производится обращение к нему. По умолчанию системная учетная запись указана вместе с контейнером, но учетная запись ASP.NET на вашем Web-сервере там не задана. Что это для вас означает? Пока вы будете использовать защищенный раздел на своем локальном Web-сервере, встроенном в Visual Studio 2005, все будет нормально. Но если вы перенесете страницу в виртуальную папку IIS и запустите ее через IIS, провайдер шифрования не сможет выполнить свою задачу. Объясняется это тем, что доступ к контейнеру осуществляется от имени учетной записи ASP.NET, которая может быть не зарегистрирована с контейнером ключей. Если вы запускаете ASP.NET с учетной записью NETWORK SERVICE (так происхо дит по умолчанию на компьютерах, работающих под управлением Windows Server 2003), то вам нужно выполнить из командной строки Windows следующую команду: aspnet_regiis.exe -pa "NetFrameworkConfigurationKey" "NT AUTHORITY\NETWORK SERVICE" Данная команда добавит разрешение доступа к контейнеру для заданной учетной записи. Важно, чтобы вы задали полное имя учетной записи, включающее домен "NT AUTHORITY\NETWORK SERVICE", как в приведенной выше команде. Заметьте, что доступ к контейнеру ключей необходимо осуществлять только при использовании провайдера, работающего по алгоритму RSA. Утилита aspnet_regiis содержит ключи, позволяющие создавать пользовательские контейнеры ключей и даже экспортировать их на другие компьютеры. Однако, со-здавая пользовательский контейнер, не забудьте обновить конфигурацию (в файле web.config сайта или приложения), чтобы дать знать об этом провайдеру RsaProtected-ConfigurationProvider.
162 Часть I Внутренние механизмы ASP.NET Защита разделов на Web-ферме Как будет показано в следующем разделе, алгоритм RSA - наиболее надежный спо-соб защиты конфигурационных разделов Web-фермы. При создании Web-фермы на каждый компьютер обычно устанавливают один и тот же набор файлов приложений, включая и файл web.config с защищенными разделами. Этот файл создается (а не-которые его разделы шифруются) на одном компьютере: либо используемом для разработки, либо эксплуатационном. Однако при установке ASP.NET на каждом из компьютеров создается свой набор пар ассиметричных ключей, поэтому вы не можете просто скопировать файлы приложений с помощью утилиты x-copy. Собственно, проблема заключается даже не в том, что у каждого компьютера свои ключи, а в том, что они отличаются от ключей, использовавшихся для шифрования раз-вертываемого файла web.config. Данную проблему можно решить двумя способами: установить на каждый из компьютеров незашифрованный файл web.config и за-шифровать его уже там, в результате чего все файлы web.config окажутся разными, за то соответствующими ключам своих компьютеров; с помощью утилиты x-copy перенести на целевые компьютеры уже зашифрован ные файлы web.config, но при этом обеспечить наличие на всех компьютерах одина-ковых ключей. Для выполнения последнего условия нужно сначала экспортировать ключи, ис-пользовавшиеся для шифрования файла web.config. Эту операцию следует выпол-нять на том компьютере, где шифровался файл web.config. Делается это с помощью следующей команды: aspnet_regiis.exe -px "NetFrameworkConfigurationKey" мои_ключи.xml Данная команда экспортирует используемый по умолчанию контейнер ключей в файл мои_ключи.xml. После этого полученный XML-файл нужно скопировать на все компьютеры Web-фермы, а затем импортировать в требуемый контейнер ключей. Имя контейнера клю-чей на всех компьютерах должно быть одинаковым. aspnet_regiis.exe -pi "NetFrameworkConfigurationKey" мои_ключи.xml Наконец предоставьте учетной записи ASP.NET на каждом компьютере разреше-ние на доступ к контейнеру: aspnet_regiis.exe -pa "NetFrameworkConfigurationKey" "NT AUTHORITY\NETWORK SERVICE" Провайдер DpapiProtectedConfigurationProvider Данный провайдер шифрует разделы файла web.config, используя Windows Data Protection API (DPAPI). Впервые появившийся в Windows 2000 провайдер является интерфейсом прикладного программирования уровня операционной системы и состо-ит из двух неуправляемых функций: CryptProtectData и CryptUnprotectData. Примечание В .NET Framework 2.0 использовать DPAPI для защиты данных приложе-ния можно посредством нового класса ProtectedData. Этот класс - просто оболочка для неуправляемого API и вызовов P/Invoke. В .NET Framework 1.x программистам приходилось вызывать P/Invoke самостоятельно или же пользуясь вспомогательными библиотеками, большинство из которых бесплатны. Примеры вы найдете по адресу: http://msdn.microsoft.com/library/en-us/dnnetsec/html/SecNetHT07.asp. Главное различие между RSA и DPAPI заключается в принципе применения клю-чей. Во-первых, DPAPI - симметричный алгоритм, то есть в нем для шифрования 
Создание пользовательских провайдеров ASP.NET Глава 4 163 и дешифрации данных используется один и тот же ключ. Во-вторых, DPAPI автома-тически генерирует ключ шифрования. Если говорить коротко, DPAPI генерирует главный ключ и шифрует его, исполь-зуя другой ключ, сгенерированный на основе пароля пользователя. Затем он создает ключ сеанса на основе главного ключа, некоторых случайных данных и некоторой необязательной энтропии - случайного текста, переданного пользователем. Именно ключ сеанса и используется для шифрования. У DPAPI имеется флаг, позволяющий работать не в пользовательском режиме, а в режиме компьютера. В таком случае для генерирования ключа, защищающего главный ключ, используется информация уровня компьютера, и любой процесс, вы-полняющийся на данном компьютере, может расшифровать текст, зашифрованный любым другим процессом, работающим на том же компьютере. В этом режиме про-вайдер DpapiProtectedConfigurationProvider работает по умолчанию. Вот как данный провайдер объявляется в файле machine.config: <providers> <add useMachineProtection="true" name="DataProtectionConfigurationProvider" keyEntropy="" type="System.Configuration.DpapiProtectedConfigurationProvider, System.Configuration, ..." /> </providers> Если вы используете провайдер DPAPI, то не почувствуете никакой разницы меж-ду IIS и встроенным Web-сервером Visual Studio 2005. А вот на Web-ферме в случае использования защиты уровня компьютера его применение проблематично - все компьютеры различны и нет надежного способа гарантировать идентичность ключей. Можете поэкспериментировать с одинаковым значением энтропии, установив одно и то же имя пользователя и один пароль на всех компьютерах. Но я уверен, что лучшим выбором для Web-фермы является провайдер на базе RSA. Примечание При работе в пользовательском режиме DPAPI применяет для генерирова-ния ключей пароль пользователя. Но что если пользователь изменит свой пароль? DPAPI перехватит это событие и повторно зашифрует главный ключ. Пароль пользователя никак не влияет на ключ сеанса, предназначаемый для шифрования и дешифрации данных. В каких случаях требуется замена провайдера С шифрованием и защитой обычно не шутят, и особенно серьезно к ним относятся, когда необходимо создать надежно защищенное окружение. В отношении защиты существует следующее золотое правило: "не создавайте собственных библиотек шиф-рования, но используйте существующие надежные библиотеки". Для шифрования данных, хранящихся в конфигурационных файлах, вам предо-ставлены две возможности с разными характеристиками, но равно эффективные. Я не вижу серьезных предпосылок для разработки собственного провайдера, заменяющего стандартные провайдеры на базе RSA и DPAPI. Хотя технически добавление пользо-вательского провайдера возможно и выполняется относительно просто. Может быть, вы захотите написать собственный провайдер, чтобы использовать другую библиотеку шифрования. Кроме того, у вас могут быть на то причины, обус-ловленные особенностями конкретного приложения. Как бы там ни было, обязательно убедитесь, что выбранная вами библиотека шифрования действительно хороша, а не просто дорога вам как результат собственных творческих экспериментов.
164 Часть I Внутренние механизмы ASP.NET Ваш собственный провайдер Ну а теперь, наконец, настала очередь привести пример разработки пользовательского провайдера. В предшествующих разделах были описаны ситуации, когда такой про-вайдер может понадобиться. В частности, говорилось об интеграции в ASP.NET 2.0 существующего кода, реализующего необходимый сервис. Ряд стандартных сервисов ASP.NET, таких как сервисы членства, ролей, пользова-тельских профилей и карты сайта, необходим большинству современных приложений. Для подобных функций в ASP.NET 2.0 имеется встроенный набор решений, реализо-ванный в виде расширяемого комплекса провайдеров. А как же быть в упоминаемом выше случае? Выбросить существующий код и использовать новую замечательную модель ASP.NET 2.0? Хотя об этом, конечно, можно подумать, скорее всего, вы пред-почтете взять все лучшее от обоих решений, то есть в рамках модели ASP.NET 2.0 повторно использовать свой надежный и отлаженный код, заключив его внутрь но-восозданного провайдера. Собственно, это и есть модель адаптера, упоминавшаяся ранее в этой главе. Предположим, что у вас имеется некий старый код для ASP.NET 1.x, реализующий пользовательские профили с применением cookie. Каждому зарегистрированному пользователю выдается cookie с некоторыми данными, описывающими его предпоч-тения относительно посещенной страницы. Этот cookie затем возвращается серверу с каждым запросом, и содержащаяся в нем информация используется при формирова-нии запрашиваемых страниц. (Кстати говоря, это весьма распространенная практика, так что данный пример имеет реальное применение.) Сейчас мы посмотрим, как можно унаследованный код заключить внутрь пользовательского провайдера. Примечание Данный пример, помимо своего практического применения, полезен еще и тем, что демонстрирует важную концепцию - адаптацию существующего, проверенного и надежного кода для работы в контексте провайдера ASP.NET 2.0. Степень возможной интеграции такого кода в провайдер зависит от контракта сервиса (членства, профилей и т. п.) и характеристик самого кода. Что касается конкретно сервиса пользовательских профилей, то повторное использование его кода несколько затруднено, поскольку модель данных профиля у каждого приложения своя. Среди прилагаемых к этой книге примеров вы найдете две демонстрационные страницы, сохраняющие сведения о предпочтениях пользователя в виде cookie: одна действует посредством пользовательского API, а дру-гая - посредством провайдера профиля, который вам предстоит разработать. Как станет ясно из дальнейшего, повторное использование существующего кода в полном объеме в данном случае нежелательно. Контракты других сервисов, таких как сервис членства или карты сайта, делают повторное использование существующего кода возможным и относительно простым. Архитектура провайдера Все провайдеры наследуют базовый класс ProviderBase и, следовательно, его метод Initialize, а также два свойства: Name и Description. Инициализация провайдера - важ-ный этап, и программировать его нужно со всей тщательностью. С этого и начнем. Инициализация провайдера Метод Initialize провайдера имеет два аргумента: public virtual void Initialize(string name, NameValueCollection config) В первом из них, name, передается имя провайдера, как оно записано в конфигу-рационном файле. Второй аргумент содержит коллекцию заданных в конфигурацион-
Создание пользовательских провайдеров ASP.NET Глава 4 165 ном файле атрибутов. Аргумент config никогда не бывает равен null - если такое произойдет, вам следует выбросить исключение. if (config == null) throw new ArgumentNullException("Null configuration parameters"); Прежде чем вызвать метод Initialize базового класса, убедитесь, что аргумент name также не равен null и не пуст: if (String.IsNullOrEmpty(name)) name = "CookieProfileProvider"; Можете присвоить ему любую константную строку - обычно для этой цели ис-пользуют имя класса. Если атрибут name установлен в файле web.config, значение вы найдете там. Далее вызовите метод Initialize базового класса. По возвращении из него позаботьтесь об установке необходимых провайдеру атрибутов. Например, провайдер, использующий cookie, может считывать задаваемые по умолчанию имя и срок действия cookie-файла. _cookieName = config["cookieName"]; if (String.IsNullOrEmpty(_cookieName)) _cookieName = ".PROF"; config.Remove("cookieName"); Обработанные атрибуты рекомендуется удалять из коллекции config. В конце метода данная коллекция должна быть пустой - это станет свидетельством того, что все атрибуты обработаны. Если она не пуста, опять-таки, выбросьте исключение. Исключение следует выбросить и при условии, что необходимый атрибут отсутствует в коллекции или не имеет допустимого значения, задаваемого по умолчанию. Внимание! Хотя все зависит от архитектуры конкретного провайдера, в общем случае вы зов API, специфического для данного сервиса, из метода Initialize - операция небе-зопасная. Старайтесь избегать ее выполнения или хотя бы убедиться, что не существует риска переполнения стека. Имейте в виду, что в то же время могут выполняться вызовы связанных с провайдером объектов, осуществляющих обратные вызовы Initialize. На практике рискованным является любой код, имеющий дело со свойством Providers, предоставляемым большинством классов сервисов, в частности Membership, ProfileManager и Roles. При использовании данного свойства вероятен вызов метода Initialize провайдера, и если обращаться к нему из метода Initialize, стек рано или поздно будет переполнен. Вопросы управления потоками Обычно экземпляр провайдера создается при получении первого запроса, для обра-ботки которого необходим соответствующий сервис. Например, провайдер профиля не загружается до тех пор, пока какой-нибудь пользователь не запросит страницу, в которой используется сервис управления пользовательскими профилями. Таким образом, экземпляр провайдера создается один раз для каждого приложения и время его жизни почти совпадает со временем жизни приложения. Во время обработки всех запросов, выполняемых в рамках определенного прило-жения, используется один и тот же экземпляр провайдера, но при этом разные запро сы мо гут выполняться в различных потоках. Иными словами, провайдер должен быть явно спроектирован как поддерживающий многопоточность (thread-safe). Последнее условие не распространяется на метод Initialize класса ProviderBase - его закрытая переменная состояния указывает, инициализирован ли уже данный провай-дер. Доступ к этой переменной выполняется правильно - из оператора lock.
166 Часть I Внутренние механизмы ASP.NET Выброс исключений Провайдер - часть API приложения. Согласно правилам хорошего программирова-ния о любой неожиданной ситуации следует сигнализировать выбросом исключения. Если вы найдете в .NET Framework подходящий класс, достаточно хорошо отража-ющий то, о чем вы намереваетесь сообщить, воспользуйтесь им. Примерами исклю-чений, которые часто выбрасываются провайдерами, являются ArgumentException, NotImplementedException и NullReferenceException. В .NET Framework имеется также класс ProviderException, который следует упот-реблять для предоставления подробной информации об исключении. Его удобно ис-пользовать в качестве базового класса исключения, специфического для провайдера. Воспользуйтесь либо самим этим классом, либо производным от него. Реализация провайдера профилей, использующего cookie Наш провайдер (назовем его CookieProfileProvider) будет сохранять данные пользова-тельских профилей в виде cookie. Он присваивает cookie-файлам имена, совпадающие с именами пользователей, и назначает им заданный в конфигурационном файле срок службы. Все свойства, определенные в модели данных, которая содержится в файле web.config, копируются в хэш-таблицу, сериализуются и сохраняются в кодировке Base64. В нашем примере используется двоичный сериализатор - так мы гарантируем, что он сможет обработать любой сериализуемый тип данных. Вы можете оптимизи-ровать код, применив для распространенных и примитивных типов более простые способы сериализации. Переопределяемые методы Класс CookieProfileProvider является производным от ProfileProvider, а тот, в свою очередь, наследует SettingsProvider. Методы, которые нам предстоит переопределить, перечислены в табл. 4-3. Табл. 4-3. Переопределяемые методы провайдера профиля Метод Где определен Описание DeleteInactive Profiles SettingsProvider Удаляет все профили, не использовав-шиеся после заданной даты DeleteProfiles SettingsProvider Удаляет все профили указанного пользователя FindInactive Pro fil esByUserName SettingsProvider Находит все профили, не использовав-шиеся после заданной даты и соот-ветствующие заданному имени пользователя FindProfiles By UserName SettingsProvider Находит все профили, соответствую-щие заданному имени пользователя GetAllInactive Profiles SettingsProvider Находит все профили, не использо-вавшиеся после заданной даты GetAllProfiles SettingsProvider Находит все профили GetNumberOf InactiveProfiles SettingsProvider Возвращает количество профилей, не использовавшихся после заданной даты GetProperty Values ProfileProvider Возвращает значения профилей, прочитанные из места их хранения Initialize ProviderBase Инициализирует провайдер SetProperty Values ProfileProvider Сохраняет текущий профиль 
Создание пользовательских провайдеров ASP.NET Глава 4 167 Я не собираюсь реализовывать все методы, унаследованные от базового класса SettingsProvider. Все они просто выбрасывают исключение "not supported": public override int DeleteProfiles(string[] usernames) { throw new NotSupportedException(); } У данного класса три открытых свойства: ApplicationName (переопределяется), CookieName и CookieExpires. public class CookieProfileProvider : ProfileProvider { private string _cookieName; private int _cookieExpires; private string _appName; public CookieProfileProvider() {} public override string ApplicationName { get { return _appName; } set { _appName = value; } } public virtual string CookieName { get { return _cookieName; } set { _cookieName = value; } } public virtual int CookieExpires { get { return _cookieExpires; } set { _cookieExpires = value; } } }Метод Initialize Данный метод считывает из конфигурационного раздела атрибуты cookieName и cookieExpires и инициализирует открытые свойства значениями по умолчанию. public override void Initialize(string name, NameValueCollection config) { if (config == null) throw new ArgumentNullException("Null configuration parameters"); //Убеждаемся, что у провайдера есть имя if (String.IsNullOrEmpty(name)) name = "CookieProfileProvider"; //Вызываем метод базового класса base.Initialize(name, config); //Считываем имя приложения _appName = config["applicationName"];
168 Часть I Внутренние механизмы ASP.NET if (String.IsNullOrEmpty(_appName)) _appName = HostingEnvironment.ApplicationVirtualPath; config.Remove("applicationName"); //Считываем имя cookie _cookieName = config["cookieName"]; if (String.IsNullOrEmpty(_cookieName)) _cookieName = ".PROF"; config.Remove("cookieName"); //Считываем срок службы cookie bool success = Int32.TryParse(config["cookieExpires"], out _cookieExpires); if (!success) _cookieExpires = 10; config.Remove("cookieExpires"); //Выбрасываем исключение, если остались неизвестные атрибуты if (config.Count > 0) { string attrib = config.GetKey(0); if (!String.IsNullOrEmpty(attrib)) throw new ProviderException("Unrecognized attribute: " + attrib); } }Метод GetPropertyValues Метод GetPropertyValues должен возвращать информацию пользовательского профиля. В нем нужно прочесть данные из их хранилища и поместить в специальную коллекцию. Возвращаемую коллекцию ASP.NET использует для инициализации членов объек та пользовательского профиля, с которым и будет работать страница. Аргументом, пе-редаваемым системой методу GetPropertyValues, является список свойств профиля, значения которых данный метод должен вернуть. Во избежание деинициализации свойств профиля, объявленных в разделе <profile> файла web.config, важно вначале обработать список запрошенных свойств и добавить их в возвращаемую коллекцию. Только после этого можно проверять наличие запро-шенных данных. Рассмотрим такой код: public override SettingsPropertyValueCollection GetPropertyValues( SettingsContext context, SettingsPropertyCollection properties) { SettingsPropertyValueCollection settings; settings = new SettingsPropertyValueCollection(); //Выясняем, сколько свойств предстоит извлечь if (properties.Count == 0) return settings; //Добавляем запрошенные свойства в выходную коллекцию, //гарантируя тем самым создание необходимого числа элементов //объекта Profile и то, что он не будет равен null foreach (SettingsProperty property in properties) { SettingsPropertyValue pv = new SettingsPropertyValue(property); settings.Add(pv); }
Создание пользовательских провайдеров ASP.NET Глава 4 169 //Считываем cookie (если таковой имеется) string username = (string)context["UserName"]; string cookie = CookieName + "_" + username; HttpCookie cookieProfile = HttpContext.Current.Request.Cookies[cookie]; if (cookieProfile == null) return settings; //Декодирование Base64 и двоичная десериализация string data = cookieProfile["SerializedData"]; byte[] bits = Convert.FromBase64String(data); Hashtable table = null; using(MemoryStream mem = new MemoryStream(bits) { BinaryFormatter bin = new BinaryFormatter(); table = (Hashtable) bin.Deserialize(mem); mem.Close(); } //Заполняем свойства данными foreach (SettingsPropertyValue spv in settings) { //Предоставленное нами значение готово для использования spv.Deserialized = true; spv.PropertyValue = table[spv.Name]; } return settings; } Первый цикл for ... each гарантирует, что каждому запрошенному свойству будет поставлен в соответствие элемент возвращаемой коллекции. Каждый объект ини-циализируется при помощи своего создаваемого по умолчанию конструктора, и ему присваивается значение соответствующего типа данных: по умолчанию false - для булевых значений, 0 - для целочисленных и т. д. Только те свойства, которые добав-лены в коллекцию settings, в объекте Profile страницы будут иметь значения (то есть не будут равны null). В файле cookie хранится закодированная хэш-таблица, которая содержит значе-ния, соответствующие свойствам из модели данных. Поговорим о структуре этого cookie подробнее. Метод SetPropertyValues Метод SetPropertyValues предназначен для сохранения содержимого пользовательского профиля по завершении обработки каждого запроса. Метод получает набор свойств, значения которых подлежат сохранению, и некоторую информацию из контекста. Такая информация представляется классом SettingsContext хэш-таблицы. Его экзем-пляр создает и заполняет сама ASP.NET, а точнее, это делает класс ProfileBase, яв-ляющийся родительским для динамически генерируемого класса профиля. В методе SetPropertyValues создаются два элемента: UserName и IsAuthenticated; в первый зано-сится имя текущего пользователя, а во второй - значение булева типа, указывающее, аутентифицирован пользователь или он подключился анонимно. Приведенный далее код копирует все подлежащие сохранению свойства в проме-жуточную хэш-таблицу. Ключ каждой записи генерируется на основе имени свойства, а ее значением является значение свойства. Затем эта хэш-таблица сериализуется в двоичную форму и переводится в кодировку Base64. Результирующая строка сохра-няется в cookie-файле в виде единственной записи с именем SerializedData. public override void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection properties)
170 Часть I Внутренние механизмы ASP.NET { //Получаем информацию о пользователе string username = (string)context["UserName"]; bool authenticated = (bool)context["IsAuthenticated"]; //Если свойств нет, возврат if (String.IsNullOrEmpty(username) || properties.Count == 0) return; //Подготавливаем cookie string cookie = CookieName + "_" + username; HttpCookie cookieProfile = HttpContext.Current.Request.Cookies[cookie]; if (cookieProfile == null) cookieProfile = new HttpCookie(cookie); cookieProfile.Expires = DateTime.Now.AddMinutes(CookieExpires); //Подготавливаем сохраняемые данные Hashtable table = new Hashtable(); foreach (SettingsPropertyValue pp in properties) { if (!authenticated && !(bool)pp.Property.Attributes["AllowAnonymous"]) continue; table.Add(pp.Name, pp.PropertyValue); } //Кодируем хэш-таблицу и записываем ее в cookie BinaryFormatter bin = new BinaryFormatter(); MemoryStream mem = new MemoryStream(); bin.Serialize(mem, table); string data = Convert.ToBase64String(mem.GetBuffer(), 0, (int) mem.Length); cookieProfile["SerializedData"] = data; //Сохраняем cookie HttpContext.Current.Response.AppendCookie(cookieProfile); }Основы сервиса профилей В коде страницы для доступа к пользовательскому профилю используется свойство HttpContext.Profile. Это свойство связано с экземпляром класса ProfileCommon. Дан-ный класс не существует статически в .NET Framework, а создается на лету после обработки содержимого подраздела <properties> раздела <profile> из файла web.config. В состав класса ProfileCommon включается столько свойств, сколько элементов в разделе <properties>. Каждое свойство имеет атрибуты, лишь отдельные из которых имеют отношение к созданию класса ProfileCommon. В табл. 4-4 перечислены те атри-буты свойств, которые вы можете задавать, используя элементы <add>. (Подробнее о настройке конфигурации рассказывается в главе 3.) Табл. 4-4. Атрибуты, задаваемые с помощью элементов <add> Атрибут Описание allowAnonymous Разрешает сохранять значения для анонимных пользователей. По умолчанию имеет значение false defaultValue Значение свойства по умолчанию customProviderData Данные для пользовательского провайдера профиля
Создание пользовательских провайдеров ASP.NET Глава 4 171 Атрибут Описание name Имя свойства provider Имя провайдера readOnly Определяет, будет ли значение свойства доступным только для чтения. По умолчанию имеет значение false serializeAs Способ сериализации значения свойства. Допустимые варианты: Xml, Binary, String и ProviderSpecific type Тип свойства в .NET Framework, по умолчанию - строковый объект На структуре свойства, входящего в состав класса ProfileCommon, отражаются толь-ко значения атрибутов readOnly и type. Остальные атрибуты используются провай-дером при сохранении данных профиля. Класс ProfileCommon наследует класс .NET Framework ProfileBase. Последний не является абстрактным, но содержит очень мало кода. Он наследует SettingsBase. Эти два базовых класса составляют основу провайдера и вызывают его методы - GetPropertyValues и SetPropertyValues. Список сохраняемых свойств считывается из файла web.config. Для каждого свойс-тва создается дескрипторный класс SettingsProperty, члены которого представляют атрибуты, перечисленные в табл. 4-4. Методы GetPropertyValues и SetPropertyValues получают коллекцию объектов класса SettingsProperty и вызываются для загрузки и сохранения соответствующих значений. На рис. 4-8 показана схема взаимодействия между провайдером профиля и демонстрационной страницей. Рис. 4-8. Взаимодействие классов и провайдеров профиля Класс ProfileBase поддерживает два метода, Create и Save, вызываемые основным кодом страницы перед ее инициализацией, но после создания разметки. Вызов мето-да Create порождает вызов метода GetPropertyValues. Вызов метода Save завершается вызовом метода SetPropertyValues. Когда вызывается метод SetPropertyValues, дескриптор содержит информацию, которая может использоваться для некоторой оптимизации. В данном случае де-скриптором свойства является экземпляр класса SettingsPropertyValue. Его свойства перечислены в табл. 4-5. Табл. 4-5. Свойства класса SettingsPropertyValue Атрибут Описание Deserialized Указывает, является ли значение свойства десериализованным. Если нет, то есть данное свойство имеет значение false, ASP.NET пытается десериа-лизировать значение, используя алгоритм, заданный в свойстве SerializeAs дескриптора SettingsProperty. Если сериализацию берет на себя провайдер, данный атрибут всегда должен иметь значение true. Именно так происходит в нашем примере Табл. 4-4. (окончание) (см. след. стр.)
172 Часть I Внутренние механизмы ASP.NET Атрибут Описание IsDirty Указывает, модифицировал ли код страницы значение свойства Name Возвращает имя свойства Property Возвращает дескриптор SettingsProperty свойства PropertyValue Значение свойства в исходной, десериализованной, форме SerializedValue Значение свойства в сериализованной форме. Его формат зависит от значения атрибута SerializeAs дескриптора SettingsProperty UseDefaultValue Указывает, содержит ли свойство значение по умолчанию Обычно провайдер профиля не сохраняет свойства, значения которых не изме-нились со времени последнего запроса. О том, изменилось ли значение свойства, сигнализирует флаг IsDirty. Точно так же провайдер может не сохранять значения по умолчанию, поскольку они жестко закодированы в web.config и присваиваются свойствам автоматически. Индикатором того, используется ли значение по умолча-нию, служит свойство UseDefaultValue. Наконец, провайдеру не обязательно брать на себя заботу о сериализации. Для повышения производительности провайдер обычно сохраняет сериализованное значе-ние, предоставленное дескриптором свойства; но если таковое не предоставляется, он сохраняет значение в исходном виде. Последнее, безусловно, возможно только для при-митивных типов. Ради простоты наш демонстрационный провайдер всегда будет брать исходные значения свойств и сериализовать их в виде последовательности байтов. Заглянув в свойство Deserialized, провайдер узнает, где ему брать сохраняемое значение: если там содержится true, то в PropertyValue, а если false, то в SerializedValue. Когда свойство Deserialized имеет значение true, а свойство PropertyValue - значение null, провайдер считает, что свойство имеет значение null. Примечание Сервис пользовательских профилей можно включать и отключать, но только совсем - вы не можете включить его для одних страниц, и отключить для других. Однако как же быть, когда требуется использовать его только с подмножеством страниц прило-жения? А ничего делать и не нужно - механизм провайдеров профиля разрабатывался именно для такого случая. Провайдер профиля вызывается только тогда, когда страница вызывает объект Profile - запрашивает через него данные профиля или выполняет их запись. Все остальное время он бездействует, так что никаких ненужных операций чтения и записи профиля система не выполняет. Профили, общие для всего приложения Свойство ApplicationName, имеющееся у большинства провайдеров. предназначено для определения области применения данных профиля. Например, вызываемые по умолчанию провайдеры, хранящие информацию в SQL Server, используют это свой-ство при создании записей для пользователей заданного приложения. Преимущества описанного подхода заключаются в том, что он позволяет несколь-ким приложениям пользоваться одним и тем же хранилищем данных. Такое маловеро-ятно, если данные хранятся в файле MDF, но становится реальным при их хранении в СУБД или передаче через Web-сервис. Наш провайдер, использующий cookie, не обращается к данному свойству. Объединяем все вместе Чтобы система вызывала ваш пользовательский провайдер, он должен быть не только зарегистрирован в приложении, но и назначен используемым по умолчанию. Кроме Табл. 4-5. (окончание)
Создание пользовательских провайдеров ASP.NET Глава 4 173 того, необходимо определить модель данных пользовательского профиля, распростра-няющуюся на все приложение. Все это делается в приведенном далее коде. <anonymousIdentification enabled="true" /> <profile enabled="true" defaultProvider="CookieProfileProvider"> <properties> <add name="BackColor" allowAnonymous="true" type="string" /> <add name="ForeColor" type="string" allowAnonymous="true"/> <add name="Links" allowAnonymous="true" type="System.Collections.Specialized.StringCollection" serializeAs="Xml" /> </properties> <providers> <clear /> <add name="CookieProfileProvider" type="ProAspNet20.CS.Components.CookieProfileProvider, ProAspCompLib" /> </providers> </profile> Заметьте, что для каждого свойства провайдера в отдельности указано, разрешен ли анонимный доступ. Если он разрешен хотя бы для одного свойства, вам необходимо явно разрешить анонимную идентификацию. При анонимной идентификации опре-деляемое системой имя пользователя назначается всем пользователям, не прошед шим аутентификацию при подключении к сайту. Отмечу, что эта функция не имеет ничего общего с аутентификацией Forms и защитой. Она просто позволяет ASP.NET приме-нять единое имя пользователя для хранения предпочтений всех анонимных пользо-вателей. За дополнительной информацией о том, как работать с сервисом про филей, вы можете обратиться к главе 5 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Для того чтобы страницы поддерживали пользовательский провайдер, никаких изменений в них вносить не нужно. Просто используйте объект Profile для чтения и установки значений свойств профиля. Модель провайдеров для пользовательских сервисов Область применения модели провайдеров не ограничена встроенными сервисами, та-кими как сервис членства или состояния сеанса. Пользовательский сервис, входящий в состав вашего приложения, также можно реализовать на основе этой модели. Предполо-жим, что вы хотите предоставить сервис для чтения глобальных установок приложения из различных хранилищ, а не только из раздела <appSettings> файла web.config. Для этого вам нужно первым делом создать класс с набором статических методов, посредством которых приложения будут этот сервис использовать. Назовем данный класс AppSettingsManager. Как минимум он должен предоставлять доступ к свойству AppSettings, представляющему собой коллекцию пар имя-значение. Тогда страницы будут изолированы от особенностей хранения и извлечения установок приложения, и для их чтения нужно будет всегда вызывать свойство AppSettingsManager.AppSettings. Аксессор get свойства AppSettings будет считывать сведения о зарегистрированном провайдере, вызывать его открытый метод (скажем, GetValues) и возвращать странице полученные от этого метода значения. Далее базовый класс провайдера необходимо определить таким образом, чтобы у него было несколько открытых методов, образующих контракт сервиса. Пусть таким 
174 Часть I Внутренние механизмы ASP.NET методом будет известный вам GetValues. Это должен быть абстрактный метод базового класса, наследуемый и реализуемый всеми производными провайдерами. Наконец, новому провайдеру нужен пользовательский раздел в файле web.config. Этот раздел будет иметь специально для указанной цели спроектированную схему, а потому для его разбора нужен пользовательский обработчик разделов. Помимо инициализационных атрибутов провайдера в указанном разделе следует перечис-лить все зарегистрированные провайдеры и указать, какой из них используется по умолчанию. Заключение Для конечного пользователя приложения применение модели провайдеров абсолютно прозрачно; само по себе оно вовсе не означает, что у приложения будет более богатый контент или что оно будет работать быстрее и гибче. Данная модель - это прежде всего элемент инфраструктуры, позволяющий усовершенствовать архитектуру при-ложения и при необходимости модифицировать некоторые системные компоненты, а также создавать собственные настраиваемые сервисные компоненты. В ASP.NET модель провайдеров реализована во многих сервисах, включая сервисы членства, ролей, пользовательских профилей и состояния сеанса. Для каждого из них существует используемый для загрузки и сохранения данных из разных источников базовый класс, который определяет контракт между сервисом ASP.NET и провай-дерами. Вы можете написать собственный провайдер, создав класс, производный от этого базового класса и переопределяющий его методы. При этом на страницах, использующих провайдер, его замена никак не отразится. В этой главе я привел обзор всех встроенных провайдеров различных сервисов и показал, как разработать собственный такой провайдер. Только факты Некоторые встроенные сервисы (например, сервисы членства, профилей и состо-яния сеанса) делегируют определенные стандартные задачи внешним заменяемым компонентам, именуемым провайдерами. Модель провайдеров открывает возможность модификации определенных частей исполняющей среды ASP.NET путем создания собственных классов, производных от базовых классов, которые определяются данной моделью. Провайдерами в ASP.NET 2.0 являются классы, производные от базовых и реали-зующие несколько абстрактных методов. Создавая собственный провайдер сервиса, вы начинаете с определения нового класса, наследующего базовый класс провайдеров данного типа. Все провайдеры всех сервисов являются производными от базового класса ProviderBase. Чаще всего провайдеры отличаются друг от друга способом ввода-вывода данных. Обычно два провайдера одного сервиса используют разные источники данных - файлы, базы данных, Web-сервисы, cookie и т. д. Большинство встроенных провайдеров ASP.NET хранят информацию в базе дан-ных aspnetdb.mdf в SQL Server 2005 Express. Для каждого приложения создается свой экземпляр провайдера. Провайдер дол-жен поддерживать потоки, поскольку отдельные запросы страниц приложения выполняются в разных потоках. 
Глава 5 Создание сложных страниц Не все страницы ASP.NET одинаковы, и не только потому, что каждая из них может вести себя по-своему и обладать индивидуальным набором элементов управления. Не-которые функции страниц реализуются с использованием потенциально длительных операций - таких, например, как обращение к базе данных или вызов Web-сервиса. Для подобных случаев классическая и по определению синхронная модель обработки страниц ASP.NET не подходит. Асинхронные обработчики HTTP существовали со времени ASP.NET 1.0, но только в ASP.NET 2.0 была реализована настоящая подде-ржка асинхронных страниц. Здесь, наконец, проведено четкое разграничение между синхронными и асинхронными страницами. Решительный переход к декларативному методу программирования, совершенный в ASP.NET 2.0, ставит перед нами новую проблему. Как устанавливать свойства эле-ментов управления, используя программные выражения? В ASP.NET 1.x поддержива-лись блоки кода ASP-стиля и выражения связывания с данными. По разным причи-нам ни те, ни другие не подходят для ситуаций, типичных для ASP.NET 2.0, - когда используются элементы управления, представляющие источники данных. Поэтому команда разработчиков ASP.NET ввела новую концепцию динамических выражений и модель расширения, основанную на построителях выражений. Так что теперь можно задавать пользовательские выражения, применение которых поднимает декларатив-ную модель программирования на качественно новый уровень. В этой главе я расскажу о трех усовершенствованиях модели программирования страниц, делающих доступными более сложные функции, а также раскрою секреты некоторых элементов скрытого механизма обработки страниц ASP.NET. Разработка асинхронных страниц В главе 2 я обратил ваше внимание на различие между синхронными и асинхронны-ми обработчиками, обслуживающими запросы страниц в ASP.NET. Давайте вкратце повторим самые существенные моменты. Каждый входящий запрос ASP.NET назначается потоку, выбранному из пула пото-ков ASP.NET. Этот запрос обслуживается обработчиком HTTP, выбираемым с учетом типа запроса и установок, заданных в файле web.config. Обработчик HTTP - это регистрируемый объект, реализующий интерфейс IHttpHandler, и в частности метод ProcessRequest, который, собственно, и отвечает за выполнение запроса. Упомянутый поток вызывает метод ProcessRequest обработчика и ждет завершения его выполнения. Как долго? Если операция выполняется медленно или запрашиваемый ресурс не отвечает, синхронная страница попросту блокируется и соответственно блокируется ее поток. Поэтому применение синхронных обработчиков для выполнения потенциально дли-тельных операций, не требующих участия центрального процессора, ставит под угрозу масштабируемость приложения. На сайте с высоким трафиком приложение может внезапно перестать отвечать на действия пользователя, если количество свободных потоков в пуле окажется равным нулю.
176 Часть I Внутренние механизмы ASP.NET Единственным выходом из этой трясины является применение асинхронных об-работчиков. В ASP.NET 1.x для их создания необходимо было хорошо разбираться в асинхронной модели .NET Framework и соответствующих событиях исполняющей среды HTTP, а кроме того, приходилось писать довольно сложный программный код. В противоположность этому в ASP.NET 2.0 существует четкое разделение обработчи-ков и страниц на синхронные и асинхронные и имеется ряд функций, существенно упрощающих разработку последних. Инструменты ASP.NET для асинхронного программирования Чем дольше поток выполняет запрос, тем дольше этот поток не возвращается в пул ASP.NET и не может использоваться для обработки новых входящих запросов. Когда потоков, доступных для обслуживания запроса, нет, этот запрос ставится в очередь. Однако очередь - ресурс конечный. Ее размер статически определяется в конфигура-ционном файле посредством атрибута appRequestQueueLimit раздела <httpRuntime> . Здесь указывается максимальное количество запросов, которые приложение может поставить в очередь, прежде чем выдаст ошибку 503 "Server too busy". По умолча-нию это количество в ASP.NET 1.x составляет 100, а в ASP.NET 2.0 его предельное значение - 5000. Синхронные страницы, инициирующие выполнение длительных задач, а в общем случае и любая форма синхронных обработчиков HTTP, - это настоящие "убийцы производительности". В лучшем случае их применение приводит к тому, что пользо-вателям сайта приходится дольше ожидать получения запрашиваемых страниц, пос-кольку запросы, вместо того чтобы немедленно выполняться, все время оказываются в очереди. Ну а в худшем случае очередь переполняется и пользователи получают сообщение "Server too busy". Примечание Интересно отменить, что, хотя количество доступных потоков в пуле и мо-жет достигать нуля, большая их часть, будучи задействованными в выполнении страниц, на самом деле простаивает. В таких случаях процент загрузки ЦП обычно минимален. Например, пока выполняется вызванный Web-сервис, локальный поток бездействует, поскольку большая часть работы происходит на удаленном компьютере. Таким образом получается, что бездействующие потоки недоступны для выполнения новых запросов, те стоят в очереди, а время отклика на запросы пользователей недопустимо возрастает. Очевидно, что такая трата ресурсов совершенно неприемлема. Интерфейс IHttpAsyncHandler В ASP.NET обработчики HTTP по умолчанию синхронны. Асинхронный же обработ-чик организован особым образом и имеет несколько иной интерфейс. От синхронного обработчика он отличается прежде всего наличием методов, предназначенных для асинхронной обработки запроса. Вместо синхронного метода ProcessRequest асинх-ронный обработчик реализует методы, составляющие интерфейс IHttpAsyncHandler; они перечислены в табл. 5-1 Табл. 5-1. Интерфейс IHttpAsyncHandler Метод Описание BeginProcessRequest Содержит код обработки запроса. Этот код должен инициировать выполнение операции во втором потоке и немедленно завершиться EndProcessRequest Содержит код завершения ранее начатой обработки запроса Итак, в асинхронном обработчике HTTP вместо интерфейса IHttpHandler реализу-ется интерфейс IHttpAsyncHandler. Соответственно, асинхронная страница ASP.NET 
Создание сложных страниц Глава 5 177 представляет собой класс, реализующий IHttpAsyncHandler, а не IHttpHandler. Объект HttpRuntime, управляющий выполнением запросов ASP.NET, разработан таким об-разом, чтобы можно было различать синхронные и асинхронные обработчики и пра-вильно с ними обращаться (см. главу 1). Метод BeginProcessRequest Сигнатура метода BeginProcessRequest такова: IAsyncResult BeginProcessRequest( HttpContext context, AsyncCallback cb, object extraData); В аргументе context передается ссылка на контекст HTTP. Помимо прочего, через этот контекст доступны внутренние объекты сервера, такие как Request и Response. Вторым аргументом является объект AsyncCallback, который нужно будет вызвать, когда выполнение запроса завершится. Третий аргумент, extraData, - это универсаль-ная переменная, содержащая дополнительные данные, которые вы хотите передать обработчику. Метод BeginProcessRequest создает новый поток и запускает в нем на выполнение длительную операцию, в которой не задействован ЦП, например вызов Web-сервиса, обращение к аппаратному устройству или выполнение сложного запроса к базе данных. Инициировав эту операцию, метод должен немедленно завершить свою работу. Значение, возвращаемое методом BeginProcessRequest, то есть объект, который реализует интерфейс IAsyncResult, позже, по окончании длительной операции, будет использовано для завершения обработки запроса и выдачи сформированной страницы. Но что собой представляет IAsyncResult? Интерфейс IAsyncResult Коротко говоря, интерфейс IAsyncResult представляет состояние асинхронной опера-ции. Этот интерфейс обычно реализуют в классах, используемых для работы с асин-хронными методами. Такой класс служит типом возвращаемого методом значения. Хороший пример - метод BeginRead класса FileStream. А еще объекты, основанные на IAsyncResult, передаются в качестве входных данных методам, завершающим асин-хронные операции, - таким, как EndRead класса FileStream. Объект, реализующий интерфейс IAsyncResult, хранит информацию о состоянии асинхронной операции и обычно предоставляет синхронизационный объект, посредс-твом которого подается сигнал о ее завершении. Метод EndProcessRequest Метод EndProcessRequest вызывается тем не принадлежащим пулу потоком, который выполняет потенциально длительную операцию, по завершении этой операции. Про-тотип данного метода следующий: void EndProcessRequest(IAsyncResult result); Его входной параметр IAsyncResult - это значение, возвращенное методом BeginProcessRequest. Внимание! Метод BeginProcessRequest вызывается в потоке, созданном вручную и не инициализируемом ссылкой на контекст HTTP. Поэтому вы не можете получить из него доступ к контексту запроса - ссылка HttpContext.Current возвращает здесь null. Роль асинхронных обработчиков трудно переоценить. Они необходимы во всех слу-чаях, когда при обработке запросов страниц выполняются потенциально длительные 
178 Часть I Внутренние механизмы ASP.NET операции. В ASP.NET 1.x создавать асинхронные страницы и обработчики было слож-но, но в ASP.NET 2.0 появились средства, упрощающие разработку асинхронных страниц. Однако такие средства существуют только для страниц .aspx. Если же вам потребуется асинхронный обработчик HTTP, то создавать его придется с нуля - так же, как это делалось в ASP.NET 1.x. Основные этапы создания асинхронного обра-ботчика в ASP.NET 2.0 описаны в главе 2. Примечание За дополнительной информацией и примерами асинхронных обработчиков для ASP.NET 1.x обратитесь к MSDN Magazine за июнь 2003 года - нужную статью вы найдете по адресу: http://msdn.microsoft.com/msdnmag/issues/03/06/Threading. Средства ASP.NET 2.0 Асинхронная страница характеризуется наличием нового атрибута директивы @Page и одной или более задач, зарегистрированных как выполняемые асинхронно. Заре-гистрировать их можно одним из двух способов: определить пару асинхронных обра-ботчиков Begin и End события PreRenderComplete либо создать объект PageAsyncTask, представляющий асинхронную задачу. Страница может быть асинхронно привязана к событию PreRenderComplete в лю-бой период своего жизненного цикла до события PreRender. Обычно такую привязку осуществляют в обработчике события Page_Load путем вызова нового метода Add-OnPreRenderCompleteAsync класса Page. Можно также зарегистрировать асинхронную задачу, вызвав метод RegisterAsyncTask и передав ему объект PageAsyncTask, - в любое время до того, как страница окажется в состоянии пререндеринга. Но независимо от способа регистрации выполнение асинхронной задачи будет начинаться автоматически, когда процесс формирования страницы дойдет до извес-тной точки. Остановимся на этом подробнее. Примечание В ASP.NET асинхронная страница - это по-прежнему класс, производный от Page. Не существует специального базового класса, предназначенного для создания таких страниц. Атрибут Async Asynk является новым атрибутом директивы @Page булева типа и служит для вклю-чения и отключения асинхронной обработки. По умолчанию его значением является false. <%@Page Async="true" ... %> Атрибут Async - это просто сообщение для анализатора страницы. Последний реализует в динамически генерируемом классе, представляющем ресурс .aspx, интер-фейс IHttpAsyncHandler. Также атрибут Async позволяет странице зарегистрировать асинхронные обработчики события PreRenderComplete. Никакой дополнительный код вследствие установки этого атрибута не выполняется. Давайте рассмотрим запрос страницы TestAsync.aspx, помеченной атрибутом Async. Динамически создаваемый для нее класс ASP.TestAsync_aspx объявляется следующим образом: public class TestAsync_aspx : TestAsync, IHttpAsyncHandler { }
Создание сложных страниц Глава 5 179 Класс TestAsync определен в файле кода. Он наследует класс Page или класс, про-изводный от Page. Что касается IHttpAsyncHandler, то это канонический интерфейс, используемый для асинхронной подготовки запрошенных ресурсов со времен ASP. NET 1.0. Позднее мы еще вернемся к встроенной реализации данного интерфейса. Метод AddOnPreRenderCompleteAsync Метод AddOnPreRenderCompleteAsync определяет асинхронный обработчик события PreRenderComplete страницы, состоящий из пары методов, Begin и End: AddOnPreRenderCompleteAsync ( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask) ); BeginEventHandler и EndEventHandler - это делегаты, объявленные следующим образом: IAsyncResult BeginEventHandler( object sender, EventArgs e, AsyncCallback cb, object state) void EndEventHandler( IAsyncResult ar) В файл кода вы помещаете вызов AddOnPreRenderCompleteAsync, выполняемый как можно раньше, и во всяком случае до того, как произойдет событие PreRender. Обычно хорошим местом для него является обработчик события Page_Load. Далее вы определяете два асинхронных обработчика событий. Примечание Прежде чем помещать вызов AddOnPreRenderCompleteAsync в обработчик события Page_Load, хорошо подумайте. Это подходящее место, если вы имеете дело со страницей, вызванной другой страницей для выполнения операции и отображения ре-зультатов. Если же страница должна выполнять асинхронную операцию по требованию, лучше поместить вызов в обработчик события возврата страницы. Однако в таком случае если страница будет возвращена с использованием других элементов управления, при ее обновлении вы рискуете потерять результаты асинхронной операции. Позднее мы еще об этом поговорим, а пока просто будем считать, что обработчик события Page_Load подходит для вызова AddOnPreRenderCompleteAsync в большинстве случаев, но данный момент требует внимания. Обработчик Begin отвечает за инициирование операции, которая потенциально может надолго заблокировать поток. От него ожидается возврат объекта IAsyncResult, содержащего описание состояния асинхронной задачи. Обработчик End завершает выполнение операции и обновляет пользовательский интерфейс и элементы управ-ления страницы. Заметьте, что вам не обязательно создавать собственный объект, реализующий интерфейс IAsyncResult. В большинстве случаев для запуска длительной операции вы будете пользоваться встроенными классами, реализующими асинхрон-ную схему и предоставляющими готовые объекты IAsyncResult. Внимание! Обработчики событий Begin и End вызываются в разное время и обычно в разных потоках, принадлежащих пулу. Именно между их вызовами и происходит дли-тельная операция. С точки зрения исполняющей среды ASP.NET события Begin и End подобны разным запросам одной и той же страницы, как будто асинхронный запрос разбит на два действия: Begin и End. Обычно действие Begin выполняется потоком, взятым из пула рабочих потоков ASP.NET, а действие End - потоком, который выбран из пула потоков завершения.
180 Часть I Внутренние механизмы ASP.NET Обработка запроса страницы достигает стадии PreRenderComplete. К этому времени у вас есть пара асинхронных обработчиков событий. Исполняющая среда ASP.NET запускает обработчик события Begin, тот начинает длительную операцию, и подготовка страницы приостанавливается до завершения данной операции. После завершения операции исполняющая среда продолжает обработку запроса, возобновляя ее с той же стадии, на которой она была приостановлена - PreRenderComplete. Выполняется обработчик события End, и страница доходит до конца своего жизненного цикла, включая генерирование разметки и выгрузку клиентской страницы. Значение стадии PreRenderComplete Таким образом, выполнение асинхронной страницы продолжается до тех пор, пока не будет достигнута стадия PreRenderComplete, затем блокируется на время выполне-ния асинхронной операции, после чего возобновляется со стадии PreRenderComplete. Возникает резонный вопрос: почему именно здесь, что такого особенного в событии PreRenderComplete? В архитектуре ASP.NET 2.0 предусмотрена единственная точка выполнения асин-хронных операций, известная как асинхронная точка (async point). Она находится между событиями PreRender и PreRenderComplete. Когда страница получает событие PreRender, асинхронная точка еще не достигнута. В момент возникновения события PreRenderComplete она уже пройдена. Как вы увидите в следующем разделе, процесс обработки запроса асинхронной страницы делится на два этапа - до и после асинх-ронной точки. Данная точка располагается вблизи события PreRenderComplete. Вот почему это событие особенное, и вам нужно о нем знать. Метод RegisterAsyncTask Метод AddOnPreRenderCompleteAsync - не единственное имеющееся в вашем рас-поряжении средство регистрации асинхронной задачи. В большинстве случаев даже лучшим решением является метод RegisterAsyncTask. Он имеет тип void и прини-мает объект класса PageAsyncTask. В полном соответствии со своим именем класс PageAsyncTask представляет задачу, подлежащую асинхронному выполнению. (О син-таксисе и применении метода RegisterAsyncTask мы поговорим чуть позже.) Создание демонстрационной асинхронной страницы На данном этапе нашего обсуждения вам недостает знания множества деталей внут-ренней реализации асинхронных страниц. И все же вы знаете достаточно, для того чтобы я мог продемонстрировать вам код простейшей асинхронной страницы, зада-ча которой - загрузить и обработать RSS-ленту из моего персонального блога. Вот разметка этой страницы: <%@Page Async="true" Language="C#" AutoEventWireup="true" CodeFile="TestAsync.aspx.cs" Inherits="TestAsync" %> <html> <body> <form id="form1" runat="server"> <% = rssData %> </form> </body> </html> А вот содержимое ее файла кода: public partial class TestAsync : System.Web.UI.Page {
Создание сложных страниц Глава 5 181 const string RSSFEED = "http://weblogs.asp.net/despos/rss.aspx"; private WebRequest req; public string rssData; void Page_Load (object sender, EventArgs e) { AddOnPreRenderCompleteAsync ( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask)); } IAsyncResult BeginTask(object sender, EventArgs e, AsyncCallback cb, object state) { //Выполняем трассировку Trace.Warn("Begin async: Thread=" + Thread.CurrentThread.ManagedThreadId.ToString()); //Подготавливаем Web-запрос RSS-ленты req = WebRequest.Create(RSSFEED); //Начинаем операцию и возвращаем объект IAsyncResult return req.BeginGetResponse(cb, state); } void EndTask(IAsyncResult ar) { //Этот код будет вызываться в потоке из пула string text; using (WebResponse response = req.EndGetResponse(ar)) { StreamReader reader; using (reader = new StreamReader(response.GetResponseStream())) { text = reader.ReadToEnd(); } //Обрабатываем данные RSS rssData = ProcessFeed(text); } //Выполняем трассировку Trace.Warn("End async: Thread=" + Thread.CurrentThread.ManagedThreadId.ToString()); //Страница обновляется с использованием блока кода ASP-стиля в исходном //файле ASPX, который выводит на экран содержимое переменной rssData } string ProcessFeed(string feed) { //Формируем выходную страницу на основе входных данных XML-формата } }
182 Часть I Внутренние механизмы ASP.NET Примечание Как вы, вероятно, знаете, RSS (Really Simple Syndication - действительно простая синдикация) - это механизм публикации лент новостей в Интернете. RSS явля-ется частью словаря XML, но в отличие от многих других элементов XML его описания вы не найдете на сайте консорциума W3C. "Официальная" спецификация RSS опубликована по адресу http://blogs.law.harvard.edu/tech/rss. Как видите, данная асинхронная страница отличается от обычной только упоми-навшимися выше элементами - атрибутом Async директивы Page и парой асинхрон-ных обработчиков событий. На рис. 5-1 данная страница показана в действии. Рис. 5-1. Демонстрационная асинхронная страница загрузила ссылки из блога Интересно также взглянуть на сообщения, полученные в результате трассировки выполнения страницы (рис. 5-2). Стадии Begin и End обслуживаются разными пото-ками и наступают в разные моменты времени. Рис. 5-2. Детальные сообщения трассировки демонстрируют два необходимых этапа асинхронной обработки запроса
Создание сложных страниц Глава 5 183 Заметьте, что время, прошедшее между моментами Exit BeginTask и Enter EndTask, гораздо больше интервала между любыми другими двумя последовательными опера-циями. Именно тут и происходит длительная операция, в данном случае - загрузка и обработка ленты RSS. Кроме того, в этот интервал входит время, затраченное на извле-чение из пула другого потока для обслуживания второй части исходного запроса. Операции, для которых подходит асинхронное выполнение Какие же операции являются хорошими кандидатами на асинхронное выполне-ние? Давайте попробуем формализовать ответ на этот вопрос. Все операции можно условно разделить на два класса: выполняемые централь-ным процессором и устройствами ввода-вывода. К первому классу относятся опе-рации, время выполнения которых определяется быстродействием процессора и объемом доступной памяти, а ко второму - те, при выполнении которых процессору большую часть времени приходится ждать завершения работы других устройств. Необходимость в асинхронной обработке возникает тогда, когда большая часть времени выполнения операции затрачивается не на обработку данных, а на их ввод и вывод. В таких ситуациях ЦП бездействует или очень мало загружен. Если же говорить о приложениях ASP.NET, то для них подобные ситуации еще более нежелательны, поскольку блокируются потоки, используемые для обслуживания запросов. Вот здесь и проявляются достоинства асинхронной модели, в которой при выполнении асинхронного ввода-вывода потоки не блокируются. Типичными примерами операций, в которых задействуются преимуществен-но устройства ввода-вывода, являются доступ к удаленным источникам данных и взаимодействие с внешними устройствами. Операции с удаленными базами данных и вызовы удаленных Web-сервисов - первые кандидаты на реализацию в рамках асинхронных страниц. Но и те операции, при выполнении которых активно используется процессор (например, алгоритм с интенсивными вычислениями, производимыми с данными, находящимися в оперативной памяти), в некоторых случаях лучше реализовать асинхронно, чтобы обеспечить быстрое освобождение потоков из пула. В таких случаях производительность, конечно, не будет столь же высокой, как при выпол-нении ввода-вывода, но по крайней мере сервер не окажется заблокированным из-за того, что в пуле не осталось свободных потоков. Реализация асинхронных страниц Если вы считаете, что вам достаточно общего представления о принципах работы асинхронных страниц ASP.NET 2.0, то можете этот раздел пропустить. Он написан для тех, кто намерен углубленно изучить данную технологию. Как уже упоминалось, атрибут Async является просто директивой для анализатора страниц. Если он задан, в результирующей странице ASP.NET реализуется интерфейс IHttpAsyncHandler, и она интерпретируется и обрабатывается исполняющей средой ASP.NET как асинхронная. Когда обработчик HTTP определенного ресурса реали-зует данный интерфейс, исполняющая среда HTTP использует модель асинхронной обработки, иллюстрируемую следующим псевдокодом: //Этот псевдокод выполняется методом ProcessRequest объекта HttpRuntime (см. главу 1) if (requestHandler is IHttpAsyncHandler) { //completionCallback указывает на код, с которого возобновляется //выполнение страницы после асинхронной точки (PreRenderComplete)
184 Часть I Внутренние механизмы ASP.NET ctx.AsyncAppHandler = requestHandler; requestHandler.BeginProcessRequest(ctx, completionCallback, ctx); }else { requestHandler.ProcessRequest(context1); FinishRequest(ctx.WorkerRequest, ctx, null); } Когда атрибут Async установлен в true, результирующий код страницы изменяется таким образом, чтобы эта страница выполнялась асинхронно. Однако если для собы-тия PreRenderComplete не задан асинхронный обработчик, по окончании выполнения вызова BeginProcessRequest немедленно происходит обратный вызов, который обслу-живается тем же потоком. Мы можем сделать следующие выводы. Одной только установки атрибута Async недостаточно для обеспечения асинхрон-ной обработки страницы; необходимо зарегистрировать задание, которое будет выполняться асинхронно. Установкой Async=true следует помечать лишь те страницы, для которых действи-тельно необходимо асинхронное выполнение. Существует возможность создания дуальных страниц, то есть таких, которые выполняются асинхронно лишь при определенных обстоятельствах. Для таких страниц задания регистрируются условно - например, после щелчка кнопки. Мы вернемся к этой теме чуть позже и рассмотрим конкретный пример. А сейчас давайте обратимся к встроенной реализации интерфейса IHttpAsyncHandler, предоставляемой исполняющей средой ASP.NET. Реализация интерфейса IHttpAsyncHandler В главе 1 речь шла о том, как можно получить исходный код динамически генериру-емых классов разработанных вами страниц. Описанным там методом я и воспользо-вался, чтобы продемонстрировать фрагмент исходного кода класса, обслуживающего демонстрационную страницу TestAsync.aspx: public virtual IAsyncResult BeginProcessRequest( HttpContext context, AsyncCallback cb, object data) { return base.AsyncPageBeginProcessRequest(context, cb, data); }public virtual void EndProcessRequest(IAsyncResult ar) { base.AsyncPageEndProcessRequest(ar); } AsyncPageBeginProcessRequest - защищенный метод класса страницы ASP.NET 2.0. Этот метод ставит задание в очередь для выполнения потоком из пула. Заданием здесь является часть процесса обработки запроса, которая завершается непосредственно перед асинхронной точкой - то есть, перед началом стадии PreRenderComplete. Ины-ми словами, метод AsyncPageBeginProcessRequest направляет запрос на выполнение в потоке из пула до точки синхронизации. Примечание "Асинхронная точка" (async point) и "точка развертывания" (unwind point) - это синонимы, которые используются в этой книге как взаимозаменяемые понятия. Асин-хронной точкой называется момент, в который система принимает решение о том, как будет производиться дальнейшая обработка: синхронно или асинхронно. 
Создание сложных страниц Глава 5 185 Для постановки задания в очередь метод AsyncPageBeginProcessRequest создает новый делегат WaitCallback и связывает его с внутренней функцией: private void AsyncPageProcessRequestBeforeAsyncPoint(object state) { this.ProcessRequest(true, false); } Метод ProcessRequest является перегруженной версией одноименного метода класса Page, используемого для синхронной обработки запроса. Но что это за буле-вы аргументы, которые ему здесь передаются? Вы все поймете, просмотрев данные трассировки стека в момент, когда выполнение страницы достигает стадии PreRender. Вот прототип метода ProcessRequest: void ProcessRequest( bool includeStagesBeforeAsyncPoint, bool includeStagesAfterAsyncPoint) Идея понятна? Работа по обслуживанию асинхронного запроса делится на две части - до и после асинхронной точки. Аргументы метода ProcessRequest определяют, какую из них следует выполнить. Метод AsyncPageBeginProcessRequest выполняет еще одну важную задачу. Когда процесс обработки запроса достигает асинхронной точки, данный метод вызывает зарегистрированные асинхронные задания. Если задание зарегистрировано с исполь-зованием асинхронного обработчика событий, вызывается обработчик Begin. В про-тивном случае, то есть если задание зарегистрировано с помощью RegisterAsyncTask, вызывается новый метод ExecuteRegisteredAsyncTasks класса Page, который запускает все зарегистрированные задания одно за другим. Метод AsyncPageEndProcessRequest управляет этапом, начинающимся со второго этапа обработки исходного запроса, то есть с асинхронной точки, и завершается созда-нием разметки страницы. На рис. 5-3 графически представлены два этапа выполнения асинхронного запроса и для сравнения - схема выполнения синхронного запроса. Рис. 5-3. Асинхронный запрос разбивается на две части - до и после асинхронной точки
186 Часть I Внутренние механизмы ASP.NET Важно знать, что два этапа работы по обслуживанию асинхронного запроса вы-полняются в разных потоках из пула. Жизненный цикл асинхронной страницы Проведенный выше анализ реализации интерфейса IHttpAsyncHandler в ASP.NET по-казывает, что жизненный цикл асинхронной страницы имеет определенные отличия. Давайте рассмотрим последовательность его событий. Объект HttpRuntime принимает запрос и вызывает метод BeginProcessRequest обра-ботчика асинхронной страницы. Выполнение операции начинается в рабочем потоке из пула ASP.NET. Сигналом о завершении операции служит обратный вызов. Рабочий поток выполняет страницу в синхронном режиме до асинхронной точки. При этом, как обычно, генерируются события вплоть до PreRender включительно. По достижении асинхронной точки начинается выполнение асинхронного задания и инициируются операции ввода-вывода. Обработчик Begin возвращает объект, ре-ализующий IAsyncResult. В состав этого объекта входит функция обратного вызова, которая будет вызвана, когда выполнение асинхронного задания завершится. Рабочий поток, обслуживающий запрос, возвращается в пул, хотя асинхронная операция продолжается. На это время ни один поток не блокируется. Когда асинхронное задание выполнено, вызывается функция обратного вызова, которая в свою очередь вызывает обработчик End, и в выходной поток страницы выводятся результаты обратного вызова. Эта работа обычно выполняется в потоке, выбранном из пула потоков завершения. Функция обратного вызова ставит в очередь "второй частичный запрос". Но на этот раз булевы аргументы имеют противоположные значения и выполняется этап, следующий за асинхронной точкой. Выполнение исходного запроса завершается, и управление возвращается объекту HttpRuntime. Объект HttpRuntime вызывает метод EndProcessRequest асинхронного обработчика страницы. Этот обработчик проделывает небольшую работу и генерирует исклю-чение, если в ходе нее происходит ошибка. На этом функции обработчика завершаются, и исполняющая среда HTTP выво-дит ответ, после чего генерирует обычную последовательность событий уровня приложения вплоть до EndRequest. На рис. 5-4 представлена подробная схема процесса завершения асинхронного выполнения запроса. Заметьте, что каждая часть кода, которая на рисунке заключена в рамку, выпол-няется в собственном потоке из пула. Также обратите внимание на то, что имеют место два вложенных обратных вызова. Внешний вызов управляет завершением всего запроса и организуется объектом HttpRuntime, тогда как внутренний логически свя-зывает между собой обработчики Begin и End и содержит пользовательский код. Этот внутренний обратный вызов связывает два этапа жизненного цикла страницы - до и после асинхронной точки. Внешний обратный вызов передает управление в инфраструктуру обработки за-проса и для разработчиков страницы недосягаем. Ниже показано, что происходит внутри этой функции обратного вызова, задача которой - завершить выполнение асинхронного запроса. private void OnHandlerCompletion(IAsyncResult ar) { //Данный код выполняется под управлением объекта HttpRuntime //для завершения жизненного цикла асинхронного запроса. //Это самая внешняя оболочка кода, написанного вами 
Создание сложных страниц Глава 5 187 //для асинхронной страницы HttpContext ctx = (HttpContext) ar.AsyncState; try { ctx.AsyncAppHandler.EndProcessRequest(ar); } catch (Exception ex) { //Восстановление после исключения } finally { //Сброс указателя на асинхронный обработчик ctx.AsyncAppHandler = null; } //Завершение выполнения запроса FinishRequest(ctx.WorkerRequest, ctx, ctx.Error); }Рис. 5-4. Этапы завершения обработки асинхронного запроса
188 Часть I Внутренние механизмы ASP.NET В результате вызова EndProcessRequest производится вызов внутреннего мето-да AsyncPageEndProcessRequest страницы. Метод FinishRequest принадлежит классу HttpRuntime. Он просто выгружает клиентскую страницу, обновляет счетчики про-изводительности и завершает обработку запроса. Асинхронным страницам не требуется полное доверие. Они вполне могут работать на среднем уровне доверия. Примечание Между началом выполнения асинхронной операции и асинхронной точкой должен быть выполнен некоторый код. Теоретически возможно завершение асинхронной операции до достижения асинхронной точки. В любом случае обратный вызов не выпол-няется до тех пор, пока не будет достигнута асинхронная точка. Реальные применения асинхронных страниц Давайте рассмотрим несколько типичных ситуаций, в которых рекомендуется ис-пользовать асинхронные страницы. Вызов Web-сервиса Для того чтобы связать Web-сервис с приложением ASP.NET, вы добавляете в про-ект так называемую Web-ссылку - файл с информацией о сервисе в формате WSDL (Web Service Description Language - язык описания Web-сервиса). Провайдер сборки WSDL-файлов создает клиентский прокси-класс, который может использоваться для осуществления вызовов Web-сервиса. Этот прокси-класс дублирует Web-методы Web-сервиса и добавляет к каждому из них пару методов Begin-End, обеспечивая тем самым возможность их асинхронного вызова. Ниже приведен основной код типичной асинхронной страницы, вызывающей Web-сервис: private MyWeatherService weather; private int temperature; IAsyncResult BeginTask(object sender, EventArgs e, AsyncCallback cb, object state) { weather = new MyWeatherService(); return weather.BeginGetTemperature(cb, state); }void EndTask(IAsyncResult ar) { temperature = weather.EndGetTemperature(ar); } Данные методы BeginTask и EndTask представляют собой пару асинхронных обра-ботчиков события PreRenderComplete. Примечание Ничто не мешает вам добавить также и синхронный обработчик события PreRenderComplete, которое генерируется сразу после асинхронной точки. Для асинх-ронных страниц синхронное событие PreRenderComplete генерируется после выполнения асинхронного End-обработчика. Прокси-класс Web-сервиса, сгенерированный в ASP.NET 2.0, поддерживает также альтернативный способ вызова методов Web-сервиса. Этот второй способ предпочти-телен для вызова методов Web-сервисов в ASP.NET 2.0. Для каждого опубликованного метода сервиса прокси-класс содержит метод xxxAsync и событие xxxCompleted. Ваш код будет выглядеть следующим образом: private MyWeatherService weather; private int temperature;
Создание сложных страниц Глава 5 189 //Этот код может быть привязан к расположенной на странице кнопке protected void OnQueryWeather(object sender, EventArgs e) { //Создаем экземпляр прокси-класса Web-сервиса weather = new MyWeatherService(); //Подготавливаем обработчик события xxxCompleted GetTempCompletedEventHandler hdlr; hdlr = new GetTemperatureCompletedEventHandler(GetTemperatureCompleted); weather.GetTemperatureCompleted += hdlr; //Асинхронно вызываем Web-метод weather.GetTemperatureAsync(...); }void GetTemperatureCompleted(object s, GetTemperatureCompletedEventArgs e) { //Обрабатываем результаты, которые извлекаем из e.Result } В чем различие двух подходов? Оно невелико, если вы выполняете один-единс-твенный асинхронный вызов. Но когда таких вызовов несколько и они связаны между собой, решение на основе метода xxxAsync упрощает задачу. Код прокси-класса авто-матически синхронизирует все поставленные в очередь вызовы и блокирует ренде-ринг страницы до тех пор, пока все они не будут выполнены. Для получения такого же эффекта при использовании подхода на основе обработчиков Begin-End события PreRenderComplete синхронизацию вам придется выполнять вручную. А это означает, что вам нужно будет собрать синхронизационные ссылки на объекты IAsyncResult (свойство AsyncWaitHandle ) в массив и вызвать для этого массива WaitHandle.WaitAll. Нет никакого смысла заниматься всем этим, коль скоро в вашем распоряжении есть метод xxxAsync и ASP.NET готова сама позаботиться о синхронизации. Другим аргументом в пользу подхода на базе метода xxxAsync является то, что контекст потока, в котором выполняется обработчик события MethodCompleted, гораздо богаче, чем контекст потока, где выполняется обработчик End события PreRenderComplete. В частности, он включает информацию имперсонализации, кон-текст HTTP и такие внутренние объекты ASP.NET, как Server и Response. Благодаря наличию информации имперсонализации вы можете использовать обработчик для выполнения таких операций, как доступ к базе данных. Примечание Вызов локального Web-сервиса обслуживается иначе, чем вызовы удален-ных сервисов. Как мы видели в главе 3, ASP.NET резервирует небольшой пул потоков для дочерних запросов, поступающих через локальных хост, в том числе и для вызовов Web-сервисов. Размер этого пула вы определяете посредством атрибута minLocalRequestFree-Threads конфигурационного раздела <httpRuntime>. Когда страница вызывает локальный Web-сервис, этот вызов обслуживается потоком не из основного, а из вспомогательного пула. Таким образом обеспечивается более эффективная обработка в случаях, когда синхронные страницы вызывают локальные Web-сервисы. Но и асинхронные страницы также выигрывают от применения такого подхода. Вызовы Web-сервисов, выполняемые по принципу "сгенерировать и забыть" Данный способ вызова Web-сервисов применяется, когда страница должна вызвать Web-сервис и продолжить работу, не ожидая никакого ответа. В таком случае обра-ботчик End для асинхронного задания не требуется.
190 Часть I Внутренние механизмы ASP.NET К сожалению, такой способ действия не поддерживается в ASP.NET 2.0. Если за-менить обработчик события End пустым значением (null), во время выполнения будет выброшено исключение. Лучшее из того, что вы можете сделать, - это создать пустой обработчик события End и пометить метод Web-сервиса атрибутом OneWay=true, а затем вызвать его, используя синхронный метод прокси-класса. Это можно сделать как для синхронной, так и для асинхронной страницы, в зависимости от оценочной латентности сети. Когда метод Web-сервиса помечен как OneWay, сервис немедленно возвращает вызывающему коду код состояния HTTP 202, чем заканчивается взаимо-действие между ним и клиентом. Метод Web-сервиса, поддерживающий атрибут OneWay, должен иметь тип void и не иметь выходных параметров. Данная технология призвана упростить обработку, которую ASP.NET и IIS выполняют на сервере. Выполнение длительных операций с базой данных В .NET Framework 2.0 провайдер данных Microsoft SQL Server для .NET поддерживает асинхронные команды. Эта поддержка реализована в классе SqlCommand и ограничена выполнением команд, не являющихся запросами на выборку, а также получением объектов записи XML и текста. Важно отметить, что асинхронные команды реализованы таким образом, что не происходит ни создания нового потока, ни, соответственно, его блокировки. Посколь-ку ADO.NET не поддерживает потоки, блокировка потоков привела бы к серьезному снижению производительности. Когда асинхронное выполнение команд разрешено, ADO.NET открывает сокет TCP к базе данных в overlapped-режиме и связывает его с портом завершения ввода-вывода. С технической точки зрения очевидным способом повышения производительности страниц ASP.NET, вовлеченных в длительные транзакции баз данных, является их асинхронная реализация. В ASP.NET 1.x для этого приходилось разрабатывать собс-твенные асинхронные обработчики, но в ASP.NET 2.0 можно пользоваться технологи-ей, описанной в этой главе. Однако, ограничившись только асинхронной реализацией самой страницы, вы будете выполнять операцию доступа к базе данных во втором потоке синхронно, а значит, заблокируете этот второй поток до ее завершения. Это было бы не проблемой для настольного приложения Microsoft Windows, но быстро приведет к серьезным неприятностям в серверном многопоточном приложении напо-добие приложения ASP.NET. Как ни печально, в ASP.NET 1.x других возможностей не существует. Однако в ASP.NET 2.0 можно реализовать дважды асинхронное решение и вы-полнять в асинхронном режиме и саму страницу, и команду доступа к базе данных. Давайте посмотрим, как это делается. Первым делом регистрируется обычная пара асинхронных обработчиков события PreRenderComplete: void Page_Load (object sender, EventArgs e) { AddOnPreRenderCompleteAsync(new BeginEventHandler(BeginTask), new EndEventHandler(EndTask)); } Далее, когда обработка страницы достигнет асинхронной точки, автоматически вызывается обработчик BeginTask: SqlConnection conn; IAsyncResult BeginTask(object sender, EventArgs e, AsyncCallback cb, object state)
Создание сложных страниц Глава 5 191 { //Трассировка (Utils.TraceThread - это пользовательская утилита, //о которой речь пойдет ниже) Utils.TraceThread("Enter BeginTask"); //Подготовка к выполнению асинхронной команды conn = new SqlConnection(GetConnectionString("LocalNWind")); //Готовим первую команду: получить информацию о клиенте cmd = new SqlCommand("SalesByCategory", conn); cmd.CommandType = CommandType.StoredProcedure; cmd.Parameters.Add("@CategoryName", SqlDbType.NVarChar, 15).Value = "Seafood"; cmd.Parameters.Add("@OrdYear", SqlDbType.Int).Value = 1997; //Выдаем команду conn.Open(); IAsyncResult ar = cmd.BeginExecuteReader(cb, state); Utils.TraceThread("Command started"); //Трассировка Utils.TraceThread("Exit BeginTask"); return ar; }string GetConnectionString(string cnEntry) { string cs; cs = ConfigurationManager.ConnectionStrings[cnEntry].ConnectionString; return cs + ";Asynchronous Processing=true;"; } Открыв подключение, вы вызываете метод BeginExecuteReader и передаете ему ссылку на функцию обратного вызова и объект состояния, полученный от инфра-структуры ASP.NET. Вы возвращаете объект IAsyncResult, который метод ADO.NET создает для отслеживания асинхронной операции. Когда выполнение команды базы данных завершается, выполняется следующий код: void EndTask(IAsyncResult ar) { using(SqlDataReader reader = cmd.EndExecuteReader(ar)) { if (!reader.Read()) return; //Связываем данные с объектом GridView1 GridView1.DataSource = reader; GridView1.DataBind();
192 Часть I Внутренние механизмы ASP.NET //Выполняем очистку reader.Close(); conn.Close(); } } Внимание! У метода BeginExecuteReader есть перегруженная версия без парамет-ров. Однако если вы будете ею пользоваться, выполнение страницы никогда не завер-шится, поскольку вы не передадите методу Begin функцию обратного вызова. Метод BeginExecuteReader без параметров годится для случаев, когда информация о завершении операции получена без помощи обратного вызова. Для краткости я удалил из метода EndTask несколько команд трассировки. Все трассировочные сообщения представлены на рис. 5-5. Рис. 5-5. Трассировка выполнения асинхронной операции базы данных Об асинхронных операциях баз данных я хотел бы сказать еще несколько слов. Во-первых, вам нужно явно разрешить в строке подключения асинхронные соединения. Это можно сделать, воспользовавшись атрибутом Asynchronous Processing. Во-вторых, в асинхронных страницах нет необходимости, когда выполнение запросов и связыва-ние с данными не влечет за собой выполнения сложных и длительных транзакций. В-третьих, в приведенном выше фрагменте метода BeginTask я использовал для трас-сировки, а конкретно - для получения идентификатора текущего потока следующую функцию: public static void TraceThread(string msg) { string displayThread = "Thread=" + Thread.CurrentThread.ManagedThreadId.ToString();
Создание сложных страниц Глава 5 193 HttpContext.Current.Trace.Warn(displayThread, msg); } Реализованная в виде статического метода класса, не являющегося классом от-деленного кода, эта утилита может получить доступ к объекту Trace единственным способом - используя объект HttpContext.Current. Как упоминалось ранее, когда вы регистрируете асинхронную операцию посредством пары обработчиков события PreRenderComplete, контекст потока, в котором выполняется обработчик End, не со-держит ссылки на объект HttpContext.Current, даже несмотря на то что данный по-ток - тот же, в котором выполняется обработчик Begin. Совет Точки трассировки - замечательное нововведение Microsoft Visual Studio 2005, дающее возможность получать трассировочные сообщения в каждой точке останова и избавляющие вас от необходимости перемежать код командами трассировки. Что-бы установить точку трассировки, нужно сначала установить обычную точку останова, а затем щелкнуть ее правой кнопкой мыши и выбрать команду When Hit. Вы сможете выбрать распечатку сообщений, а также воспользоваться целым рядом предопределенных макросов, позволяющих, например, вывести идентификатор текущего потока. В отличие от точек останова точки трассировки не останавливают выполнение кода. Результаты трассировки, выполняемой с их помощью, вы будете видеть в окне Output в среде Visual Studio 2005. Запуск нескольких асинхронных заданий Выполняя вызов AddOnPreRenderCompleteAsync, вы на самом деле регистрируете для асинхронной страницы делегаты обработчиков событий Begin и End. Эти делегаты могут поддерживать более одного подписчика. Таким образом, для запуска нескольких асинхронных заданий достаточно выполнить несколько вызовов AddOnPreRender-CompleteAsync и продолжить работу. Вот пример: void Page_Load (object sender, EventArgs e) { AddOnPreRenderCompleteAsync( new BeginEventHandler(BeginTask1), new EndEventHandler(EndTask1)); AddOnPreRenderCompleteAsync( new BeginEventHandler(BeginTask2), new EndEventHandler(EndTask2)); AddOnPreRenderCompleteAsync( new BeginEventHandler(BeginTask3), new EndEventHandler(EndTask3)); } Рендеринг страницы будет автоматически отложен до завершения выполнения всех заданий. Есть ли у этой технологии какие-нибудь недостатки? Давайте раз-местим на пути выполнения кода точки трассировки и посмотрим, что произойдет. Если добавить точку трассировки в начало Page_Load и во все пары обработчиков Begin-End, а потом запустить страницу, в окне Output в среде Visual Studio 2005 будет выведено примерно следующее (я немного подредактировал текст, чтобы сделать его более читабельным): Page_Load(object, EventArgs), Thread: 0x230 BeginTask1(object, EventArgs, AsyncCallback, object), Thread: 0x230 EndTask1(IAsyncResult), Thread: 0x1228 BeginTask2(object, EventArgs, AsyncCallback, object), Thread: 0x1228 EndTask2(IAsyncResult), Thread: 0x230
194 Часть I Внутренние механизмы ASP.NET BeginTask3object, EventArgs, AsyncCallback, object), Thread: 0x230 EndTask3(IAsyncResult), Thread: 0xD78 Что все это значит для вас? Задания всегда выполняются поочередно, чем гаран-тируется правильность конечного результата. Поток, завершивший одно задание, начинает следующее. Поочередное выполнение заданий в контексте асинхронной страницы само по себе не является чем-то плохим, и страница остается хорошо мас-штабируемой, однако при этом страдает производительность. Как насчет того, чтобы все задания выполнять параллельно? Приложения, которым не требуется последовательное выполнение заданий, долж-ны использовать один обработчик и из него инициировать выполнение ряда асинх-ронных операций. Вот схема такого кода: void Page_Load (object sender, EventArgs e) { AddOnPreRenderCompleteAsync( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask)); }IAsyncResult BeginTask(object sender, EventArgs e, AsyncCallback cb, object state) { //Запуск первого задания //Запуск второго задания }void EndTask(IAsyncResult ar) { //Завершение первого задания //Завершение второго задания } Однако перед нами встает другая проблема. Необходим объект IAsyncResult, кото-рый будет сообщать странице о завершении всех операций. Для каждой операции в отдельности можно использовать объект, полученный от метода Begin; но для множес-твенных вызовов нужен пользовательский объект. Задача такого составного объекта IAsyncResult - отслеживать все выполняющиеся операции и сообщить ASP.NET, когда работа будет окончена. Пользовательский класс, реализующий интерфейс IAsyncResult В своей простейшей форме пользовательский класс, который реализует интерфейс IAsyncResult, содержит счетчик ссылок и встроенный обратный вызов, который будет уменьшать этот счетчик при каждом вызове. Кроме того, класс должен предоставлять доступ ко всем свойствам данного интерфейса. Вот пример кода такого класса: public class CompositeAsyncResult : IAsyncResult { AsyncCallback _cb; object _state; AsyncCallback _completionCallBack; int _pendingOperations;
Создание сложных страниц Глава 5 195 //Модификатор volatile обычно используется для поля, //которое должно быть доступно нескольким потокам без //блокировки, в последовательном режиме volatile bool _allCompletedSynchronously; //Ctor public CompositeAsyncResult(AsyncCallback cb, object state, int count) { _cb = cb; _state = state; _pendingOperations = count; _allCompletedSynchronously = true; _completionCallBack = new AsyncCallback(this.CompletionCallback); } //Возвращает делегат функции обратного вызова для сообщения о завершении public AsyncCallback Callback { get { return _completionCallBack; } } //Встроенная функция обратного вызова вызывается при завершении задания public void CompletionCallback(IAsyncResult ar) { //Если текущий вызов не завершился синхронно, //устанавливаем состояние соответственно if (!ar.CompletedSynchronously) _allCompletedSynchronously = false; //Уменьшаем счетчик и проверяем, все ли задания завершились if (Interlocked.Decrement(ref _pendingOperations) == 0) { //Готово; выполняем обратный вызов ASP.NET _cb(this); } } //Возвращает объект состояния, переданный через ctor object IAsyncResult.AsyncState { get { return _state; } } //Возвращает объект wait-handle, который мы используем WaitHandle IAsyncResult.AsyncWaitHandle { get { return null; } } //Указывает, все ли задания синхронно завершились bool IAsyncResult.CompletedSynchronously { get { return (_pendingOperations == 0) && _allCompletedSynchronously; } }
196 Часть I Внутренние механизмы ASP.NET //Указывает, завершилась ли асинхронная операция bool IAsyncResult.IsCompleted { get { return (_pendingOperations == 0); } } } Данный класс получает функцию обратного вызова ASP.NET, посредством кото-рой он будет сообщать странице о завершении операции, и сохраняет ее. Он также реализует открытую функцию обратного вызова, которая будет использоваться всеми асинхронными заданиями. Когда очередное задание завершится, эта функция будет вызвана и уменьшит значение счетчика. Когда значение счетчика достигнет нуля, придет время подать сигнал странице ASP.NET. Количество заданий, выполнение которых нужно проконтролировать, устанавливается в конструкторе. Следующая страница использует единственный обработчик Begin для запуска четырех запросов на получение RSS-ленты. void Page_Load (object sender, EventArgs e) { AddOnPreRenderCompleteAsync ( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask)); }IAsyncResult BeginTask(object sender, EventArgs e, AsyncCallback cb, object state) { //Создаем пользовательский объект AsyncResult CompositeAsyncResult ar = new CompositeAsyncResult(cb, state, 2); //Первый запрос req1 = WebRequest.Create(RSSFEED1); ar1 = req1.BeginGetResponse(ar.Callback, state); //Второй запрос req2 = WebRequest.Create(RSSFEED2); ar2 = req2.BeginGetResponse(ar.Callback, state); return ar; }void EndTask(IAsyncResult ar) { string text; WebResponse response; StreamReader reader; using (response = req1.EndGetResponse(ar1)) { using (reader = new StreamReader(response.GetResponseStream())) { text = reader.ReadToEnd(); } rssData += ProcessFeed(text); } using (response = req2.EndGetResponse(ar2)) { using (reader = new StreamReader(response.GetResponseStream())) {
Создание сложных страниц Глава 5 197 text = reader.ReadToEnd(); } rssData += ProcessFeed(text); } } Существует, однако, более простой путь одновременного выполнения несколь-ких задач, и даже с более богатым контекстом выполнения - применение метода RegisterAsyncTask. Мы вернемся к этой теме чуть позже. Применение пользовательских методов Begin Во всех рассмотренных нами примерах объект, который нужно было вернуть или заключить в объект-оболочку, генерировался методом класса .NET Framework, таким как метод BeginGetResponse класса WebRequest. Но что если вам нужно асинхронно выполнить метод, не поддерживающий асинхронную модель? В таком случае вы создаете обычную асинхронную оболочку для пары BeginInvoke и EndInvoke: public partial class MultiTaskAsync : System.Web.UI.Page { protected delegate void AsyncTaskDelegate(); private AsyncTaskDelegate _func; void Page_Load(object sender, EventArgs e) { AddOnPreRenderCompleteAsync( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask)); } IAsyncResult BeginTask(object sender, EventArgs e, AsyncCallback cb, object state) { _func = new AsyncTaskDelegate(DoTheAsyncTask); IAsyncResult result = _func.BeginInvoke(cb, state); return result; } public void DoTheAsyncTask() { //Здесь выполняется задача, для которой написан этот код, //например: Thread.Sleep(10000); } void EndTask(IAsyncResult ar) { _func.EndInvoke(ar); } } Внимание! Если вы внимательно изучите программный интерфейс класса Page, то обнаружите в нем доступное для записи свойство AsyncMode булева типа. Это свойство защищенное, но его можно переопределить в классе отделенного кода. Оно не предна-значено для непосредственного доступа из пользовательского кода и устанавливается анализатором на основе значения атрибута Async директивы @Page. Текущее значение данного свойства указывает, работает ли страница в асинхронном режиме. Эта инфор-мация открывается вовне через доступное только для чтения свойство IsAsync. Для того чтобы страница была асинхронной, необходим интерфейс IHttpAsyncHandler; с другой стороны, исполняющая среда HTTP в любом случае будет вызывать страницу синхронно. Как вы знаете, реализацию интерфейса нельзя включать и отключать программно.
198 Часть I Внутренние механизмы ASP.NET Программная установка свойства AsyncMode влияет на значение, возвращаемое свойством IsAsync, но не меняет поведения страницы, которое зависит только от атрибута Async директивы @Page. Метод RegisterAsyncTask Метод RegisterAsyncTask является основой альтернативного способа асинхронного выполнения заданий, инициируемых страницей ASP.NET. Собственно говоря, данный метод можно назвать API, не связанным непосредственно с асинхронными страница-ми. Он работает и в случае, когда атрибут Async директивы @Page установлен в false. Метод RegisterAsyncTask применяемый совместно с асинхронными страницами, явля-ется исключительно мощным средством выполнения асинхронных операций. С помощью данного метода можно зарегистрировать одну или более асинхронных задач. Выполнение этих заданий начинается, когда страница достигает асинхронной точки, то есть немедленно после события PreRender. Определение асинхронного задания Следующий код показывает, как переработать нашу демонстрационную страницу, считывающую ленту RSS, с тем чтобы использовать метод RegisterAsyncTask. void Page_Load (object sender, EventArgs e) { PageAsyncTask task = new PageAsyncTask( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask), null, null); RegisterAsyncTask(task); } Для вызова RegisterAsyncTask нужно сначала создать экземпляр класса PageAsyncTask. Его конструктор принимает до пяти параметров: public PageAsyncTask( BeginEventHandler beginHandler, EndEventHandler endHandler, EndEventHandler timeoutHandler, object state, bool executeInParallel) У параметров beginHandler и endHandler тот же прототип, что и у аналогичных обработчиков, использовавшихся нами для метода AddOnPreRenderCompleteAsync. Но в отличие от последнего метод RegisterAsyncTask позволяет также задать функ-цию тайм-аута и флаг, с помощью которого включается и отключается параллельное выполнение нескольких зарегистрированных заданий. Делегат timeoutHandler указывает метод, который должен быть вызван, если за-дание не завершится в течение заданного времени, по умолчанию - 45 с. Другой тай-маут можно задать либо в конфигурационном файле, либо в директиве @Page. Вот как он задается в конфигурационном файле: <system.web> <pages asyncTimeout="30" /> </system.web> Что касается директивы @Page, то она имеет целочисленный атрибут AsyncTimeout, в котором можно задать требуемое число секунд.
Создание сложных страниц Глава 5 199 Так же, как методу AddOnPreRenderCompleteAsync, вы можете передать состояние делегатам, выполняющим задание. В параметре state может быть задан любой объект. С его помощью можно повторно использовать приведенный выше код чтения двух блогов: void Page_Load (object sender, EventArgs e) { PageAsyncTask task1 = new PageAsyncTask( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask), null, RSSFEED1, true); PageAsyncTask task2 = new PageAsyncTask( new BeginEventHandler(BeginTask), new EndEventHandler(EndTask), null, RSSFEED2, true); RegisterAsyncTask(task1); RegisterAsyncTask(task2); }public IAsyncResult BeginTask(object sender, EventArgs e, AsyncCallback cb, object state) { //Готовимся к выполнению Web-запроса string blog = (string) state; req = WebRequest.Create(blog); //Начинаем операцию IAsyncResult obj = req.BeginGetResponse(cb, state); return obj; } Альтернативный способ определения заданий для асинхронного и параллельного выполнения основан на использовании класса-оболочки. Давайте создадим класс с именем RssFeedAsyncReader, содержащий логику асинхронного чтения лент RSS: public class RssFeedAsyncReader { private WebRequest _req; private string _rssData; private string _blogUrl; public RssFeedAsyncReader(string blog) { _blogUrl = blog; } public IAsyncResult BeginRead(object sender, EventArgs e, AsyncCallback cb, object state) { //Готовимся к выполнению Web-запроса _req = WebRequest.Create(_blogUrl);
200 Часть I Внутренние механизмы ASP.NET //Начинаем операцию IAsyncResult obj = _req.BeginGetResponse(cb, state); return obj; } public void EndRead(IAsyncResult ar) { string text; using (WebResponse response = _req.EndGetResponse(ar)) { StreamReader reader; using (reader = new StreamReader(response.GetResponseStream())) { text = reader.ReadToEnd(); } //Обрабатываем данные RSS _rssData = ProcessFeed(text); } } private string ProcessFeed(string feed) { } public string GetRssData() { return _rssData; } } Этот класс содержит два открытых метода, которые служат для запуска и заверше-ния асинхронной операции. Можно также добавить третий открытый метод - для об-работки исключений тайм-аута. Теперь вы можете зарегистрировать столько заданий, сколько пожелаете, и запускать их параллельно. Следующий пример (RssAsync.aspx) показывает, как одновременно прочитать мои английский и итальянский блоги: public partial class RssAsync : System.Web.UI.Page { const string RSSFEED1 = "http://weblogs.asp.net/despos/rss.aspx"; const string RSSFEED2 = "http://blogs.ugidotnet.org/dinoes/rss.aspx"; RssFeedAsyncReader rss1, rss2; public string rssData; void Page_Load (object sender, EventArgs e) { //Регистрируем обработчик для PreRenderComplete PreRenderComplete += new EventHandler(RssAsync_PreRenderComplete); //Создаем экземпляры класса для асинхронного чтения блога rss1 = new RssFeedAsyncReader(RSSFEED1); rss2 = new RssFeedAsyncReader(RSSFEED2);
Создание сложных страниц Глава 5 201 //Создаем задания PageAsyncTask task1 = new PageAsyncTask( new BeginEventHandler(rss1.BeginRead), new EndEventHandler(rss1.EndRead), null, null, true); PageAsyncTask task2 = new PageAsyncTask( new BeginEventHandler(rss2.BeginRead), new EndEventHandler(rss2.EndRead), null, null, true); //Регистрируем задания RegisterAsyncTask(task1); RegisterAsyncTask(task2); } void RssAsync_PreRenderComplete(object sender, EventArgs e) { //Обновляем пользовательский интерфейс, //выводя данные блога rssData = rss1.GetRssData() + rss2.GetRssData(); } } Приведенный код длиннее, но, согласитесь, нельзя сказать, чтобы он был сложным и непонятным. На мой взгляд, он выглядит гораздо более профессиональным. На рис. 5-6 показана результирующая страница. Рис. 5-6. Асинхронная страница для чтения лент RSS
202 Часть I Внутренние механизмы ASP.NET Явное выполнение асинхронных заданий Выполнение всех заданий, зарегистрированных с помощью метода RegisterAsyncTask, начинается с вызова метода ExecuteRegisteredAsyncTasks класса Page. Этот метод авто-матически вызывается кодом класса Page непосредственно перед асинхронной точкой, как показывает следующий псевдокод: //Этот псевдокод выполняется внутри метода //ProcessRequest класса Page //Генерирует событие PreRender для страницы //и всех ее дочерних элементов управления this.PreRenderRecursiveInternal(); //Выполняет зарегистрированные задания if (this._asyncInfo == null) this.ExecuteRegisteredAsyncTasks(); //Это асинхронная точка: остановка, если //следующая часть запроса не разрешена if (!includeStagesAfterAsyncPoint) return; //Данный код выполняется по завершении всех асинхронных //заданий. Он генерирует для страницы событие PreRenderComplete //и выполняет операции оставшейся части ее жизненного цикла this.PerformPreRenderComplete(); Метод ExecuteRegisteredAsyncTasks является открытым, и его можно вызывать про граммным способом из любого места кода, где потребуется выполнить задания с полным их контролем. Метод RegisterAsyncTask и синхронные страницы Если вызвать метод AddOnPreRenderCompleteAsync для страницы, помеченной атри-бутом Async, она выбросит исключение. Если же в аналогичной ситуации вызвать RegisterAsyncTask, страница будет работать нормально, хотя такое решение не явля-ется оптимальным с точки зрения масштабируемости приложения. Давайте устано-вим точки трассировки в начале ключевых функций обсуждавшейся выше страницы RssAsync.aspx и установим атрибут Async ее директивы @Page в false. Вот каким будет результат: Page_Load(object, EventArgs), Thread: 0x230 BeginRead(object, EventArgs, AsyncCallback, object), Thread: 0x230 BeginRead(object, EventArgs, AsyncCallback, object), Thread: 0x230 EndRead(IAsyncResult), Thread: 0x1718 EndRead(IAsyncResult), Thread: 0x1228 RssAsync_PreRenderComplete(object, EventArgs), Thread: 0x230 Как видите, поток 0x230 начинает два асинхронных задания, но остается забло-кированным до их завершения, поскольку ему еще нужно выполнить финальные операции по обработке запроса страницы. В асинхронной странице данный поток был бы возвращен в пул сразу после второго вызова BeginRead, а финальные операции выполнялись бы уже в другом потоке.
Создание сложных страниц Глава 5 203 Выбор оптимального подхода Так в каких же случаях следует использовать метод AddOnPreRenderCompleteAsync, а в каких - RegisterAsyncTask? С функциональной точки зрения оба подхода почти идентичны. В обоих случаях процесс выполнения запроса делится на два этапа - до и после синхронной точки. В чем же тогда состоят различия? Первое различие - логическое. RegisterAsyncTask - это универсальный API, раз-работанный для асинхронного по отношению к странице выполнения заданий и не связанный только с асинхронными страницами. В то же время метод AddOnPreRender-CompleteAsync - это специализированный API, предназначенный только для асинх-ронных страниц. Существуют и другие различия. Так, RegisterAsyncTask выполняет обработчик End в потоке с более богатым контекстом, чем AddOnPreRenderCompleteAsync. Данный контекст потока включает информацию о имперсонализации и контекст HTTP. Кроме того, RegisterAsyncTask позволяет установить таймаут и тем гарантировать, что задание не будет выполняться дольше определенного времени. Наконец, применение RegisterAsyncTask упрощает реализацию множественных вызовов удаленных источников. Для обеспечения их параллельного выполнения достаточно установить соответствующий флаг, и нет нужды создавать собственный объект IAsyncResult. Вывод таков: для одиночного задания подойдет любое из двух решений, но когда требуется параллельно выполнить несколько заданий, следует пользоваться методом RegisterAsyncTask. Пользовательские типы выражений В ASP.NET поддерживается несколько типов выражений, каждый из которых разра-ботан с определенной целью и обладает собственными уникальными возможностями. Что такое выражение? В ASP.NET этим термином обозначают любой исполняемый фрагмент кода, который можно поместить в файл страницы ASP.NET, заключив внутрь тэга <% ... %>. В ASP.NET 1.x использовались выражения двух типов - блоки кода, подобные блокам кода классической ASP, и выражения, связанные с данными. В ASP.NET 2.0 введен третий тип - динамические выражения, лучше отвечающие декларативной модели программирования. Блоки кода ASP-стиля В классической ASP блоками кода назывались фрагменты исполняемого кода, заклю-ченные в тэги <% ... %>. В них мог содержаться любой код, понятный исполняющей среде ASP, включая операции присвоения значений переменным, операторы цикла, объявления функций и, конечно, их вызовы. Внутренняя архитектура классиче ских страниц ASP позволяет использовать такую модель - неструктурированную, свобо-дную, не отличающуюся строгостью и неэлегантную с точки зрения пуристов про-граммирования (да и не только их). Как работают блоки кода в классической ASP Исполняющая среда ASP.NET строит страницу инкрементально, по мере разбора со-держимого исходного файла. Результирующий вывод получается путем объединения в конечные блоки кода всех литеральных выражений, встреченных в процессе разбора. При этом среда выполнения сценариев работает постоянно - она обрабатывает содер-жимое блоков <% ... %> без сохранения состояния относительно текущего запроса.
204 Часть I Внутренние механизмы ASP.NET Примечание В классической ASP принцип использования среды выполнения сценариев объясняет, каким образом функцию, объявленную в одном блоке, можно вызывать из другого. Так происходит потому, что тело функции публикуется и остается видимым в контексте среды выполнения сценариев в течение всего времени выполнения запроса. В ASP.NET аналогичного механизма нет, и поэтому блоки кода ASP.NET гораздо менее функциональны. В классической ASP существует два вида блоков кода - встроенный (inline) код и встроенные выражения. Последние являются просто сокращенной формой записи вызова Response.Write и имеют следующий хорошо известный формат: <% x = 1 %> <% = x %> Первая строка - пример встроенного кода; вторая является встроенным выраже-нием, выводящим содержимое инициализированной ранее переменной x. Как работают блоки кода в ASP.NET ASP.NET является не развитием ASP, а совершенно новой исполняющей средой, и хо-тя в ней сохранились блоки кода, они утратили часть своей функциональности. Тем не менее их поддержка системой совершенно полноценна, и с выходом ASP.NET 2.0 в этом отношении ничего не изменилось. В ASP.NET блоки кода больше не обрабатываются ни во время рендеринга, ни во время выгрузки страницы. Этим они кардинально отличаются от прежних блоков кода, и являются элементом совершенно иной модели исполнения. Рассмотрим сле-дующий фрагмент кода страницы: <form id="Form1" runat="server"> <% for (int i=0; i<8; i++) %> <% { %> <font size="<%=i %>"> I <b style="font-family:Webdings;color:Red">Y</b> this book! </font><br> <% } %> </form> Результат его выполнения показан на рис. 5-7. Рис. 5-7. Страница ASP.NET, созданная с использованием блоков кода ASP-стиля
Создание сложных страниц Глава 5 205 Динамически сгенерированный код страницы связывает блоки кода с серверным родительским элементом, которым в данном примере является Form1. При отсутствии серверного тэга form может использоваться тэг <head>, если он помечен атрибутом runat=server. Если же у страницы нет ни одного тэга, помеченного данным атрибутом, блок кода связывается с самой страницей. В любом случае он ассоциируется с сервер-ным объектом, производным от Control. (Кто не знает - класс Control является одним из предков класса Page.) Почему именно Control? Дело в том, что у данного класса имеется важный, но редко применяемый метод SetRenderMethodDelegate. В состав каждого серверного элемента управления, включающего блок кода, вхо-дит делегат рендеринга, добавленный путем вызова метода SetRenderMethodDelegate. Ниже приведен код, используемый для рендеринга формы. (Он представляет собой отредактированную версию динамического кода страницы и получен способом, опи-санным в главе 1.) HtmlForm BuildControlForm1() { HtmlForm ctrl = new HtmlForm(); form1 = ctrl; ctrl.ID = "Form1"; //Добавление в дерево страницы других //дочерних серверных элементов управления //Добавление делегатов рендеринга для обработки блоков кода ctrl.SetRenderMethodDelegate(new RenderMethod(RenderForm1)); return ctrl; }void RenderForm1(HtmlTextWriter w, Control parameterContainer) { for (int i=1; i<8; i++) { w.Write("<font size=\""); w.Write(i); w.Write("\">" + I "<b style=\"font-family:Webdings;color:Red\">Y</b> " + "this book! </font><br>"); } } Содержимое всех блоков кода интегрируется в процедуру рендеринга формы, вы-зовы которой перемежаются вызовами метода RenderControl объявленных серверных элементов управления и литералов. Вывод блока кода используется для создания специализированной функции рендеринга, которая завершает формирование итого-вой страницы. Ограничения блоков кода в ASP.NET В ASP.NET блоки кода нельзя использовать для динамической установки свойств элементов управления. Например, следующая строка не сработает: <asp:Button runat=server id="Button1" Text=<% =GetText() %> /> Если заключить блок кода в кавычки, его текст будет выведен как есть. Если же кавычки не использовать, как в приведенном примере, вы получите ошибку компиля-ции - серверные тэги не могут содержать конструкций <% ... %>. Модель, основанная 
206 Часть I Внутренние механизмы ASP.NET на применении SetRenderMethodDelegate, работает при формировании тела страницы на этапе рендеринга, но не при установке свойств объекта на этапе синтаксического разбора. В ASP модель формирования страницы позволяла использовать данный синта-ксис, поскольку весь текст накапливался в специальном буфере в памяти и из двух последовательных элементов составлялся оператор установки атрибута. Объектная модель ASP.NET не позволяет применять такой подход. Пока исходный вопрос этого раздела остался без ответа: как декларативным путем присвоить свойству динамически формируемое значение? И вот тут на сцену выходят выражения связывания с данными. Выражения связывания с данными Для того чтобы разработчики могли присваивать значения атрибутам элементов уп-равления декларативным способом, в ASP.NET 1.x был введен новый тип динамичес-ких выражений, получивших название выражений связывания с данными (data-binding expressions). Рассмотрим следующий фрагмент исходного файла страницы: <form id="form1" runat="server"> <h2>Today is <asp:Label ID="Today" runat="server" Text="<%# DateTime.Now %>" /> </h2> </form> Свойству Text элемента управления Label присваивается результат вычисления выражения, заключенного между тэгами блока кода. По своему синтаксису выражения связывания с данными почти идентичны блокам кода за одним исключением - это префикс #. Поэтому для краткости далее я буду именовать выражения связывания с данными #-выражениями. Как работает связывание с данными Простая вставка символа # в корне меняет результирующую разметку. Синтаксичес-кий анализатор страниц ASP.NET распознает этот символ и автоматически создает для экземпляра элемента управления обработчик события DataBinding. Вот код (слегка отредактированный), сгенерированный исполняющей средой ASP.NET: Label BuildControlToday() { Label ctrl = new Label(); this.Today = ctrl; ctrl.ApplyStyleSheetSkin(this); ctrl.ID = "Today"; ctrl.DataBinding += new EventHandler(DataBindingToday); return ctrl; }void DataBindingToday(object sender, EventArgs e) { Label target = (Label) sender; Control container = (Control) target.BindingContainer; target.Text = Convert.ToString(DateTime.Now, CultureInfo.CurrentCulture); } В теле метода DataBindingToday - обработчика события DataBinding - произво-дится выполнение выражения и присвоение его результата свойству Text.
Создание сложных страниц Глава 5 207 Выражение копируется в точности, а это означает, что любые допущенные в нем ошибки будут обнаружены на этапе компиляции. Если же код написан плохо, во время выполнения будет выброшено исключение. Выражения связывания с данны-ми могут содержать любой код, возвращающий значение, допустимое для свойства, которому оно присваивается (то есть имеющее совместимый тип). При желании для формирования этого значения можно даже вызывать методы класса Page или внешних компонентов. Внимание! Выражения связывания с данными можно вычислить только после вызова метода DataBind. Этот метод вызывается для страницы или конкретного элемента управ-ления. Если он не вызван ни разу, выражения связывания с данными не вычисляются. Ограничения выражений связывания с данными В ASP.NET 2.0 дебютировали новые элементы управления, представляющие источ-ники данных. Они вывели на сцену новую модель связывания с данными. Будучи присоединенными к элементам управления, связанным с данными, элементы, пред-ставляющие источники данных, интеллектуально их обслуживают, не генерируя для страницы события, являющиеся запросами на получение данных. Элементы управ-ления, представляющие источники данных, позволяют задать все необходимые уста-новки во время разработки, в том числе определить выполняемые команды, строки подключения, типы используемых данных и т. д. Примечание Дополнительную информацией об элементах управления, представляющих источники данных, вы можете найти в моей книге "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Будучи лидерами декларативного программирования, эти новые элементы управ-ления открывают возможность связывания данных со свойствами без явного вызова DataBind. Они не являются элементами управления, связанными с данными, хотя тесно взаимодействуют с такими элементами управления - особенно с элементами управления нового поколения наподобие GridView и DetailsView. Если учесть, что элементы управления, представляющие источники данных, не являются связанными с данными, следует ли нам ожидать, что для декларативной установки свойств будет генерироваться событие DataBind? Нет, данный метод вызываться не будет, поскольку это противоречило бы декла-ративной модели. Если бы метод DataBind был вызван, данные элемента управления не были бы объявлены вовсе - они извлекаются во время выполнения, как у традици-онных элементов управления, связанных с данными. Поэтому элементы управления, представляющие источники данных, ведут себя совершенно иначе, когда дело доходит до рендеринга связанных данных. И по этой причине #-выражения не подходят для таких элементов управления. Однако настоящей причиной несовместимости #-выражений и элементов управ-ления, представляющих источники данных, является не дополнительный вызов Data-Bind. В некоторых случаях даже его недостаточно, для того чтобы заставить элемент управления работать, как требуется. Давайте посмотрим почему. Почему #-выражения не подходят для элементов управления, представляющих источники данных Поскольку при обработке выражений связывания с данными к элементу управления подключается обработчик события DataBinding, для их вычисления необходим вызов этого обработчика. Но почему такие выражения не подходят для элементов управле-ния, представляющих источники данных? 
208 Часть I Внутренние механизмы ASP.NET Возьмем следующий код: <asp:SqlDataSource id="MySource" runat="server" ConnectionString=<% #ConfigurationManager.ConnectionStrings[...] %> /> <asp:GridView id="grid" runat="server" datasourceid="MySource" /> Вы помещаете вызов метода DataBind в обработчик события Page_Load, и код работает. Когда вызывается DataBind, устанавливается свойство ConnectionString эле-мента управления SqlDataSource. Поэтому когда GridView хочет получить свои данные, элемент управления, представляющий их источник, может их предоставить. Теперь переставим местами два элемента управления в разметке так, чтобы GridView предшествовал SqlDataSource. При вызове DataBind все элементы управ-ления связываются со своими данными в той последовательности, в которой они размещены в файле страницы. Когда очередь связывания данных доходит до GridView, он обнаруживает, что должен попросить предоставить данные элемент управления SqlDataSource. К сожалению, в это время строка подключения элемента управле-ния SqlDataSource еще не установлена, поскольку процесс связывания с данными последнего еще не начинался. Поэтому генерируется исключение. Для полной поддержки элементов управления, представляющих источники дан-ных, необходим новый тип выражений. В ASP.NET 2.0 они называются динамическими выражениями. Для краткости я буду называть их $-выражениями. Примечание Выражения - не единственный способ установки свойств элементов уп-равления, представляющих источники данных. Вы можете использовать жестко закоди-рованные строки или, еще лучше, устанавливать свойства программным путем в обра-ботчике события Page_Load. Необходимо новое поколение выражений для эффективного декларативного программирования не только элементов управления, представляющих источники данных, но и других серверных элементов управления страниц ASP.NET. Динамические выражения в ASP.NET 2.0 Назначение динамических выражений - устанавливать свойства элементов управления на этапе синтаксического разбора, не полагаясь на механизм связывания с данны-ми. Чтобы понять, что они собой представляют, вернемся к коду, сгенерированному при использовании #-выражения. Значение свойству было присвоено в обработчике события DataBinding. При использовании $-выражений присвоение производится в методе, который строит элемент управления. Все динамические выражения являются экземплярами одного класса - ExpressionBuilder. Он определяет механизм синтаксического разбора выражения и возвра-щает представляющее это выражение дерево CodeDOM. Существует несколько пре-допределенных построителей выражений; они описаны в табл. 5-2. Табл. 5-2. Построители выражений Синтаксис Описание AppSettings:[атрибут] Возвращает значение заданного параметра из раздела <appSettings> конфигурационного файла ConnectionStrings:[элемент].[атрибут] Возвращает значение заданного атрибута заданного элемента раздела <appSettings> конфигурационного файла Resources:[файл_ресурса],[имя_ресурса] Возвращает значение заданного глобального ресурса
Создание сложных страниц Глава 5 209 При декларативном связывании свойства элемента управления со значением вы-ражения необходимо следовать приведенной ниже схеме: <%$ префикс:выражение %> Построитель определяет и префикс, и полный синтаксис выражения. За двоето-чием (:) обычно следует разделенный запятыми список параметров. Построитель $ConnectionStrings Данный построитель извлекает из конфигурационного файла строку подключения. Префикс $-выражения с его использованием - ConnectionStrings; после точки распо-лагаются два атрибута, разделенных точкой: имя подлежащего обработке элемента из раздела <connectionStrings> и имя считываемого атрибута. Вот пример: <%$ ConnectionStrings:LocalNWind.ConnectionString %> Это выражение обращается к элементу LocanNWind раздела <connectionStrings> и считывает содержащееся там значение атрибута connectionString. Приведенное выше выражение можно переписать в следующем более компактном формате: <%$ ConnectionStrings:LocalNWind %> Поддерживаются всего два атрибута - ConnectionString и ProviderName. Следую-щий код демонстрирует применение выражения, с помощью которого инициализи-руется элемент управления, представляющий источник данных. <asp:SqlDataSource runat="server" id="MySource" ConnectionString="<%$ ConnectionStrings:LocalNWind %>" ProviderName="<%$ ConnectionStrings:LocalNWind.ProviderName %>" /> Построитель $AppSettings Построитель $AppSettings используется для декларативного доступа к содержимому раздела <appSettings> конфигурационного файла. Его префикс - appSettings, после двоеточия стоит обыкновенная строка. В параметре построителя задается имя атри-бута, значение которого вас интересует. Предположим, что в файле web.config есть такой раздел: <appSettings> <add key="AppVersionNumber" value="8.2.2001" /> </appSettings> Выражение <% $AppSettings:AppVersionNumber %> возвращает содержимое атри-бута value. Например: <asp:Label runat="server" id="Label1" Text="<%$ AppSettings:AppVersionNumber %>" /> Построитель $Resources Построитель $Resources позволяет извлечь глобальные ресурсы, определенные в задан-ном файле .resx. Префикс построителя - Resources; синтаксис - разделенная запятой строка, в которой первый элемент задает имя (без пути и расширения) к файлу .resx, а второй - имя извлекаемого ресурса. Оба элемента обязательны. <asp:Label runat="server" id="Label1" Text="<%$ Resources:MyResources, AppTitle %>" />
210 Часть I Внутренние механизмы ASP.NET Пробелы в выражении обычно не обязательны, и синтаксический анализатор не обращает на них внимания. (Но поскольку это зависит от реализации анализатора, применяя пользовательские построители, будьте внимательны.) Приведенный код извлекает значение ресурса с именем AppTitle из файла MyResources.resx. Учтите, что построитель выражений $Resources не извлекает локальные ресурсы страницы; он работает только с файлами .resx, расположенными в папке App_GlobalResources. Примечание Следите за тем, чтобы в выражениях типы возвращаемого значения и свойст ва элемента управления, которому это значение присваивается, были совме-стимыми. Если задать строку подключения там, где ожидается идентификатор цвета, вы получите исключение или же страница поведет себя не так, как ожидалось. Возможности, доступные во время разработки Динамические выражения можно определять с помощью дизайнера Visual Studio 2005. Вы выбираете элемент управления и в окне его свойств щелкаете в поле Expressions, а потом выбираете свойство, значение которого будет устанавливаться, и задаете выражение (рис. 5-8). Подобная функциональность может быть предусмотрена и для пользовательских построителей, но это не обязательно. Рис. 5-8. Visual Studio 2005 Expression Designer в действии Некомпилируемые страницы и выражения У некомпилируемых .aspx-страниц ASP.NET 2.0 в директиве @Page задана установка CompilationMode=Never. Такая страница не компилируется ASP.NET, но при этом предоставляется по запросу правильно и быстро (подробнее о таких страницах рас-сказывалось в главе 1). Некомпилируемые страницы не содержат исполняемого кода - ни обработчиков событий, ни файлов отделенного кода, - но могут содержать серверные элементы управления и динамические выражения. С помощью $-выражений некомпилируемые страницы можно делать немного более динамическими. Написание пользовательского построителя выражений Для создания пользовательского выражения необходимо выполнить две задачи: со-здать новый класс, производный от ExpressionBuilder, и зарегистрировать его в разделе <compilation> конфигурационного файла. В качестве примера попробуем создать пользовательское выражение, помещающее на страницу значения из объекта Profile.
Создание сложных страниц Глава 5 211 Будучи частью контекста HTTP, объект Profile представляет собой экземпляр ди-намически генерируемого класса. Этот класс наследует ProfileBase и содержит столько свойств, сколько элементов имеется в разделе <profile> конфигурационного файла. Каждый объект Profile ассоциируется с конкретным пользователем - зарегистриро-ванным либо анонимным. В главе 4 рассказывалось, как создать провайдер пользова-тельского профиля. Дополнительную информацию о работе с API поль зовательских профилей вы найдете в главе 5 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Класс ProfileExpressionBuilder Создавая класс, производный от ExpressionBuilder, вы должны переопределить в нем три метода и одно свойство (табл. 5-3). Табл. 5-3. Члены класса ExpressionBuilder Член Описание EvaluateExpression Возвращает объект, представляющий результат вычисления выражения. Данный метод вызывается только в том случае, если выражение задано в файле некомпилируемой страницы и метод SupportsEvaluate вернул true. EvaluateExpression - не абстрактный метод, но в реализации базового класса он возвращает null GetCodeExpression Возвращает объект CodeDOM, используемый классом страницы для генерирования исходного кода, возвращающего результат вычисления выражения. Метод абстрактный и должен быть переопределен ParseExpression Возвращает объект, представляющий результат синтаксического разбора выражения. Он должен выделить аргументы выражения и вернуть объект, который делает данные доступными другим методам класса. Метод не является абстрактным, но в реализации базового класса он возвращает null SupportsEvaluate Свойство булева типа, указывающее, может ли выражение быть вычисле-но для некомпилируемой страницы. По умолчанию установлено в false Сердцем построителя является метод GetCodeExpression. Он получает объект, воз-вращенный методом ParseExpression, с полезной информацией, полученной из строки, следующей за двоеточием. Метод GetCodeExpression должен вернуть объект CodeDOM, представляющий код, который должен быть сгенерирован на основе выражения. Для построителя Profile предлагается такой синтаксис: <%$ Profile:имя_свойства %> Префикс здесь - Profile, а на месте имя_свойства будет имя свойства, определен-ного в объекте профиля. Начнем разработку класса. [ExpressionPrefix("Profile")] public class ProfileExpressionBuilder : ExpressionBuilder { //Разбор аргументов выражения public override object ParseExpression(string expression, Type propertyType, ExpressionBuilderContext context) { return expression; } }
212 Часть I Внутренние механизмы ASP.NET Атрибут [ExpressionPrefix] определяет префикс построителя. Этот префикс можно также задать в файле web.config при регистрации построителя, так что применение данного атрибута не является обязательным. Метод ParseExpression получает аргумен-ты выражения в параметре expression. Они поступают в форме строки, а метод должен выполнить ее разбор и извлечь полезную информацию. В данном случае аргументом выражения является имя свойства профиля, так что разбор не требуется и метод просто возвращает полученную строку. В других случаях, когда часть выражения, следующая за двоеточием, является составной, метод должен выполнить ее разбор и заполнить пользовательский объект (например, массив) готовой к использованию информацией. Объект, возвращенный методом ParseExpression, передается на вход методу GetCodeExpression. public override CodeExpression GetCodeExpression( BoundPropertyEntry entry, object parsedData, ExpressionBuilderContext context) { //Извлекаем имя свойства профиля //(предполагается, что parsedData - строка, но проверить это не помешает) string property = (string) parsedData; //Необходимо сгенерировать код для правой части оператора присваивания. //Пусть это будет вызов статического метода класса. //Определяем объект CodeDOM, представляющий параметр статического метода CodePrimitiveExpression prim = new CodePrimitiveExpression(property); CodeExpression[] args = new CodeExpression[1] { prim }; //Определяем объект CodeDOM, представляющий вызов метода CodeTypeReferenceExpression refType; refType = new CodeTypeReferenceExpression(base.GetType()); return new CodeMethodInvokeExpression(refType, "GetProperty", args); } Метод GetCodeExpression извлекает имя свойства профиля из аргумента parsedData, в котором ему передается объект, возвращенный методом ParseExpression. Задача ме-тода GetCodeExpression - сгенерировать объект CodeDOM, представляющий правую часть оператора присваивания. Этот оператор в итоге должен иметь такой вид: элемент_управления.имя_свойства = результат выполнения_выражения; Встроенные построители часто создают CodeDOM-ссылку на статический метод класса выражения. Таким образом использование CodeDOM сводится к минимуму - достаточно сформировать вызов метода, а большую часть кода написать на языке про-граммирования. Приведенный выше код возвращает дерево объектов CodeDOM, пред-ставляющее вызов статического метода GetProperty. Этот метод принимает единствен-ный параметр, которым является имя свойства. Вам нужно добавить метод GetProperty в класс ProfileExpressionBuilder. Метод отвечает за доступ к данным объекта Profile. public static object GetProperty(string propertyName) { return HttpContext.Current.Profile.GetPropertyValue(propertyName); } Второй и третий аргументы конструктора класса CodeMethodInvokeExpression оп-ределяют имя вызываемого метода и передаваемые ему аргументы. Первый аргумент содержит ссылку на целевой объект, которому принадлежит метод. Поскольку целевой объект - это просто тип, метод должен быть статическим.
Создание сложных страниц Глава 5 213 Поддержка некомпилируемых страниц Наш построитель практически готов. Но если требуется, чтобы им можно было поль-зоваться и в некомпилируемых страницах, необходимо проделать еще кое-какую ра-боту. Для начала следует переопределить метод EvaluateExpression. Этот метод должен возвращать значение выражения. Обратите внимание на различие: некомплируемой странице нужен именно результат выражения, поскольку никакой код генерироваться не будет. Обычной же странице требуется CodeDOM-описание кода, которое система транслирует в код на языке C# или Visual Basic .NET. public override object EvaluateExpression(object target, BoundPropertyEntry entry, object parsedData, ExpressionBuilderContext context) { //В parsedData находится то, что вернул ParseExpression string propName = (string) parsedData; return GetProperty(propName); }public override bool SupportsEvaluate { get { return true; } } Наконец, нужно переопределить свойство SupportsEvaluate, чтобы оно возвращало true, и тем самым включить поддержку некомпилируемых страниц. Регистрация построителя $Profile Новый построитель выражений добавляется в приложение путем создания новой записи в подразделе <expressionBuilders> раздела <compilation> конфигурационного файла. <compilation> <expressionBuilders> <add expressionPrefix="Profile" type="ProAspNet20.CS.Components.ProfileExpressionBuilder" /> </expressionBuilders> </compilation> Новый построитель не может быть зарегистрирован в файле web.config, располо-женном в дочернем каталоге приложения. Место регистрационной записи - в файле web.config приложения или сайта. Использование построителя $Profile Выражения $Profile можно использовать в любой странице ASP.NET для присвоения значений свойствам любых элементов управления. Возьмем, к примеру, следующую модель данных (мы уже пользовались ею в главе 4): <profile enabled="true"> <properties> <add name="BackColor" type="string" allowAnonymous="true"/> <add name="ForeColor" type="string" allowAnonymous="true"/> <add name="Links" type="System.Collections.Specialized.StringCollection" allowAnonymous="true" serializeAs="Xml" /> </properties> </profile>
214 Часть I Внутренние механизмы ASP.NET Вот как можно установить фоновый цвет тэга <body> и источник данных рас-крывающегося списка: <body runat="server" bgcolor="<%$ Profile:BackColor %>"> <form id="form1" runat="server"> <asp:DropDownList id="List1" runat="server" DataSource="<%$ Profile:Links %>" /> </form> </body> Свойство Links - это коллекция строк, а следовательно, его можно использовать для заполнения раскрывающегося списка. Однако для запуска механизма связывания раскрывающегося списка с данными необходимо выполнить вызов DataBind. (Он не имеет ничего общего с построителем выражений - просто таково требование любого элемента управления, связанного с данными.) Построитель выражений предназначен для установки значений свойств. Если воспользоваться им для размещения на странице произвольного текста, как в приве-денном ниже фрагменте, будет выброшено исключение. <body> <%$ Profile:CopyrightText %> </body> Если вы захотите использовать технологию построителей выражений для созда-ния собственного механизма разбора макросов, придется прибегнуть к маленькой хитрости. Воспользуйтесь элементом управления Literal - самым легковесным из всех серверных элементов управления ASP.NET - как оболочкой для динамического выражения. Вот пример: <asp:Literal runat="server" Text="<%$ Profile:CopyrightText %>" /> В любом случае для использования построителя выражений необходим сервер-ный элемент управления, имеющий хоть одно открытое свойство - так устроен этот механизм. Детали реализации В завершение нашего обсуждения построителей выражений заглянем в программный код, генерируемый ASP.NET в процессе обработки исходного кода страницы, в которой используются построители. Характерно, что построители выражений - элемент, вклю-чающийся в процесс на этапе синтаксического разбора страницы. Они взаимодействуют с анализатором ASP.NET во время создания исходного кода динамического класса стра-ницы. Вот какой код сгенерирован для приведенного выше примера с раскрывающимся списком, свойство DataSource которого связано со свойством профиля: DropDownList BuildControlList1() { DropDownList ctl = new DropDownList(); List1 = ctl; ctl.ApplyStyleSheetSkin(this); ctl.ID = "List1"; ctl.DataSource = (object) ProfileExpressionBuilder.GetProperty("Links"); return ctl; } Мы нарочно добавили метод GetProperty в класс ProfileExpressionBuilder и объяви-ли его статическим. В построителе дерево CodeDOM, возвращенное методом GetCodeExpression, описывает вызов этого статического метода.
Создание сложных страниц Глава 5 215 Разработка фильтров анализатора для страниц ASP.NET Перед возвратом пользователю страница ASP.NET проходит несколько преобразова-ний: сначала выполняется ее синтаксический разбор с созданием класса, а затем ком-пиляция этого класса в сборку. В ASP.NET 1.x компонент, выполняющий синтаксичес-кий разбор страницы - класс PageParser - находится вне досягаемости разработчика, за исключением одной открытой статической функции, с помощью которой можно получить экземпляр динамического класса страницы. Однако данная функция исполь-зуется редко, разве что при построении специализированных тестовых окружений или инструментов, предназначенных для разработчиков. Вот что это за функция: public static IHttpHandler GetCompiledPageInstance( string virtualPath, string inputFile, HttpContext context) Она принимает виртуальный путь к странице и путь к ее файлу, а также контекст HTTP и возвращает экземпляр класса, производного от Page, генерирующего разметку ресурса .aspx. В остальном класс PageParser скрыт от разработчика, и большинство его методов помечены как закрытые или внутренние. В ASP.NET 2.0 программный интерфейс класса PageParser в основном такой же, как в ASP.NET 1.x, но теперь он поддерживает одну очень интересную возможность - фильтрацию вывода анализатора страницы. Назначение фильтров анализатора состо-ит в том, чтобы предоставить механизм, который на этапе синтаксического разбора будет фильтровать элементы управления и код страницы. Механизм фильтрации, разрабатывавшийся для создания окружений, в которых можно без труда заменять некоторые ключевые функции Microsoft SharePoint, позволяет блокировать опреде-ленные типы элементов управления, базовые классы страницы, код сценариев, а также ссылки на пользовательские элементы управления и эталонные страницы. Внимание! Фильтры анализатора не генерируют кода и не могут модифицировать де-рево кода, созданное для страницы. Им просто предлагается сказать "да" или "нет" опре деленным типам элементов управления, присутствующих на странице, или другим элементам, поддерживаемым ее кодом. Такими фильтрами пользуются для блокирования нежелательных элементов страницы, а не для замены существующих элементов или модификации стандартного кода, генерируемого для ресурса .aspx. Класс PageParserFilter По умолчанию ASP.NET 2.0 не использует никаких фильтров анализатора. Однако в ее состав входит базовый класс для создания пользовательских фильтров. Этот класс называется PageParserFilter, а определен он в пространстве имен System.Web.UI. Класс PageParserFilter помечен как абстрактный, то есть вы можете его наследо-вать, но не использовать как есть. Ни один из его членов, однако, абстрактным не является. Тем не менее, как вы увидите далее, при разработке собственного фильтра вам придется переопределить некоторое количество методов, чтобы приложение было правильно откомпилировано. Программный интерфейс В табл. 5-4 и 5-5 перечислены методы и свойства класса PageParserFilter. Все методы являются виртуальными и могут быть переопределены в производ-ном классе. Хотя с синтаксической точки зрения их переопределение не является обязательным, на практике оно необходимо, поскольку большинство методов имеют пустую реализацию.
216 Часть I Внутренние механизмы ASP.NET Табл. 5-4. Методы класса PageParserFilter Метод Описание AllowBaseType Указывает, может ли страница наследовать заданный класс AllowControl Указывает, разрешен ли для страницы заданный тип элементов управления. Данный метод используется для построения списков элементов управления, защищенных как в SharePoint AllowServerSideInclude Указывает, разрешено ли для данной страницы заданное серверное включение AllowVirtualReference Указывает, допустима ли для страницы виртуальная ссылка на ресурс определенного типа (такой как пользо-вательский элемент управления, эталонная страница или обычный элемент управления) GetCompilationMode Возвращает идентификатор режима компиляции страницы ParseComplete Анализатор страницы вызывает этот метод, чтобы сообщить о завершении синтаксического разбора PreprocessDirective Дает фильтру анализатора возможность выполнить пре-добработку директив страницы. Заметьте, что этот метод не может использоваться для поддержки пользователь-ских директив Свойства также подлежат переопределению. Переопределить их даже более важно, поскольку значения, присваиваемые им по умолчанию, делают практически невоз-можной для ASP.NET компиляцию любой страницы, на которую распространяется действие фильтра. Табл. 5-5. Свойства класса PageParserFilter Свойство Описание AllowCode Указывает, разрешает ли анализатор странице иметь программный код. По умолчанию это свойство установ-лено в false, и поэтому, если страница содержит блок <script> или связана с файлом кода, генерируется ошибка компиляции NumberOfControlsAllowed Определяет максимальное количество элементов управ-ления, которое может входить в состав одной страницы. По умолчанию установлено в 0 NumberOfDirectDependenciesAllowed Определяет максимальное количество прямых файло-вых зависимостей, допустимое для одной страницы. По умолчанию установлено в 0 TotalNumberOfDependenciesAllowed Определяет максимальное количество прямых и кос-венных файловых зависимостей, допустимое для одной страницы. По умолчанию установлено в 0 Пользовательский фильтр анализатора выглядит примерно так: public class CustomPageFilter : PageParserFilter { public override bool AllowCode { get { return true; } }
Создание сложных страниц Глава 5 217 public override int NumberOfControlsAllowed { get { return 20; } } public override int NumberOfDirectDependenciesAllowed { get { return 10; } } public override int TotalNumberOfDependenciesAllowed { get { return 100; } } } Как уже упоминалось, чтобы не получить обвал ошибок компиляции для совершен-но правильного кода, нужно переопределить переменные класса, которые не должны возвращать нули. Регистрация фильтра анализатора ASP.NET по умолчанию не будет использовать класс PageParserFilter - ведь это базовый класс, который служит отправной точкой для разработки ваших собственных фильтров анализатора. Создав такой фильтр, в должны его активизировать, для чего применяется следующий сценарий, включаемый в файл web.config: <pages pageParserFilterType="ProAspNet20.CS.Components.ваш_фильтр" /> Этот элемент <pages> нужно поместить в раздел <system.web>. Во время выполне-ния фильтр никак себя не проявляет, и единственным признаком его существования являются ошибки времени компиляции, которые, как обычно, выводятся на панели ошибок Visual Studio 2005. Реальные примеры Рассмотрим несколько ситуаций, в которых проявляются преимущества фильтров анализатора. Главной причиной их применения является то, что они дают разработ-чикам возможность снабжать свои приложения типичным для Windows SharePoint Services элементом - безопасным списком элементов управления. Наличие такого списка позволяет Web-мастеру запрещать рендеринг клиенту определенных элементов управления. В ASP.NET данная функциональность не реа-лизована, но разработчикам оставлена возможность сделать это самостоятельно. Кроме того, пользовательские фильтры анализатора позволяют разработчикам реализовать любые необходимые проверки и удалять определенные базовые классы, виртуальные ссылки и включения. Создание списка безопасных элементов управления В SharePoint списком безопасных элементов управления называется набор серверных элементов управления, которые можно без опасений использовать в документах. В ASP.NET такая функциональность отсутствует, но мы ее реализуем. Заметьте, одна-ко, что фильтр в ASP.NET применяется во время синтаксического разбора, в результате чего выводятся сообщения об ошибках компиляции. Вы переопределяете метод AllowControl, и в его новой версии сравниваете тип эле-мента управления, подвергнутого синтаксическому разбору, со списком допустимых типов, хранящимся во внешнем источнике. Метод AllowControl имеет два параметра: в первом задается тип только что проанализированного элемента управления, а во втором передается объект ControlBuilder, использовавшийся для разбора тэга элемента 
218 Часть I Внутренние механизмы ASP.NET управления. Этот второй параметр потребуется вам в случае, если для принятия ре-шения нужно будет проанализировать исходную разметку элемента управления. public class SafeListPageFilter : PageParserFilter { private List<Type> _safeControlList; protected virtual List<Type> SafeControlList { get { if (_safeControlList == null) { _safeControlList = new List<Type>(); LoadSafeControlList(); } return _safeControlList; } } public override bool AllowControl( Type controlType, ControlBuilder builder) { return SafeControlList.Contains(controlType); } private void LoadSafeControlList() { //Обычно список типов считывается из внешнего источника: //базы данных, XML-файла, или, еще лучше, его получают //от пользовательского провайдера SafeControlList.Add(typeof(System.Web.UI.WebControls.TextBox)); SafeControlList.Add(typeof(System.Web.UI.WebControls.Button)); } } Этот демонстрационный код поддерживает список объектов Type, содержащий типы элементов управления, допустимых для применения на странице. Этот список заполняется информацией, прочитанной из внешнего источника данных, такого как база данных или XML-файл. В свете того, о чем рассказывалось в главе 4, имеет очевидный смысл применить для этой цели пользовательский провайдер. В нашем примере для страницы разрешены всего два вида элементов управления - TextBox и Button. Это означает, что при компиляции страницы с любыми другими элементами управления будут выданы сообщения об ошибках (рис. 5-9). Итак, списки безопасных элементов управления - концепция, типичная для Share-Point и не поддерживаемая в ASP.NET. Однако ничто не мешает разработать анало-гичную функцию для ASP.NET, равно как и противоположную - списки блокируемых элементов управления. В конечном счете, у вас есть возможность выполнять в своем фильтре любые не-обходимые проверки. Если AllowControl вернет true, компилятор будет считать, что с элементом управления все в порядке; в противном случае он выдаст сообщение об ошибке.
Создание сложных страниц Глава 5 219 Рис. 5-9. Если страница содержит небезопасные элементы управления, вы получите сообщения об ошибках компиляции Блокирование базовых классов Тем же способом, каким мы блокировали элементы управления страницы ASP.NET, можно блокировать и рендеринг, источником которого является небезопасный базо-вый класс. Для этого вам нужно переопределить метод AllowBaseType, с тем чтобы он возвращал значение булева типа, указывающее, безопасен ли заданный класс. public virtual bool AllowBaseType(Type baseType) { return IsSafeClass(baseType); }private bool IsSafeClass(Type classType) { //Сверьте имя класса со списком безопасных классов } Одним из применений фильтра такого типа может быть гарантия того, что все страницы приложения будут наследовать один и тот же базовый класс. Примечание В атрибуте pageBaseType раздела <pages> конфигурационного файла можно задать общий базовый класс для всех страниц приложения. Чем такое решение отличается от решения на основе фильтра с переопределенным методом AllowBaseType? Фильтр обеспечивает соблюдение конкретных требований к программному коду, тогда как атрибут pageBaseType дает способ написания кода, отвечающего определенному требованию: используемый базовый класс должен считаться безопасным. Блокирование виртуальных ссылок Метод AllowVirtualReference определяет, разрешены ли на данной странице вирту-альные ссылки на ресурсы заданного типа. Как показано ниже, у этого метода два параметра: public virtual bool AllowVirtualReference( string virtualPath, VirtualReferenceType referenceType ) В первом параметре задается виртуальный путь к ресурсу, такому как эталонная страница, другая страница ASP.NET или пользовательский элемент управления, а во втором параметре указывается тип ресурса. VirtualReferenceType - это перечислимый тип; его члены описаны в табл. 5-6.
220 Часть I Внутренние механизмы ASP.NET Табл. 5-6. Перечисление VirtualReferenceType Член Описание Master Виртуальный путь к эталонной странице Page Виртуальный путь к странице ASP.NET SourceFile Виртуальный путь к файлу кода, который компилируется с использованием компилятора определенного языка UserControl Виртуальный путь к пользовательскому элементу управления Other Виртуальный путь к ресурсу, который не относится ни к одному из перечисленных выше типов Одной строкой кода вы можете заблокировать все пользовательские элементы управления. Вот как это делается: public override bool AllowVirtualReference(string virtualPath, VirtualReferenceType refType) { //Пропускаем все, кроме пользовательских элементов управления return (refType != VirtualReferenceType.UserControl) }Добавление ко всем страницам литеральной строки Как уже упоминалось, фильтры анализатора не дают разработчикам возможности мо-дифицировать код, сгенерированный стандартным анализатором - классом PageParser, который является скрытым внутренним классом ASP.NET. Все переопределяемые методы, проанализированные здесь, дают лишь возможность принять либо отклонить каждый из элементов страницы, и не более того. Однако есть все же одно исключение: вы можете частично модифицировать вывод страницы одним определенным образом. Пользы от этого немного, так что я упоминаю о данной возможности скорее шутки ради, а также для полноты изложения. Итак, с помощью фильтра можно добавить во все обработанные страницы литеральную строку. Делается это так: public override void ParseComplete(ControlBuilder rootBuilder) { //Убеждаемся, что это страница, а не какой-нибдуь другой ресурс if (rootBuilder is FileLevelPageControlBuilder) rootBuilder.AppendLiteralString("<b>written by Dino Esposito</b>"); } Вы переопределяете метод ParseComplete и добавляете строку в переданный ему объект-построитель. Предварительно не забудьте убедиться, что переданный вам ресурс - это именно страница, а не, скажем, skin-файл или иной ресурс. Ведь добав-ление строки в другой ресурс может нарушить его синтаксис, и в результате будет сгенерирована ошибка анализатора. Метод ParseComplete вызывается, перед самым окончанием разбора страницы. Его аргументом является ссылка на корневой построитель - объект, выводящий метод BuildControlTree в динамически созданный код страницы (подробности см. в главе 1). Метод BuildControlTree отвечает за разметку страницы. Он содержит вызовы методов, формирующих все ее северные элементы управления. Вот какова его структура, когда 
Создание сложных страниц Глава 5 221 описанным выше способом на страницу добавляется литерал (как обычно, реальный код я несколько подредактировал): private void BuildControlTree(YourPage_aspx ctrl) { IParserAccessor parser = (IParserAccessor) ctrl; //Записывает начало разметки parser.AddParsedSubObject(new LiteralControl("<html>")); //Создает элемент управления <head>, если таковой имеется HtmlHead ctrl1 = BuildControl__control1(); parser.AddParsedSubObject(ctrl1); //Начинает запись тела страницы parser.AddParsedSubObject(new LiteralControl("<body>")); //Создает форму и все ее дочерние элементы HtmlForm ctrl2 = BuildControl__form1(); parser.AddParsedSubObject(ctrl1); parser.AddParsedSubObject(new LiteralControl("</body></html>")); //Сюда попадает все, что вы добавили посредством фильтра parser.AddParsedSubObject(new LiteralControl(тут ваше сообщение)); } Сообщение выводится как есть и никакому анализу не подвергается. При желании можете "декорировать" его, используя любые HTML-элементы, такие как шрифты, якоря и изображения. Заметьте, что текст вставляется в разметку после закрывающего тэга </html>, но большинству браузеров это не мешает. Заключение Исполняющая среда, где происходит обработка страниц, в ASP.NET 2.0 обладает значительно большими возможностями, чем в предшествующих версиях. Новые ди-рективы, дополнительные атрибуты и усовершенствования синтаксиса дают возмож-ность создавать более сложные и богатые элементами страницы, причем меньшими усилиями. Асинхронные страницы - пожалуй, лишь верхушка айсберга, многие дру-гие средства и ресурсы позволяют теснее взаимодействовать с процессом подготовки страницы. Конечная цель создателей ASP.NET 2.0 заключалась не только в том, чтобы обеспечить возможность создания более сложных страниц, но и в том, чтобы облегчить этот процесс. Как говорится в рекламе, "потратишь меньше - получишь больше". Создавая асинхронные страницы, вы обеспечиваете возможность параллельного выполнения нескольких заданий в асинхронном режиме, без блокирования потоков и без снижения масштабируемости приложения. Механизм обработки динамических выражений предусматривает возможность построения выражений с пользовательским синтаксисом. Выражения призваны поднять декларативное программирование на следующий уровень - а декларативное программирование требует дополнительной поддержки со стороны средств разработки и, в конечном счете, предполагает умень-шение количества кода, который вам приходится писать для приложения. Наконец, фильтры анализатора позволяют вам самостоятельно решать, что дозволено включать в состав страниц, а что - запрещено.
222 Часть I Внутренние механизмы ASP.NET Этой главой завершается часть I данной книги, посвященная внутренним меха-низмам и расширяемости ASP.NET. В следующей главе мы приступим к изучению специализированных функций и возможностей исполняющей среды ASP.NET, кото-рые можно использовать при разработке приложений. А начнем мы с возможностей сценариев. Только факты Асинхронные страницы идеально подходят для реализации длительных операций, таких как транзакции баз данных или вызовы Web-сервисов, без блокирования потоков и с параллельным выполнением нескольких заданий. В состав ASP.NET 2.0 входит специализированный API, упрощающий создание асинхронных страниц. ASP.NET 1.x поддерживает асинхронное выполнение, но большую часть необходимого для его реализации кода приходится писать собс-твенноручно, причем этот код довольно сложен. В ASP.NET 2.0 достаточно пометить страницу атрибутом Async и зарегистриро-вать задания для асинхронного выполнения. Модифицированный цикл обработ-ки запроса разделит выполнение страницы на два этапа, выполняемые разными потоками из пула. На первом этапе задание будет запущено, а поток возвращен в пул. Предварительно будет подготовлен механизм обратного вызова, посредством которого по завершении задания будет запущен второй этап выполнения запроса. Для этого второго этапа из пула будет выбран новый поток, в котором и осущес-твится рендеринг страницы. В ASP.NET 2.0 поддерживаются выражения трех типов: блоки кода, выражения связывания с данными и динамические выражения. Последние обрабатываются на этапе синтаксического разбора и используются для установки свойств. Существует возможность определить пользовательский синтаксис динамических выражений, написав новый класс, производный от ExpressionBuilder. Фильтры анализатора страницы дают вам возможность руководить отбором эле-ментов управления и других функциональных элементов, осуществляемым на этапе синтаксического разбора. Данная технология позволяет создать список бло-кируемых элементов управления и гарантировать, что ни один из перечисленных в нем элементов управления не будет включен в состав страниц. Встретив такой элемент, компилятор выдаст сообщение об ошибке. Фильтры анализатора страниц не могут использоваться для модификации кода, сгенерированного ASP.NET. 
Часть II Специализированные средства ASP.NET Глава 6. Работа с кодом сценариев ................................................................................ 224 Глава 7. Страницы с элементами Web Parts ................................................................... 261 Глава 8. Программирование для мобильных устройств ................................................ 307 Глава 9. Работа с изображениями ................................................................................... 336 Глава 10. Навигация по сайту ............................................................................................ 366
Глава 6 Работа с кодом сценариев Приложения для Web - это приложения особого рода, они требуют взаимодействия клиентского и серверного кода. За последнее десятилетие технологии создания таких приложений претерпели огромные изменения, но все достижения в этой области ка-саются исключительно серверного кода. Серверное окружение становится все богаче, тогда как на клиентской стороне ровным счетом ничего не меняется. В результате мы пришли к ситуации, когда для преодоления клиентских ограни-чений приходится прибегать к невероятно сложным решениям на сервере. Суть их всегда сводится к тому, что на сервере автоматически генерируется и вставляется в формируемые сервером страницы особый клиентский код, осуществляющий вызовы сервера без снижения производительности из-за постоянных возвратов формы. Бла-годаря этому пользователи получают лучшее от двух миров, но какой ценой! В этой главе я расскажу о технологиях, помогающих с успехом применять сце-нарии на клиентской стороне (по крайней мере в тех случаях, когда они разрешены браузером). В центре внимания будут два главных вопроса: преодоление ограничений JavaScript путем абстрагирования клиентского кода в серверных классах и выполнение вызовов сервера клиентом без обновления страницы. Включение в страницы клиентских сценариев Клиентский код - исключительно важная часть Web-приложения, поскольку он сообщает странице некоторую динамичность и при этом не требует выполнения пос-тоянных операций возврата формы. Для современных страниц, богатых графикой и другими элементами, постоянные обновления в процессе работы просто неприем-лемы, каким бы мощным ни был компьютер и сколь широкой ни была бы полоса пропускания. Всякое Web-приложение устроено таким образом, что оно передает серверу за-просы без сохранения состояния. При этом спектр задач, которые можно выполнять на стороне клиента, крайне ограничен: проверка введенных пользователем данных, предварительное заполнение полей, скрытие и отображение частей страницы, дина-мическая ее модификация и вывод связанных с ней всплывающих окон - вот, пожа-луй, и все. Для выполнения любой из этих задач клиентскую страницу необходимо снабдить некоторым сценарием. Как же вставляются такие сценарии? Существует несколько решений, от жесткого их кодирования и применения клиентских включаемых файлов до генерирования кода сценариев на сервере. Код сценария должен взаимодействовать с браузером и объектной моделью, которую тот использует для представления текущей страницы и ее установок. Поэтому, прежде чем создавать сценарий или включать его в страницу, необходимо узнать, какой браузер установлен у клиента и каковы его возможности. Это даст возможность адаптировать код страницы и ее элементов управления к кон-кретному устройству.
Работа с кодом сценариев Глава 6 225 Определение возможностей браузера Информация о браузере заключена в объекте HttpCapabilitiesBase, возвращаемом свойством Request.Browser. В .NET Framework есть два класса, производных от HttpCapabilitiesBase: BrowserCapabilities и MobileCapabilities. Первый представляет браузеры настольных устройств, а второй - мобильных. Следует различать две разные задачи, встающие перед разработчиком в зависимос-ти от конкретной ситуации. Если известно, что написанный для страницы сценарий будет успешно выполнен тем или иным браузером (например, Internet Explorer или Firefox), все что нужно для включения или отключения данного сценария - это оп-ределить тип браузера. В других случаях тип браузера не имеет значения, зато важно знать, поддерживается ли браузером та или иная возможность или функциональный элемент, скажем, cookie, обратные вызовы сценариев или фреймы. Определение типа браузера В заголовке User-Agent полученного сервером запроса обычно содержится полная информация о браузере. Доступ к содержимому этого заголовка осуществляется посредством свойства Request.UserAgent. У Internet Explorer (IE) 6.0 заголовок агента пользователя выглядит следующим образом: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.1) А у Mozilla Firefox 1.0 он таков: Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0 Как видите, строка пользовательского агента содержит не только имя браузера - в ней указаны его версия, операционная система хоста, язык и поддерживаемые плат-формы. Но что если вам просто нужно знать, какой браузер обратился с запросом, Inter net Explorer или Firefox? В таком случае вы прибегаете к свойству Browser или Type: <h2>This browser is <% =Request.Browser.Browser %></h2> <h2>This browser is <% =Request.Browser.Type %></h2> <h2>This browser is <% =Request.UserAgent %></h2> Свойство Browser возвращает имя браузера, а свойство Type - еще и базовую информацию о его версии. В табл. 6-1 приведено несколько примеров значений, воз-вращаемых этими свойствами. Табл. 6-1. Имена браузеров Браузер Свойство Browser Свойство Type Internet Explorer 6.0 IE IE6 Internet Explorer 5.5 IE IE55 Mozilla Firefox 1.0 Mozilla Mozilla1.7.5 Netscape 7.2 Netscape Netscape72 Netscape Communicator 4.6 Netscape Netscape4 В состав класса HttpCapabilitiesBase входит также функция булева типа IsBrowser, предназначенная для быстрой проверки типа браузера. Данная функция принимает строку с именем браузера и возвращает true, если оно принадлежит текущему бра-узеру, и false в противном случае. Учтите, что для проверки используется свойство Browser. Поэтому для любой версии Internet Explorer вызовы IsBrowser("IE6") и IsBrowser("Internet Explorer") вернут false, и применить для его идентификации можно будет только строку "IE": <h2>This browser is IE: <% =Request.Browser.IsBrowser("IE") %></h2>
226 Часть II Специализированные средства ASP.NET Но что если вы захотите узнать версию браузера, то есть вам важно, какая кон-кретно программа установлена у пользователя, Internet Explorer 5.5 или Internet Explorer 4.0? Следующий код показывает, как убедиться, что запрос получен от Internet Explorer версии 4.0 или более поздней: HttpBrowserCapabilities caps = Request.Browser; if (caps.IsBrowser("IE") && caps.MajorVersion >3) { } Примечание Кто отвечает за псевдонимы, назначенные браузерам в ASP.NET? Иными словами, почему используется IE, а не Internet Explorer, или Mozilla, а не Firefox? Вся информация о браузере - как идентификатор его типа, так и перечень возможностей - считывается из серверных файлов, расположенных в инсталляционной папке ASP.NET. Сведения о популярных браузерах (включая и их псевдонимы) введены разработчиками ASP.NET, но администраторы могут дополнять и модифицировать данный файл. Получение информации о возможностях браузера Возможности браузера определяются статически, путем чтения информации из сервер-ного хранилища, а не с помощью динамической отправки соответствующего запроса бра-узеру. Указанные сведения хранятся в папке, расположенной по следующему пути: %WINDOWS%\Microsoft.NET\Framework\[версия]\Config\Browsers В данной папке вы найдете несколько файлов .browser, по одному на каждое известное системе семейство браузеров. Файл .browser имеет формат XML; в нем указаны идентификаторы и перечислены возможности каждой из известных версий браузера. Обратите внимание: это сведения, имеющиеся на текущий момент; их можно редактировать и дополнять. Если вы узнали о существовании устройства, неизвестного ASP.NET, смело добавляйте сведения об этом устройстве в соответствующий файл из папки Browsers. В исполняющей среде возможности заданного браузера представлены объектом класса HttpCapabilitiesBase. У него есть множество доступных только для чтения свойств, обеспечивающих типизированный доступ ко всей наличной информации. Некоторые из них перечислены в табл. 6-2. Все эти свойства определены как открытые. Табл. 6-2. Наиболее популярные свойства класса HttpCapabilitiesBase Свойство Описание ActiveXControls Указывает, поддерживает ли браузер компоненты ActiveX BackgroundSounds Указывает, поддерживает ли браузер фоновый звук Beta Указывает, является ли версия браузера бета-выпуском Browser Возвращает имя браузера ClrVersion Возвращает объект Version, содержащий информацию об общеязыковой среде .NET, установленной у клиента Cookies Указывает, поддерживает ли браузер cookie Crawler Указывает, является ли браузер агентом поисковой машины EcmaScriptVersion Возвращает номер версии языка ECMAScript, поддерживаемого браузером Frames Указывает, поддерживает ли браузер HTML-фреймы Item Индексированное свойство, возвращающее сведения о поддержке браузером заданной возможности 
Работа с кодом сценариев Глава 6 227 Свойство Описание JavaApplets Указывает, поддерживает ли браузер Java-апплеты JavaScript Указывает, поддерживает ли браузер язык JavaScript MajorVersion Возвращает целое число, представляющее старший номер версии браузера MinorVersion Возвращает десятичное число, представляющее младший номер версии браузера MSDomVersion Указывает версию поддерживаемой браузером объектной модели доку-мента Microsoft HTML (MSHTML) SupportsCallback Указывает, поддерживает ли браузер обратные вызовы сценариев SupportsCss Указывает, поддерживает ли браузер CSS SupportsXmlHttp Указывает, поддерживает ли браузер получение XML через HTTP с использованием объекта XmlHttpRequest или его разновидности Tables Указывает, поддерживает ли браузер таблицы HTML Type Возвращает строку, содержащую имя и главный номер версии браузера (например, "Internet Explorer 6" или "Netscape 7") VBScript Указывает, поддерживает ли браузер язык VBScript Version Возвращает строку, содержащую полный номер версии браузера (и целочисленную, и дробную часть) W3CdomVersion Возвращает номер версии поддерживаемой браузером модели W3C DOM Если вы пишете приложение для мобильного устройства, то вам следует привести значение, возвращенное свойством Request.Browser, к типу MobileCapabilities и исполь-зовать его в таком виде. В .NET Framework 1.0 класс MobileCapabilities отсутствует, но его можно загрузить отдельно, если ваше приложение должно работать с мобильными устройствами. Выбор целевого клиента По умолчанию свойство Request.Browser возвращает объект HttpCapabilitiesBase, пред-ставляющий возможности браузера, направившего запрос. Что это за браузер, ASP.NET узнает из строки агента пользователя. В ASP.NET можно конфигурировать страницы таким образом, чтобы они предназначались для одного "целевого клиента". Иден-тификация браузера при этом не выполняется, и страница использует возможности браузера, заданные для конкретного целевого клиента. Выбор целевого клиента осуществляется одним из двух способов: программно, с помощью свойства ClientTarget класса Page, или декларативно, посредством одноимен-ного атрибута директивы @Page. Свойство ClientTarget содержит строку, а принимает оно значения, соответствующие зарегистрированным целевым клиентам. Как рас-сказывалось в главе 3, в разделе <clientTarget> конфигурационного файла хранится список поддерживаемых целевых клиентов. Идентификатор целевого клиента в этом списке - не что иное, как псевдоним зарегистрированного браузера. Вывод, ориентированный на конкретное устройство Во многих случаях после определения типа браузера в приложении просто изменяется значение того или иного свойства элемента управления. Если это все, что вам нужно, данную задачу можно делегировать ASP.NET 2.0, указав значения свойств элементов управления, соответствующие разным типам браузеров. <asp:Button ID="Button1" runat="server" Text="I'm a Button" ie:Text="IE Button" mozilla:Text="Firefox Button" /> Табл. 6-2. (окончание)
228 Часть II Специализированные средства ASP.NET Свойство Text кнопки будет содержать значение "IE button", если страница просмат-ривается в Internet Explorer, или значение "Firefox button", если ее открыли в Firefox. Когда используется любой другой браузер, на кнопке выводится значение атрибута Text, не имеющего префикса. Идентификатором браузера можно помечать любые свойства, задаваемые внутри тэгов. В качестве такого идентификатора подойдет зна-чение свойства Browser класса HttpCapabilitiesBase. Примечание Поддержка программного определения возможностей браузера важна для принятия решения о том, как лучше реализовать определенную функцию. Например, для элемента управления, выводящего информацию по требованию, скажем, узла дере-ва, кнопка развертывания может быть реализована как обыкновенная кнопка возврата формы или же как клиентская кнопка. В последнем случае отображаемый текст заранее включается в состав страницы, с тем чтобы его можно было выводить и скрывать по щелчку. Мы вернемся к теме сценариев серверных элементов управления в главе 13. Регистрация блоков сценариев Код сценариев, которые вы включаете в состав страницы, как правило, должен вза-имодействовать с ее клиентскими элементами, сгенерированными на сервере. Пред-положим, вы поместили на страницу элемент управления TextBox. Функция, которая будет проверять введенное в это поле значение, должна знать идентификатор эле-мента управления. Как лучше всего это организовать? Учтите, что сценарий может быть написан вручную и размещен в разделах <script> основного файла страницы, либо импортироваться из внешних файлов или ресурсов, либо даже формироваться программным путем. Рассмотрим каждый из этих вариантов. Жестко закодированный сценарий В классическом HTML-файле код сценариев располагается в разделах <script>, поме-ченных атрибутом language. Весь код, связанный с HTML-элементами и событиями, должен либо входить в состав файла страницы, либо находиться в одном из связан-ных с ней файлов. Простейший способ вставки кода сценария в страницу ASP.NET состоит в том, чтобы включить в нее один или более тэгов <script>, не помеченных атрибутом runat=server. В качестве примера приведем небольшой сценарий, который делает текущую страницу домашней страницей браузера: <script language="javascript" type="text/javascript"> function SetAsHomePage(obj) { obj.style.behavior="url(#default#homepage)"; obj.setHomePage("http://www.contoso.com"); }</script> Вы помещаете этот код в файл страницы и добавляете клиентскую кнопку для его вызова: <input type="button" value="Set home page" onclick="SetAsHomePage(this)" /> При использовании элемента управления button в клиентскую страницу включа-ется кнопка, по щелчку которой выполняется возврат формы. Не то чтобы это было неправильно, но в данном действии нет необходимости. Каковы недостатки приведенного выше кода? Прежде всего, отметим то, что в нем используется Dynamic HTML, а следовательно, для его выполнения требуется Internet Explorer версии 5.5 или выше. "Зашив" сценарий в страницу, вы можете проверить строку агента пользователя в самом этом сценарии или добавить клиентский код, который вначале определит возможности браузера, а затем сгенерирует для страницы 
Работа с кодом сценариев Глава 6 229 сценарий, поддерживаемый этим браузером. Для вставки такого сценария в страницу можно воспользоваться функцией document.write, которую поддерживает большинство браузеров. Жестко закодированные сценарии подходят далеко не для каждого случая, хотя об этом варианте тоже не стоит забывать. Одной из трудностей, связанных с их при-менением, является необходимость знать идентификаторы HTML-элементов, с ко-торыми вы работаете, что особенно неудобно, когда над страницами и сценариями трудятся разные команды. Любые изменения идентификаторов должны своевременно отражаться в сценариях. Посмотрим, можно ли переписать код приведенного выше примера так, чтобы он зависел от используемого браузера. В новой версии клиентский сценарий будет генерироваться серверным кодом. Класс ClientScriptManager Класс Page представляет текущий экземпляр страницы. Все, что эта страница будет передавать браузеру, описывается посредством литералов и экземпляров серверных эле-ментов управления, и код сценария - не исключение. Если вы хотите, чтобы в разметке страницы присутствовал код на языке JavaScript, сделайте его элементом серверной объектной модели страницы. Жестко закодированный сценарий выводится как лите-ральный текст. Однако, как упоминалось выше, это лишь одна из возможностей. У класса Page имеется ряд методов, пользуясь которыми вы можете программно сформировать и включить в состав страницы сценарий, учитывая при этом условия времени выполнения. В ASP.NET 2.0 эти методы доступны через свойство ClientScript класса Page - они принадлежат вспомогательному классу с именем ClientScriptManager, экземпляр которого возвращает данное свойство. В ASP.NET 1.x те же методы были оп-ределены непосредственно в классе Page. Описание методов класса ClientScriptManager, используемых для вывода сценария по требованию, приведено в табл. 6-3. Табл. 6-3. Члены класса ClientScriptManager, предназначенные для работы со сценариями Метод Описание GetCallbackEventReference Возвращает прототип функции клиентского сценария, осуществляющий обратный вызов серверного кода GetPostBackClientHyperlink Добавляет строку javascript: в начало строки, полученной от метода GetPostBackEventReference, как показано ниже: javascript:__doPostBack('CtlID','') GetPostBackEventReference Возвращает прототип функции клиентского сценария, осуществляющий обратный вызов серверного кода; метод принимает объект Control и аргумент функции и возвраща-ет строку, подобную следующей: __doPostBack('CtlID','') GetWebResourceUrl Возвращает URL для вызова ресурса, хранящегося в сбор-ке страницы IsClientScriptBlockRegistered Определяет, зарегистрирован ли для страницы заданный клиентский сценарий IsClientScriptIncludeRegistered Определяет, зарегистрирован ли для страницы заданный включаемый в нее внешний сценарий IsOnSubmitStatementRegistered Определяет, зарегистрирован ли для страницы заданный клиентский submit-сценарий (см. след. стр.)
230 Часть II Специализированные средства ASP.NET Метод Описание IsStartupScriptRegistered Определяет, зарегистрирован ли для страницы заданный клиентский startup-сценарий RegisterArrayDeclaration Используется для добавления в клиентскую страницу мас-сива ECMAScript. Данный метод принимает имя массива и строку, которая будет использоваться в том виде, в каком вы ее задали, в качестве тела массива. Например, если вы-звать метод с аргументами "theArray" и "'a', 'b'", то в резуль-тате получится следующий код на языке JavaScript: var theArray = new Array('a', 'b'); RegisterClientScriptBlock Вставляет в клиентскую страницу блок клиентского сцена-рия, располагаемый между открывающимся HTML-тэгом <form> и всеми серверными элементами управления RegisterClientScriptInclude Выводит разметку для импорта внешнего файла сценария с использованием атрибута src тэга <script> RegisterClientScriptResource Вызывает метод RegisterClientScriptInclude для регистрации внешнего файла сценария, который входит в состав ресур-сов страницы RegisterExpandoAttribute Выводит разметку для импорта пользовательского, нестан-дартного атрибута RegisterHiddenField Выводит разметку для скрытого поля RegisterOnSubmitStatement Выводит клиентский сценарий, ассоциированный с собы-тием OnSubmit формы RegisterStartupScript Выводит клиентский сценарий после тэга <form>, чтобы он запускался непосредственно перед выводом страницы, когда все элементы управления уже инициализированы Как видите, у класса ClientScriptManager имеются члены трех типов: GetXXX, IsXXX и RegisterXXX. Методы GetXXX возвращают стандартный код JavaScript в виде строки. Этот код страницы и элементы управления используются для реализации стандартных функций, таких как обратный вызов сценария (script callback), возврат формы и переход по гиперссылке. Методы RegisterXXX регистрируют для страницы фрагменты кода, чтобы сценарий выводился в выходной поток при рендеринге стра-ницы. Что касается методов IsXXX, то они проверяют, зарегистрирован ли уже для страницы определенный код, и таким образом позволяют избежать его дублирования и происходящих в результате ошибок на клиентской странице. Блоки кода, выводимые по требованию Для того чтобы переписать нашу функцию назначения домашней страницы с учетом возможностей браузера, сначала нужно идентифицировать браузер, составить строку кода на языке JavaScript, а затем зарегистрировать этот сценарий для страницы. Связь между страницей и сценарием устанавливается посредством метода RegisterClient ScriptBlock. Учтите, что сформированная вами функция будет выполняться только в случае ее явного вызова из блока <script>, входящего в состав страницы, например из обработчика события, такого как щелчок кнопки или выбор элемента в раскры-вающемся списке. Любой код, зарегистрированный с помощью метода RegisterClientScriptBlock, встав-ляется внутрь тэга <form> - после скрытого поля состояния представления и перед литералами и серверными элементами управления, входящими в состав формы. Мо-дифицируем приведенный выше исходный код серверной страницы, чтобы сценарий Табл. 6-3. (окончание)
Работа с кодом сценариев Глава 6 231 включался в клиентскую страницу только в том случае, когда запрос получен от Internet Explorer версии не ниже 5.5: <body> <form id="form1" runat="server"> <div> <input runat="server" type="button" ID="HomePageButton" value="Set home page" /> </div> </form> </body> Данная страница содержит клиентскую кнопку не submit-типа без обработчика события. Атрибуты этого элемента, необходимые для запуска сценария, будут добав-лены на сервере в процессе формирования разметки страницы. Теперь рассмотрим класс отделенного кода страницы: protected void Page_Load(object sender, EventArgs e) { string HOMEPAGE = "http://weblogs.asp.net/despos"; //Должен быть IE55 или выше HttpBrowserCapabilities caps = Request.Browser; if (caps.IsBrowser("IE") && (caps.MajorVersion > 5 || (caps.MajorVersion == 5 && caps.MinorVersion >= 5))) { //Разрешаем использование кнопки и определяем обработчик события onclick HomePageButton.Disabled = false; HomePageButton.Attributes["onclick"] = "SetHomePage(this)"; //Регистрируем необходимый код сценария Type t = this.GetType(); if (!ClientScript.IsClientScriptBlockRegistered(t, "SetHomePage")) { //Составляем и регистрируем сценарий string js = BuildScriptCode(HOMEPAGE); ClientScript.RegisterClientScriptBlock(t, "SetHomePage", js); } } else HomePageButton.Disabled = true; }private string BuildScriptCode(string url) { StringBuilder sb = new StringBuilder(); sb.AppendLine("function SetHomePage(obj) {"); sb.AppendLine(" obj.style.behavior=\"url(#default#homepage)\";"); sb.AppendFormat(" obj.setHomePage(\"{0}\");\r\n", url); sb.AppendLine("}"); return sb.ToString(); } В обработчике события Page_Load вы определяете характеристики браузера и, если они соответствуют вашим ожиданиям, конфигурируете кнопку и составляете сценарий. Когда сценарий готов, вы регистрируете его для страницы, с тем чтобы он был включен в ответ браузеру.
232 Часть II Специализированные средства ASP.NET Класс Page поддерживает несколько хэш-таблиц для отслеживания сценариев, подлежащих включению в ответ. Жизненный цикл этих хэш-таблиц ограничен вре-менем выполнения запроса. С помощью метода IsClientScriptBlockRegistered вы можете проверить, зарегистрирован ли для страницы определенный сценарий. При регистра-ции сценарию назначается уникальное имя и задается тип страницы либо элемента управления, с которым он должен быть связан. Попытки повторной регистрации с указанием одного и того же типа и имени блокируются. Но если вы зарегистрируете тот же сценарий под другим именем или свяжете его с другим типом, он будет выве-ден в ответе браузеру дважды, в результате чего на клиентской стороне произойдет ошибка обработки сценария. На рис. 6-1 показана демонстрационная страница, открытая в браузерах Mozilla Firefox и Internet Explorer 6.0. Как видите, только в Internet Explorer кнопка назна-чения домашней страницы активна и действует. Рис. 6-1. Сценарий выводится только для браузера Internet Explorer версии 5.5 или выше В ASP.NET 2.0 у методов RegisterXXX имеются перегруженные версии, прини-мающие дополнительный аргумент булева типа, по умолчанию равный false. Если установить его в true, сценарий будет выведен в собственном блоке <script>. Когда же этот аргумент равен false, блок <script> не создается и разработчик сам отвечает за включение сценария в состав нужного элемента. Внимание! Кнопка ASP.NET (тэг <asp:Button>) включается в клиентскую страницу в виде элемента <input type=submit>. Это означает, что страница выполнит код, заданный в атри-буте onclick, а затем осуществит возврат формы. В ASP.NET 2.0 элемент управления Button имеет свойство UseSubmitBehavior, по умолчанию установленное в true. Если установить его в false, элемент <input> будет иметь тип Button, но атрибут onclick окажется связанным со стандартным сценарием возврата формы. Страница, как и раньше, будет выполнять возврат формы, но вы не сможете использовать атрибут onclick для предварительного выполнения клиентского кода. Однако поскольку возврат формы осуществляется с ис-пользованием метода submit из DOM, можно перехватить клиентское событие OnSubmit и все же выполнить свой код до возврата формы. Для регистрации соответствующего сценария воспользуйтесь методом RegisterOnSubmitStatement.
Работа с кодом сценариев Глава 6 233 Стартовые блоки кода Стартовыми (startup) блоками кода называются сценарии, выполняемые, когда стра-ница полностью инициализирована, но еще не выведена на экран. Перед регистрацией такого кода необходимо убедиться, что вызываемые из него функции доступны для страницы. Эти функции можно создавать на лету, жестко кодировать или же помещать во внешние файлы либо ресурсы, связанные со страницей. Для того чтобы код выполнялся как стартовый, его необходимо зарегистрировать с помощью метода RegisterStartupScript. Стартовый блок <script> вставляется сразу после закрывающегося тэга </form>. Учтите, что если этот блок содержит только определение функции, данная функция не выполняется. Если же в нем содержится вызов функции (либо определение и вызов), код выполняется на клиентской сторо-не. Доступ к любому HTML-элементу можно осуществлять без опасений, поскольку сценарий расположен ниже формы и выполняется после обработки браузером всех ее HTML-элементов. Внимание! У каждого браузера своя модель DOM, но большинство из них поддержи-вают стандарт HTML 4.0. Во избежание проблем, связанных с различием браузеров, рекомендуется писать код сценария, используя стандартные методы DOM, независимо от того, какие сокращения предлагают конкретные браузеры (пусть даже это будет Internet Explorer). Для доступа к HTML-элементу, например, лучше применять document.getElementById или ему подобный метод и избегать приемов, основанных на непосредственном использовании имени элемента. Вот пример безопасного доступа к текстовому полю: function ShowValue() { var obj = document.getElementById("TextBox1"); alert(obj.value); } В Visual Studio 2005 реализована полная IntelliSense-поддержка объекта document. Код сценария для submit-элемента Бывают случаи, когда некоторый код нужно выполнить непосредственно перед воз-вратом формы. Как это лучше сделать, зависит от желаемого результата. Если возврат формы осуществляется посредством обычной кнопки типа submit (то есть элемента <input> типа submit, reset или image), единственная ваша возможность - связать код сценария с атрибутом onclick. В таком случае функция обработки события onclick будет выполняться до возврата формы и даже сможет заблокировать эту операцию. Например, следующий сценарий отменяет возврат формы, если пользователь не дает на него согласия (то есть возвращает false): function ConfirmDeletion(msg) { return confirm(msg); } Важно знать, что submit-кнопки и сценарии OnSubmit никак между собой не связа-ны. Согласно стандартам W3C DOM объектная модель страницы должна генерировать событие OnSubmit. Однако если возврат формы инициируется submit-кнопкой, просто написать обработчик события OnSubmit недостаточно. Данное событие генерируется только в том случае, если возврат формы осуществляется с использование DOM-метода submit. С точки зрения приложения ASP.NET это означает, что если вам нужно выполнить некоторый сценарий перед возвратом формы, следует пользоваться не обычным эле-ментом управления Button, а классом LinkButton или же элементом управления Button, 
234 Часть II Специализированные средства ASP.NET снабженным специализированным сценарием, который управляет возвратом формы. Тогда страница будет использовать для возврата формы метод submit и генерировать событие OnSubmit - словом, будет вести себя так, как вам требуется. Заметьте, что упомянутый специализированный сценарий представляет собой строку, возвраща-емую методом GetPostBackEventReference, описанным в табл. 6-3. Для регистрации обработчика используется метод RegisterOnSubmitStatement: ClientScript.RegisterOnSubmitStatement(this.GetType(), "MySubmit", js); В результате выполнения этого кода форма снабжается атрибутом OnSubmit, свя-занным с функцией, имя которой фиксировано - WebForm_OnSubmit. Также добав-ляется блок <script> с прототипом данной функции. Ее телом является код, который вы передали методу RegisterOnSubmitStatement. Этот код должен быть исполняемым и не включать объявлений каких-либо вспомогательных функций. Вот что содержит страница после регистрации submit-сценария: <script type="text/javascript"> function WebForm_OnSubmit() { //Здесь размещается то, что вы передали методу RegisterOnSubmitStatement //True для продолжения, False для отмены return true; }</script> Форме, как мы уже сказали, присваивается атрибут onsubmit: <form id="form1" method="post" action="HomePage.aspx" onsubmit="javascript:return WebForm_OnSubmit();"> Обработка события OnSubmit является прекрасным решением для ситуаций, когда автор сценария не может контролировать способ и момент возврата формы. Например, если вы создаете страницу с одной submit-кнопкой, то, вероятно, предпочтете написать ее обработчик onclick, а не возиться с перехватом события OnSubmit. Иное дело, когда вы пишете специализированный элемент управления. Он располагается на странице, содержащей другие элементы управления, один из которых может инициировать возврат формы. В таком случае регистрация обработчика OnSubmit является единс-твенной возможностью выполнить необходимые действия перед возвратом формы. Итак, имейте в виду, что ни один элемент управления страницы не в состоянии перехватить событие возврата формы, если этот возврат осуществляется посредством элемента <input> типа submit, reset или image. Серверные внешние сценарии Выше уже упоминалось о возможности размещения сценария во внешнем файле, связанном со страницей, или среди ресурсов сборки страницы. Связывание файла JavaScript со страницей осуществляется с помощью метода RegisterClientScriptInclude: ClientScript.RegisterClientScriptInclude("MyScript", "http://www.foo.com/script.js"); Первым аргументом является псевдоним сценария. Ниже приведена разметка, получаемая в результате этого вызова: <script src="http://www.foo.com/script.js" type="text/javascript"></script>
Работа с кодом сценариев Глава 6 235 Загрузка кода сценария из ресурса Если вы хотите загружать код сценария из хранилища ресурсов сборки страницы, то сначала добавьте файл сценария в проект как встроенный ресурс, а затем свяжите его со страницей посредством метода RegisterClientScriptResource: ClientScript.RegisterClientScriptResource(this.GetType(), "MyScript.js"); В результате в разметку страницы будет включен следующий элемент <script>: <script src="/ProAspNetAdv/WebResource.axd?d=...&t=..." type="text/javascript"></script> Загрузку заданного сценария из хранилища ресурсов сборки выполняет HTTP-обработчик WebResource.axd. Метод RegisterClientScriptResource вызывает для выпол-нения своей задачи метод RegisterClientScriptInclude, передав ему URL, указывающий на WebResource.axd. Следующий псевдокод поможет вам получить представление о внутренней реализации метода RegisterClientScriptResource: public void RegisterClientScriptResource(Type type, string resourceName) { RegisterClientScriptInclude(type, resourceName, GetWebResourceUrl(type, resourceName)); } Вызываемый здесь метод GetWebResourceUrl принадлежит классу ClientScriptManager; он возвращает URL заданного ресурса. Этот URL указывает на WebResource.axd и служит для извлечения запрошенного ресурса из сборки. Методу GetWebResourceUrl требуется также объект Type, используемый для поиска сборки, содержащей ресурс. Эта сборка идентифицируется как загруженная в текущий AppDomain и содержа-щая заданный тип. Во втором аргументе методу GetWebResourceUrl передается имя встроенного ресурса. Преимущества хранения кода сценария как ресурса Каковы преимущества загрузки кода сценария из хранилища ресурсов сборки? Такой сценарий легко редактировать и совместно использовать в виде отдельного файла, поскольку его можно рассматривать как род жестко закодированного сценария. В то же время его можно загружать в память программно и можно выполнять его предва-рительную обработку, например, заменять символы подстановки соответствующими значениями и добавлять недостающие фрагменты, основываясь на условиях, извес-тных во время выполнения. Но для того чтобы воспользоваться всеми этими преимуществами, нужно дейс-твовать несколько иначе, чем рассказывалось выше, при описании файлов сценариев, поскольку метод GetWebResourceUrl работает с URL, а не с содержимым сценария. Идея заключается в том, чтобы загрузить содержимое ресурса прямо из сборки, пре-вратить его в объект подходящего типа (скажем, в строку или байтовый массив) и вставить в страницу. Assembly current = Assembly.GetExecutingAssembly(); Stream stm = current.GetManifestResourceStream("MyScript.js"); StreamReader reader = new StreamReader(stm); string contents = reader.ReadToEnd(); reader.Close(); stm.Close(); //Обрабатываем содержимое встроенного ресурса
236 Часть II Специализированные средства ASP.NET Приведенный фрагмент кода показывает, как осуществляется доступ к ресурсам текущей сборки как к потоку и как происходит извлечение содержимого встроенного в сборку файла сценария. Примечание Я уже упоминал о том, что в ASP.NET 1.x не было свойства ClientScript и все методы, связанные со сценариями, определялись прямо в классе Page. В ASP.NET 2.0 рекомендуется использовать методы объекта ClientScript. Прежние методы тоже доступны, но помечены как устаревшие. Тем более что объект ClientScript имеет гораздо больше методов для работы со сценариями, чем объект Page. Создание всплывающих окон Одним пользователям всплывающие окна нравятся, другие их терпеть не могут. Поэ-тому, с одной стороны, такие окна очень популярны, а с другой, не менее популярны их блокировщики, встроенные в большинство современных браузеров. С точки зрения разработчика, занимающего нейтральную позицию, ничего плохого во всплывающих окнах нет. Ведь, в конечном счете, если в каком-то окне и делается что-то нехорошее, то не самим окном, а его контентом, и с равным успехом может быть сделано основ-ным кодом страницы. Использование всплывающих окон - прекрасное решение для случаев, когда в ответ на некоторые действия пользователя нужно вывести определенные, относительно статичные, данные, предназначенные только для чтения. Механизм навигации по сайту с такими окнами не работает: поскольку вызвавшая окно страница остается активной, страница, открытая во всплывающем окне, не включается в историю и к ней нельзя вернуться с помощью кнопки Назад. В ASP.NET 2.0 не предусмотрена поддержка включения в Web-приложение всплы-вающих окон и нет метода Register-типа для программного генерирования необхо-димого кода. И хотя создание всплывающих окон не является таким уж сложным делом, занятие это несколько утомительное, поскольку, во-первых, соответствующий сценарий приходится писать вручную, а во-вторых, стиль интерфейса окна задается в строковой форме. Давайте посмотрим, как заключить код формирования вызовов базового API, поддерживаемого большинством браузеров, в метод Register-типа, вы-зываемый программным способом на сервере. Примечание В Web имеется множество статей, посвященных проблеме всплывающих окон. Одну из них, с интересной аргументацией как за, так и против применения таких окон, вы найдете по адресу: http://www.accessify.com/tutorials/the-perfect-pop-up.asp. Базовый API для работы со всплывающими окнами Модель DOM большинства браузеров определяет объект window, содержащий как минимум один метод для создания модульного или немодального всплывающего окна - он называется open. Прототип этого метода не стандартизирован, но в боль-шинстве случаев срабатывает такой вызов: window.open(url, title, [, style]); В параметре url задается целевой URL для открытия окна, параметр title определяет заголовок окна, а необязательный параметр style задает его визуальные характерис-тики. Этот метод можно применять в браузерах Internet Explorer и Mozilla. Начиная с версии 4.0, Internet Explorer предлагает также два специализированных метода, showModalDialog и showModalessDialog: window.showModalDialog(url [, params] [, style]); window.showModalessDialog(url [, params] [, style]);
Работа с кодом сценариев Глава 6 237 Оба метода принимают URL и два необязательных параметра. URL указыва-ет на страницу, подлежащую отображению во всплывающем окне, аргумент params представляет объект JavaScript, в котором передаются дополнительные значения, обрабатываемые страницей, а аргумент style содержит разделенную символами точ-ки с запятой строку визуальных установок для полос прокрутки, кнопок изменения размера, кнопки вызова справки, строки состояния и т. д. Для создания всплывающего окна нужно вставить в страницу ASP.NET код сцена-рия, вызывающий один из перечисленных методов. Этот код можно связать с любой из клиентских кнопок или вызывать как стартовый: <script language="javascript"> function ShowPopup(url) { window.showModalDialog(url, "", ""); }</script> Вместо того чтобы каждый раз вручную вставлять аналогичный фрагмент кода во все страницы, где должно вызываться всплывающее окно, можно создать пользо-вательскую подпрограмму, регистрирующую для текущей страницы весь код вывода всплывающих окон. Результат будет таким же, но исходная страница получится ак-куратнее и изящнее. Примечание Синтаксис установки стилей окна в объектных моделях Internet Explorer и Mozilla различен. Более подробно об этом вы можете узнать из документации, кото-рую найдете соответственно по адресам http://msdn.microsoft.com/library/default.asp?url=/workshop/author/dom/domoverview.asp и http://www.mozilla.org/docs/dom. Разработка глобального метода Существует два подхода к разработке глобального компонента, используемого для вставки кода вывода всплывающих окон в Web-страницу: написание метода типа RegisterXXX, вызываемого в классе отделенного кода, и создание нового специализи-рованного элемента управления. О специализированных элементах управления мы поговорим в главе 13, а пока рассмотрим первый из указанных подходов. public void RegisterPopupWindow(Type t, string functionName, string targetUrl, bool modal, string style, bool addScriptTag) { //Получаем код на JavaScript string js = BuildScriptCode(targetUrl, functionName, modal, style); //Регистрируем сценарий для страницы if (!ClientScript.IsClientScriptBlockRegistered(functionName)) ClientScript.RegisterClientScriptBlock(t, functionName, js, addScriptTag); } Пользовательский метод RegisterPopupWindow построен по аналогии с остальными методами RegisterXXX. Он принимает тип, псевдоним сценария и аргумент булева типа, указывающий, должен ли использоваться самый внешний тэг <script>. Кроме того, у данного метода имеется три дополнительных параметра, предназначенных для конфигурирования создаваемого всплывающего окна, а именно URL его содержимого, флаг модальности и визуальные стили.
238 Часть II Специализированные средства ASP.NET Получив все эти сведения, метод RegisterPopupWindow формирует код на языке JavaScript, который затем регистрирует для текущей страницы, используя метод RegisterClientScriptBlock свойства ClientScript класса страницы. В дополнение можно написать несколько перегруженных версий данного метода, как показано ниже: public void RegisterPopupWindow(Type t, string functionName, string targetUrl) { RegisterPopupWindow(t, functionName, targetUrl, true, "", true); }public void RegisterPopupWindow(Type t, string functionName, string targetUrl, bool modal) { RegisterPopupWindow(t, functionName, targetUrl, modal, "", true); } Метод RegisterPopupWindow следует сделать доступным классу отделенного кода каждой страницы, где будет использоваться данное всплывающее окно, а еще луч-ше - включить прямо в этот класс. Вы можете откомпилировать указанный метод в составе внешней библиотеки как статический метод вспомогательного класса. В качес-тве альтернативы его можно определить в родительском классе страниц и определять классы отделенного кода этих страниц как производные от данного класса. Примечание В браузерах Mozilla модальные всплывающие окна создаются путем добав-ления атрибута Modal=yes в строку параметров окна. Без такой установки окно получится немодальным и его поведение будет таким же, как при установке dependent=true. Атрибут dependent делает новое окно дочерним по отношению к исходному. Сводим все вместе Связать с клиентским обработчиком события код вывода всплывающего окна так же просто, как любой другой сценарий. Параметр functionName служит идентифи-катором сценария во внутренней хэш-таблице страницы и в то же время определяет имя клиентской функции, которая выводит всплывающее окно. Ниже приведен код, показывающий, как организовать вывод всплывающего окна по щелчку кнопки и вы-вести в этом окне заданную страницу: protected void Page_Load(object sender, EventArgs e) { string URL = "http://weblogs.asp.net/despos"; //Регистрация кода сценария Type t = this.GetType(); if (!Page.ClientScript.IsClientScriptBlockRegistered(t, "ShowPopup")) { //Конфигурирование кнопки PopupButton.Attributes["onclick"] = "ShowPopup()"; PopupButton.Disabled = false; //Составление сценария и его регистрация RegisterPopupWindow(t, "ShowPopup", URL, true); } else PopupButton.Disabled = true; }
Работа с кодом сценариев Глава 6 239 Итак, в обработчике события Page_Load кнопка связывается с функцией ShowPopup, написанной на JavaScript. Сценарий этой функции создается посредством вызова ме-тода RegisterPopupWindow. Когда пользователь щелкает кнопку, он перенаправляется во всплывающее окно, где отображается Web-страница, связанная с URL, который был задан при регистрации этого окна (рис. 6-2). Рис. 6-2. Демонстрационная страница и открываемое из нее всплывающее окно в Internet Explorer Технология Script Callbacks Все Web-разработчики приветствуют появление программных и программируемых средств, позволяющих избежать обновления страницы. Представьте себе такую, весьма типичную, ситуацию. Вы разместили на странице ASP.NET таблицу и панель для на-вигации по этой таблице. Когда пользователь щелкает одну из кнопок, чтобы увидеть следующую группу строк, выполняется возврат формы, на сервере производится опре-деленная работа, а затем страница выводится повторно, причем без единого изменения, за исключением того, что на ней отображаются следующие строки таблицы. Если страница большая и сложная, такое поведение сильно тормозит работу пользователя и вызывает у него раздражение. Почему же мы допускаем, чтобы 50 Кбайт разметки и данные состояния представления загружались при каждом действии пользователя (не говоря уже о том, что часть этой информации еще и выгружается каждый раз на сервер)? Протокол HTTP и все основанные на нем Web-технологии разрабатывались для выполнения запросов от маленьких и легковесных клиентов, без сохранения состоя-ния, и их авторы никогда не уделяли достаточного внимания данной проблеме. Необ-ходимость в обновлении данных без обновления всей страницы возникла уже после 
240 Часть II Специализированные средства ASP.NET того, как концепция Web была реализована, а сама сеть стала достаточно мощной и масштабной, чтобы на ней можно было основывать более сложные приложения. Но теперь, когда эта необходимость стала такой настоятельной, мы хотим ее реа-лизовать. А для этого нам нужно, чтобы браузер невидимо для пользователя подклю-чился к серверу по заданному URL и передал серверной части приложения опреде-ленные данные, а также чтобы после выполнения на сервере соответствующей работы браузеру были возвращены новые данные для обновления страницы, осуществляемого с использованием Dynamic HTML. Согласитесь, что все это вполне осуществимо, и не такие уж наши требования большие. Прежде всего, чтобы им удовлетворять, браузер должен иметь внутренний компонент, реализующий такое его поведение. Далее, должна быть принята некая стандартная программная модель, согласно которой на сервере существовали бы ресурсы, способные принять и интерпретировать данные клиента и отправить ему необходимые ответные данные. Наконец, следует решить вопрос о том, как браузер будет обновлять клиентскую страницу. Для этой цели может использоваться функция на языке JavaScript, а браузер должен предоставлять объектную модель, используя которую сценарий сможет динамически модифицировать структуру и контент отоб-ражаемой страницы. Ну а теперь посмотрим, что нам предлагает ASP.NET. Базовый API ASP.NET Современные браузеры работают таким образом, что для вызова сервера, не сопро-вождающегося обновлением всей страницы, нужно встраивать в страницу специализи-рованный компонент, способный осуществлять параллельные (то есть производимые во время просмотра страницы пользователем) вызовы серверных ресурсов. Этим компонентом-посредником может быть элемент ActiveX, Java-апплет или же объект, определенный в объектной модели браузера. Данный компонент будет получать вызовы от клиентского сценария и устанав-ливать фоновое подключение к определенному серверному ресурсу - скорее всего, странице или обработчику ASP.NET. Этот ресурс получит некие входные данные и вернет выходные. Выходные данные будут обработаны клиентом и использованы для обновления страницы посредством объектной модели Dynamic HTML. Когда компо-нент-посредник создан, реализация данной схемы не требует особых усилий и ее без труда можно выполнить в ASP.NET 1.x и даже в классической ASP. С выходом ASP.NET 2.0 сама по себе проблема не исчезла, но появился систем-ный код, абстрагирующий детали параллельного вызова и обмена данными. Теперь в вашем распоряжении есть готовый механизм, называемый обратным вызовом сцена-рия (script callback) и существенно упрощающий решение задачи. Данный механизм скрывает детали реализации параллельного вызова и избавляет вас от необходимости учитывать в своем коде множество нюансов, связанных с работой каждого конкрет-ного браузера. Объект XmlHttpRequest Когда в 1999 году был выпущен Internet Explorer 5.0, разработчики клиентских сце-нариев получили в свое распоряжение простой, но эффективный объект, осуществля-ющий отправку строк в формате XML по протоколу HTTP - этот объект называется XmlHttpRequest. Он представляет собой не что иное, как объектную модель, построен-ную поверх протокола HTTP. Роль XML в этой модели весьма условна: объект позво-ляет отправлять данные в формате XML посредством HTTP, но только в том случае, если эти данные будут передаваться как обычный HTTP-контент.
Работа с кодом сценариев Глава 6 241 В Internet Explorer объект XmlHttpRequest реализован как COM-объект и имеет идентификатор (progID) Microsoft.XmlHttp. Данный компонент послужит основой для организации необходимых нам параллельных вызовов. Ниже приведен код на языке JavaScript, подключающийся к серверу по заданному URL и возвращающий ответ: function DoPost(url) { var http = new ActiveXObject("Microsoft.XmlHttp"); http.open("POST", url, false); http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); http.send(null); return http.responseText; } Метод open принимает три аргумента: глагол HTTP (например, GET или POST), целевой URL и флаг, указывающий, должен ли вызов обрабатываться асинхронно (значение false соответствует его синхронной обработке). Данный метод подготав-ливает все необходимое для вызова, но сам вызов выполняется позже посредством метода send. Тем временем вы формируете заголовки запроса. Аргументом метода send является тело запроса. При вызове данного метода формируется и отправляется серверу необходимый пакет. Web-сервер получает запрос и обрабатывает его. Ответ возвращается объекту XmlHttpRequest, который предоставляет его вызывающему коду в нескольких разных форматах, в том числе в виде обычного текста или объекта XML DOM. Свойство responseText возвращает ответ в виде текста, а свойство responseXml пытается, если это возможно, преобразовать его в объект XML DOM. В последнем случае используются COM-интерфейсы из библиотеки MSXML. О платформе .NET объект XmlHttpRequest ничего не знает. В ASP.NET 2.0 обратный вызов сценариев реализован на основе объекта XmlHttpRequest, но слой абстрагирования полностью скрывает от вас этот объект. Примечание Объект XmlHttpRequest является жертвой популярности, которую приобрели в последние годы технологии XML и COM, появившиеся еще до выхода .NET Framework. Прогнозировалось повсеместное распространение XML, и поддержка этого формата рас-сматривалась как достоинство любой технологии. Созданный в то время, когда COM считалась единственной достойной технологией реализации компонентов, XmlHttpRequest был написан как объект COM многократного использования, что теперь стало его главным ограничением. Ниже я еще вернусь к этому вопросу. Детали реализации Реализуя для своей страницы обратный вызов сценария, вы связываете с ней файл сценария на языке JavaScript. Данный файл включается в состав ресурсов сборки system.web; его URL указывает на ресурс WebResource.axd - сообщаю об этом на тот случай, если вы захотите заглянуть в его исходный код, который можно найти во временной папке Internet Explorer. В файле сценария определена функция WebForm_DoCallback, отвечающая за под-готовку и выдачу параллельного вызова. У нее несколько параметров, в том числе функция JavaScript, которая отвечает за обновление страницы, и входные данные для серверного кода. URL не передается ей в качестве аргумента, но вместо этого определяется в сценарии как значение глобальной переменной. Когда речь заходит об обратном вызове сценария страницы ASP.NET, этим URL всегда является адрес текущей страницы.
242 Часть II Специализированные средства ASP.NET Внутри функции WebForm_DoCallback создается новый экземпляр объекта XmlHttpRequest, отправляется запрос, ответ обрабатывается и передается JavaScript-функции обратного вызова, обновляющей страницу в браузере. Обратный вызов сценария можно считать особым видом возврата формы, ведь запрос направляется той же странице и проходит через тот же цикл событий. Допол-нительная информация, содержащаяся в запросе, служит для метода ProcessRequest класса Page признаком обратного вызова, и тот ведет себя соответственно. В частности, в запрос добавляется пара скрытых полей: CALLBACKPARAM и CALLBACKID. Первое содержит входные данные для метода страницы, предназначенного для обработки запроса, а второе - идентификатор страницы (или серверного элемента управления), которая будет обрабатывать запрос. Когда эти поля присутствуют в запросе, свойство IsCallback класса Page возвращает true. Примечание При выполнении обратного вызова сценария серверная страница (или элемент управления) получает исходное состояние представления и исходные значения полей ввода. Строка данных метода POST создается при загрузке страницы и в ней не отражаются изменения, которые пользователь внес после этого момента и до нача-ла параллельного вызова. Для того чтобы сервер получил текущие данные, их нужно передавать в виде явно заданного аргумента. Точно так же состояние представления не обновляется при получении ответа от сервера. Одним словом, параллельный вызов осуществляется как обычный возврат формы, но проходит неполный цикл обработки. Поддержка разных браузеров Появление в Internet Explorer объекта XmlHttpRequest вдохновило команду Mozilla на создание эквивалентного объекта, интегрированного в DOM этого браузера. Слой абстрагирования обратного вызова сценариев, то есть функция WebForm_DoCallback, определяет тип браузера, от которого поступил запрос, и действует соответствующим образом. Приведем фрагмент кода связанного файла сценария: __nonMSDOMBrowser = (window.navigator.appName.indexOf('explorer') == -1); function WebForm_DoCallback(eventTarget, eventArgument, eventCallback, context, errorCallback) { if (__nonMSDOMBrowser) { var xmlRequest = new XMLHttpRequest(); } else { var xmlRequest = new ActiveXObject("Microsoft.XmlHttp"); } } Таким образом, код поддержки обратного вызова сценария из ASP.NET работает и с Internet Explorer, и с браузерами на базе Mozilla, такими как Firefox, Netscape 6.x и Safari 1.2, и даже с последними версиями Opera. А вместе эти браузеры составля-ют 95 % соответствующего сегмента рынка. Так почему бы не пользоваться данной технологией? Внимание! Как уже упоминалось, в Internet Explorer объект XmlHttpRequest реализован в виде COM-компонента. Чтобы в приложении можно было задействовать технологию обратного вызова сценариев, пользователь должен понизить уровень безопасности, раз-решив применять компоненты ActiveX. В остальных браузерах это не требуется.
Работа с кодом сценариев Глава 6 243 Выполнение параллельного вызова По сути своей параллельный вызов мало чем отличается от программного возврата формы, выполняемого кодом JavaScript. Серверу направляется запрос с тем же URL, что и при запросе исходной страницы. Обратные вызовы ASP.NET базируются на двух разных и не взаимодействующих блоках кода - один на клиенте, инициирующем и контролирующем операцию, а другой - на сервере, обрабатывающем запрос и гене-рирующем возвращаемые значения. Механизм обратного вызова позволяет создать у пользователя иллюзию, что все происходит на клиентской стороне, как в классическом настольном приложении. Функция обратного вызова получает значение, являющееся результатом работы сер-вера, и может динамически обновить страницу, если только браузер поддерживает динамический HTML. Давайте подробнее изучим код, выполняющийся на стороне клиента. Примечание В мире Microsoft первой реализацией обратного вызова сценария была технология Remote Scripting, появившаяся еще в конце 90-х годов. В ней для установки фонового соединения с сервером использовался Java-апплет, а для обслуживания запро-са - страница классической ASP. Эта страница должна была предоставлять для взаимо-действия с клиентом особую объектную модель - нечто вроде стандартного открытого интерфейса. Клиентский код вызывал такой объект по известному имени. Входные пара-метры и возвращаемые значения сериализовались в строки. Технология Remote Scripting основывалась на синхронных и асинхронных удаленных вызовах процедур и работала с Netscape 4.x и Internet Explorer 4, а также более поздними версиями этих браузеров, но только на платформе Windows. За дополнительной информацией по данному вопросу вы можете обратиться по адресу http://msdn.microsoft.com/library/en-us/rmscpt/Html/rmscpt.asp. Клиентский код Параллельный вызов ASP.NET начинается с выполнения системной функции JavaScript. Эта функция связана с обработчиком события уровня страницы, такого как щелчок кнопки или выбор элемента в раскрывающемся списке. Для примера рассмотрим страницу с кнопкой More Info, посредством которой извлекается информация о выбранном сотруднике. Эта кнопка не должна иметь тип submit, иначе, когда пользователь ее щелкнет, будет выполнен обычный возврат формы с полным обновлением страницы, чего мы как раз и пытаемся избежать. Пусть наша разметка будет такой: <asp:dropdownlist id="cboEmployees" runat="server" DataTextField="lastname" DataValueField="employeeid" /> <input type="button" runat="server" id="buttonTrigger" value="More Info"> Класс отделенного кода этой страницы заполняет раскрывающийся список ре-зультатами выполнения запроса. Пользователь выбирает элемент из списка, а потом щелкает кнопку для получения дополнительных сведений. При обработке страницы на сервере в ее состав динамически включается обработчик события onclick. Делается это в обработчике события Page_Load: private IEnumerable GetListOfNames() { //Извлечение записей для заполнения раскрывающегося списка }protected void Page_Load(object sender, EventArgs e)
244 Часть II Специализированные средства ASP.NET { if (!IsPostBack) { //Заполнение раскрывающегося списка cboEmployees.DataSource = GetListOfNames(); cboEmployees.DataBind(); //Подготовка функции JavaScript для вызова string rpc = ClientScript.GetCallbackEventReference( this, "document.forms[0].elements['cboEmployees'].value", "UpdateEmployeeViewHandler", "null", "null", false); //Привязка ее к кнопке string js = String.Format("javascript:{0}", rpc); buttonTrigger.Attributes["onclick"] = js; } } Метод GetCallbackEventReference возвращает вызов JavaScript, который будет связан с атрибутом onclick клиентской кнопки. Когда страница выводится на экран, кнопку описывает такой сценарий: <input name="buttonTrigger" type="button" id="buttonTrigger" value="More Info" onclick="javascript:WebForm_DoCallback('__Page', document.forms[0].elements['cboEmployees'].value, UpdateEmployeeViewHandler, null, null, false)" /> Где же определена функция WebForm_DoCallback? Она хранится среди ресурсов сборки system.web и связывается со страницей посредством динамически генерируе-мого оператора включения сценария, а точнее, оператора его загрузки из хранилища ресурсов: <script src="/ProAspNetAdv/WebResource.axd?d=...&t=..." type="text/javascript"></script> В той странице, которая отправляется пользователю, приведенный сценарий раз-мещается сразу за тэгом <form>. Изменения клиентской страницы этим не исчер-пываются - регистрируется также стартовый сценарий, инициализирующий среду обратного вызова. Приведенный ниже сценарий будет следовать за тэгом </form>: <script type="text/javascript"> var pageUrl = '/ProAspNetAdv/Samples/Ch06/Callback/ShowInfo.aspx'; WebForm_InitCallback(); </script> Глобальной переменной pageUrl присваивается URL текущей страницы. Также бу-дучи определенной в связанном сценарии, функция WebForm_InitCallback запоминает текущее содержимое всех полей ввода (в том числе состояние представления), чтобы эти данные можно было отправлять с каждым обратным вызовом, инициированным страницей.
Работа с кодом сценариев Глава 6 245 Код, инициирующий обратный вызов Сценарий, загружаемый из ресурса ASP.NET, и функции, вызываемые из кода JavaScript страницы, считаются закрытыми деталями реализации и в будущих версиях могут быть изменены. Вам как разработчику нужно сконцентрироваться на програм-мном интерфейсе метода GetCallbackEventReference объекта ClientScript. Аргументы, передаваемые этому методу, определяют, как будет запускаться и работать механизм обратного вызова. public string GetCallbackEventReference( Control target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) Роль каждого из этих аргументов указана в табл. 6-4. Метод имеет несколько перегруженных версий, в которых отдельным аргументам присвоены значения по умолчанию. В одной из этих версий аргумент target имеет строковый тип и содержит уникальный идентификатор целевого элемента управления вызова. Если целевой является страница, можно использовать предопределенный идентификатор __Page. Табл. 6-4. Параметры метода GetCallbackEventReference Параметр Описание target Указывает серверный объект, который будет обрабатывать вызов. Этим объектом может быть страница или любой из ее элементов управления - главное, чтобы в нем был реализован интерфейс ICallbackEvent Handler. Если целевой объект не реализует данный интерфейс, выбрасывается исключение argument Задает входные параметры метода, который нужно вызвать на сервере. Если передано несколько значений, разработчик должен упаковать их в одну строку. Содержимое данного параметра передается серверному методу в том виде, в каком оно получено от клиента clientCallback Задает имя клиентской функции JavaScript, которая получит возвраща-емое значение вызова сервера. Что бы не вернул серверный метод, пусть даже строку, это значение будет передано данной функции JavaScript без изменений. Если функция не определена или недоступна на клиентской странице, происходит ошибка сценария. Обычно данная функция использует полученные данные для динамического обновления страницы context Клиентский сценарий, который выполняется непосредственно перед инициированием обратного вызова. Результат выполнения этого сценария передается клиентскому обработчику события clientErrorCallback Имя клиентской функции JavaScript, получающей результат в том случае, если в серверном методе происходит ошибка. Тогда функция, заданная в аргументе clientCallback, не вызывается useAsync Если данный аргумент равен true, вызов сервера выполняется асинхрон-но, в противном случае - синхронно; по умолчанию он равен false Вернемся к коду, который мы коротко рассмотрели раньше: //Вызывается в обработчике события Page_Load string rpc = ClientScript.GetCallbackEventReference( this, "document.forms[0].elements['cboEmployees'].value",
246 Часть II Специализированные средства ASP.NET "UpdateEmployeeViewHandler", "null", "null", false); Целевым объектом данного вызова является страница, поэтому в классе отделен-ного кода страницы должен быть реализован интерфейс ICallbackEventHandler. Если это не так, метод GetCallbackEventReference выбрасывает исключение. Данный метод проверяет, реализует ли аргумент target (которому в приведенном выше примере присвоено значение this) необходимый интерфейс. Если в аргументе target задан идентификатор, метод вначале находит соответствующий элемент управления, а затем проверяет наличие интерфейса. Аргумент, передаваемый серверному методу, является результатом вычисления заданного выражения JavaScript: document.forms[0].elements['cboEmployees'].value Заметьте, что это единственный надежный способ передачи серверу актуальных значений. Как уже было сказано, свойства серверных элементов управления содер-жат исходные значения, те, которыми они инициируются при создании страницы. А когда выполняется возврат формы (напомню, что обратный вызов сценария - это самый обыкновенный возврат формы с укороченным жизненным циклом), состоя-ние элементов управления обычно возвращается к исходному, а затем обновляется полученными от страницы значениями. В случае обратного вызова сценария ни со-стояние представления, ни значения полей ввода, полученные сервером, не отражают состояние формы на момент обратного вызова. Поэтому, обратившись к свойствам, скажем, раскрывающегося списка, вы увидите исходное состояние данного элемента управления таким, каким оно было на момент создания страницы, а не его текущее состояние с внесенными пользователем изменениями. Примечание Получив обратный вызов, исполняющая среда ASP.NET восстанавливает страницу к тому состоянию, в котором она находилась в момент последнего возврата формы. Почему так? Почему не используется текущее состояние страницы на клиентском компьютере? Дело в том, что состояние на момент последнего возврата формы - это последнее известное согласованное состояние страницы. Реальное состояние формы в момент обратного вызова может быть несогласованным, поскольку в некоторых полях могут содержаться недопустимые данные. Кроме того, если бы серверу отправлялась последняя версия формы, он бы генерировал событие изменения при каждом обратном вызове. А такое поведение может иметь нежелательные побочные эффекты. Например, что если один из элементов управления страницы использует скрытое поле для отслежи-вания собственного клиентского состояния? (Так поступает элемент управления TreeView, и точно так же могут действовать другие сложные элементы управления.) Это состояние будет отправляться на сервер и при каждом обратном вызове будет генерироваться событие изменения, что приведет к ненужным издержкам из-за выполнения операций, связанных с указанным событием (скажем, обновлением базы данных), а также из-за воспроизведения всех изменений, внесенных со времени последнего обратного вызова. Вывод таков: текущие данные, а не просто данные состояния, можно передавать серверу только в виде параметров вашей конкретной функции обратного вызова. Когда вы будете писать код JavaScript для извлечения и отправки серверу данных формы, убедитесь, что большинство браузеров понимает используемый вами синтак-сис. Например, для доступа к текущему выделенному элементу раскрывающегося списка могут использоваться такие выражения: document.forms[0].elements["yourDropDown"].value document.all["yourDropDown"].value
Работа с кодом сценариев Глава 6 247 Оба выражения сработают в Internet Explorer, но только первое будет понято также и браузерами Mozilla. Кроме того, первое из выражений соответствует стандарту DOM, тогда как второе имеет синтаксис, специфический для Internet Explorer. Серверный код Вы уже знаете, что целевой объект операции обратного вызова - будь то страница или ее элемент управления - должен реализовывать интерфейс ICallbackEventHandler. Этот интерфейс состоит из двух методов: RaiseCallbackEvent и GetCallbackResult. Пер-вый из них должен содержать код, который вы хотите выполнить на сервере в ответ на обратный вызов. Полученный результат должен быть перехвачен во внутреннем методе, возвращаемом вторым методом - GetCallbackResult. public partial class ShowInfo : Page, ICallbackEventHandler { private string _results; void ICallbackEventHandler.RaiseCallbackEvent(string eventArgument) { //Получаем дополнительную информацию об указанном сотруднике int empID = -1; bool success = Int32.TryParse(eventArgument, out empID); EmployeeInfo emp = GetEmployeeDetails(empID); //Подготавливаем ответ для клиента: строку, разделенную запятыми. //Формат этой строки вы определяете сами, главное, чтобы он был //известен клиентской функции обратного вызова, написанной на JavaScript string[] buf = new string[6]; buf[0] = emp.ID.ToString(); buf[1] = emp.FirstName; buf[2] = emp.LastName; buf[3] = emp.Title; buf[4] = emp.Country; buf[5] = emp.Notes; _results = String.Join(",", buf); } string ICallbackEventHandler.GetCallbackResult() { return _results; } } Когда целевым объектом вызова является страница, вы можете реализовать ин-терфейс ICallbackEventHandler в классе отделенного кода, а если файл отделенного кода отсутствует, воспользоваться директивой @Implements и поместить код прямо в файл страницы. Когда же целевым объектом является элемент управления, вы просто добавляете интерфейс в список базовых классов. Входным значением метода RaiseCallbackEvent является значение параметра argument, описанного в табл. 6-4. Вывод метода GetCallbackResult - это строка, которая будет передана JavaScript-функции clientCallback для завершения операции и отоб-ражения ее результатов на странице. Как уже было сказано, содержимое и формат строк, получаемых методом RaiseCal lbackEvent и возвращаемых методом GetCallbackResult, всецело определяются вами. Это может быть и текстовая строка, и строка-массив с заданным символом-разделителем, 
248 Часть II Специализированные средства ASP.NET и даже сериализованный объект. Правда, что касается последнего, то им может быть только объект JavaScript, поскольку последним звеном цепи, где происходит интер-претация полученных данных, является функция JavaScript. Примечание Поддерживаемые форматы возвращаемого значения - это одна из харак-теристик, определяющих преимущество одной технологии обратного вызова перед другой. Например, существует библиотека Ajax.NET, которая позволяет использовать в качестве возвращаемых значений объекты различных классов .NET и берет на себя заботу об их сериализации в объекты JavaScript. Atlas - технологический прообраз будущих платформ ASP.NET, также делает нечто подобное. Ниже об обеих технологиях будет рассказано подробнее. Демонстрационный код получает идентификатор сотрудника и, используя внут-ренний метод, запрашивает дополнительную информацию. Все данные упаковываются в объект EmployeeInfo. Если вы пользуетесь API обратного вызова сценария, то не можете вернуть этот объект как есть - его придется преобразовать в строку, формат которой определяете вы сами. В нашем примере я выбрал разделенную запятыми строку, содержащую расположенные в определенном порядке значения полей: иден-тификатор, имя, фамилия и т. д. Примечание Интерфейс ICallbackEventHandler может быть реализован и специализиро-ванным элементом управления. В таком случае элемент управления вставляет в страницу клиентский сценарий и обрабатывает запрос клиента. Обновление страницы Клиентский код обратного вызова, написанный на Jet, может быть связан со стра-ницей или включен прямо в нее. Данная функция должна знать формат результата, возвращаемого сервером. Платформы Ajax.NET и Atlas выполняют всю работу по включению в страницу вспомогательных сценариев, необходимых для того, чтобы разработчик, применяющий технологию обратного вызова, мог на стороне клиента работать с объектами, которые имеют интерфейс, по возможности приближенный к интерфейсу серверных объектов. Если же вы предпочитаете пользоваться исходным API Script Callbacks, вам придется самостоятельно выполнять десериализацию по-лученной строки, преобразуя ее в нечто пригодное к употреблению. <script language="javascript"> function UpdateEmployeeViewHandler(response, context) { //Десериализуем ответ, превращая его в массив строк var o = response.split(','); //Получаем ссылки на элементы, подлежащие обновлению var e_ID = document.getElementById("e_ID"); var e_FName = document.getElementById("e_FName"); var e_LName = document.getElementById("e_LName"); var e_Title = document.getElementById("e_Title"); var e_Country = document.getElementById("e_Country"); var e_Notes = document.getElementById("e_Notes"); //Обновляем элементы страницы данными, полученными от сервера e_ID.innerHTML = o[0]; e_FName.innerHTML = o[1]; e_LName.innerHTML = o[2]; e_Title.innerHTML = o[3]; e_Country.innerHTML = o[4];
Работа с кодом сценариев Глава 6 249 e_Notes.innerHTML = o[5]; } </script> На рис. 6-3 показано, как страница из нашего примера выглядит в браузерах Internet Explorer 6.0 и Firefox. Рис. 6-3. Демонстрационная страница, выполняющая обратный вызов сценария, в Internet Explorer и Firefox Значение DOM Реализация обратного вызова сценария в ASP.NET избавляет вас от необходимости разбираться в деталях программирования, связанных с конкретными браузерами. Код, импортируемый из стандартных сборок ASP.NET, гарантированно работает со всеми браузерами, совместимыми с Internet Explorer и Mozilla. К сожалению, это только полдела. Платформа ASP.NET гарантирует, что любой совместимый браузер произведет параллельный вызов и вернет сгенерированный сервером ответ локальной функции JavaScript. Но то, что будет происходить дальше, нравится вам это или нет, зависит только от вас и клиентского браузера. Если клиентский браузер не поддерживает динамическое обновление страницы, вы мало что тут можете сделать - разве что воспользоваться фреймами, всплываю-щими окнами или выполнить целую серию вызовов document.write. К счастью, сегодня большинство браузеров, способных выполнить обратный вызов сценария, реализуют также и модель DOM, поддерживающую динамическое обновление. При написании функции обратного вызова на JavaScript важно придерживаться стандартной объектной модели и правильно ею пользоваться. Если код обновления содержит элементы, специфические для Internet Explorer, он не будет работать в Firefox или Netscape Navigator. Приведу пример типичной ошибки. Предположим, что в составе страницы имеется тэг <span> с именем e_ID. Следующий код будет работать в Internet Explorer, но не будет работать в Firefox и Netscape Navigator: var userID = ...; e_ID.innerHTML = userID; В DOM браузеров Mozilla нет элемента e_ID, хотя инспектор DOM показывает элемент с таким именем. Дело в том, что разработчики Internet Explorer не придержи-ваются стандартов. Данный браузер автоматически определяет для каждого элемента 
250 Часть II Специализированные средства ASP.NET страницы одноименное свойство. Такое его поведение не является общепринятым и стандартным, и не стоит рассчитывать, что другие браузеры тоже будут так работать. Более правильно будет использовать метод document.getElementById, определяемый стандартом W3C: var userID = ...; var e_ID = document.getElementById("e_ID"); e_ID.innerHTML = userID;W3C Если вы хотите получить надежный и универсальный сценарий, пишите его в строгом соответствии со стандартами W3C DOM. (Я, конечно, понимаю, что если вы привыкли работать с Internet Explorer, это может поначалу вызывать некоторые затруднения, но дело того стоит.) Примечание Ни API ASP.NET Script Callbacks, ни Ajax.NET не предоставляют более абстрактной объектной модели, которая скрывала бы различия между объектными мо-делями документа, реализованными в разных браузерах. А все потому, что существует утвержденный стандарт, которого и нужно придерживаться и который избавляет вас от необходимости беспокоиться об этих различиях. Для Atlas, однако, Microsoft, похоже, вы-брала многообещающее и амбициозное решение - создать объектную модель элементов управления, используемую и на клиенте, и на сервере, и открывающую возможность про-граммной установки свойств с обеих сторон. Браузерный адаптер элементов управления возьмет на себя заботу о рендеринге запрошенного обновления в понятный браузеру код сценария. Однако пока это всего лишь отсвет блистательного будущего ASP.NET. Пример с главным и подчиненным списками Параллельные вызовы сервера широко используются некоторыми новыми элементами управления ASP.NET, такими как TreeView и GridView. В частности, TreeView применяет их для извлечения содержимого узлов разворачиваемой ветви дерева. Что касается GridView, то он с помощью таких вызовов выводит частями свои данные и меняет порядок их сортировки. Технология обратного вызова сценария имеет множество применений и наиболее часто используется для создания страниц, содержащих иерархические данные. Да-вайте рассмотрим один из таких случаев. Представьте себе страницу с двумя списка-ми - родительским и дочерним. Когда пользователь выбирает элемент родительского списка, дочерний обновляется для отображения соответствующих данных. Пусть ро-дительский список содержит, к примеру, имена сотрудников, а дочерний заполняется перечнями принятых ими заказов. Вот код такой страницы: <asp:SqlDataSource runat="server" ID="EmpSource" ConnectionString="<%$ ConnectionStrings:LocalNWind %>" SelectCommand="SELECT employeeid, lastname FROM employees" /> <asp:DropDownList ID="listEmployees" runat="server" DataSourceID="EmpSource" DataTextField="lastname" DataValueField="employeeid" onchange="ShowOrders(this.options[this.selectedIndex].value);" /> <asp:DropDownList runat="server" ID="listOrders" style="visibility:hidden" /> Элемент управления SqlDataSource заполняет раскрывающийся список listEmployees фамилиями сотрудников, взятыми из базы данных Northwind. Атрибут onchange данного списка служит для перехвата события, состоящего в выборе пользователем элемента списка. Мы связали этот атрибут с функцией JavaScript ShowOrders, внутри которой инициируется параллельный вызов. Код функции ShowOrders генерируется в обработчике события Page_Load:
Работа с кодом сценариев Глава 6 251 void Page_Load(object source, EventArgs e) { string rpc = ClientScript.GetCallbackEventReference(this, "arg", "UpdateOrders", "null", "ShowError", false); string func = "function ShowOrders(arg) { " + rpc + "; }"; ClientScript.RegisterClientScriptBlock(this.GetType(), "ShowOrders", func, true); } Функция Page_Load включает в состав страницы следующий сценарий: <script type="text/javascript"> function ShowOrders(arg) { WebForm_DoCallback('__Page', arg, UpdateOrders, null, ShowError, false); } </script> Заметьте, что методу GetCallbackEventReference выражение, которое должно ис-пользоваться в качестве параметра серверного метода, в явном виде не передается, вместо этого указывается имя формального параметра arg, значение которого опре-делено в исходном файле .aspx: this.options[this.selectedIndex].value Параметр arg, содержащий это выражение, служит для передачи значения, выбран-ного в раскрывающемся списке. Синтаксис здесь тот же, который мы использовали в предыдущем примере в аналогичной ситуации - для извлечения текущего значения, выбранного в раскрывающемся списке. На сервере метод обработки параллельного вызова получает идентификатор сотруд-ника и выполняет запрос на выборку всех связанных с ним заказов. Идентификаторы этих заказов упаковываются в разделенную запятыми строку и возвращаются клиенту. Затем указанная строка передается функции JavaScript с именем UpdateOrders: function UpdateOrders(result) { if (!result) return; var childDropDown = document.forms[0].elements['listOrders']; if (!childDropDown) return; childDropDown.length = 0; var listOrders = document.getElementById("listOrders"); var rows = result.split('|'); for (var i = 0; i < rows.length; ++i) { var option = document.createElement("OPTION"); option.value = rows[i]; option.innerHTML = rows[i]; listOrders.appendChild(option); } listOrders.style.visibility = "visible"; } Дочерний раскрывающийся список очищается и динамически заполняется полу-ченными идентификаторами заказов. По умолчанию этот список невидим, но после заполнения флаг его видимости устанавливается. Обратите внимание на то, что вместо стиля display применяется стиль visibility, благодаря чему элементы сохраняют свое местоположение на странице. (Когда используется стиль display, элемент не включа-ется в DOM страницы.) На рис. 6-4 наша страница показана в действии.
252 Часть II Специализированные средства ASP.NET Рис. 6-4. Демонстрационная страница с главным и подчиненным списками, выполняющая обратный вызов сценария, в Internet Explorer 6.0 и Netscape 7.2 Стоит ли применять технологии параллельных вызовов Технологии параллельных вызовов порождены насущной потребностью, и сегодня они предлагаются большинством браузеров. ASP.NET Script Callback - лишь один из данной технологии API, который можно использовать для реализации таких вызовов. Существуют и более сложные библиотеки, к числу которых относятся проект с открытым исходным кодом Ajax.NET (о нем рассказывается в следую-щем разделе) и система Atlas, созданная той же командой, которая разрабатывала ASP.NET, и демонстрирующая будущие ее возможности. В целом технологии параллельных вызовов призваны избавить приложения от необходимости полного обновления страницы при каждом изменении выводи-мых на ней данных. Их преимущества очевидны: страница выполняется быстрее и создает у пользователя впечатление непрерывности, как будто вся текущая работа производится локально. Однако с архитектурной точки зрения не все так замечательно, поскольку эти технологии нарушают принцип разделения слоев представления и бизнес-логики. Когда данные загружаются на клиентский ком-пьютер, код JavaScript должен как-то их обрабатывать и, что более важно, знать об их назначении. В зависимости от того, какой именно клиентский код вы пи-шете и какие используете сервисы среды выполнения, нарушение границ слоев приложения может представлять, а может и не представлять проблемы. В любом случае этому аспекту нужно уделить внимание. Библиотека Ajax.NET Интерфейс прикладного программирования Script Callback, предлагаемый ASP.NET, представляет сложный путь выполнения типичной задачи - отправки запросов сер-веру и получения ответов, не покидая текущей страницы. Такие параллельные вы-зовы невозможно реализовать без поддержки со стороны браузера - ведь нужен некий компонент-посредник, который будет отправлять запросы и получать ответы, передавая их клиентской функции обратного вызова. В Internet Explorer этой цели служит COM-объект XmlHttpRequest; в браузерах на базе Mozilla и в Opera имеется DOM-объект с таким же именем. Наличие доступа к подобному объекту - первое условие реализации параллельных обратных вызовов.
Работа с кодом сценариев Глава 6 253 Далее все зависит от API, предоставляемого исполняемой средой. В ASP.NET используется низкоуровневый API Script Callback, незначительно абстрагирующий детали реализации, за исключением, быть может, метода, автоматически генерирую-щего сценарий, который инициирует обратный вызов. Существуют и другие библиотеки ASP.NET, реализующие параллельные вызовы. От API Script Callback их отличает прежде всего уровень абстрагирования базовых операций. Примером может служить библиотека Ajax.NET. Использование библиотеки Название Ajax является сокращением от Asynchronous JavaScript And XML (асинх-ронный JavaScript и XML). Оно обозначает не новую особенную технологию, а скорее комплекс существующих технологий (таких как JavaScript, DOM браузера, CSS и XmlHttpRequest), объединенных для создания более интерактивных Web-приложе-ний. Используя продукты Ajax-типа, вы создаете страницы, данные которых могут обновляться независимо, без полного обновления самой страницы. Вместо возврата формы такие приложения просто направляют серверу еще один запрос на получение данных. В настоящее время описанный подход применяется в нескольких приложениях Google, в частности Google Maps, Google Suggest и Gmail, внесших большой вклад в распространение соответствующей модели программирования. Существует несколько бесплатных и коммерческих библиотек, реализующих подход Ajax, создатели которых пытались упростить разработку Web-приложений и обеспечить максимально тесную интеграцию клиентского и серверного окружений. Библиотека Ajax.NET, версии ко-торой имеются и для ASP.NET 1.x, и для ASP.NET 2.0, является проектом с открытым исходным кодом. Примечание Для загрузки библиотеки Ajax.NET, а также с целью получить дополнитель-ную информацию о ее применении вы можете обратиться по адресу http://ajax.schwarzinteractive.de/csharpsample/default.aspx. Довольно полный обзор стиля программирования Ajax вы найдете по адресу http://en.wikipedia.org/wiki/ajax. Необходимые настройки Для применения библиотеки Ajax.NET вам потребуется сборка ajax.dll, которая долж-на находиться либо в GAC, либо в папке Bin приложения. Кроме того, необходимо добавить в файл web.config запись для обработчика HTTP: <httpHandlers> <add verb="POST,GET" path="ajax/*.ashx" type="Ajax.PageHandlerFactory, Ajax" /> </httpHandlers> Наличие этой записи гарантирует, что все запросы с указанием URL, соответ-ствующего шаблону ajax/*.ashx, будут перенаправляться компоненту Ajax. Заметьте, что вам не нужно создавать для приложения подкаталог ajax. Как рассказывалось в главе 2, для перехвата запросов на получение ресурсов с заданным именем приме-няется пользовательский обработчик HTTP. При этом вовсе не обязательно, чтобы запрошенный файл в действительности существовал - все зависит от того, что будет делать данный обработчик. В нашем случае ни файлы, ни подкаталог не требуются. Задача обработчика Ajax, вызываемого при загрузке страницы, заключается в том, чтобы сгенерировать для нее необходимый сценарий. Вот и все, что нужно для подготовки плацдарма. Теперь посмотрим, как создать страницу, использующую библиотеку Ajax.NET.
254 Часть II Специализированные средства ASP.NET Создание демонстрационной страницы Страница, которую мы сейчас создаем, называется TestAjax.aspx. Она содержит встро-енную функцию JavaScript и несколько клиентских и серверных тэгов. В частности, в ее состав входит клиентская кнопка с надписью Find, связанная со встроенной в страницу функцией JavaScript GetCustomerDetail. Когда пользователь щелкает на этой кнопке, функция выполняется. <%@Page Language="C#" CodeFile="TestAjax.aspx.cs" Inherits="TestAjax" %> <script type="text/javascript"> function GetCustomerDetail() { var customerID = document.getElementById("customerID"); var response = TestAjax.GetCustomerByID(customerID.value); var oCustomer = response.value; if (oCustomer.Type == "UnknownCustomer") { alert("Customer not found"); } else { var fn = document.getElementById("firstName"); var ln = document.getElementById("lastName"); fn.innerHTML = oCustomer.FirstName; ln.innerHTML = oCustomer.LastName; } } </script> <html> <head runat="server"> <title>Testing Ajax</title> </head> <body> <form id="form1" runat="server"> <h2>Enter a Customer ID (1, 2, 3, ...)</h2> <asp:textbox id="customerID" runat="server" text="1" /> <input onclick="GetCustomerDetail()" type="button" value="Find"> <hr /> <asp:label id="firstName" runat="server" />&nbsp; <asp:label id="lastName" runat="server" /> <br /> </form> </body> </html> На рис. 6-5 данная страница показана в действии в еще одном браузере - Opera 8.5. Что же особенного в этой странице? Вроде бы, разметка как разметка. Но встро-енная функция JavaScript заслуживает некоторого внимания. Бросаются в глаза две детали: вызов очевидно отсутствующего объекта, и объект JavaScript, используемый для обработки возвращаемого значения этого вызова: var response = TestAjax.GetCustomerByID(customerID.value); var oCustomer = response.value; if (oCustomer.Type == "UnknownCustomer") { } else { }
Работа с кодом сценариев Глава 6 255 Рис. 6-5. Демонстрационная страница, использующая технологию Ajax, в браузере Opera 8.5 Где определен метод TestAjax.GetCustomerByID? И где определен прототип пере-менной oCustomer? В поиске ответа заглянем в файл кода страницы: using System; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using Ajax; using ProAspNet20; public partial class TestAjax : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { Utility.RegisterTypeForAjax(typeof(TestAjax)); Utility.RegisterTypeForAjax(typeof(ProAspNet20.Customer)); Utility.RegisterTypeForAjax(typeof(ProAspNet20.UnknownCustomer)); } [AjaxMethod()] public Customer GetCustomerByID(string customerID) { //Сюда поместите код для извлечения информации о клиенте из БД switch (customerID) { case "1": return new Customer("John", "Doe"); case "3": return new Customer("Jim", "Idontknowthisguy"); default: return new UnknownCustomer(); } } } Как видите, GetCustomerByID - метод серверного класса, помеченного атрибутом [AjaxMethod]. Дополнительно инфраструктура Ajax регистрирует в обработчике со-бытия Page_Load три типа: ProAspNet20.Customer, ProAspNet20.UnknownCustomer и Test-Ajax. Каково их назначение? Серверная страница осуществляет рендеринг результатов для клиента с помощью объекта JavaScript, имеющего то же имя, что и класс страницы, в нашем примере - TestAjax. Серверный метод, помеченный атрибутом [AjaxMethod], становится методом этого объекта JavaScript. Тело данного метода автоматически 
256 Часть II Специализированные средства ASP.NET генерируется инфраструктурой Ajax; его задача - инициировать параллельный вызов соответствующего серверного метода посредством XmlHttpRequest. Рассматриваемый серверный метод может вернуть любой объект, зарегистрирован-ный инфраструктурой Ajax, и вовсе не обязательно, чтобы это была строка, как в ASP. NET Script Callback. Любой объект, зарегистрированный Ajax, превращается в процессе рендеринга в объект JavaScript, связанный с клиентской страницей (рис. 6-6). Рис. 6-6. Демонстрационная страница, использующая технологию Ajax, в браузере Opera 8.5 Таким образом вы можете удаленно вызывать произвольное количество серверных методов и использовать собственные объекты как на стороне клиента, так и на стороне сервера. Детали реализации Когда страница, созданная с использованием технологии Ajax, выводится в браузере, она содержит следующие тэги <script>: <script type="text/javascript" src="/ProAspNetAdv/ajax/common.ashx" /> <script type="text/javascript" src="/ProAspNetAdv/ajax/TestAjax, [assembly].ashx" /> <script type="text/javascript" src="/ProAspNetAdv/ajax/ProAspNet20.Customer, [assembly].ashx" /> <script type="text/javascript" src="/ProAspNetAdv/ajax/ProAspNet20.UnknownCustomer, [assembly].ashx" /> Как уже упоминалось, ни один из ресурсов .ashx не указывает на реальный файл, который вам нужно было бы поместить на Web-сервер. Это просто символические конечные точки запросов, которые сообщают HTTP-обработчику Ajax о необходимости сгенерировать код сценария. Например, конечная точка common.ashx служит для вставки в страницу TestAjax.aspx такого кода: var TestAjax = { GetCustomerByID:function(customerID,callback,context) { return new ajax_request(this.url + '?_method=GetCustomerByID&_session=no', 'customerID=' + enc(customerID), callback, context);
Работа с кодом сценариев Глава 6 257 }, url:'/ProAspNetAdv/ajax/TestAjax,App_Web_3obyp7mk.ashx' } Объект JavaScript TestAjax имеет два члена: функцию GetCustomerByID и свой ство url. В общем случае объект может содержать столько функций, сколько методов, помеченных атрибутом [AjaxMethod], имеется у класса отделенного кода TestAjax. Внутренний метод ajax_request определен в том же сценарии и представляет базовый API для инициирования удаленного вызова. В определенном смысле ajax_request является аналогом WebForm_DoCallback. Примечание Специфический для страницы объект JavaScript очень напоминает прок-си-класс Web-сервиса. Подобно такому классу, данный объект представляет удаленный интерфейс на клиентском компьютере; для каждого метода этого интерфейса в составе объекта имеется предопределенный код его вызова. Если common.ashx служит для вставки в страницу базового API Ajax.NET, то другая конечная точка, .ashx, вставляет код, выполняющий рендеринг зарегистрированных типов .NET в объекты JavaScript. При сериализации класса .NET порождается объект JavaScript, имеющий такой же набор свойств и полей. Простые типы (например, строки, даты и числа) превращаются в собственные типы JavaScript. Каждому классу .NET можно поставить в соответствие специально разработанный конвертер, что и делает Ajax.NET для классов DataSet, DataTable, DataView, DataRow, Image, а также для коллекций. Вы можете создавать и регистрировать собственные пользователь-ские конвертеры. Конвертер Ajax представляет собой класс, реализующий интерфейс IAjax ObjectConverter. Сравнение технологий Ajax.NET и ASP.NET Script Callbacks Инструментальные средства Ajax.NET и ASP.NET Script Callbacks можно охаракте-ризовать как фукнционально эквивалентные, использующие одну и ту же базовую инфраструктуру - XmlHttpRequest. Тем не менее они предоставляют разные API и реализуют диаметрально противоположные взгляды на параллельные вызовы. Подробный анализ В табл. 6-5 перечислены этапы выполнения параллельного вызова, определяемые каждой из описываемых технологий. Табл. 6-5. Руководство по осуществлению параллельного вызова в Script Callbacks и Ajax.NET ASP.NET Script Callbacks Ajax.NET Связать с клиентским элементом код сценария, который будет инициировать удаленный вызов. Для этого необходимо вызвать GetCallbackEventReference, что обычно делается в обработчике события Page_Load класса отделенного кода Связать с клиентским элементом код сценария, ко-торый будет инициировать удаленный вызов. Этот код содержит вызов динамически создаваемого клиентского объекта, играющего роль прокси. Один и тот же код, связанный с клиентским элементом, действует и как инициатор параллельного вызова, и как функция обратного вызова Реализовать в классе отделенного кода интерфейс ICallbackEventHandler и на-писать серверный метод для его вызова. Этот метод получает и возвращает строку Зарегистрировать типы .NET, которые должны быть известны клиентскому коду. Как минимум, сюда от-носится тип класса отделенного кода. Соответству-ющие вызовы обычно выполняются в обработчике события Page_Load Написать клиентскую функцию обратно-го вызова, которая будет получать резуль-таты параллельного вызова в виде строки Снабдить методы страницы, которые должны быть доступны для вызова клиентом, атрибутом [AjaxMe thod] 
258 Часть II Специализированные средства ASP.NET Очевидно, что модель программирования Ajax.NET проще и интуитивно понят-нее. Есть у нее и несколько технических преимуществ. Во-первых, она не требует, чтобы вы концентрировали все вызываемые серверные операции в одном методе, а во-вторых, позволяет вернуть клиентскому коду практически любой сериализуемый объект .NET. Помимо упомянутых практических отличий технологии Script Callbacks и Ajax.NET имеют разную архитектуру. Многократные вызовы или тяжеловесность Возможность вызова любого серверного метода, определенного в классе страницы, делает библиотеку Ajax.NET более дружественной к пользователю. Вы можете напи-сать единственную функцию JavaScript, инициирующую вызов, получающую ответ и обновляющую страницу. При этом облегчается как написание сложных приложений, так и выполнение из одной страницы нескольких удаленных вызовов. Но помните, что каждый вызов Ajax требует обращения к серверу, а чем больше таких вызовов, тем сильнее страдает производительность. Поэтому стремитесь сократить количество удаленных вызовов, и не используйте их без надобности. Технология Script Callback, с другой стороны, отличается тяжеловесностью. Вы вынуждены писать менее специализированные серверные методы и концентрировать всю логику в одном методе, а на стороне клиента обходиться единственным вызовом, возвращающим всю необходимую информацию. Таким образом, подход Ajax.NET гибче и элегантнее, тогда как Script Callback с его спартанским API позволяет вам делать все то же самое, обходясь куда более скудными средствами. Удаленный вызов процедур и возврат формы С точки зрения архитектуры две рассматриваемые нами технологии в корне различ-ны. Ajax.NET основана на удаленном вызове процедур, она обеспечивает вам свободу выбора метода и типов передаваемых параметров. Что касается Script Callbacks, то в ней применяется метод возврата формы, скрытый от разработчика простенькой оболочкой. При каждом параллельном обращении к серверу запрашивается исход-ная страница (как при обычном возврате формы) и отсылается обратно последнее известное хорошее состояние страницы. Иными словами, состояние представления передается серверу при каждом параллельном вызове. Запрос обрабатывается обычным образом вплоть до события LoadComplete. Точка раскрутки параллельного вызова располагается непосредственно перед событием PreRender. Когда процесс обработки достигает этой точки, вызывается метод, предна-значенный для обработки параллельного вызова, и результаты возвращаются клиенту. Следующий псевдокод показывает, что происходит в данной точке: ICallbackEventHandler handler; handler = FindControl(target) as ICallbackEventHandler; if (handler != null) { handler.RaiseCallbackEvent(arguments); string results = handler.GetCallbackResult(); Response.Write(results); return; } Такое решение менее прямолинейное, чем удаленный вызов процедур, и сопро-вождается обычными для возврата формы затратами, включая отправку состояния представления. Однако, хотя состояние представления передается серверу, оно не обновляется и не возвращается клиенту. Но действительно ли данное состояние тре-
Работа с кодом сценариев Глава 6 259 буется серверному коду? В большинстве случаев ему нужно всего лишь выполнить удаленный вызов без сохранения состояния. А если так, технология ASP.NET Script Callbacks неоправданно тяжеловесна. С другой стороны, применение предлагаемого Ajax.NET стиля программирования, допускающего множественные вызовы, чревато созданием неэффективных страниц, авторы которых злоупотребляют удаленными вызовами, производя их без необходимости. Система Atlas Система Atlas представляет собой комплекс технологий разработки Web-прило-жений, используя которые можно обновлять данные страниц посредством пря-мых вызовов Web-сервера - без обновления всей страницы. Данный проект стал ответом Microsoft на появление модели программирования Ajax. Система Atlas состоит из двух инфраструктур - клиентской и серверной. Клиентская библиоте-ка сценариев реализует объектно-ориентированный API, совместимый с разными браузерами. Вам предоставляется возможность осуществлять асинхронные вызовы Web-сервисов, пользоваться средствами динамического HTTP и другими полез-ными элементами, создавая полнофункциональный пользовательский интерфейс. Серверный код состоит из обновленных серверных элементов управления, подде-рживающих декларативный способ создания разметки, и клиентских сценариев, необходимых для реализации технологии Atlas. Для создания эффективных приложений Ajax разработчикам необходимо хо-рошо знать технологии клиентских сценариев и разбираться в малейших разли-чиях DOM отдельных браузеров. Таким образом, Atlas - это не просто еще одна библиотека Ajax-типа. Ее создатели пытались упростить разработку с клиент-ской стороны и интегрировать клиентскую и серверную части решения, исполь-зуя новые обогащенные серверные элементы и Web-сервисы. Для Atlas создана обширная библиотека JavaScript, позволяющая работать с такими программными элементами, как классы и пространства имен, изначально отсутствовавшими в JavaScript. Впервые представленная на Professional Developer's Conference 2005, Atlas Framework является первой ласточкой нового поколения серверных технологий, основанных на применении программируемых элементов управления, кото-рые способны работать и на сервере, и на клиенте, снабженных настоящим объектно-ориентированным API. Дополнительную информацию по данной теме и демонстрационный код вы найдете по адресу http://atlas.asp.net. Заключение С самого начала Web-приложения возвращали Web-серверу формы и отображали разметку, полученную от него в ответ. Такой способ работы имеет множество пре-имуществ. Каждый запрос независим от следующего, и для их выполнения не нужно сохранять состояние. Все взаимодействие между браузером и сервером состоит в от-правке форм в одном направлении, а страниц - в другом. Когда текущая отображаемая страница нуждается в получении от сервера дополнительных данных, она производит возврат формы, после чего браузер получает совершенно новую страницу. Однако для современных страниц, богатых графикой и другими тяжеловесными элементами, такое постоянное обновление становится причиной снижения производительности. С конца 1990-х годов разработчики искали оптимальные пути создания интер-активных Web-решений, но хотя их появилось с тех пор немало, они не набирали критической массы и ни одно из них не стало стандартом. Или, быть может, при 
260 Часть II Специализированные средства ASP.NET достаточно широком их распространении ни одно не удовлетворяло разработчиков в полной мере, и мы все ждали, что вот-вот появится "то самое" решение. Создание Google Maps привело к настоящей революции в мире Web: страницы этого приложе-ния больше не выполняли возврат формы, а направляли серверу отдельные запросы на получение данных и динамически обновляли только эти данные, но не весь свой интерфейс. Без сомнения, за этим методом будущее Web-страниц. Как серверная технология, предназначенная для создания Web-страниц, ASP.NET не могла остаться в стороне. Первым шагом в этом направлении стало решение Script Callbacks, включавшее API для создания интерактивных страниц. Но, будучи основанным на модели классического возврата формы, это решение оказалось чересчур тяжеловесным, хотя и предлагало супероптимизированную модель обмена данными: "делайте в одном вызове столько, сколько сумеете". Следующим, явно более удачным шагом стало решение Ajax.NET, основанное на противоположном подходе к вопросу о взаимодействии. Оно значительно гибче, легковеснее и предлагает более простую модель программирования. Но обе технологии имеют два существенных недостатка: отсутствие богатой клиентской объектной модели, скрывающей различия DOM разных браузеров, и четкое разделение между клиентским и серверным аспектами программирования. И вот, наконец, появилась Atlas Framework, представленная на Professional Developer's Conference 2005 и распространяемая как дополнение к платформе ASP.NET 2.0. В этой новой модели воплощены ключевые технологии будущих Web-приложений. Когда ее разработка завершится, мы получим в свое рас-поряжение семейство серверных элементов управления, которые будут пользоваться новыми сервисами времени выполнения, единообразно программируемыми на сто-роне клиента и на стороне сервера. Сегодня система Atlas доступна как "technology preview", но завтра она станет сердцем нового поколения ASP.NET. Так что имейте ее в виду, используя пока технологию Ajax.NET. Только факты Существуют три способа включения кода сценариев в страницы ASP.NET: вставка его прямо в страницы, генерирование на сервере и связывание. Класс Page содержит методы для регистрации блоков кода сценариев, вставляемых в определенные места страницы, например в обработчик события OnSubmit или точку запуска формы. Разметка страницы ASP.NET может быть статически связана с определенным бра-узером или же динамически модифицироваться в соответствии с возможностями того браузера, который ее запросил. Технология обратного вызова сценария позволяет программным способом напра-вить серверу запрос и получить в ответ строковое значение. Эта строка передается коду JavaScript, который выполняет ее разбор и обновляет страницу содержащи-мися в ней данными. В технологии обратного вызова сценария используется возврат формы, который отрабатывается обычным образом до события PreRender. При каждом параллель-ном вызове серверу передается состояние представления, причем исходное, а не содержащее данные, введенные в форму последними. Сервер работает с последним известным ему хорошим состоянием страницы, то есть с состоянием на момент ее создания. Ajax.NET - это библиотека с открытым исходным кодом, позволяющая вызывать серверные методы, используя прокси-класс сценария, и сериализовать типы .NET в объекты JavaScript. 
Глава 7 Страницы с элементами Web Parts Своевременное получение необходимой информации в подходящем формате - важ-ный фактор экономии времени, а время, как известно, - это деньги. Современные Web-сайты часто отображают на одной странице много разнородной информации. Поначалу пользователям это нравится, но со временем начинает вызывать ощуще-ние дискомфорта. Данная проблема решается путем создания страниц с модельной структурой и персонализированным контентом. Если, к примеру, руководитель желает по утрам просматривать определенную информацию, разработчик корпоративного сайта должен предоставить ему такую возможность, причем так, чтобы экран во вре-мя ее просмотра не содержал других, ненужных в данный момент элементов, а сама информация была легко доступна. Как же создать такой Web-сайт, или, уместнее сказать, портал, с персонализи-руемым интерфейсом и богатым контентом? Отображение такого контента само по себе не является проблемой для разработчика, но вот как им эффективно управлять, и как предоставить пользователю возможность персонализации страниц? Ответом на этот вопрос стала новая технология Microsoft, включенная в состав ASP.NET 2.0 и получившая название Web Parts. Разрабатывать сайты с ее использованием - одно удовольствие. В этой главе мы исследуем состав и возможности системы ASP.NET 2.0 Web Parts, а затем построим маленький, но в высшей степени персонализируемый Web-сайт. Обзор Web Parts ASP.NET Web Parts Framework - это входящая в состав ASP.NET инфраструктура, предназначенная для создания Web-приложений с богатым и объемным контентом. Созданные на ее основе сайты позволяют пользователям отбирать и просматривать только ту часть контента, которая их интересует. Основой данной инфраструктуры являются компоненты Web Parts, в буквальном переводе Web-части или Web-разде-лы. Это контейнерные компоненты, которые могут содержать контент любого типа и потому особенно полезны для создания Web-порталов. Что такое Web Parts На рис. 7-1 показан Web-сайт My MSN. Страница этого сайта состоит из набора бло-ков, каждый из которых представляет определенный вид информации. Ни один из блоков, которые вы видите на странице, не находится здесь по воле разработчика сайта. Все их отобрал и расположил удобным для себя образом поль-зователь, для чего ему предоставлены специальные ссылки Add Content и Change Details. Страницы с подобной настраиваемой структурой можно создавать и в ASP.NET, составляя их из компонентов Web Parts.
262 Часть II Специализированные средства ASP.NET Рис. 7-1. Страница сайта My MSN, принадлежащая зарегистрированному пользователю, составлена из выбранных им информационных блоков Содержимое компонента Web Part Отдельный компонент Web Part можно представить себе как окно с некоторой инфор-мацией, доступной на данной странице. Пользователи могут его закрывать, сворачи-вать и восстанавливать. Это внешняя сторона дела; с программной же точки зрения Web Part является контейнером, заполненным обычным HTML-содержимым - ста-тическим текстом, ссылками, изображениями и различными элементами управления, в том числе пользовательскими (user) и специализированными (custom). Объединив технологию Web Parts и API для работы с пользовательскими профилями, разра-ботчик может без труда создавать страницы и элементы управления, адаптируемые к индивидуальным нуждам каждого конкретного пользователя. Контентом Web Part может быть любая информация, представляющая интерес для всех пользователей сайта, определенной их группы или даже одного конкретного пользователя. Как правило, такой контент предоставляется внешними Web-сайтами, публикующими финансовую, метеорологическую, спортивную новостную или иную информацию. Кроме того, популярны компоненты Web Parts с личными данными пользователей, такими, как список избранных ссылок, галерея фотографий или ре-зультаты поиска. Структура и интерфейс Web Part С точки зрения разработчика Web Part - это род интеллектуального элемента управ-ления Panel. Подобно ему Web Part может содержать любой контент, поддерживаемый ASP.NET. Что делает компонент Web Part более мощным, чем обыкновенная панель, так это поддержка, получаемая им от менеджера Web Parts, и особые графические элементы, которые служат для управления его окном на экране. Интерфейс Web Part 
Страницы с элементами Web Parts Глава 7 263 напоминает интерфейс обычного окна. У него есть строка заголовка и кнопки для свертывания, закрытия и восстановления. Хотя Web Part может действовать как контейнер информации, поступающей из внешнего источника, такого, как сайт или страница, он отличается от фрейма. Фрейм - всего лишь ссылка на URL, и за его заполнение контентом, полученным по данному URL, всецело отвечает браузер. Тогда как Web Part является серверным элементом управления, передаваемым браузеру в виде чистого HTML. Этот компонент можно наполнить содержимым, собранным с других сайтов, но вы сами отвечаете за его сбор. Обычно для сбора информации используется технология HTML scraping, а если есть возможность, то Web-сервисы. Web Parts и Microsoft SharePoint В мире Microsoft Windows продукты и технологии SharePoint упрощают совместную работу и сотрудничество служащих компании или организации. Страницы Web-сайта, созданного по технологии SharePoint, могут содержать компоненты Web Parts, специ-ально предназначенные для отображения окон с персонализированной информацией, индивидуально настроенных каждым пользователем. Хотя области применения технологий SharePoint и ASP.NET пересекаются, сами эти технологии различны. SharePoint ориентирована в первую очередь на подде-ржку совместной работы в рамках организации, а также взаимодействия между со-трудниками организации и ее партнерами и клиентами. Портал SharePoint, таким образом, является одним из инструментов сотрудничества. Что касается ASP.NET, то она является исполняющей средой, которая может служить хост-средой прило-жения SharePoint. Кроме того, ASP.NET 2.0 - это инфраструктура, используемая разработчиками для создания решений портального типа без применения продуктов и технологий SharePoint. Закономерен вопрос: есть ли у инфраструктур SharePoint и ASP.NET нечто общее? Есть, и вы, наверное, уже догадались, что именно: это компоненты Web Parts. Совре-менные компоненты Web Parts, используемые в SharePoint - это элементы управления ASP.NET с дополнительным слоем кода, который обеспечивает их взаимодействие с инфраструктурой SharePoint. Компоненты Web Parts из ASP.NET 2.0 представля-ют собой серверные элементы управления, взаимодействующие с инфраструктурой ASP.NET Web Parts и имитирующие поведение документов SharePoint. Примечание SharePoint и ASP.NET со временем будут объединены, но в какой степе-ни - пока неизвестно. Не вызывает сомнения лишь то, что следующая версия SharePoint будет всецело основана на ASP.NET 2.0 и что компоненты Web Part из ASP.NET будут полностью поддерживаться SharePoint. Собственно, в значительной степени это уже про-исходит, когда вы устанавливаете SharePoint Service Pack 2. Некоторые нововведения модели компиляции ASP.NET (такие, как некомпилируемые страницы, фильтры анализа-тора и провайдеры виртуального пути) введены как раз для этой цели - портирования SharePoint к ASP.NET 2.0. Web Parts, очевидно, на очереди. Когда выйдет следующая версия SharePoint, ASP.NET Web Parts и SharePoint Web Parts, очевидно, будут одним и тем же. Введение в Web Parts Framework В состав страницы, созданной на основе технологии Web Parts, входит несколько компонентов из Web Parts Framework, каждый из которых имеет свою функцию. Центральным элементом инфраструктуры Web Parts является элемент управления WebPart, но он здесь не единственный. Перечень всех элементов управления с их описаниями приведен в табл. 7-1.
264 Часть II Специализированные средства ASP.NET Табл. 7-1. Компоненты Web Parts Framework Компонент Описание WebPartManager Управляет всеми элементами Web Parts страницы. У этого компонента нет пользовательского интерфейса, и во время выполнения он невидим WebPart Содержит контент, представляемый пользователю в перемещаемом окне. WebPart является абстрактным классом; для отображения контента с его использованием нужно создать собственный класс либо путем наследования, либо как пользовательский элемент управления WebPartZone Контейнер элементов управления WebPart уровня страницы CatalogPart Базовый класс для элементов управления Catalog Part. Такой элемент вводит для пользователя список доступных элементов Web Part, кото-рые тот может динамически включать в состав страницы. В приложе-ниях приме няются производные от него классы - ImportCatalogPart, PageCatalogPart и DeclarativeCatalogPart CatalogZone Контейнер уровня страницы для элементов управления CatalogPart ConnectionsZone Контейнер уровня страницы для соединений пар элементов Web Part, размещенных на странице EditorPart Базовый класс для всех элементов-редакторов, используемых для моди-фикации содержимого элементов Web Parts. Editor Part имеет собствен-ный пользовательский интерфейс, посредством которого пользователи производят установку свойств EditorZone Контейнер уровня страницы для элементов управления EditorPart Инфраструктура Web Parts включает класс WebPartManager и три типа компонен-тов, называемых частями: Web Parts (Web-части), Catalog Parts (части-каталогизато-ры) и Editor Parts (части-редакторы). Части и зоны Зоной называется контейнер частей, обладающий собственным пользовательским интерфейсом и функциональностью. Страница ASP.NET может содержать несколько зон, а каждая из них - одну или более частей. Зона отвечает за рендеринг элементов пользовательского интерфейса, общих для всех входящих в нее частей, таких как строки заголовка, границы, кнопки управления окном, а также заголовки и нижние колонтитулы. Web Part определяет контент, отображаемый в окне на странице, тогда как Editor Part дает пользователю возможность редактировать структуру и установки конк-ретного элемента Web Part. Предположим, что вы создали Web Part для отображе-ния прогноза погоды для нескольких избранных городов. Editor Part этого Web Part предоставит дружественный интерфейс, чтобы пользователь мог составить список интересующих его городов и задать необходимые установки, например указать, ка-кие он хочет видеть значения температуры: по Цельсию или по Фаренгейту. Такой элемент есть на сайте My MSN; чтобы войти в режим редактирования его установок, нужно щелкнуть кнопку Select Your Cities на странице или одноименную команду меню, открываемого из строки заголовка (рис. 7-2). Набор свойств, которые можно редактировать, определяется конкретным типом Web Part. При этом на самом деле пользователь редактирует свойства элемента управления WebPart. Инфраструктура Web Parts позволяет пользователю выбрать части, которые он хочет включить в состав страницы, и разместить их, как ему нравится. Список до-ступных частей предоставляется элементом управления Catalog Part, который дает пользователю возможность динамически добавлять одни части и удалять другие. Каталог действует и как хранилище частей, удаленных пользователем со страницы, 
Страницы с элементами Web Parts Глава 7 265 с его помощью их также можно восстановить. Мы подробно рассмотрим элементы Catalog Parts и Editor Parts далее в этой главе. Рис. 7-2. Редактирование параметров блока прогноза погоды на сайте My MSN Web Parts - это исключительно серверные элементы управления. Их базовым клас-сом является WebPart, наследующий другой абстрактный базовый класс, называемый Part. Аналогичным образом, EditorPart и CatalogPart являются базовыми классами элементов Catalog Parts и Editor Parts, и оба также наследуют класс Part. Он, в свою очередь, является производным от класса одного из встроенных серверных элементов управления - Panel. Все части реализованы как ASP.NET-контейнеры других элемен-тов управления. Вся эта иерархия представлена на рис. 7-3. Рис. 7-3. Иерархия классов частей Примечание В ASP.NET 2.0 элемент управления Panel обогащен функцией прокрутки содержимого. Для этого в его состав добавлен CSS-стиль overflow. Того же результата в ASP.NET 1.x можно добиться, вручную назначив данный стиль разметке .aspx. Класс WebPartManager WebPartManager - это элемент управления, не имеющий визуального представления и управляющий многими видами элементов страницы, созданной по технологии Web Parts. В частности, данный элемент-менеджер поддерживает коллекцию зон и частей и знает, какие части входят в состав каждой из зон. В Web-форме может содержаться только один элемент WebPartManager. В простейших случаях вся ваша работа с этим менеджером состоит в добавлении его на страницу: <asp:WebPartManager runat="server" id="MyWebMan" />
266 Часть II Специализированные средства ASP.NET Однако для того чтобы менеджер веб-частей полностью реализовал свои возмож-ности, требуется немного кодирования. Например, он отслеживает режим отображения страницы и уведомляет зоны и части о его изменении. Режим отображения определяет способ рендеринга этих элементов. По умолчанию установлен режим Normal, согласно которому зоны каталога и редактора скрыты и отображаются только элементы Web Parts с их собственными заголовками и границами. Программный доступ к списку зон осуществляется посредством коллекции Zones. Элемент WebPartManager обеспечивает конечным пользователям возможность переносить части из одних зон в другие, а также перемещать их в пределах зоны. Кроме того, он предоставляет интерфейс для редактирования внешнего вида, свойств и поведения элементов управления. Еще он генерирует события жизненного цикла элементов Web Parts, такие как добавление, перемещение, соединение и удаление. Наконец, WebPartManager отвечает за инициирование взаимодействия двух свя-занных частей и за программное перемещение, закрытие элементов Web Parts и им-портирование их контента. Две части одной страницы могут взаимодействовать и обмениваться информацией через особый канал, представленный объектом WebPartConnection. Взаимодействие частей возможно, если обе они реализуют специальные интерфейсы. Элемент Web Part, предназначенный для предоставления информации другим частям, должен ре-ализовывать набор интерфейсов провайдера. Тогда часть-потребитель сможет пре-допределенным образом обращаться к его свойствам и методам. Специальная зона соединений позволяет конечным пользователям динамически создавать соединения, выбирая в списке подходящие элементы Web Parts и указывая, какой из них будет потребителем, а какой - провайдером. Работа объектов, обеспечивающих соединение частей, рассматривается далее в этой главе. Зоны Web Parts Для каждого вида частей в ASP.NET 2.0 предусмотрен свой класс зон. Так, контейне-ром элементов WebPart является WebPartZone. Набор элементов Web Parts он хранит в виде свойства-коллекции WebParts, обеспечивая хостинг их контента. Кроме того, при переключении в режим Design элемент WebPartZone обеспечивает конечным пользова-телям возможность свободного перетаскивания Web Parts с помощью мыши. Режим Design - это один из поддерживаемых менеджером Web Parts режимов отображения страницы, распространяющийся на все находящиеся на ней элементы Web Parts. Эле-мент WebPartZone имеет довольно много настраиваемых разработчиком свойств; к их числу относятся PartStyle (стиль контента), PartTitleStyle (стиль строки заголовка) и MenuVerbStyle (стиль элементов меню, связанного с каждым элементом Web Part данной зоны). Мы вернемся к вопросу о стилях немного погодя. Зоны других типов более специализированы. Элемент EditorZone используется для хранения элементов-редакторов, предназначенных для конфигурирования элементов Web Parts; CatalogZone служит для отображения каталога доступных Web Parts, из которого пользователь может выбирать требуемые части; наконец, ConnectionsZone содержит элементы, представляющие связи пар Web Parts, необходимые для их вза-имодействия и образования представлений "главный-подчиненный". Создание страниц с элементами Web Parts Вы уже, наверное, ждете не дождетесь, когда я наконец продемонстрирую разметку страницы, состоящей из элементов Web Parts. Что ж, вот и первый пример: <%@Page Language="C#" CodeFile="Parts.aspx.cs" Inherits="Parts" %> <%@Register TagPrefix="x" TagName="News" Src="News.ascx" %>
Страницы с элементами Web Parts Глава 7 267 <%@Register TagPrefix="y" TagName="Favorites" Src="Favorites.ascx" %> <html> <head><title>Simple Web Parts</title></head> <body> <form id="form1" runat="server"> <h1>Demonstrating WebParts zones</h1> <asp:WebPartManager ID="WebMan" runat="server" /> <asp:WebPartZone ID="WebPartZone1" runat="server" HeaderText="This is Zone #1" PartChromeType="TitleAndBorder" BorderColor="#CCCCCC"> <PartStyle Font-Size="0.8em" ForeColor="#333333" /> <PartTitleStyle Font-Size="0.8em" Font-Names="verdana" BackColor="#507CD1" ForeColor="White" /> <PartChromeStyle BackColor="#EFF3FB" BorderColor="#D1DDF1" Font-Names="Verdana" ForeColor="#333333" /> <ZoneTemplate> <x:News runat="server" id="News" /> <y:Favorites runat="server" id="Favs" /> </ZoneTemplate> </asp:WebPartZone> </form> </body> </html> Давайте посмотрим, из чего состоит тело этой страницы. Форма содержит элемент управления WebPartManager, управляющий выполнением и рендерингом всех дочер-них частей. Еще в форме есть Web-зона с несколькими стилями и парой частей. Эта зона имеет заголовок и границы. Тэг <ZoneTemplate> содержит определения входящих в зону элементов управления Web Parts. Как выглядит данная страница в браузере, показано на рис. 7-4. Рис. 7-4. Зона с двумя элементами Web Parts - новостным и содержащим список избранных ссылок
268 Часть II Специализированные средства ASP.NET Содержимое каждого элемента Web Part отображается посредством пользователь-ского элемента управления, составленного из других элементов управления, литералов и разметки, объявленных в отдельном исходном файле .ascx, компилируемом на лету подобно обычной странице. (О пользовательских элементах управления мы подробно поговорим в главе 12.) Для того чтобы такой элемент можно было использовать в составе страницы, его необходимо зарегистрировать с помощью директивы @Register. Данная директива определяет соответствие между именем и префиксом тэга с одной стороны и исходным файлом - с другой. Роль пользовательских элементов управления Есть два способа определения контента элементов Web Parts. Один из них заключает-ся в создании специализированного серверного элемента управления, наследующего класс WebPart и реализующего некоторые из интерфейсов, представленных в схеме на рис. 7-3. Этот подход более гибкий и мощный, для его использования необходимо овладеть основными навыками создания специализированных элементов управления ASP.NET. Второй подход проще, быстрее реализуется и в большинстве случаев не менее эффективен. Он основан на применении пользовательского элемента управ-ления. Как же соотносятся элементы Web Parts и пользовательские элементы управления? И те и другие отображают контент, описанный посредством разметки. Однако созда-ние элементов Web Parts дает вам возможность осуществлять условный рендеринг, а также реализовать больше интерфейсов и упростить развертывание и совместное использование элементов разными приложениями. Однако если вам нужно, лишь отобразить более-менее статичный контент с отно-сительно простой логикой обработки, удобнее действовать посредством пользователь-ских элементов управления, поскольку создать их проще и делается это быстрее. Ну и конечно, мощным и эффективным решением в определенных случаях может стать объединение двух технологий. Внешний глянец, кнопки управления окном и меню На рис. 7-4 был представлен элемент Web Part, в строке заголовка которого справа находится маленькая треугольная кнопка. С ее помощью раскрывается меню, как показано на рис. 7-5. Рис. 7-5. Меню с командами управления окном: при свертывании Web Part команда Minimize заменяется командой Restore Используя команды системного меню можно выполнить частичную настройку. По умолчанию в нем выводятся элементы Minimize (или Restore) и Close. Если щелкнуть кнопку Close, Web Part будет удален со страницы. Однако система не уничтожит его, а всего лишь переместит в каталог, где вы его найдете, открыв Catalog Part.
Страницы с элементами Web Parts Глава 7 269 Стиль меню можно задавать по своему вкусу; по умолчанию подменю раскрыва-ются, если задержать на команде указатель мыши. Под "глянцем" (chrome) Web Part подразумеваются его заголовок и рамка. Вы можете отобразить оба эти элемента или какой-либо один из них. Как правило, глянец определяют для зоны, и он наследуется всеми входящими в ее состав Web Parts. Примечание Заголовки элементов Web Parts в приведенном здесь примере не опре-делены (см. рис. 7-5). Эти элементы Web Parts реализованы в виде пользовательских элементов управления. Как определяются их заголовки? Вместе с другими установками их задают посредством членов нескольких определенных в ASP.NET специализированных интерфейсов - в частности, IWebPart. Данный интерфейс целесообразнее реализовывать при создании серверного элемента управления, но и для пользовательского элемента управления его также можно реализовать, как будет сделано в одном из следующих примеров. Web Parts на базе ролей Включая в состав страницы элемент Web Part, необходимо убедиться в наличии оп-ределенных условий времени выполнения. Такие элементы имеют свойство-фильтр, которое можно проверять во время выполнения, чтобы выяснить, доступен ли дан-ный элемент для текущего пользователя с учетом его ролей. Если включить в состав объекта-менеджера обработчик события AuthorizeWebPart и осуществлять фильтрацию элементов Web Parts, вы сможете скрывать и отображать эти элементы с учетом ролей текущего пользователя. Подробно эта тема рассматривается дальше. Создание элементов Web Parts Давайте создадим демонстрационный элемент Web Part и поэкспериментируем с его свойствами. Как рассказывалось выше, такой элемент представляет собой псевдоокно, расположенное на Web-странице и содержащее информацию, которую пользователь желает видеть на этой странице. Подобно окнам приложений его можно перемещать, а его контент в той или иной степени подлежит конфигурированию. Инфраструктура Web Parts обеспечивает возможность перетаскивания частей страницы с помощью мыши, изменения их набора и взаимного расположения. За программирование логи-ки, а также создание элементов пользовательского интерфейса, предназначенных для редактирования и каталогизации контента, отвечает разработчик страницы. Главная задача элементов Web Parts - выводить информацию для пользователя. Источник информации определяется назначением конкретного элемента Web Part и приложения, в состав которого он входит. Например, на порталах с персонализи-рованными страницами пользователей такие элементы отображают контент, взятый из локальной сети (отчеты, документы, объявления и т. п.) или предоставляемый внешними Web-сайтами (блоги, новости, биржевые котировки и т. д.) Элемент Web Part явно или неявно наследует абстрактный класс WebPart. Поэтому с него и начнем наше исследование. Класс WebPart У вас есть две возможности создания разметки компонента Web Part: разработать спе-циализированный элемент управления, производный от WebPart, или воспользоваться другими серверными элементами управления, в том числе специализированными и пользовательскими (файлы .ascx). Существующие серверные и пользовательские элементы управления, не наследующие WebPart, будучи помещенными в Web-зону (программно или декларативно) автоматически обретают полную функциональность Web Parts. В таком случае указанные элементы во время выполнения заключаются 
270 Часть II Специализированные средства ASP.NET в объект-оболочку GenericWebPart, и менеджер Web Parts воспринимает их как насто-ящие элементы управления Web Parts. Как было показано на рис. 7-3, класс GenericWebPart является производным от WebPart. Поэтому непосредственно использовать его в разметке страницы нельзя. Кроме того, заметьте, что каждый экземпляр класса GenericWebPart может служить оболочкой только одного серверного элемента управления. Примечание Благодаря наличию класса GenericWebPart вы можете определять шаблоны зон, как показано ниже: <ZoneTemplate> <asp:Button runat="server" ID="Button1" Text="Hello" /> </ZoneTemplate> Когда тэг <ZoneTemplate> содержит более одного дочернего элемента, применяется только первый. Кроме того, вы не можете использовать литералы, не превратив их в серверные элементы управления. Если опустить атрибут runat="server", приведенный ниже контент будет проигнорирован. <ZoneTemplate> <h1 runat="server" ID="H1">Hello</h1> </ZoneTemplate> Применение существующих элементов управления для составления Web Part - без сомнения, удобная возможность, которая может сэкономить вам время и усилия. Однако ограничением данного подхода является то, что в каждую зону помещается только один элемент управления. Чтобы обойти это ограничение, можно восполь-зоваться составными специализированными элементами управления, а еще лучше, агрегировать и связать между собой несколько элементов управления, создав пользо-вательский элемент. Однако создание нового специализированного элемента управле-ния, производного от класса WebPart, обеспечивает вам возможность максимального программного контроля над поведением Web Part. Внимание! Создание элементов Web Parts как пользовательских элементов управления дает вам возможность разрабатывать их, применяя визуальные средства, имеющиеся в Visual Studio 2005. С точки зрения итоговой функциональности не имеет значения, какой элемент управления вы создадите - специализированный или пользовательский. Иными словами, пользовательские элементы управления - не просто еще одно средство созда-ния Web Parts, они могут реализовывать интерфейсы и необходимые операции подобно обычным серверным элементам управления, производным от WebPart. Все упирается в ваши собственные предпочтения. Однако пользовательские и серверные элементы управ-ления обладают разными характеристиками, причем независимо от того, используются ли они при разработке Web Parts. Существенным ограничением пользовательских элементов управления, о котором вам следует помнить, является то, что они не могут наследоваться и их нельзя добавить на панель инструментов Visual Studio 2005. О пользовательских элементах управления мы поговорим в главе 12. Члены класса WebPart В табл. 7-2 перечислены важнейшие свойства класса WebPart. Просмотрев ее, вы получите представление о том, насколько мощные возможности программирования заложены в элементах Web Parts. Заметьте, что данный класс косвенно наследует классы WebControl и Panel, поэтому у него довольно много дополнительных визуаль-ных свойств - это BackColor, BackImageUrl и ScrollBars.
Страницы с элементами Web Parts Глава 7 271 Табл. 7-2. Свойства класса WebPart Свойство Описание AllowClose Указывает, может ли конечный пользователь закрыть Web Part AllowConnect Указывает, допускает ли Web Part подключение к нему других элемен-тов управления AllowEdit Указывает, может ли конечный пользователь модифицировать Web Part посредством пользовательского интерфейса элемента управления Editor Part AllowHide Указывает, может ли конечный пользователь скрывать Web Part AllowMinimize Указывает, может ли конечный пользователь сворачивать Web Part AllowZoneChange Указывает, может ли конечный пользователь перемещать Web Part из одной зоны в другую AuthorizationFilter Строка произвольного формата, которую менеджер Web Parts использует для определения того, может ли данный Web Part быть добавлен на страницу CatalogIconImageUrl URL изображения, представляющего данный элемент Web Part в каталоге Web Parts ChromeState Определяет состояние окна Web Part: нормальное или свернутое ChromeType Определяет, какие элементы имеет окно Web Part: границы, заголовок, границы и заголовок или ни одного из этих элементов ConnectErrorMessage Содержит сообщение, выводимое для конечного пользователя, если при установке соединения произошла ошибка Description Описание Web Part, используемое в каталогах и отображаемое в под-сказке, которая появляется, если задержать указатель мыши в строке заголовка Direction Направление вывода текста: слева направо или справа налево DisplayTitle Полный текст заголовка, отображаемого в строке заголовка Web Part ExportMode Определяет, какие из свойств Web Part могут экспортироваться: все, некоторые, никакие (по умолчанию) HasSharedData Указывает, ассоциированы ли с данным элементом Web Part какие-либо совместно используемые данные персонализации HasUserData Указывает, ассоциированы ли с данным элементом Web Part какие-либо данные персонализации HelpMode Определяет тип пользовательского интерфейса, выбранного для отобра-жения справки Web Part HelpUrl URL раздела справки Web Part Hidden Указывает, отображается данный элемент Web Part или скрыт ImportErrorMessage Сообщение, отображаемое, когда при импортировании данных Web Part происходит ошибка IsClosed Указывает, закрыт ли в данный момент элемент Web Part IsShared Указывает, могут ли с данным элементом Web Part совместно работать несколько пользователей IsStandalone Указывает, содержится ли Web Part в зоне Web Parts IsStatic Указывает, что Web Part объявлен в разметке, а не добавлен на страницу программным способом Subtitle Строка, объединяемая с содержимым свойства Title для получения пол-ного заголовка Web Part Title Заголовок Web Part TitleIconImageUrl URL изображения, которое выводится в строке заголовка (см. след. стр.)
272 Часть II Специализированные средства ASP.NET Свойство Описание TitleUrl URL дополнительной информации о Web Part. Если этот URL задан, он выводится в строке заголовка Verbs Набор команд управления (в том числе управления окном), связанных с данным элементом Web Part WebBrowsableObject Возвращает ссылку на Web Part, когда его можно редактировать пос-редством пользовательского элемента управления Editor Part Zone Объект зоны, содержащей Web Part в данный момент ZoneIndex Индекс Web Part в зоне, в которой он находится Интерфейс программирования класса WebPart большей частью состоит из свойств, перечисленных в данной таблице. У класса имеется всего один метод и нет ни од-ного собственного события (если не считать события, унаследованные от базовых серверных элементов управления). Открытым методом класса WebPart является CreateEditorParts, возвращающий коллекцию пользовательских объектов Editor Part, используемых для редактирования Web Part, когда активен режим Edit. Если учесть, что класс WebPart имеет абстрактную природу, будет интересно познакомиться с перечнем его защищенных методов (табл. 7-3). Помимо свойств, унаследованных от родительских элементов управления, WebPart имеет всего одно свойство - WebPartManager, - возвращающее ссылку на соответствующий менеджер Web Parts. Табл. 7-3. Защищенные переопределяемые методы класса WebPart Метод Когда вызывается OnClosing Web Part закрывается OnConnectModeChanged Web Part начинает или завершает процесс подключения к другому элементу управления OnDeleting Web Part удаляется со страницы OnEditModeChanged Включается или отключается режим редактирования Web Part Переопределяя в производном от WebPart классе перечисленные в таблице методы, вы тем самым реализуете пользовательские процедуры обработки событий Web Part. Все эти события генерируются в ответ на действия пользователя или вызов методов класса менеджера Web Parts. Интерфейсы Web Parts Как видно на рис. 7-3, WebPart является производным от класса Part и реализует не-сколько интерфейсов: IWebPart, IwebActionable и IWebEditable, - которые определяют типичные свойства пользовательского интерфейса, предназначенные для расширения возможностей пользователя при работе с Web Part. Именно с этими интерфейсами связано главное отличие двух способов реализации Web Parts: на основе базового класса WebPart или простых пользовательских элементов управления. Когда вы создаете класс, производный от WebPart, перечисленные интерфейсы в нем уже реализованы, но вы можете переопределять отдельные их методы по свое-му усмотрению. Когда же Web Part создается на основе пользовательского элемен-та управления, все эти интерфейсы нужно реализовать вручную - если, конечно, Табл. 7-2. (окончание)
Страницы с элементами Web Parts Глава 7 273 соот ветствующие функции вам требуются. Делать это не обязательно, но отсутствие данных интерфейсов влечет за собой возникновение побочных эффектов. Например, когда у Web Part нет интерфейса IWebPart, он не имеет заголовка (см. рис. 7-4). Как можно судить по приведенной ниже структуре интерфейсов Web Parts, их составляют свойства, перечисленные в табл. 7-2: public interface IWebPart { string CatalogIconImageUrl { get; set; } string Description { get; set; } string Subtitle { get; } string Title { get; set; } string TitleIconImageUrl { get; set; } string TitleUrl { get; set; } }public interface IWebEditable { EditorPartCollection CreateEditorParts(); object WebBrowsableObject { get; } }public interface IWebActionable { WebPartVerbCollection Verbs { get; } } В стандартной реализации данных интерфейсов свойство WebBrowsableObject воз-вращает this (или Me при использовании Microsoft Visual Basic .NET), а коллекция Verbs пуста. Свойства Title и Description интерфейса IWebPart реализованы так же, как аналогичные свойства класса Part. Они хранят свои значения в состоянии пред-ставления. По умолчанию Subtitle и другие строковые свойства IWebPart возвращают пустую строку. Фильтр авторизации Менеджер Web Parts контролирует процесс добавления Web Parts на страницу. Важно отметить, что не каждому пользователю позволено размещать на своей странице все доступные Web Parts. Когда Web Part добавляется на страницу - при ее запуске или программным способом, - менеджер Web Parts генерирует событие AuthorizeWebPart, чтобы выяснить, разрешено ли добавление этого элемента. В пользовательском об-работчике указанного события разработчик может проверить значение свойства AuthorizationFilter элемента Web Part и узнать, допускают ли условия времени вы-полнения добавление этого элемента. Свойство AuthorizationFilter действует подобно ролям пользователей, но являет-ся более универсальным. Иными словами, вы можете заполнить его информацией о ролях - но это не единственная возможность. Например, в него можно записать какие-нибудь другие сведения или эмулировать роли пользователей в системе, где они не поддерживаются как элемент системы аутентификации. <asp:WebPartManager runat="server" OnAuthorizeWebPart="AuthorizeWebPart" /> Согласно приведенной выше директиве при добавлении Web Part на страницу, находящуюся под юрисдикцией менеджера, будет вызван следующий обработчик события: void AuthorizeWebPart(object sender, WebPartAuthorizationEventArgs e) {
274 Часть II Специализированные средства ASP.NET if (!String.IsNullOrEmpty(e.AuthorizationFilter)) { if (e.AuthorizationFilter == "Admin") e.IsAuthorized = true; else e.IsAuthorized = false; } } В состав структуры WebPartAuthorizationEventArgs входит свойство AuthorizationFilter, которое является копией соответствующего свойства Web Part. Через него вы получа-ете доступ к строке фильтра, а затем устанавливаете определенным образом свойство IsAuthorized. Заметьте, что по умолчанию - то есть, если вы не обрабатываете в странице со-бытие AuthorizeWebPart - свойству AuthorizationFilter присваивается пустая строка, и это означает, что Web Part авторизирован. Внимание! Web Part является настраиваемым серверным элементом управления. Помимо описанных здесь возможностей он позволяет управлять состоянием представления, обес-печивает доступ ко внутренним структурам ASP.NET, контексту запроса и информации об аутентификации. Web Part StockViewer Структура реального Web Part не намного сложнее, чем в следующем примере: public class StockViewerWebPart : WebPart { //Если имеются открытые свойства, они определяются здесь... public override string Title { } protected override void RenderContents (HtmlTextWriter writer) { } } В таком классе определяют открытые свойства, влияющие не поведение компо-нента, при желании переопределяют свойство Title, чтобы у Web Part был информа-тивный заголовок, и в обязательном порядке переопределяют метод RenderContents, генерирующий вывод компонента. Приведенный код представляет тот необходимый минимум, который нужен для создания пользовательского элемента Web Part. Однако демонстрационный компо-нент StockViewer, на примере которого я покажу, как создаются пользовательские элементы Web Part, несколько сложнее, поскольку он обладает дополнительными функциями. В полном соответствии со своим именем элемент StockViewer выводит котировки акций нескольких компаний и автоматически обновляет эти сведения с заданной периодичностью. Открытый интерфейс В компоненте StockViewer переопределены свойства Title и Subtitle, задающие содер-жимое строки заголовка Web Part. Вот стандартный способ переопределения свойств из базового класса WebPart: public override string Title {
Страницы с элементами Web Parts Глава 7 275 get { if (String.IsNullOrEmpty(base.Title)) return "Stock Viewer"; return base.Title; } set { base.Title = value; } } В отличие от свойства Title свойство Subtitle доступно только для чтения. Его переопределенная версия выглядит следующим образом: public override string Subtitle { get { if (String.IsNullOrEmpty(base.Subtitle)) return "Random quotes"; return base.Subtitle; } } Пользовательский элемент Web Part обычно имеет несколько открытых свойств, посредством которых пользователи могут настраивать отображаемый в нем контент. Наш элемент StockViewer обладает двумя свойствами: Stocks и RefreshRate. Первое представляет компании, котировки акций которых отображаются в текущий момент, а второе задает интервал обновления данных в секундах. Предполагается, что Stocks содержит разделенную запятыми строку названий компаний. [Personalizable] [WebBrowsable] public string Stocks { get { return _stocks; } set { _stocks = value; } }[Personalizable] [WebBrowsable] public int RefreshRate { get { return _refreshRate; } set { _refreshRate = value; } } Оба свойства хранят свои значения в закрытых членах, не сохраняющих состояние. Значения открытых свойств не изменяются при возврате формы страницей, если толь-ко они явно не изменены посредством редактора, поэтому включать их в состояние представления не требуется. Данные значения в определенном смысле статичны, и их можно устанавливать при загрузке Web Part на страницу. Какова роль двух используемых здесь атрибутов? Атрибуты свойств Web Part Присвоенный открытому свойству элемента атрибут [Personalizable] указывает, что значение этого свойства должно сохраняться в связанном с данной страницей 
276 Часть II Специализированные средства ASP.NET хранилище данных, когда элемент используется в зоне Web Parts или в составном элементе управления, заключенном в оболочку Web Part. Как рассказывалось в гла-ве 4, элементы Web Part автоматически сохраняют свое состояние, используя текущий провайдер персонализации. По умолчанию данные персонализации записываются в одну из таблиц файла aspnetdb.mdf. Если опустить этот атрибут, значение свойства не будет сохраняться - по окончании обработки запроса оно будет утрачено. Не все свойства можно снабжать данным атрибутом. Он используется только со свойствами, которые являются открытыми, доступными для чтения и записи (то есть, у них есть аксессор get и мутатор set) и не индексированными (свойствам-коллекци-ям, таким как Item, его назначать нельзя). Значение свойства, не имеющего данного атрибута, не будет сохраняться, если только это свойство не реализует интерфейс IPersonalizable и не сохраняет свое значение самостоятельно, для чего оно должно быть снабжено соответствующим кодом, написанным вами вручную. Атрибут [WebBrowsable] указывает, что свойство можно редактировать посредством пользовательского интерфейса Editor Part, зависящего от типа свойства. Свойства, помеченные данным атрибутом, должны быть доступными для чтения и записи и от-крытыми. Если свойство не имеет атрибута [WebBrowsable], пользователи не могут его редактировать, а установка и изменение его значения выполняются программно. Обычно свойства, помеченные данным атрибутом, предназначаются для настрой-ки поведения элемента управления или Web Part, как свойства Stocks и RefreshRate нашего демонстрационного компонента StockViewer. Помимо двух описанных атрибутов свойствам Web Part можно приписывать также атрибуты [WebDescription] и [WebDisplayName], используемые в режиме Edit. Первое определяет строку, выводимую во всплывающей подсказке, а второе - надпись, опи-сывающую свойство в пользовательском интерфейсе редактора. Механизм рендеринга Если список компаний пуст, наш элемент Web Part просто выводит соответствующее сообщение (рис. 7-6). Когда же задана хоть одна компания, он создает таблицу, содер-жащую по одной строке для каждой из них, как показано на рис. 7-7. Рис. 7-6. Элемент Web Part StockViewer, не содержащий данных Вывод данных обеспечивается переопределением метода RenderContents WebPart. Вот код этого метода, написанный для класса StockViewer: protected override void RenderContents (HtmlTextWriter writer) { if ((_stocks == null) || (_stocks.Length == 0)) {
Страницы с элементами Web Parts Глава 7 277 writer.Write("<b>No stocks available.</b><hr>" + "<i style=\"font-size:85%\">Specify some names and create a list of stocks to monitor. " + "For example, \"XYZ, FOO, BAR\"</i>"); } else { CreateTableOfStocks(writer); string msg = "No auto refresh"; if (RefreshRate >0) msg = String.Format("{0} seconds delay", RefreshRate); string text = String.Format( "<br><div style=\"margin:5\">" + "<span style=\"font-size:80%\">" + "<span id=\"LastUpdated\">{0}</span> -" + "Quotes supplied by <b>RandomQuotes Inc</b>, {1}. " + "</span></div><br>", DateTime.Now.ToString("hh:mm:ss"), msg); writer.Write(text); } }Рис. 7-7. Элемент Web Part StockViewer в действии Основную работу здесь выполняет вспомогательный метод CreateTableOfStocks: void CreateTableOfStocks(HtmlTextWriter writer) { Table t = new Table(); //Заголовок CreateTableHeader(t); //Строки string[] list = _stocks.Split(new char[] { ',' });
278 Часть II Специализированные средства ASP.NET for (int i = 0; i < list.Length; i++) { string stockID = list[i]; TableRow row = new TableRow(); c1 = new TableCell(); c1.Text = stockID; row.Cells.Add(c1); //Данный ID будет использоваться для обновления //клиентского элемента управления с помощью //удаленного вызова сценария ASP.NET c2 = new TableCell(); c2.ID = "StockValue" + i.ToString(); c2.Text = GetCurrentValue(stockID); row.Cells.Add(c2); t.Rows.Add(row); } t.RenderControl(writer); } Каждая строка таблицы содержит две ячейки - одну для названия компании и еще одну для текущего значения. Количество строк равняется количеству компаний. Как уже упоминалось, свойство Stocks возвращает разделенную запятыми строку, содер-жимое которой для удобства обработки преобразуется в массив строк. Итоговый вид нашего компонента Web Part показан на рис. 7-7. Автоматическое обновление Элемент управления, предназначенный для отображения биржевых котировок, не может быть статичным. Как минимум, он должен предоставлять пользователю воз-можность периодически обновлять котировки (скажем, щелкая специальную кнопку). Но гораздо лучше, если Web Part будет делать это автоматически, с заданной пери-одичностью. Наш компонент StockViewer поступает именно так. Период обновления задается в нем в свойстве RefreshRate. Давайте посмотрим, как оно используется. Идея заключается в следующем. Web Part генерирует код для обратного вызова сценария, с тем чтобы клиентская страница регулярно обращалась к серверу, и тот присылал ей новые данные для обновления компонента. Для реализации такого реше-ния можно с успехом применить технологию ASP.NET Script Callback или Ajax.NET. Добавим в конец метода CreateTableOfStocks следующий код: if (RefreshRate > 0) {if (!Page.ClientScript.IsStartupScriptRegistered( this.GetType(), "RefreshQuotes")) { string js = GetRefreshScript(); Page.ClientScript.RegisterStartupScript( this.GetType(), "RefreshQuotes", js, true); } } Он регистрирует как стартовый некоторый код JavaScript, создающий таймер и периодически выполняющий параллельный вызов сервера для получения свежих котировок: private string GetRefreshScript() {
Страницы с элементами Web Parts Глава 7 279 StringBuilder sb; sb = new StringBuilder("\r\nfunction RefreshQuotes() {\r\n"); sb.AppendLine(Page.ClientScript.GetCallbackEventReference( this, "null", "UpdateQuotes", "null")); sb.AppendFormat(" window.setTimeout(\"RefreshQuotes()\", {0});", RefreshRate*1000); sb.AppendLine("\r\n}"); sb.AppendLine(GetUpdateQuotesScript()); sb.AppendLine("RefreshQuotes();"); return sb.ToString(); } Приведенный код генерирует следующий сценарий на языке JavaScript: function RefreshQuotes() { WebForm_DoCallback('WebMan$MyStocks', null, UpdateQuotes, null, null, false); window.setTimeout("RefreshQuotes()", 5000); } В результате каждые пять секунд клиентская страница осуществляет параллельный вызов серверного элемента Web Part и обновляет данные Web-части. Для этой цели применяется технология ASP.NET Script Callback. Элемент StockViewer - хороший пример пользовательского элемента управления, осуществляющего обратные вызовы сценария. Он извлекает актуальные котировки и выводит их на экран. Ниже приве-ден серверный код, реализующий механизм параллельного вызова. Вместо реальных котировок он просто возвращает случайные числа: private string results; void ICallbackEventHandler.RaiseCallbackEvent(string argument) { string buf = "," + _stocks; string[] list = buf.Split(new char[] { ',' }); list[0] = DateTime.Now.ToString("hh:mm:ss"); for (int i=1; i<list.Length; i++) { list[i] = GetCurrentValue(list[i]); } results = String.Join(",", list); return; }string ICallbackEventHandler.GetCallbackResult() { return results; } Как рассказывалось в главе 6, по завершении параллельного вызова сервера выпол-няется функция обратного вызова JavaScript, которая обновляет страницу. В данном случае эта функция обратного вызова содержит такой код: function UpdateQuotes(response, context) { var quotes = response.split(',');
280 Часть II Специализированные средства ASP.NET for(i=1; i<quotes.length; i++) { var elem = document.getElementById("StockValue" + (i-1).toString()); elem.innerHTML = quotes[i]; } var now = document.getElementById("LastUpdated"); now.innerHTML = quotes[0]; } Строка, полученная данной функцией от сервера, имеет следующую структуру: текущее_время, котировка1, ..., котировкаN Значения котировок извлекаются из нее и используются для обновления ячеек таблицы, в которых выводятся котировки, так же, как и время, которое выводится под таблицей. Примечание Полный исходный код этого и других приведенных в книге примеров до-ступен по адресу: http://www.microsoft.com/mspress/companion/0-7356-2177-2/. Для использования элемента StockViewer на странице нужна следующая разметка. (Разумеется, работая в Visual Studio 2005, все необходимые элементы управления вы можете разместить на странице путем перетаскивания.) <asp:WebPartManager ID="WebMan" runat="server" /> <asp:WebPartZone ID="WebPartZone1" runat="server" HeaderText="This is Zone #1" PartChromeType="TitleAndBorder"> <ZoneTemplate> <x:StockViewerWebPart runat="server" id="MyStocks" RefreshRate="5" Stocks="XYZ,MYCOMP,FOO,BAR" Title="Stock Viewer" /> </ZoneTemplate> </asp:WebPartZone> Если значение свойства RefreshRate больше нуля, создается клиентский таймер для периодического выполнения параллельных вызовов. Без такого таймера список котировок будет оставаться неизменным в течение всего времени просмотра страницы, если только вы не создадите кнопку для обновления их вручную. На рис. 7-8 показана автоматически обновляемая версия нашего элемента Web Part. Рис. 7-8. Компонент StockViewer обновляет биржевые котировки с периодичностью, определяемой значением его свойства RefreshRate
Страницы с элементами Web Parts Глава 7 281 Примечание В приведенном выше примере названия компаний, котировки акций ко-торых отслеживает StockViewer, являются вымышленными, а сами котировки - просто случайные числа. Код, отвечающий за извлечение текущего значения для выбранной компании, заключен внутрь метода GetCurrentValue. Достаточно вам переписать этот метод, и он будет возвращать реальные данные, а StockViewer из игрушки превратится в полезный компонент, который вы сможете использовать в собственных разработках. Другие способы создания элементов Web Parts Как упоминалось выше, наследование базового класса WebPart - лишь один из спосо-бов создания элементов Web Parts, хотя, пожалуй, его можно назвать самым гибким и мощным. Теперь давайте рассмотрим другие, более быстрые, но не менее эффек-тивные способы. Web Part как пользовательский элемент управления На рис. 7-4 была показана демонстрационная страница, содержащая два элемента Web Parts, созданных на базе пользовательских элементов управления. После регистрации такого элемента управления для страницы его можно использовать в составе зоны следующим образом: <ZoneTemplate> <x:News runat="server" id="News" /> <x:Favorites runat="server" id="Favs" /> </ZoneTemplate> Как выглядит код каждого из этих элементов? Их внутренняя структура поч-ти идентична. Оба они извлекают данные из связанного XML-файла и повторяют структуру каждого связанного элемента. Разница только в том, что их XML-файлы имеют разные наборы узлов, а значит деревья HTML, генерируемые этими элемен-тами, также получаются разными. Ниже приведен исходный код пользовательского элемента управления Favorites. <%@Control Language="C#" ClassName="MyFavorites"%> <asp:XmlDataSource ID="XmlData" runat="server" DataFile="/App_Data/webpartsdata.xml" XPath="WebPartsData/Favorite" /> <asp:Repeater ID="Repeater1" DataSourceID="XmlData" runat="server"> <HeaderTemplate> <h2>Your Favorites</h2> <ul> </HeaderTemplate> <SeparatorTemplate> <br /><br /> </SeparatorTemplate> <ItemTemplate> <li> <a href='<%# XPath("url")%>'><b><%# XPath("title")%></b></a> <br /> <span style="font-size:85%"> <%# XPath("description") %> </span> </li> </ItemTemplate> <FooterTemplate>
282 Часть II Специализированные средства ASP.NET </ul> </FooterTemplate> </asp:Repeater> Когда пользовательский элемент управления используется в составе зоны Web Parts, он заключается в оболочку, образованную экземпляром класса GenericWebPart. Данный класс наследует WebPart и, соответственно, содержит стандартную реализацию интерфейса IWebPart, а также других интерфейсов, связанных с компонентами Web Parts. Таким образом, для установки заголовка, подзаголовка и других визуальных свойств пользовательского элемента управления Web Part можно применить один из двух способов: написать собственную реализацию указанных интерфейсов, имеющихся в составе класса GenericWebPart, или полагаться на их реализацию по умолчанию. Для реализации интерфейса в пользовательском элементе управления следует воспользоваться директивой @Implements, как показано в следующем примере, где для Web Part Favorites переопределен интерфейс IWebPart: <%@Control Language="C#" ClassName="MyFavorites"%> <%@Implements Interface="System.Web.UI.WebControls.WebParts.IWebPart" %> <script runat="server"> private string _title = "Favorite Links"; string IWebPart.Title { get { return _title; } set { _title = value; } }//Реализация остальных членов интерфейса IWebPart </script> Интерфейс пользовательского элемента управления можно реализовать в классе отделенного кода. Если данный элемент управления не реализует интерфейсов Web Part, соответс-твующие свойства можно, тем не менее, использовать в разметке. Они распознаются благодаря тому, что определены в классе-оболочке GenericWebPart. Вот пример: <x:News runat="server" id="News" Title="News of the day" /> <x:Favorites runat="server" id="Favs" /> Теперь у обоих элементов управления Web Parts имеются пользовательские заго-ловки. Web Part News устанавливает их явно, через оболочку GenericWebPart, а Web Part Favorites - неявно, используя внутреннюю реализацию IWebPart. На рис. 7-9 показаны те же пользовательские элементы управления, что и на рис. 7-4, но пра-вильно озаглавленные. Web Parts как серверные элементы управления Как же упоминалось, для создания Web Parts можно использовать отдельные сервер-ные элементы управления. Достаточно поместить такой элемент управления в сегмент <ZoneTemplate> зоны Web Parts и проследить за тем, чтобы он был единственным в данном сегменте. Литералы игнорируются, но в случае обнаружения нескольких серверных элементов управления на их основе будет создано несколько элементов Web Parts. <ZoneTemplate> <asp:Calendar ID="Calendar1" runat="server" Title="Today" >
Страницы с элементами Web Parts Глава 7 283 <TodayDayStyle BackColor="#FF8000" /> </asp:Calendar> <asp:Wizard ID="Wizard1" runat="server" ActiveStepIndex="0"> <WizardSteps> <asp:WizardStep ID="WizardStep1" runat="server" Title="Step 1" /> <asp:WizardStep ID="WizardStep2" runat="server" Title="Step 2" /> </WizardSteps> </asp:Wizard> </ZoneTemplate> Приведенная разметка превращается в страницу, представленную на рис. 7-10. Рис. 7-9. Правильно озаглавленные пользовательские элементы управления Web Parts Рис. 7-10. Элементы управления Wizard и Calendar в разных Web Parts
284 Часть II Специализированные средства ASP.NET Заметьте, что атрибут Title серверного элемента управления можно использовать даже несмотря на то, что сам этот элемент знать не знает о свойстве Title. Это снова результат использования класса-оболочки GenericWebPart. Стили Web-зон Подобно любому другому серверному элементу управления Web Part может быть "украшен" с помощью стилей и визуальных свойств. Учтите, однако, что, поскольку он размещается в зоне, его оформление осуществляется автоматически в соответствии с ее визуальными установками. В частности, он наследует шрифт, цвет и параметры рамки и становится похожим на все остальные Web Parts этой зоны. Внешний вид его изменится, как только пользователь переместит его в другую зону, - он воспримет ее установки. Таково поведение Web Part по умолчанию, хотя он волен сам определять свой внешний вид, руководствуясь значениями собственных свойств и стилей. В таком случае его внешний вид не меняется при перемещении из одной зоны в другую. Обще-при нятой практикой, однако, является сохранение исходного поведения Web Part, поскольку в этом случае пользователь может настраивать зону по своему усмотрению, и все ее части выглядят единообразно. Свойства зоны, предназначенные для ее оформления Web-зона имеет серию свойств, предназначенных для настройки ее внешнего вида и входящих в ее состав Web Parts. Они перечислены в табл. 7-4. Табл. 7-4. Свойства, предназначенные для оформления зоны Свойство Описание EmptyZoneTextStyle Стиль пустой зоны на этапе изменения ее структуры ErrorStyle Стиль для вывода сообщения об ошибке, которое отображается, когда элемент Web Part не может быть загружен или создан; в таком случае вместо запрошенного элемента Web Part выводится элемент управления ErrorWebPart FooterStyle Стиль нижнего колонтитула зоны HeaderStyle Стиль верхнего колонтитула зоны MenuCheckImageStyle Стиль отметки, которая выводится в меню окна Web Part рядом с выбранной командой MenuLabelHoverStyle Стиль надписи, которая появляется в строке заголовка, когда пользователь наводит указатель мыши на кнопку меню, чтобы его открыть MenuLabelStyle Стиль надписи, которая представляет меню Web Part MenuPopupStyle Стиль раскрывающегося меню команд управления окном Web Part MenuVerbHoverStyle Стиль выделенного элемента меню MenuVerbStyle Стиль надписи, представляющей элемент меню PartChromeStyle Стиль рамки элементов Web Parts, содержащихся в зоне PartStyle Стиль границ и содержимого элементов Web Part, содержащихся в зоне PartTitleStyle Стиль строки заголовка элементов Web Part, содержащихся в зоне SelectedPartChromeStyle Стиль рамки выделенного элемента Web Part в режиме Edit TitleBarVerbStyle Стиль кнопок управления окном в строке заголовка зоны
Страницы с элементами Web Parts Глава 7 285 В Visual Studio 2005 очень помогает в оформлении зоны функция AutoFormat элемента управления WebPartZone (рис. 7-11). В большинстве случаев вы будете поль-зоваться ею, а не возиться с установкой перечисленных свойств вручную. Рис. 7-11. Оформление зоны с помощью функции AutoFormat в Visual Studio 2005 Свойства, управляющие поведением зоны Помимо свойств, служащих для оформления зоны, элемент управления Web Zone име-ет несколько свойств, управляющих ее поведением. Они перечислены в табл. 7-5. Табл. 7-5. Свойства Web Zone, которые управляют поведением зоны Свойство Описание AllowLayoutChange Указывает, разрешено ли добавлять элементы управления Web Parts в данную зону, удалять их из зоны и перемещать в ее пределах; по умолчанию имеет значение true DragHighlightColor Цвет заголовка зоны во время перетаскивания элемента Web Part в режиме Design EmptyZoneText Текст, который выводится в режиме Design, когда зона пуста LayoutOrientation Определяет, как элементы Web Parts упорядочиваются внутри зоны, - по вертикали (по умолчанию) или по горизонтали Padding Величина промежутков (в пикселах) между Web Parts в зоне ShowTitleIcons Указывает, должен ли в строке заголовка каждого элемента Web Part выводиться его значок WebPartVerbRenderMode Указывает, где должны выводиться команды управления Web Part - в меню или строке заголовка. По умолчанию используется раскрывающееся меню Команды (verbs) играют в технологии Web Parts очень важную роль. Каждая такая команда представляет действие, которое может быть выполнено элементом Web Part. Доступные команды нужно как-то отображать для пользователя. По умолчанию они выводятся в строке заголовка в составе раскрывающегося меню или в виде ссылок в правой ее части (рис. 7-12).
286 Часть II Специализированные средства ASP.NET Рис. 7-12. Команды выведены в правой части строки заголовка Web Part в виде ссылок Элемент Web Zone имеет несколько свойств, предназначенных для конфигуриро-вания команд, их активизации и отключения. Элементы Web Parts могут переопре-делять для себя установки, заданные на уровне зоны. Остановимся на этом моменте подробнее. Команды Web Parts Командами определяются действия, выполняемые пользователем над элементом Web Part как целым: свертывание, восстановление, редактирование или закрытие. Их набор конфигурируется для зоны, но может переопределяться или включаться/отключаться для каждого отдельного Web Part посредством свойств AllowXXX, описанных выше в табл. 7-2. Стандартные системные команды перечислены в табл. 7-6. Табл. 7-6. Системные команды Web Parts Команда Описание Close Закрывает Web Part и убирает его с экрана. Закрытый Web Part может быть воз-вращен в зону с использованием элемента Catalog Part (об этом я расскажу ниже) Connect Соединяет два элемента Web Parts, сконфигурированных для работы в режиме провайдера и потребителя (об этом также будет рассказано далее) Delete Удаляет Web Part со страницы. Удаленный Web Part уничтожается, и вернуть его на страницу нельзя Edit Выводит для текущего элемента Web Part элемент Editor Part для редактирования его свойств, отображаемых в браузере Export Позволяет конечному пользователю экспортировать данные Web Parts в XML-файл. Для того чтобы эта команда появилась в меню, свойство ExportMode эле-мента Web Part не должно быть установлено в WebPartExportMode.None Help Выводит справку Web Part либо путем перехода к заданной странице, либо от-крывая модальное или немодальное окно. Чтобы эта команда появилась в меню, должно быть установлено свойство HelpUrl элемента Web Part Minimize Сворачивает окно Web Part Restore Восстанавливает свернутое окно Web Part Учтите, что свойства, связанные с командами, принадлежат не отдельным эле-ментам Web Parts, а зоне, то есть для всех элементов Web Parts одной зоны заданы одинаковые установки этих свойств, хотя и может быть запрещено выполнение от-дельных команд.
Страницы с элементами Web Parts Глава 7 287 Так, команду Close можно запретить следующей установкой: <CloseVerb Enabled="false" /> Команда, запрещенная для всей зоны, не может быть разрешена на уровне отде-льного элемента Web Part с помощью соответствующего свойства AllowXXX. Напри-мер, запрет, наложенный приведенной выше установкой, нельзя отменить, задав для отдельного элемента Web Part значение true атрибута AllowClose. Обратное, однако, возможно - команда, разрешенная для зоны, может быть запрещена для ее части. Предположим, что для зоны задана следующая установка: <MinimizeVerb Enabled="true" /> Тогда для отдельного элемента Web Part вы можете установить AllowMinimize в false и тем блокировать попытки пользователя свернуть его окно. Команды представлены объектами WebPartVerb, у которых есть несколько свойств, включая Description (всплывающая подсказка), Text (текст либо заменяющий текст, если используется изображение) и ImageUrl (изображение). Список членов класса WebPartVerb завершает пара булевых свойств - Enabled и Visible, - которые опреде-ляют доступность и видимость команды в меню. Определение пользовательской команды Помимо стандартных команд элемент Web Part может иметь и свои собственные. Их определяют с помощью интерфейса IWebActionable, состоящего из единственного свойства - Verbs. Если вы создаете Web Part как классический серверный элемент управления, свойство Verbs необходимо переопределить, поскольку оно уже опре-делено в составе класса, наследующего класс Part. Если же Web Part создается как пользовательский элемент управления, вы реализуете интерфейс IWebActionable в этом пользовательском элементе. Ниже показано, как добавить пользовательскую команду Refresh в наш демонстрационный элемент StockViewer: private WebPartVerbCollection _verbs; public override WebPartVerbCollection Verbs { get { if (_verbs == null) { ArrayList a = new ArrayList(); WebPartVerb verb = new WebPartVerb("Refresh", new WebPartEventHandler(RefreshQuotesFromMenu)); verb.Text = "Refresh"; a.Add(verb); _verbs = new WebPartVerbCollection(base.Verbs, a); } return _verbs; } } Вы сохраняете команды в закрытом члене типа WebPartVerbCollection. Коллекция Verbs будет содержать только новые команды. Однако хорошая практика - объе динять пользовательские команды, определенные в базовом классе, с командами разрабаты-ваемого вами класса. (Это делается автоматически при создании нового экземпляра 
288 Часть II Специализированные средства ASP.NET класса WebPartVerbCollection в приведенном фрагменте кода.) Каждая команда пред-ставляет собой экземпляр класса WebPartVerb. Помимо свойств, которые мы коротко описали в предыдущем разделе, команда может иметь два обработчика событий - клиентский и серверный. Их можно определять, используя конструктор. Согласно приведенному выше фрагменту кода при выборе команды Refresh страница Web Part осуществляет возврат формы и выполняется код метода RefreshQuotesFromMenu. Соответствующего клиентского кода в данном случае нет. На рис. 7-13 показан Web Part StockViewer с пользовательской командой Refresh в строке заголовка. Рис. 7-13. Пользовательская команда Refresh в строке заголовка Web Part Заметьте, что подобно стандартным командам пользовательская может выводиться в виде ссылки в строке заголовка или же в раскрывающемся меню, в зависимости от установок зоны. Сохранение персонализованных данных Web Part Типичная страница, созданная по технологии Web Parts, по определению является персонализованной. Когда пользователь изменяет раскладку страницы, ее новый вариант должен быть сохранен и должен использоваться при следующем посещении данной страницы. В ASP.NET 2.0 вам не придется писать для этого ни строчки кода. Требуется лишь сконфигурировать приложение, чтобы оно работало с нужным про-вайдером персонализации. В общем случае это просто означает, что вам необходимо убедиться в существовании действующего файла aspnetdb.mdf в папке App_Data или в наличии альтернативной таблицы SQL Server, заданной в файле web.config. (О про-вайдерах персонализации Web Parts рассказывалось в главе 4.) Технология персонализации позволяет сохранять свойства и состояние элементов Web Parts в долговременном хранилище. Необходимо различать данные персонали-зации и данные состояния представления, поскольку последние относятся к конк-ретному запросу или сеансу подключения браузера. Не следует также путать данные персонализации с данными пользовательских профилей, которые индивидуальны для каждого пользователя, но одинаковы для всего приложения. Данные персонализации Web Part уникальны для пользователя и для страницы. По способу применения ин-формация персонализации делится на две категории: индивидуальная (по умолчанию) и совместно используемая. Соответственно она хранится в двух разных местах. На-пример, при использовании базы данных SQL Server это две разные таблицы. Когда страница выполняется в режиме персонализации User (индивидуальный), менеджер Web Parts загружает и сохраняет персонализационные данные для каждого пользователя. Это означает, что свойства Web Part, помеченные как User, загружа-ются и сохраняются, а свойства, помеченные как Shared (совместно используемые), загружаются, но не сохраняются. Свойство Web Part помечается как User или Shared 
Страницы с элементами Web Parts Глава 7 289 посредством атрибута [Personalizable], который вам уже знаком. У него есть несколько перегруженных версий: [Personalizable(PersonalizationScope scope)] [Personalizable(PersonalizationScope scope, bool isSensitive)] Посредством первой из них задается режим персонализации - User или Shared, а с помощью второй можно также указать, должны ли данные свойства считаться конфиденциальными. Применяя атрибут [Personalizable] без параметров (как было сделано в примере StockViewer), вы тем самым оставляете значения по умолчанию: режим персонализации - User, данные не конфиденциальны. Когда страница выпол-няется в режиме персонализации Shared, менеджер Web Parts загружает только те свойства, которые помечены как Shared, то есть те, значения которых относятся ко всем пользователям. В зависимости от прав текущего пользователя эти данные могут быть модифицированы и записаны в хранилище. Режим персонализации страницы можно задавать статически, в элементе разметки <asp:WebPartManager>, или программно - в обработчике события PreInit. WebPartManager1.Personalization.InitialScope = PersonalizationScope.Shared; По умолчанию страница, созданная по технологии Web Parts, выполняется в режиме User. У свойства Personalization есть и другие интересные свойства - такие как Toggle-Scope, служащее для переключения между двумя режимами персонализации, и Provider, возвращающее текущий экземпляр провайдера персонализации (см. главу 4). Совет Данные персонализации Web Part хранятся в постоянной памяти и никогда не устаревают. Но вам может потребоваться их сбросить. Если вам известна структура хранилища данных провайдера (по умолчанию это база данных aspnetdb.mdf), вы можете очистить любые хранящиеся там параметры. Если же такие подробности вам не извес-тны или вы как разработчик не имеете разрешений на доступ к хранилищу данных, то можете очистить данные персонализации программным способом: WebPartManager1.Personalization.ResetPersonalizationState(); Метод ResetPersonalizationState выполняет сброс всего сохраненного состояния текущей страницы - как индивидуального, так и общего. Таким образом, режим персонализации определяет, к каким пользователям отно-сятся те или иные данные персонализации. Данные, помеченные как User, применя-ются только к одному конкретному пользователю и элементу Web Part на заданной странице. Данные, помеченные как Shared, применяются ко всем пользователям, просматривающим любую страницу сайта. При создании Web Part с открытыми свойствами большинство из них вы будете определять как User, то есть индивиду-альные данные пользователя, работающего с конкретным элементом Web Part на определенной странице. Для этого достаточно использовать атрибут [Personalizable] без параметров. Внимание! Следует отметить, что когда текущий пользователь не аутентифицирован, всегда используется режим персонализации Shared. Кроме того, текущему пользовате-лю не разрешается изменять состояние персонализации. Типичным следствием такой ситуации является то, что когда вы перемещаете элементы Web Part из одной зоны в другую или изменяете значения их свойств, при попытке сохранения нового состояния генерируется исключение.
290 Часть II Специализированные средства ASP.NET Редактирование Web Parts и вывод их списка Помимо прочего, менеджер Web Parts отвечает за установку текущего режима отобра-жения элементов Web Parts. Режим отображения определяет, как Web Parts выводятся в своих зонах и требуется ли для них дополнительный пользовательский интерфейс или функциональность. Изменение режима отображения отражается на таких опера-циях, как перемещение элементов Web Parts между зонами, редактирование свойств отдельных Web Parts, добавление или удаление Web Part и соединение двух Web Parts для обмена информацией. Изменение режима отображения Для того чтобы сменить режим отображения, нужно присвоить новое значение свой-ству DisplayMode менеджера Web Parts: WebPartManager1.DisplayMode = mode; Предопределенного элемента пользовательского интерфейса (скажем, меню), пред-назначенного для этого, не существует, и если вы хотите предоставить пользователю возможность изменять режим отображения, вам придется разработать соответству-ющий интерфейс самостоятельно. С этой целью чаще всего применяется элемент управления Menu, список переключателей или раскрывающийся список доступных режимов. Рассмотрим характеристики разных режимов отображения. Поддерживаемые режимы отображения В табл. 7-7 перечислены все доступные режимы отображения Web Parts ASP.NET. По умолчанию действует режим Browse, то есть на экран выводится только содержимое Web Parts, без каких-либо дополнительных элементов пользовательского интерфейса. Табл. 7-7. Режимы отображения Режим Описание Browse Web Parts выводят только собственный контент; никакие дополнительные функции не доступны и никакие дополнительные элементы управления поль-зовательского интерфейса не выводятся Catalog На экран выведены все элементы Catalog Parts, связанные с текущей страни-цей, и пользователь может добавлять на страницу новые Web Parts, выбирая их в каталоге или импортируя из внешних файлов, где они были сохранены в сери-ализованной форме Connect Пользователь имеет возможность соединять элементы Web Part, чтобы один из них стал потребителем, а другой - поставщиком данных Design Пользователь может перемещать Web Parts внутри зоны и из одной зоны в другую Edit На экран выведены все элементы Catalog Parts, связанные с текущей страни-цей, и пользователь может модифицировать атрибуты отдельных элементов управления Web Parts. Для каждого семейства свойств (представляющих вне-шний вид, поведение Web Part или пользовательских) определен свой редактор Когда активен режим Design, конечные пользователи могут перемещать элементы Web Parts с помощью мыши. Необходимый для этого код сценария автоматически вставляется в клиентскую страницу. Подобно режиму Browse режим Design досту-пен всем и всегда. Что касается режимов Edit, Catalog и Connect, то они доступны 
Страницы с элементами Web Parts Глава 7 291 только в том случае, когда страница содержит зону редактора, зону каталога или зону соединений соответственно. Для того чтобы узнать, какие режимы доступны в конкретный момент времени, обратитесь к свойству SupportedDisplayModes класса WebPartManager. Создание пользовательского элемента управления, предназначенного для переключения режимов отображения В качестве средства переключения режимов отображения страницы, созданной по технологии Web Parts, я предпочитаю использовать раскрывающийся список режимов, как показано на рис. 7-14. Рис. 7-14. Раскрывающийся список режимов отображения Структура этого элемента управления очень проста. После загрузки он заполняется названиями режимов, возвращенными свойством-коллекцией SupportedDisplayModes класса WebPartManager. Список конфигурируется таким образом, чтобы при выборе в нем значения автоматически выполнялся возврат формы. При таком возврате на сервере обновляется свойство DisplayMode менеджера Web Parts, и страница возвра-щается пользователю в обновленном виде. Следующий код представляет собой пол-ную реализацию пользовательского элемента управления - переключателя режимов modeswitcher.ascx. <%@Control Language="C#" ClassName="ModeSwitcher" %> <script runat="server"> WebPartManager wpm; void Page_Load(object sender, EventArgs e) { wpm = WebPartManager.GetCurrentWebPartManager(Page); if (!IsPostBack) { foreach (WebPartDisplayMode mode in wpm.SupportedDisplayModes) { if (mode.IsEnabled(wpm)) SupportedModes.Items.Add(mode.Name); } } }
292 Часть II Специализированные средства ASP.NET public void SelectedIndexChanged(object sender, EventArgs e) { string selectedMode = SupportedModes.SelectedValue; WebPartDisplayMode mode = wpm.SupportedDisplayModes[selectedMode]; if (mode != null) wpm.DisplayMode = mode; }</script> <asp:DropDownList ID="SupportedModes" runat="server" AutoPostBack="true" OnSelectedIndexChanged="SelectedIndexChanged" /> Разумеется, подобный компонент можно написать, используя классический сер-верный элемент управления. Однако это один из тех случаев, когда проявляются достоинства пользовательских элементов управления - их легко изучить, легко со-здавать, а главное - они эффективны. (Мы вернемся к ним в главе 12.) Для применения данного переключателя режимов на демонстрационной странице его нужно зарегистрировать: <%@Page Language="C#" CodeFile="Portal.aspx.cs" Inherits="Portal" %> <%@Register tagprefix="x" tagname="Mode" src="ModeSwitcher.ascx" %> <x:Mode runat="server" id="Switcher" /> А теперь посмотрим, как изменяется пользовательский интерфейс зон Web Parts в разных режимах отображения. Изменение раскладки зоны Для дальнейшего изучения технологии Web Parts нам потребуется демонстрационная страница, представляющая полные ее возможности, чтобы мы могли исследовать все режимы отображения Web Parts. Эта страница содержит несколько зон и разные элементы Web Parts. Разработка демонстрационной страницы Ниже приведен базовый код, необходимый для создания зоны Web Parts. Однако для привлечения внимания пользователя вы можете оформить зону, применяя красочные стили. Проще всего воспользоваться для этого функцией меню AutoFormat дизайнера Visual Studio 2005 (см. рис. 7-11). Чтобы не усложнять код, в данном примере я не применял стилевое оформление. <asp:WebPartZone ID="WebPartZone1" runat="server" HeaderText="Zone #1"> <ZoneTemplate> <x:News runat="server" id="News" Title="News of the day" /> <x:Favorites runat="server" id="Favs" /> </ZoneTemplate> </asp:WebPartZone> <asp:WebPartZone ID="WebPartZone2" runat="server" HeaderText="Zone #2"> <ZoneTemplate> <asp:Calendar ID="Calendar1" runat="server" Title="Today" /> <asp:Wizard ID="Wizard1" runat="server" ActiveStepIndex="0"> <WizardSteps>
Страницы с элементами Web Parts Глава 7 293 <asp:WizardStep ID="WizStep1" runat="server" Title="Step 1" /> <asp:WizardStep ID="WizStep2" runat="server" Title="Step 2" /> </WizardSteps> </asp:Wizard> <x:StockViewerWebPart runat="server" id="MyStocks" Title="Stock Viewer" RefreshRate="5" Stocks="XYZ,MYCOMP,FOO,BAR" /> </ZoneTemplate> </asp:WebPartZone> Как видите, вторая зона содержит три элемента Web Parts, два из которых - Calendar и Wizard (упрощенный) - чисто серверные. Заметьте, что эти зоны могут иметь разные наборы команд, и их можно по-разному оформить. Как я уже не раз подчеркивал в этой главе, основное назначение Web Parts - вы-вод персонализированного контента, а потому само собой разумеется, что страницы, созданные на основе данной технологии, должны просматриваться аутентифици-рованными пользователями. В свете этого было бы хорошо выводить на странице имя аутентифицированного пользователя, а также предоставлять ссылку для выхода (сброса данных аутентификации). В ASP.NET 2.0 для этой цели предназначены два новых элемента управления. С помощью следующей разметки создается горизонтальная панель, на которой отображается имя пользователя (элемент управления LoginName), ссылка для вы-хода (элемент управления LoginStatus) и элемент управления, который служит для переключения режимов у правого края панели (см. рис. 7-14). <table width="100%" bgcolor="cyan"> <tr> <td align="left"> <asp:LoginName runat="server" ID="LoginName1" FormatString="Welcome, <b>{0}</b>" /> <asp:LoginStatus runat="server" id="LoginStatus1" /> </td> <td align="right"> <x:ModeSwitcher runat="server" id="Switcher" /> </td> </tr> </table> Перемещение Web Parts Пользователи могут перемещать Web Parts вверх и вниз в пределах зоны, а также из одной зоны в другую. Но для этого им сначала нужно переключиться в режим Design. В этом режиме активизируются возможности перетаскивания. Будучи перемещенным в другую зону, Web Part автоматически наследует ее визуальные установки, включая строку состояния и команды. На рис. 7-15 зафиксирован момент перемещения ком-понента Today из Zone #2 в Zone #1. Горизонтальная линия между двумя Web Parts в Zone #1 указывает, куда будет вставлен Web Part. Когда пользователь перетаскивает Web Part, та зона, куда он попадет, если поль-зователь его отпустит, очерчивается рамкой. Окончив формирование структуры зон, пользователь может снова выбрать режим Browse, чтобы вернуться к стандартному представлению страницы.
294 Часть II Специализированные средства ASP.NET Рис. 7-15. В режиме Design можно перемещать Web Parts между зонами путем перетаскивания Примечание Операции перетаскивания реализуются в клиентском сценарии, для чего необходима поддержка со стороны DOM браузера. Когда Web Part помещается в новую позицию, происходит автоматический возврат формы для сохранения новой раскладки зоны в хранилище данных персонализации. Если по окончании операции перетаскивания позиция Web Part не изменилась (то есть пользователь поместил его туда, где он и был), возврат формы не производится. Операции перетаскивания поддерживаются только в браузерах Internet Explorer. Имейте это в виду, разрешая пользователям переключаться в режим Design - не забывайте сначала узнать тип браузера и, если им окажется не Internet Explorer, сделать данный режим недоступным. Создание Editor Zone Для обеспечения возможности динамического редактирования страницы, построенной по технологии Web Parts, первым делом следует определить зону редактирования. Соответствующий элемент управления называется EditorZone. На странице нужна только одна такая зона, содержащая несколько редакторов. ASP.NET поддерживает целый ряд специализированных типов редакторов: один используется для изменения значений открытых свойств Web Part, другой - для настройки поведения Web Part, третий - для изменения его структуры, четвертый - внешнего вида и т. д. Режим редактирования Для добавления на страницу зоны редактирования нужно включить в ее состав сле-дующий код: <asp:EditorZone runat="server"> <ZoneTemplate>
Страницы с элементами Web Parts Глава 7 295 <asp:AppearanceEditorPart runat="server" /> <asp:LayoutEditorPart runat="server" /> <asp:PropertyGridEditorPart runat="server" /> </ZoneTemplate> </asp:EditorZone> Как обычно, я не использовал здесь стили, чтобы его не усложнять. В разделе <ZoneTemplate> перечисляются редакторы, которые должны быть доступны. Зона редактирования отображается только в режиме Edit и точно в том месте, которое вы для нее определили. Совет Как правило, на странице определяют табличную структуру и назначают свои типы зон - для Web Parts, Editor Parts, Catalog Parts или соединений - отдельным ее ячейкам. В типичной таблице перечисленные зоны располагаются в крайнем справа столбце. При активизации режима редактирования страницы у всех ее Web Parts появля-ется новая команда - Edit. Способ ее представления (в виде ссылки или элемента меню) зависит от установок зоны. Внешне режим Edit очень похож на режим Design, и пользователи могут делать в нем все то же самое, что и в режиме Design (с поправ-кой на тип браузера). Для того чтобы приступить к редактированию конкретного элемента Web Part, пользователь должен выбрать его команду Edit. В результате на экране появятся все зарегистрированные редакторы, как показано на рис. 7-16. Как видите, теперь у редактируемого Web Part нет команды Edit, но все остальные команды по прежнему присутствуют в его меню. Рис. 7-16. Пользовательский интерфейс редактирования установок выбранного элемента Web Part
296 Часть II Специализированные средства ASP.NET Компоненты Editor Parts В табл. 7-8 перечислены типы компонентов Editor Parts. Для одной зоны можно выбрать несколько редакторов. Все они будут отображаться в ней в заданном вами порядке. Табл. 7-8. Editor Parts Редактор Описание AppearanceEditorPart Позволяет редактировать визуальные установки, такие как ширина, заголовок, направление текста и тип рамки BehaviorEditorPart Позволяет изменять отдельные настройки поведения, в частности указывать, поддерживает ли Web Part редактирование и свертывание. Этот элемент Editor Part позволяет также редактировать справку и ссылки в строке заголовка LayoutEditorPart Дает возможность задать состояние окна (нормальное или сверну-тое) и указать, какой зоне принадлежит данный Web Part, а также изменить индекс Web Part в выбранной зоне PropertyGridEditorPart Служит для редактирования пользовательских свойств Web Part. Пользовательским называется открытое свойство, определен-ное в классе, производном от WebPart, и помеченное атрибутами [Personalizable] и [WebBrowsable] В нижней части зоны редактора располагается стандартная панель инструментов с кнопками, предназначенными для сохранения изменений и выхода из режима ре-дактирования (OK), сохранения с продолжением редактирования (Apply) и выхода без сохранения (Cancel). Изменения записываются в хранилище данных персонализации. Эта функция предоставляется исполняющей средой ASP.NET 2.0 и дополнительного кодирования не требует. Внимание! Чтобы редактор свойств появился на экране, у Web Part должны иметь-ся персонализируемые и отображаемые в браузере (browsable) свойства. Для сервер-ных и пользовательских элементов управления это свойства, помеченное атрибутами [Personalizable] и [WebBrowsable]. Использование полей не допускается. Создание Catalog Zone В зоне каталога сгруппированы компоненты, обеспечивающие пользователю возмож-ность добавлять Web Parts на страницу во время выполнения. В каталоге выводится список Web Parts, которые пользователь может размещать на странице. Кроме того, он действует как хранилище Web Parts, удаленных со страницы пользователем. Для отображения каталога пользователь должен перейти в режим Catalog. Режим Catalog В приведенном ниже коде показано, как можно добавить на страницу зону каталога. Все каталоги, которые будут использоваться в этой зоне, перечисляются в разделе <ZoneTemplate> . Оформление я, как обычно, опустил. <asp:CatalogZone ID="CatalogZone1" runat="server"> <ZoneTemplate> <asp:PageCatalogPart ID="PageCatPart1" runat="server" /> <asp:DeclarativeCatalogPart ID="DeclCatPart1" runat="server"> </asp:DeclarativeCatalogPart>
Страницы с элементами Web Parts Глава 7 297 <asp:ImportCatalogPart ID="ImportCatalogPart1" runat="server" /> </ZoneTemplate> </asp:CatalogZone> Как видите, существует несколько типов каталогов с разными характеристиками и наборами функций; они описаны в табл. 7-9. Табл. 7-9. Типы элементов Catalog Parts Каталог Описание DeclarativeCatalogPart Содержит список Web Parts, не присутствующих в исходной раскладке страницы, но доступных для размещения на ней поль-зователем ImportCatalogPart Позволяет пользователю импортировать элемент Web Part, экспортированный во внешний файл с другой страницы PageCatalogPart Содержит список Web Parts, которые первоначально присутствовали на странице, но потом были удалены Пример каталога вы видите на рис. 7-17. Здесь перечислены закрытые Web Parts, и пользователь может вернуть их на страницу, добавив в любую из зон. Рис. 7-17. Каталог Web Parts Элементы Catalog Parts выводятся на странице в той последовательности, в какой они объявлены в разделе CatalogZone. Зона каталога предоставляет список ссылок для отображения пользовательского интерфейса каждого каталога. Интерфейс первого из них выводится автоматически.
298 Часть II Специализированные средства ASP.NET Каталог DeclarativeCatalogPart Элемент управления DeclarativeCatalogPart содержит список Web Parts, которые поль-зователь может по своему желанию добавлять на страницу. Эти Web Parts статически объявлены в исходном файле .aspx в дочернем разделе WebPartsTemplate, как показано ниже: <asp:DeclarativeCatalogPart runat="server"> <WebPartsTemplate> <x:WeatherWebPart runat="server" zipcode="00015" /> <x:BookFinder runat="server" author="Dino Esposito" /> </WebPartsTemplate> </asp:DeclarativeCatalogPart> Web Parts, которыми управляет DeclarativeCatalogPart, не создаются до тех пор, пока пользователь явно не добавит их на страницу. Для просмотра списка Web Parts, доступных пользователю, нужно щелкнуть соот-ветствующую ссылку в зоне каталога. На рис. 7-18 показан типичный пользователь-ский интерфейс каталога типа DeclarativeCatalogPart. Рис. 7-18. В каталоге представлены дополнительные Web Parts, которые пользователь может поместить на страницу После добавления на страницу Web Part становится ее частью, и если его потом закрыть, его имя будет добавлено в каталог закрытых Web Parts. Внимание! Заголовки элементов Catalog Parts и Editor Parts, отображаемых в режимах Catalog и Edit соответственно, можно изменять, используя свойство Title. Так, на рис. 7-18 панель каталога DeclarativeCatalogPart озаглавлена "Optional Web Parts".
Страницы с элементами Web Parts Глава 7 299 Импорт и экспорт Web Parts Каталог ImportCatalogPart предоставляет интерфейс (рис. 7-19), посредством которого пользователи могут импортировать Web Part из другой страницы или даже другого приложения через файл .webpart. Такой файл создается при экспорте Web Part со страницы. Рис. 7-19. Пользовательский интерфейс для импорта Web Part Web Part нельзя экспортировать, если его свойство ExportMode имеет значение, отличное от None, присвоенного ему по умолчанию. Чтобы разрешить экспорт всех свойств, нужно установить ExportMode в All: <asp:StockViewerWebPart runat="server" ExportMode="All" ... /> Чтобы разрешить экспорт свойств, не содержащих конфиденциальные данные, свойству ExportMode присваивают значение NonSensitiveData. (Напомню, что конфи-денциальность свойства определяется атрибутом [Personalizable].) Когда Web Parts разрешено экспортировать, в строке заголовка или в меню присутствует команда Export. При ее выборе появляется окно с предупреждением о том, что вы можете случайно экспортировать конфиденциальные данные (рис. 7-20). Рис. 7-20. Сообщение с предупреждением о риске экспортирования конфиденциальных данных
300 Часть II Специализированные средства ASP.NET Независимо от установок экспортирования, заданных для конкретного Web Part, приложение должно явно разрешить экспорт Web Parts. Для этого вам необходимо установить атрибут enableExport в разделе <webParts> файла web.config. <webParts enableExport="true" /> Экспортируются только те свойства, которые помечены атрибутом [Personalizable]. Как упоминалось ранее, с помощью этого атрибута можно указать, содержит ли свойс-тво конфиденциальные данные. Файл .webpart загружается на клиентский компьютер в папку, которую укажет пользователь. Его содержимое - это чистый XML: <?xml version="1.0" encoding="utf-8"?> <webParts> <webPart> <metaData> <type name="ProAspNet20.StockViewerWebPart, ProAspCompLib" /> <importErrorMessage>Cannot import this Web Part.</importErrorMessage> </metaData> <data> <properties> <property name="AllowClose" type="bool">True</property> <property name="ExportMode" type="exportmode">All</property> </properties> </data> </webPart> </webParts> Полученный файл .webpart можно скопировать на другой компьютер и импорти-ровать в другое приложение. После импорта Web Part будет выглядеть в точности так, как в исходном приложении. Соединение Web Parts Web Parts, расположенные на одной странице, могут взаимодействовать друг с дру-гом, обмениваясь данными. Для этого в каждом из них должны быть реализованы необходимые интерфейсы. Взаимодействие является односторонним и осуществля-ется с использованием сервисов специального объекта-соединения. Данный объект создает канал между двумя Web Parts, один из которых является потребителем, а дру-гой - поставщиком данных. Когда два Web Parts соединены между собой, измене-ния данных провайдера немедленно отражаются в потребителе. Очевидно, что такая модель хорошо подходит для представления данных, организованных по принципу "главный-подчиненный". Модель соединения Web Parts Модель соединения Web Parts определяет две взаимосвязанные сущности: соедине-ние и точка подключения. Соединение представляет связь двух точек - провайдера и потребителя. Управляет соединениями менеджер Web Parts. Каждый Web Part может взаимодействовать с несколькими Web Part.
Страницы с элементами Web Parts Глава 7 301 Соединяемые Web Parts Соединения можно определять двумя способами, которые не являются взаимо-исключающими: статически и динамически. Статические соединения декларативно перечисляются в теле менеджера Web Parts; динамическими управляет пользователь посредством зоны соединений. При обсуждении соединений мы будем использовать в качестве примера следующие Web Parts: <ZoneTemplate> <x:EmployeesWebPart runat="server" id="emp" Title="Employee Info" /> <x:OrdersWebPart runat="server" id="ord" Title="Orders 1997" /> </ZoneTemplate> Предположим, что эти два Web Parts содержатся в одной Web-зоне и их нужно соединить. Для этого они должны иметь определенную внутреннюю структуру: один необходимо сконфигурировать как потребитель, а другой - как провайдер. Создание статического соединения Web Parts Для того чтобы определить статическое соединение двух Web Parts, нужно добавить в объявление менеджера Web Parts узел <StaticConnections>: <asp:WebPartManager runat="server" id="WebPartManager1"> <StaticConnections> <asp:WebPartConnection ID="Conn1" ProviderID="emp" ProviderConnectionPointID="EmployeeIDProvider" ConsumerID="ord" ConsumerConnectionPointID="EmployeeIDConsumer" /> </StaticConnections> </asp:WebPartManager> Соединение идентифицируется объектами провайдера и потребителя; для каждого задается идентификатор и имя точки подключения. Свойства соединения ProviderID и ConsumerID должны соответствовать идентификаторам соединяемых объектов, а свойства ConsumerConnectionPointID и ProviderConnectionPointID - именам их точек подключения. Для использования статического соединения зону соединений определять не обя-зательно - оно автоматически активизируется при открытии страницы. Создание динамического соединения Web Parts Динамические соединения дают пользователю возможность интерактивно соединять и разъединять Web Parts. Для этого на странице должна присутствовать зона соеди-нений: <asp:ConnectionsZone ID="ConnectionsZone1" runat="server" /> Эта зона не может содержать дочерних узлов и текста, за исключением узлов, определяющих ее стили. Если для страницы определена такая зона, менеджер Web Parts добавляет в список доступных режимов отображения режим Connect. Когда он активен, в меню Web Parts, допускающих соединение, появляется дополнительная команда Connect.
302 Часть II Специализированные средства ASP.NET В результате выбора этой команды отображается пользовательский интерфейс, предназначенный для соединения зон и зависящий от того, является данный элемент Web Parts потребителем или провайдером. Этот интерфейс представлен на рис. 7-21. На снимке справа показано то, что пользователь видит после щелчка на ссылке в окне, расположенном слева. Рис. 7-21. Установка соединения между провайдером и потребителем Примечание Если один из двух соединенных Web Parts закрыть, а потом открыть, соединение будет разорвано, и его придется создавать заново. Точки подключения и интерфейсы Теперь давайте подробнее рассмотрим, как соединяются два Web Parts. Выше упоми-налось, что соединение устанавливается с использованием точек подключения явного коммуникационного контракта. Наличие точки подключения не гарантирует возможность взаимодействия с Web Part - она просто является средством для создания коммуникационного канала меж-ду двумя Web Parts. Точка подключения может действовать как провайдер или как потребитель. Взаимодействие между провайдером и потребителем определяется коммуникаци-онным контрактом. Такой контракт представляет собой интерфейс, реализованный в провайдере. Интерфейс может содержать свойства, события и методы, используемые потребителем после установки соединения. Потребитель не должен реализовывать какой-либо интерфейс, но должен знать об интерфейсах, поддерживаемых провай-дером. Создание схемы "главный-подчиненный" Предположим, что у нас есть два Web Parts, наследующих базовый класс WebPart. Провайдер называется EmployeesWebPart; он выводит информацию о выбранном со-труднике. Пользуясь простой формой, пользователь вводит идентификатор сотрудни-ка и получает его персональные данные. Этот идентификатор Web Part экспортирует посредством коммуникационного контракта. Имя потребителя - OrdersWebPart; он получает идентификатор сотрудника и вы-водит заказы, принятые им в текущем году. Таким образом, соединение описанных компонентов устанавливает между ними отношения "главный-подчиненный".
Страницы с элементами Web Parts Глава 7 303 Провайдер При создании Web Part, который будет служить провайдером, в первую очередь нуж-но определить коммуникационный контракт для точки подключения. Этот контракт определяется в виде интерфейса: interface IEmployeeInfo { int EmployeeID { get; set; } } Наш демонстрационный компонент EmployeesWebPart является пользовательским элементом управления ASP.NET, производным от WebPart; он реализует интерфейс контракта следующим образом: public class EmployeesWebPart : WebPart, IEmployeeInfo { private int _empID; public int EmployeeID { get { return _empID; } set { _empID = value; } } } Для того чтобы значение свойства EmployeeID выводилось в редакторе свойств, оно помечено как отображаемое в браузере и персонализируемое. [Personalizable(true)] [WebBrowsable(true)] public int EmployeeID { get { return _empID; } set { _empID = value; } } Следующим шагом является создание точки подключения провайдера. Вы опре-деляете функцию, возвращающую экземпляр текущего класса, и помечаете ее атри-бутом [ConnectionProvider]. Эта функция создает точку подключения, основываясь на интерфейсе IEmployeeInfo: [ConnectionProvider("EmployeeIDProvider", "EmployeeIDProvider")] public IEmployeeInfo GetEmployeeInfo() { return this; }
304 Часть II Специализированные средства ASP.NET Имя точки подключения должно соответствовать значению свойства ProviderName (если она провайдерная) или ConsumerName (если она потребительская), заданного в тэге <asp:WebPartConnection>. Примечание Когда провайдерный элемент WebPart реализует один провайдерный ин-терфейс, как в данном примере, нет нужды явно упоминать этот интерфейс в атрибуте ConnectionProvider. Но когда элемент поддерживает несколько интерфейсов, вы должны добавить в данный атрибут третий параметр, идентифицирующий контракт, на котором основано соединение. Потребитель Код для элемента Web Part, действующего как потребитель, написать еще проще. У него единственная задача - обеспечить создание потребительской точки подклю-чения для заданного интерфейса. [ConnectionConsumer("EmployeeIDConsumer", "EmployeeIDConsumer")] private void GetEmployeeInfo(IEmployeeInfo empInfo) { if (empInfo != null) { _empID = empInfo.EmployeeID; FindEmployeeInfo(); } else throw new Exception("No connection data found."); } Эта точка подключения автоматически создается исполняющей средой ASP.NET и соответствует методу, который помечен атрибутом [ConnectionConsumer]. Указанный метод используется в качестве функции обратного вызова при изменении данных провайдера. Пользовательский интерфейс нашего демонстрационного компонента составляет единственный элемент управления DataGrid, заполняемый результатами запроса к таблице Orders базы данных Northwind. Сводим все вместе Теперь давайте посмотрим на код разметки, определяющий для страницы объект статического соединения Web Parts (для динамического соединения никакого кода вы не найдете ни в разметке, ни в файле отделенного кода, поскольку оно создается посредством пользовательского интерфейса зоны соединений). <StaticConnections> <asp:WebPartConnection ProviderID="emp" ProviderConnectionPointID="EmployeeIDProvider" ConsumerID="ord" ConsumerConnectionPointID="EmployeeIDConsumer" /> </StaticConnections> Этим объявлением устанавливается соединение между Web Parts с идентифика-торами emp и ord; первый из них является провайдером и имеет точку подключения с именем EmployeeIDProvider, а второй служит потребителем, и его точка подключения называется EmployeeIDConsumer. Теперь при любом изменении свойств, предоставляемых провайдером через его интерфейс, будет генерироваться соответствующее событие, обрабатываемое функ-цией обратного вызова потребителя. Потребитель будет извлекать список заказов текущего сотрудника и выводить его на экран, как показано на рис. 7-22.
Страницы с элементами Web Parts Глава 7 305 Рис. 7-22. Отношение "главный-подчиненный" установлено между двумя независимыми, но взаимодействующими Web Parts Web Part, играющий роль провайдера, определяет открытое и отображаемое в бра-узере свойство EmployeeID. Если его установить, изменение немедленно отразится в потребителе, для чего будет выполнен его обратный вызов. Заключение Web Parts Framework обеспечивает разработчикам приложений ASP.NET возможность без особого труда создавать модульные приложения с персонализируемыми страни-цами. Web Part - это серверный элемент управления, представляющий собой панель, на которой выводятся элементы пользовательского интерфейса. Подобно любому другому серверному элементу управления его можно конфигурировать посредством свойств, методов и событий. Технология Web Parts интегрирована в исполняющую среду ASP.NET, которая проделывает за вас большую часть работы. Вы делите страницу на зоны и помещаете в каждую их них один или несколько элементов Web Parts. Каждый из них автома-тически снабжается рамкой, заголовком и необходимыми командами (такими как Minimize, Edit и Close). Он выглядит, как обычное окно настольного приложения. Web Parts Framework поддерживает несколько рабочих режимов, включая Design, Edit и Catalog. В режиме Design пользователи могут перетаскивать Web Parts, разме-щая их по своему вкусу. Режим Edit служит для изменения свойств, определяющих внешний вид и поведение Web Parts. Необходимый для этого пользовательский ин-терфейс предоставляет исполняющая среда, так что вам не приходится ничего про-граммировать. Наконец, в режиме Catalog отображается список доступных Web Parts, включая те, которые пользователь ранее закрыл.
306 Часть II Специализированные средства ASP.NET Когда пользователь завершает конфигурирование страницы, содержащей Web Parts, его установки автоматически сохраняются. При следующем посещении стра-ницы конфигурация пользователя восстанавливается. Опять-таки, вам для этого не нужно писать никакого кода - необходимо лишь заранее сконфигурировать механизм персонализации. Только факты Страницы ASP.NET можно составлять из особых компонентов SharePoint-стиля, напоминающих окна настольного приложения, - они называются Web Parts. Хотя каждый Web Part выводит свой независимый контент, он является интег-ральной частью страницы, и при его обновлении обновляется вся страница. Web Parts располагаются в зонах, которых на странице может быть несколько. Существует ряд стандартных зон специального назначения, используемых для редактирования установок Web Parts, вывода каталога Web Parts и установки соединений. Web Part - серверный элемент управления, и его можно реализовать любым из перечисленных способов: как составной элемент управления, пользовательский элемент управления или специализированный серверный элемент управления, производный от класса WebPart. Хотя с точки зрения приложения это менее ин-тересно, Web Part может быть реализован и как единственный серверный элемент управления - специализированный или стандартный. Каждый Web Part снабжается набором команд, предназначенных для выполнения над ним системных операций, таких как редактирование установок, свертывание, закрытие, экспорт и соединение. Два Web Parts можно соединить, чтобы они действовали по принципу "провай-дер-потребитель". Тогда при изменении данных, представленных открытым ин-терфейсом провайдера, потребитель будет обновлять свои данные. 
Глава 8 Программирование для мобильных устройств С помощью мобильных элементов управления ASP.NET можно создавать Web-прило же-ния для мобильных устройств, используя ту же модель приложения, что и в разработках для настольных компьютеров. Мобильные элементы управления предназначены для широкого спектра устройств - сотовых телефонов, пейджеров, КПК и других персо-нальных помощников, таких как Palm и BlackBerry. Для поддержки мобильных техно-логий модель Web Forms в ASP.NET была расширена в двух направлениях, а именно поддержка устройств и поддержка специализированных элементов управления. Все поддерживаемые устройства перечисляются в новом разделе файла machine.config, куда вы можете добавлять сведения о новых устройствах и элементах управления. Мобильные приложения создаются с использованием мобильных элементов уп-равления ASP.NET и ее объектной модели. Основываясь на данных конфигурации, подсистема Mobile Web Forms определяет, от какого устройства поступил текущий запрос, и осуществляет рендеринг с применением соответствующего языка разметки и необходимой логики. Мобильные элементы управления абстрагируют подмножество серверных элементов управления ASP.NET и интеллектуально производят рендеринг приложения для целевого устройства. Кроме того, существует несколько специали-зированных мобильных элементов, к числу которых относится, например, PhoneCall. В этой главе приведен обзор мобильных элементов управления ASP.NET, рас-смотрены основы технологии разработки мобильных приложений и коротко описаны функции Visual Studio для разработчиков таких приложений. Обзор мобильных элементов управления Мобильные элементы управления ASP.NET - это серверные элементы управления, а следовательно, их атрибуту runat должно быть присвоено значение server. Они вы-полняются на сервере и поэтому могут использовать потенциал .NET Framework несмот-ря на скромный объем памяти мобильных устройств. Все мобильные элементы управ-ления наследуют класс MobileControl, который, в свою очередь, является производным от класса Control. Серверные и мобильные элементы управления имеют общий набор свойств, методов и событий. Мобильные Web-формы наследуют класс MobilePage. Архитектура мобильных элементов управления Мобильные элементы управления обеспечивают возможность адаптации стандартных элементов управления ASP.NET к устройству, от которого получен запрос. Ключевым моментом их работы является идентификация браузера, которая играет здесь гораздо более важную роль, чем при использовании обычных элементов управления. Мобильные и классические серверные элементы управления Рендеринг классических серверных элементов управления выполняется по-разно-му в зависимости от типа целевого клиента (настольного браузера). Однако, хотя 
308 Часть II Специализированные средства ASP.NET результирующая разметка для разных целевых клиентов может сильно различаться, эти различия касаются главным образом стиля. Классические серверные элементы управления всегда генерируют HTML-или XHTML-код. Хотя между стандартами HTML 3.2 и HTML 4.0 и между этими стан-дартами и их реализацией в конкретных браузерах имеются некоторые различия, все это не идет ни в какое сравнение с разнообразием синтаксисов и диалектов раз-метки, существующим в мобильном мире. Поэтому функция определения браузеров мобильных устройств реализована на уровне системы, тогда как в приложениях для настольных браузеров ее реализация оставлена на усмотрение разработчика. Мобиль-ная исполняющая среда ASP.NET анализирует строку пользовательского агента и выбирает соответствующий адаптер мобильного устройства. Вот почему мобильные элементы управления приспосабливаются к возможностям конкретного устройства, направившего зарос. Набор поддерживаемых беспроводных устройств довольно разнообразен - от пер-сональных цифровых помощников с полнофункциональными браузерами до сотовых телефонов с миниатюрными экранами. Поэтому не только разметка, но и структура приложения должны существенно изменяться в зависимости от типа устройства. В общем случае средство разработки мобильных приложений должно абстрагировать многие аспекты клиентской среды, такие как различие языков разметки, зависящее от реализации одного и того же языка, разные форм-факторы, в частности разные разме-ры дисплея и программируемых кнопок. Мобильные элементы ASP.NET берут на себя задачу абстрагирования, позволяя вам сконцентрироваться на логике приложения. Разные языки разметки Мобильные элементы управления поддерживают несколько языков разметки. Наибо-лее популярные из них перечислены в табл. 8-1. Табл. 8-1. Языки разметки, поддерживаемые мобильными элементами управления Язык Описание Compact HTML 1.0 Подмножество HTML 3.2, специально разработанное для мобильных телефонов, а также других устройств с питанием от батареи и малым объемом памяти. Сокращенным названием данного языка является cHTML. Язык широко применяется в японских устройствах I-Mode HTML 3.2 Относительная старая версия HTML, поддерживаемая такими карманными компьютерами, как Pocket PC 2002, Palm и BlackBerry WML 1.x Wireless Markup Language (язык разметки беспроводных устройств) является одним из самых популярных языков беспроводных устройств. Он разработан в рамках инициативы более широкого масштаба, целью которой было определение прикладного протокола беспроводных устройств - широко известного Wireless Application Protocol (WAP). Язык WML позволяет программировать клавиши мобильного телефона, в частности цифровую и программную клавиатуры XHTML Это XML-версия HTML, являющаяся ключевым элементом стандарта WAP 2.0 Иерархия мобильных элементов управления Мобильные элементы управления ASP.NET логически подразделяются на пять ка-тегорий: контейнеры, текст, условия проверки, списки и разные элементы. Все они в алфавитном порядке перечислены в табл. 8-2. Некоторые из них очень похожи на элементы управления Web Forms. Однако все мобильные элементы управления 
Программирование для мобильных устройств Глава 8 309 отличаются адаптивным рендерингом. Тему адаптивного рендеринга мы подробно рассмотрим в отдельном разделе. Табл. 8-2. Мобильные элементы управления ASP.NET Элемент управления Описание AdRotator Обеспечивает циклическую смену рекламных баннеров подобно тому, как это делает одноименный элемент управления ASP.NET Calendar Дает пользователю возможность выбрать дату, в точности как одноименный элемент управления ASP.NET Command Подобно элементу управления Button из ASP.NET по щелчку генерирует событие возврата формы CompareValidator Идентичен одноименному элементу управления ASP.NET CustomValidator Идентичен одноименному элементу управления ASP.NET DeviceSpecific Обеспечивает возможность адаптировать внешний вид элементов управления Form и Panel к определенному типу аппаратных уст-ройств Form Подобен элементу управления HtmlForm из ASP.NET, однако на мобильной странице может выводиться несколько форм Image Идентичен одноименному элементу управления ASP.NET Label Идентичен одноименному элементу управления ASP.NET Link Представляет гиперссылку на другую форму мобильной страницы или на произвольный URL. Подобен элементу управления HyperLink из ASP.NET List Подобен элементам управления ASP.NET Repeater и DataList, применяет шаблоны к связанным данным. Поддерживает специфические шаблоны различных устройств ObjectList Подобен элементу управления ASP.NET DataGrid, выводит строки таблицы данных и поддерживает несколько команд Panel Подобно элементу управления ASP.NET Panel служит для группи-ровки и организации элементов управления PhoneCall Для устройств, поддерживающих телефонию, представляет ссылку на номер телефона, по которому можно позвонить. Подобен тэгу mailto гиперссылки HTML RangeValidator Идентичен одноименному элементу управления ASP.NET RegularExpressionValidator Идентичен одноименному элементу управления ASP.NET RequiredFieldValidator Идентичен одноименному элементу управления ASP.NET SelectionList Выводит список элементов, связанных с данными. В зависимости от того, как вы его сконфигурируете, может вести себя как раскрываю-щийся список или список флажков. Выбор элемента в таком списке не вызывает автоматического возврата формы, но при следующем возврате формы генерируется серверное событие StyleSheet Невидимый элемент управления для централизованного определе-ния стилей, применяемых к другим элементам управления. Может содержать несколько определений стилей TextBox Представляет однострочное текстовое поле; режим "только чтение" не поддерживает TextView Используется для вывода больших блоков текста, поддерживает простейшее форматирование текста и листание ValidationSummary Подобен элементу управления ValidationSummary из ASP.NET, выводит результаты проверки в отдельной форме
310 Часть II Специализированные средства ASP.NET Почти все мобильные элементы управления, кроме разве что PhoneCall и TextView, имеют аналоги среди серверных элементов управления ASP.NET. Интерфейс про-граммирования проверочных элементов практически такой же, как в ASP.NET, с той лишь разницей, что не все устройства поддерживают клиентскую проверку. На рис. 8-1 показана схема взаимосвязей элементов управления. Элементы, представленные бе-лыми прямоугольниками, - это абстрактные классы. Рис. 8-1. Иерархия классов мобильных элементов управления ASP.NET Прежде чем переходить к подробному изучению характеристик каждой группы элементов управления, вам нужно кое-что узнать о структуре мобильной страницы ASP.NET. Мобильные страницы ASP.NET Базовым классом всех мобильных Web-страниц ASP.NET является MobilePage, насле-дующий класс ASP.NET Page. Класс отделенного кода мобильной страницы наследует MobilePage или класс, производный от него. Все мобильные элементы управления интерпретируются как специализированные (custom controls) и должны явно регистри-роваться для страницы. Давайте рассмотрим исходный код такой мобильной страницы.
Программирование для мобильных устройств Глава 8 311 Пример мобильной страницы Ниже приведен код демонстрационной страницы, которая выводит название языка, поддерживаемого беспроводным устройством. <%@Page Language="C#" CodeFile="Hello.aspx.cs" Inherits="Hello" %> <%@Register TagPrefix="mobile" Namespace="System.Web.UI.MobileControls" Assembly="System.Web.Mobile" %> <%@Import Namespace="System.Web.Mobile" %> <html xmlns="http://www.w3.org/1999/xhtml" > <body> <mobile:Form ID="Form1" runat="server"> Language is <mobile:Label runat="server" font-bold="true" id="theBrowser" /> </mobile:Form> </body> </html> Страница содержит элемент управления Label, выводящий полужирным шрифтом литерально заданный текст. Обработчик события Load определяет предпочтительный для данного устройства тип рендеринга, считывает из конфигурационного файла соответствующие установки и выводит их. Класс MobileCapabilities определен в про-странстве имен System.Web.Mobile, а все элементы управления - в пространстве имен System.Web.UI.MobileControls. public partial class Hello : System.Web.UI.MobileControls.MobilePage { protected void Page_Load(object sender, EventArgs e) { MobileCapabilities mobCaps = (MobileCapabilities) Request.Browser; theBrowser.Text = mobCaps.PreferredRenderingType; } } При просмотре на устройстве, использующем браузер Openwave 7.0 (информацию о нем вы найдете по адресу http://odn.openwave.com), страница выглядит так, как показано на рис. 8-2. Рис. 8-2. Мобильное приложение в эмуляторе Openwave
312 Часть II Специализированные средства ASP.NET Мобильная страница определяет возможности устройства и генерирует следующую разметку на WML 1.1: <wml> <head> <meta http-equiv="Cache-Control" content="max-age=0" /> </head> <card> <do type="accept"><noop /></do><p> Language is <b>wml11</b></p> </card> </wml> Интересно, что ту же страницу можно открыть и в Internet Explorer. В таком слу-чае целевым языком будет HTML 3.2. На рис. 8-3 показана версия данной страницы для Internet Explorer. Рис. 8-3. Мобильное приложение в Internet Explorer В данном случае вывод, направляемый целевому устройству, совсем иной: <html><body> <form id="Form1" name="Form1" method="post" action="Hello.aspx?__ufps=149742"> <input type="hidden" name="__VIEWSTATE" value="/wEXA ... CVL"> <input type="hidden" name="__EVENTTARGET" value=""> <input type="hidden" name="__EVENTARGUMENT" value=""> <script language=javascript><!--function __doPostBack(target, argument){ var theform = document.Form1 theform.__EVENTTARGET.value = target theform.__EVENTARGUMENT.value = argument theform.submit() } //--> </script> Language is <b>html32</b> </form> </body></html> Примечание Существует множество эмуляторов для тестирования интерфейса мо-бильных приложений во время разработки. Хотя перед выпуском такого приложения его нужно самым тщательным образом протестировать на реальных устройствах, эмуляторы исключительно полезны на этапе разработки. Большинство производителей телефонов предоставляют эмуляторы своих устройств. Объект MobilePage может содержать элементы управления только двух видов: Form и StyleSheet. Литеральный текст, размещенный вне формы, игнорируется. Если вне формы размещены другие элементы управления, компилятор выдает сообщение об ошибке. Весь необходимый текст и элементы управления должны размещаться внутри формы. Хотя мобильная страница может содержать и более одной формы, только одна 
Программирование для мобильных устройств Глава 8 313 из них видима в каждый конкретный момент времени. Применять таблицу стилей не обязательно, но если вы хотите ею пользоваться, она должна быть у страницы одна. Разбивка на страницы Мобильные элементы управления ASP.NET позволяют автоматически разбивать содержимое формы на небольшие части. Этот механизм называется разбивкой на страницы (pagination). При его использовании сегменты контента автоматически форматируются по размеру экрана целевого устройства. В конец результирующей клиентской страницы помещаются типичные элементы пользовательского интерфейса, предназначенные для перехода от одной части страницы к другой. По умолчанию для форм разбивка на страницы отключена. Чтобы включить ее, нужно установить свойство Paginate объекта Form в true. Следует отметить, что, хотя данную функцию можно активизировать и для отдельных элементов управления, ваша установка не будет иметь никакого эффекта, если свойство Paginate формы-контейнера содержит false. У элемента управления Form есть и другие свойства, управляющие разбивкой на страницы, - к их числу относятся PageCount, CurrentPage и PagerStyle. Существует возможность включить разбивку на страницы для отдельного элемента формы через свойство этой формы ControlToPaginate, которому нужно присвоить идентификатор элемента управления. Главная цель разбивки на страницы - избежать перегрузки памяти устройства слишком большими страницами. Особенно эффективен данный метод для элемен-тов управления, которые выводят на экран большой объем данных, а вот для форм, содержащих интерактивные элементы управления и поля ввода, его применение не является необходимым. Разбивка на страницы реализуется путем разделения формы или элемента управления на части. Некоторые элементы управления, например List, управляют разбивкой на страницы сами и сами решают, как лучше разделить свой вы-вод на части. Форма может содержать элементы-контейнеры, в которых размещаются другие элементы управления; чтобы такой контейнер мог быть разделен на части, его дочерние элементы управления должны помещаться на странице. На рис. 8-4 показан вывод формы с отключенной разбивкой на страницы (слева) и рядом вывод той же формы, когда данная функция включена. Рис. 8-4. Результат разбивки формы мобильного приложения на страницы
314 Часть II Специализированные средства ASP.NET Внимание! Открыв на мобильном устройстве демонстрационную страницу, показанную на рис. 8-4, не удивляйтесь, если, щелкнув ссылку Next, получите сообщение об ошибке. В таком случае вам нужно отключить cookie. Жизненный цикл мобильной страницы Жизненный цикл мобильной страницы ASP.NET, этапы которого перечислены ниже, практически идентичен жизненному циклу обычной страницы Web Forms. Он включает те же события, хотя поведение системы до и после их генерирования разное. О жизнен-ном цикле обычной страницы ASP.NET подробно рассказывается в главе 3 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Инициализация страницы На этом этапе определяется адаптер устройства, ко-торый будет использоваться при формировании вывода страницы, и устанавли-вается свойство Adapter класса MobilePage. Поиск адаптера начинается с файла machine.config, затем производится в файле web.config из корневого каталога сайта, а уж потом - в файлах web.config, расположенных ниже по иерархии. Адаптер выбирается на основе характеристик текущего устройства. Обратите внимание: с целью повышения производительности адаптер кэшируется, поэтому его поиск для каждого пользовательского агента производится один раз. Загрузка состояния представления На данном этапе восстанавливается сохра-ненное состояние страницы. Никакие события с этим этапом не ассоциированы. Загрузка данных возврата страницы Страница загружает входящие данные фор-мы, кэшированные в объекте Request, и соответствующим образом обновляет свои свойства. Никакие пользовательские события с данным этапом не ассоциированы. Загрузка пользовательского кода Страница готова к выполнению инициали-зационного кода, связанного с ее логикой и поведением. Она генерирует событие Load и загружает информацию с учетом специфики адаптера устройства. Если вы хотите управлять этим этапом, то можете реализовать обработчик данного события как для страницы, так и для адаптера. Отправка уведомлений об изменении возвращенных данных формы Элементы управления, входящие в состав страницы, генерируют события изменения, если их состояние изменилось со времени последнего возврата формы. Для того чтобы элемент управления мог генерировать на этом этапе событие изменения состоя-ния, в нем нужно реализовать интерфейс IPostBackDataHandler. Пользовательские события на данном этапе не генерируются. Обработка события возврата формы Страница выполняет код, связанный с со-бытием, которое вызвало возврат формы. Предрендеринг Перед рендерингом вывода код получает последнюю возмож-ность внести какие-либо изменения. Событие, с которым разработчик может свя-зать соответствующий код мобильной страницы или адаптера устройства, называ-ется PreRender. Именно на этом этапе производится разбивка на страницы. Вывод страницы формируется с учетом параметров разбивки. Сохранение состояния представления Состояние страницы сериализуется в строку, которая затем сохраняется - обычно в виде скрытого поля. Пользова-тельские события на данном этапе не генерируются. Рендеринг страницы Страница генерирует вывод, который будет направлен клиенту. За вывод дочерних элементов управления в нужном порядке отвечает адаптер. 
Программирование для мобильных устройств Глава 8 315 Выгрузка страницы На этом этапе адаптер устройства выполняет необходимые фи-нальные операции. Событие Unload доступно и странице, и адаптеру устройства. Если вы сравните процессы обработки запроса мобильной и настольной страниц в ASP.NET 1.x, то обнаружите различие, связанное главным образом с этапом ини-циализации - для мобильных страниц выбирается подходящий адаптер устройства, который затем используется для их рендеринга. В ASP.NET 2.0 это различие не столь существенно, поскольку для настольных страниц также применяется адаптивный рендеринг. Адаптеры устройств Благодаря применению адаптеров устройств программист может разрабатывать мо-бильное приложение, не ориентируясь на конкретное устройство. При обработке кон-кретного запроса адаптер транслирует высокоуровневое описание пользовательского интерфейса в слой представления, подходящий для того устройства, от которого этот запрос поступил. Можно провести интересную аналогию между драйверами устройств из Microsoft Windows и адаптерами мобильных устройств из ASP.NET. И те и другие генерируют команды, понятные конкретному устройству, только адаптеры выводят их в форме разметки. Адаптеры - это своего рода мосты между отдельными мобиль-ными элементами управления и целевыми устройствами. Для каждого конкретного устройства мобильный элемент управления может иметь уникальный адаптер, и каж-дый экземпляр элемента управления связывается со своим экземпляром адаптера. Наличие адаптера является ключевым условием рендеринга мобильных элементов управления. В общем случае для каждого поддерживаемого устройства могут быть определены следующие классы: Адаптер страницы Будучи связанным со страницей, данный класс реализует функции, связанные с состоянием представления и возвратом формы, и вклю-чает методы, выполняющие сохранение и загрузку данных состояния элементов управления, специфических для конкретного устройства, в частности связанных с разбивкой на страницы и активной формой. Также данный адаптер отвечает за подготовку ответа клиенту и рендеринг каркаса страницы. Адаптер страницы реализует интерфейс IPageAdapter, относящийся к API поддержки мобильных устройств. Адаптер формы Будучи связанным с элементом управления form, данный адап-тер предоставляет методы, управляющие интерактивностью формы. Кроме того, он должен включать методы для адаптации универсальной формы к конкретно му устройству. Например, он может разбивать поля формы на страницы или объе динять их в меню. Наконец, адаптер формы должен быть способен вывести ее каркас. Адаптер элемента управления Это базовый класс адаптеров элементов управле-ния, также являющийся базовым и для адаптеров страницы и формы. Он предо-ставляет методы для рендеринга элементов управления, генерирующих события возврата формы, и для рендеринга свойств, определяющих стили. Класс для записи текста (text writer) Данный класс не является адаптерным, но работает в тесном сотрудничестве с адаптерами. Он наследует класс HtmlTextWriter. Поскольку он выполняет для элемента управления весь необходимый рендеринг, экземпляр данного класса создается для каждого адаптера. Обычно класс для записи текста содержит вспомогательные методы, в частности предназначенные для кодирования данных. В состав ASP.NET 2.0 входит несколько адаптеров устройств - по одному для каждого языка разметки, cHTML, XHTML, HTML и WML. 
316 Часть II Специализированные средства ASP.NET Контейнерные элементы управления Среди мобильных элементов управления ASP.NET есть два контейнера, Panel и Form, которые могут содержать другие элементы управления. Элемент Form может выпол-нять возврат данных серверу; Panel, являющийся просто средством группировки связанных между собой элементов управления, такой функцией не обладает. Панели могут быть вложенными, и в форме может содержаться любое их количество; формы же включать одна в другую нельзя. Элемент управления Panel Приведенный ниже код выводит две панели, содержащие текст с минимальным фор-матированием. Учтите, что не каждый атрибут поддерживается всеми существующими устройствами. Например, сотовые телефоны игнорируют цвета фона и текста. <mobile:Form runat="server"> <mobile:Panel runat="server" Font-Bold="true" Alignment="Right"> <mobile:Label runat="server">Programming ASP.NET 2.0</mobile:Label> </mobile:Panel> <mobile:Panel runat="server" BackColor="yellow"> <mobile:Label runat="server">Dino Esposito</mobile:Label> </mobile:Panel> </mobile:Form> Панель может содержать любые мобильные элементы управления ASP.NET, кроме MobilePage, Form и StyleSheet. Сама она не имеет визуального представления, и все стили, которые вы для нее задаете, применяются к размещенным на ней элементам. Размеще-ние дочерних элементов и их стили могут быть изменены адаптером устройства. Заметьте, что элемент управления Panel может использоваться для выделения места под динамически генерируемые дочерние элементы управления. Элемент управления Form Элемент управления Form является самым внешним контейнером элементов уп-равления, размещенных на мобильной странице. Он предоставляет такие часто ис-пользуемые свойства, как Action и Method. Свойство Action по умолчанию содержит пустую строку, в результате чего при возврате формы задается исходный URL. При активизации и деактивизации форма генерирует события. Страница может содержать несколько форм, но в каждый конкретный момент в браузере выводится только одна из них. Установка текущей формы выполняется посредством свойства ActiveForm, доступного и для чтения. Когда на одной странице активны несколько форм, для перехода между ними используется элемент управле-ния Link. <mobile:Form id="Form2" runat="server"> <mobile:Label runat="server" text="Second page of information" /> <mobile:Link runat="server" NavigateURL="#Form1" text="Back" /> </mobile:Form> Для того чтобы элемент управления указывал на нужную форму, его свойству NavigateURL следует присвоить ее идентификатор с префиксом в виде символа #. Списочные элементы управления Мобильными эквивалентами традиционных списочных и итеративных элементов управления ASP.NET являются элементы управления List, ObjectList и SelectionList. Элемент List выглядит как Repeater и DataList; он выводит статический или связан-
Программирование для мобильных устройств Глава 8 317 ный с данными список элементов. Элемент SelectionList необходим для того, чтобы пользователь мог выбирать в списке более одного элемента управления. Что касается ObjectList, то он служит для отображения информации из базы данных в табличном формате. Заметьте, что он всегда связан с данными, тогда как два других элемента управления могут выводить списки статичных или программно генерируемых эле-ментов. Элемент управления List Элемент управления List направляет на устройство последовательность элементов. Он может работать в статическом или интерактивном режиме. В статическом режиме данный элемент генерирует статический список чисто текстовых элементов. В интер-активном режиме получаются элементы, по щелчку на которых генерируются события. Если написан обработчик события ItemCommand, элемент интерактивен, в противном случае он статичен. Когда свойство ItemsAsLinks установлено в true, элементы списка превращаются в гиперссылки. В таком случае событие ItemCommand не генериру-ется, а в ответ на щелчок пользователя просто выполняется переход по заданному URL. Этот URL присваивается свойству DataValueField, а текст гиперссылки задается в свойстве DataTextField. Следующий код принадлежит странице, которая выводит список городов и поз-воляет пользователю выбрать один из них. Она состоит из двух форм: одна из них содержит список, а другая - информацию, которая выводятся после выбора элемента в этом списке. <mobile:Form id="IntroForm" runat="server"> <b>Where do you want to go today?</b> <mobile:List runat="server" id="Cities" OnItemCommand="List_Click" > <item Text="Rome" Value="€10" /> <item Text="New York" Value="$500" /> <item Text="London" Value="€200" /> <item Text="Paris" Value="€350" /> <item Text="Sydney" Value="$1200" /> </mobile:List> </mobile:Form> <mobile:Form runat="server" id="ResultsForm"> <mobile:Label runat="server" id="Info"/> </mobile:Form> Класс отделенного кода выводит код для переключения в результирующую форму. protected void List_Click(object sender, ListCommandEventArgs e) { string msg = String.Format("Going to {0} for {1}.", e.ListItem.Text, e.ListItem.Value); Info.Text = msg; ActiveForm = ResultsForm; } На рис. 8-5 это приложение показано в действии. Список городов генерируется элементом управления List, а наличие обработчика ItemCommand обеспечивает воз-можность выбора элемента списка. Внимание! Будьте внимательны, когда используете символ $ в мобильных приложениях. В WML этот символ имеет особое значение - он предназначен для идентификации пере-менных. Однако мобильные элементы управления ASP.NET автоматически обрабатывают его вхождения в исходных файлах и правильно осуществляют его рендеринг, дублируя этот символ: $$.
318 Часть II Специализированные средства ASP.NET Рис. 8-5. Демонстрационное приложение Элемент управления List можно связать с источником данных только посредством свойства DataSource и объектов, реализующих интерфейс IEnumerable. Мобильные эле-менты управления не поддерживают элементов управления, представляющих источ-ники данных, и не имеют свойства DataSourceID. За дополнительной информацией о модели связывания с данными ASP.NET рекомендую обратиться к главе 9 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Вам следует знать, что элемент управления List можно связать всего с двумя столбцами источника данных, один будет привязан к свойству Text элемента спис-ка, а другой - к свойству Value. Соответствующие установки задаются в свойствах DataTextField и DataValueField элемента управления List. Если же вам нужно, чтобы текст элемента списка формировался на основе большего числа полей источника данных, определите обработчик события ItemDataBind. void OnItemDataBind(object sender, ListDataBindEventArgs e) { e.ListItem.Text = String.Format ("{0} - ${1}", DataBinder.Eval(e.DataItem, "city"), DataBinder.Eval(e.DataItem, "price")); } Для тех устройств, у которых возможности рендеринга богаче, можно задавать шаб-лоны, по которым настраивается представление элементов данных. В таком режиме элемент управления List функционирует подобно серверному элементу управления ASP.NET Repeater. Элемент управления ObjectList Объект ObjectList является мобильным эквивалентом серверного элемента управления DataGrid ASP.NET. В частности, он может работать в двух режимах - списка и деталей. В режиме списка он выводит нечто вроде меню, составленного из значений одного поля. Так сделано в расчете на устройства с маленькими экранами. Свойство LabelField поз-воляет указать, какое связанное поле будет использоваться для заполнения этого меню. Пользователь может щелкать элементы, после чего производится переключение в режим деталей, в котором отображаются все поля текущей строки данных. Как обеспечивается возможность щелкать элементы, зависит от конкретного устройства.
Программирование для мобильных устройств Глава 8 319 В режиме деталей может отображаться панель инструментов с командами, задан-ными с использованием тэга <command>, и командой возврата, текст которой задается в свойстве BackCommandText. Наконец, свойство AutoGenerateField (по умолчанию устанавливаемое в true) совместно с элементами <fields> используется для выбора связанных полей, подлежащих отображению. Элемент управления ObjectList имеет несколько отличий от элемента управления List. В частности, ObjectList позволяет связать с каждым элементом несколько команд. Набор команд может совместно использоваться всеми элементами или быть у каждого элемента своим. Еще одно отличие заключается в том, что ObjectList поддерживает несколько представлений и не поддерживает статических элементов. Далее в этой главе мы разработаем демонстрационное приложение, в котором с помощью элемента управления ObjectList отображаются некоторые данные. Элементы управления ObjectList и List полностью поддерживают внутреннюю разбивку на страницы и при выводе очередной части пользовательского интерфейса генерируют событие LoadItems. Разработчик задает общее количество элементов в свойстве ItemCount. По умолчанию это свойство содержит 0, и изменение его зна-чения сигнализирует о том, что для элемента будет применяться пользовательская разбивка на страницы. Ожидается, что обработчик события LoadItems будет извлекать необходимые данные и связывать их с элементом управления. Элемент управления SelectionList Элемент SelectionList отличается от прочих списочных элементов управления для мо-бильных устройств тем, что позволяет выбирать пользовательский интерфейс списка элементов. Подобно раскрывающемуся списку или набору переключателей он выводит список элементов и может предоставлять пользователю возможность выбирать из них один или несколько. При выборе элемента не происходит автоматическое генерирова-ние серверного события, как это бывает с некоторыми другими списочными элемен-тами управления, когда свойство AutoPostBack установлено в true. Когда выделяется другая группа элементов, генерируется событие SelectedIndexChanged. Элемент управления SelectionList поддерживает пять разных вариантов рендерин-га: раскрывающийся список (по умолчанию), набор кнопок-переключателей, набор флажков, обычный список, список с множественным выделением. Способ выбора (тип рендеринга) задается в свойстве SelectType. Не все устройства поддерживают каждый из перечисленных способов выбора. Например, сотовые телефоны обычно поддержи-вают только списки с множественным выбором и флажки; переключатели, списки и раскрывающиеся списки превращаются в списки с множественным выбором. Рассмотрим код, показывающий, как отобразить список элементов и узнать, какие из них выбраны. <mobile:Form runat="server" id="Form1"> Your skills? <br /> <mobile:SelectionList runat="server" id="list" SelectType="checkbox" /> <mobile:Command runat="server" OnClick="Button_Click" Text="Go" /> </mobile:Form> <mobile:Form runat="server" id="ResultsForm"> <mobile:Label runat="server" id="Results" /> </mobile:Form> Отделенный код этой формы заполняет элемент управления связанными данными. public partial class Select : System.Web.UI.MobileControls.MobilePage {
320 Часть II Специализированные средства ASP.NET protected void Page_Load(object sender, EventArgs e) { if (!IsPostBack) { ArrayList values = new ArrayList(); values.Add("ASP.NET"); values.Add("ADO.NET"); values.Add("SQL Server"); values.Add("XML"); list.DataSource = values; list.DataBind(); } } protected void Button_Click(object sender, EventArgs e) { string buf = ""; foreach (MobileListItem item in list.Items) buf += (item.Selected ? item.Text + ", " : ""); buf = buf.TrimEnd(); if (buf.EndsWith(",")) buf = buf.TrimEnd(','); Results.Text = buf; ActiveForm = ResultsForm; } } На рис. 8-6 данное приложение показано в действии. Слева вы видите заполнен-ный элемент SelectionList, справа - результаты выбора, а посередине - командную кнопку. Рис. 8-6. Элемент управления SelectionList в действии Текстовые элементы управления В ASP.NET определен абстрактный класс TextControl, наследуемый некоторыми на-вигационными элементами управления и элементами, служащими для ввода текста. Все текстовые элементы управления имеют свойство Text, которое можно устанав-ливать программно и которое обычно используется для рендеринга вывода элемента 
Программирование для мобильных устройств Глава 8 321 управления. Примерами элементов управления, производных от класса TextControl, являются Link, TextBox и Label. Мобильный элемент управления Label подобен од-ноименному классическому элементу управления ASP.NET, а мобильный элемент управления Link - одноименному классическому элементу управления HyperLink. Текстовыми элементами управления являются также Command, представляющий командную кнопку, и PhoneCall. Элемент управления TextBox Элемент управления TextBox генерирует однострочное текстовое поле и хранит в свойстве Text введенный пользователем текст. Данный элемент может работать в режиме пароля и в числовом режиме, но не поддерживает многострочного редакти-рования и не может выводиться как поле, доступное только для чтения. Вы можете задавать для него способ выравнивания и максимальную длину. <mobile:TextBox runat="server" id="theUser" OnTextChanged="Alert" /> Элемент управления TextBox поддерживает серверное событие OnTextChanged, об-работчик которого выполняется, когда между двумя последовательными операциями возврата формы значение текстового поля изменяется. Элемент управления Command Элемент управления Command обладает большинством характеристик классичес-ких элементов управления ASP.NET Button и LinkButton. Он может выводиться как кнопка типа submit (по умолчанию) или гиперссылка и при этом быть представлен изображением. Свойство Format позволяет выбирать между типами Button и Link; если задан тип Link, элемент можно выводить в виде изображения, задав URL этого изображения в свойстве ImageUrl. Если речь идет об устройстве, поддерживающем программируемые клавиши, элемент Command может выводить надпись для одной из таких кнопок. (Программируемые клавиши поддерживаются многими мобильными телефонами.) Щелчок элемента управления Command вызывает событие возврата формы. Сер-верный код обработки этого события можно связать с событием ItemCommand или OnClick. Если используется событие ItemCommand, необходимо задать имя команды, а при желании и ее аргументы. Когда пользователь щелкнет элемент управления, по значению булева свойства CausesValidation станет явно, должен ли данный элемент управления выполнить проверку всех остальных элементов управления той же формы. Приведенный далее код показывает, как использовать элементы управления TextBox и Command. <mobile:Form runat="server"> Search for: <mobile:TextBox runat="server" font-bold="true" id="theSubject" /> <mobile:Command runat="server" Text="GO" OnClick="OnSearch" /> </mobile:Form> <mobile:Form runat="server" id="ResultsForm"> <mobile:Label runat="server" id="theResults" /> </mobile:Form> Когда пользователь щелкает командную кнопку, на сервере выполняется следу-ющий код: protected void OnSearch(object sender, EventArgs e) { string msg = "Results for '{0}'";
322 Часть II Специализированные средства ASP.NET msg = String.Format(msg, theSubject.Text); theResults.Text = msg; ActiveForm = ResultsForm; } Свойство ActiveForm объекта Form позволяет программно выбирать текущую фор-му или узнавать, какая форма является текущей. Данное приложение в действии показано на рис. 8-7. Рис. 8-7. Элементы управления TextBox и Command в действии Элемент управления PhoneCall Элемент управления PhoneCall используется для вывода на экран номера телефона. При этом, если устройство позволяет осуществлять звонки (как сотовый телефон), пользователь может щелкнуть этот номер телефона, чтобы по нему позвонить. В про-тивном случае номер выводится как гиперссылка или даже просто как текст. <mobile:Form runat="server"> Phone numbers found for Joe: <mobile:PhoneCall runat="server" AlternateFormat="{0} at {1}" AlternateURL="http://www.acme.com" PhoneNumber="111-222-0000" Text="ACME Corp" /> <mobile:PhoneCall runat="server" AlternateFormat="{0} at {1}" PhoneNumber="111-333-0000" Text="Home" /> </mobile:Form> Свойство AlternateFormat может содержать любую строку, оно используется для формирования вывода на устройствах, не обладающих функцией телефонии. Данное свойство может принимать два параметра: в первый подставляется значение атрибута Text, а во второй - атрибута PhoneNumber. Альтернативный текст выводится как чис-тый текст, когда не задано свойство AlternateURL, превращающее его в гиперссылку 
Программирование для мобильных устройств Глава 8 323 на указанный в этом свойстве URL. Если атрибут Text не задан, на экран выводится номер телефона. На рис. 8-8 показан вывод элемента управления PhoneCall в сотовом телефоне с браузером Openwave. Рис. 8-8. Элемент управления PhoneCall Проверочные элементы управления Все проверочные мобильные элементы управления являются производными от абс-трактного класса BaseValidator, который, в свою очередь, наследует базовый класс TextControl. Все элементы управления имеют свойства Text и ErrorMessage. Значе-ние свойства Text выводится элементом управления в том случае, когда введено не-допустимое значение, а если оно не задано, валидатор выводит значение свойства ErrorMessage. Свойство ErrorMessage имеет еще одно назначение - содержащийся в нем текст выводится в элементе управления ValidationSummary. Для мобильных элементов управления определены следующие пять валидаторов. CompareValidator - сравнивает значения двух элементов управления, используя заданный оператор сравнения. В свойстве ControlToValidate задается идентификатор проверяемого элемента управления, а значение, с которым производится сравне-ние, задается либо явно в свойстве ValueToCompare, либо неявно через свойство ControlToCompare. Последнее содержит идентификатор другого элемента управле-ния, значение которого будет использоваться для сравнения. CustomValidator - позволяет проверить значение, используя собственный метод. В его свойстве ControlToValidate задается проверяемый элемент управления, а код проверки вставляется в обработчик серверного события ServerValidate. Для того чтобы проинформировать исполняющую среду о результатах проверки, вы уста-навливаете свойство IsValid структуры данных, представляющей событие, в false или true. RangeValidator - выясняет, попадает ли значение заданного элемента управления в определенный диапазон. Границы диапазона задаются свойствами MinimumValue и MaximumValue, они должны быть указаны обе. В свойстве Type можно задать тип сравниваемых значений. 
324 Часть II Специализированные средства ASP.NET RegularExpressionValidator - проверяет, соответствует ли значение заданного эле-мента управления определенному регулярному выражению. Проверяемый эле-мент управления задается в свойстве ControlToValidate, а выражение - в свойстве ValidationExpression. RequiredFieldValidator - производит контроль ввода для обязательного поля. При этом речь не всегда идет о том, что поле не должно быть пустым; в некото-рых случаях важно, чтобы введенное значение отличалось от значения свойства InitialValue - только при этом условии проверка (выполняемая при потере полем фокуса ввода) считается успешной. Когда в состав страницы включены валидаторы, ASP.NET выводит сообщения об ошибках проверки. Эта задача выполняется элементом управления ValidationSummary, который собирает все сообщения, заданные для разных валидаторов, объединяет их в одну строку и выводит результирующий текст во второй форме. Свойство BackLabel позволяет задать текст кнопки, служащей для возврата к исходной форме. Элемент управления Command - единственный из мобильных элементов управле-ния, вызывающий валидацию входных данных формы; TextBox и SelectionList - единс-твенные элементы управления, значения которых подлежат валидации. У первого про-веряется значение свойства Text, а у второго - значение свойства SelectedIndex. Однако и другие элементы управления (например, пользовательские и специализированные) могут участвовать в процессе валидации со своими собственными свойствами. Для этого их нужно пометить атрибутом [ValidationProperty]. (Подробнее об этом говорится в главе 4 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference".) Ниже показано, как создать страницу, проверяющую пользовательский ввод. Она содержит элемент управления SelectionList, в котором выводится перечень знаний кандидата на некоторую должность. Кандидат должен выбрать хотя бы один элемент в этом перечне. С элементом SelectionList связан валидатор RequiredFieldValidator. Значение свойства InitialValue ASP.NET автоматически устанавливает в -1. <mobile:Form runat="server" id="Main"> <mobile:RequiredFieldValidator runat="server" ErrorMessage="Must indicate a skill!" ControlToValidate="skills" /> <b>Indicate your skills</b><br> <mobile:SelectionList runat="server" id="skills" SelectType="checkbox" /> <mobile:Command runat="server" OnClick="Submit" Text="Send" /> </mobile:Form> <mobile:Form runat="server" id="ResultsForm"> <b>Recognized skills</b> <mobile:Label runat="server" id="Results" /> </mobile:Form> Когда пользователь щелкает кнопку, служащую для передачи данных на сервер, страница активизирует все свои валидаторы, чтобы перед отправкой данных убедиться в их правильности. protected void Page_Load(object sender, EventArgs e) { if (!IsPostBack) { ArrayList values = new ArrayList(); 
Программирование для мобильных устройств Глава 8 325 values.Add("ASP.NET"); values.Add("ADO.NET"); values.Add("XML"); values.Add("Windows Forms"); values.Add("SQL Server"); skills.DataSource = values; skills.DataBind(); } }protected void Submit(object sender, EventArgs e) { if (!Page.IsValid) return; string buf = ""; foreach (MobileListItem item in skills.Items) buf += (item.Selected ? item.Text + ", " : ""); buf = buf.TrimEnd(); if (buf.EndsWith(",")) buf = buf.TrimEnd(','); Results.Text = buf; ActiveForm = ResultsForm; } Если свойство IsValid объекта MobilePage содержит значение false, процедура завер-шает свою работу и клиенту возвращается та же форма с валидатором, отображающим сообщение об ошибке. При желании можно использовать вторую форму с элементом управления ValidationSummary, активизируемую по требованию. Действие приведен-ного выше кода продемонстрировано на рис. 8-9. Рис. 8-9. Проверка пользовательского ввода с применением валидаторов Разработка мобильных приложений Пришло время соединить все то, что вы узнали об элементах управления и страницах мобильных приложений, и разработать небольшое демонстрационное приложение. В зависимости от возможностей целевого устройства разработчик приложения либо 
326 Часть II Специализированные средства ASP.NET обеспечивает кэширование на клиентском устройстве той информации, которая за-тем будет передаваться серверной системе, либо реализует взаимодействие между клиентской и серверной системами в реальном времени. Приложения первого типа чаще создают для интеллектуальных устройств вроде Pocket PC, а второго - для ус-тройств с малым объемом памяти и маломощными процессорами, таких как сотовые телефоны. Однако ограниченные возможности программного и аппаратного обеспе-чения подобных устройств затрудняют процесс создания эффективных и полезных приложений. Наиболее распространенным видом приложений для маломощных мо-бильных устройств являются программы для поиска информации. Такую программу разработаем и мы. Наша задача - создать приложение, с помощью которого пользователи смогут за-прашивать информацию о клиенте и, возможно, звонить ему по телефону. Безусловно, предмет поиска (клиент) выбран произвольно, с тем же успехом в большой базе дан-ных можно искать любую другую информацию. Понятие большой базы данных здесь условно - она велика в сравнении с возможностями мобильного устройства. Если в обычном Web-приложении можно выводить по 20 записей за раз, то в мобильном все, что вы можете предложить пользователю, - это несколько компактных элементов данных, помещающихся на маленьком экране. При разработке мобильного приложения обязательно нужно учитывать и воз-можности ввода, поддерживаемые устройствами, для которых данное приложение предназначено. Если в мире Web пользователю часто предлагают ввести критерий, позволяющий сузить область поиска, то для беспроводного устройства такое решение подходит не всегда, поскольку выполнять текстовый ввод на нем неудобно. Приложение для поиска клиентов Наше приложение будет извлекать информацию о клиенте, которого пользователь хотел бы посетить или с которым он хотел бы связаться по телефону. При этом в памяти устройства база данных всех клиентов отсутствует - если это сотовый теле-фон, она туда просто не помещается, а если это более интеллектуальное устройство, скажем, КПК, то, может быть, пользователь забыл синхронизировать его базу данных с серверной или хочет получить самую свежую информацию. Разработка архитектуры приложения Многие настольные приложения выполняют поиск инкрементально - пользователь вводит частичный ключ и система возвращает список соответствий. Затем пользо-ватель либо сужает область поиска, либо просто выбирает один из предложенных вариантов. Такой способ работы предполагает наличие удобной клавиатуры, но у мобильных устройств ее обычно не бывает. Как правило, такое устройство снабжено цифровой клавиатурой, но алфавитной - далеко не всегда. А рассчитывать на то, что пользователю понравится постоянно вводить текст, пользуясь цифровой клавиату-рой, явно не приходится, особенно если учесть, что мобильные устройства потому и называются мобильными, что ими часто пользуются на ходу или в дороге, работая одной рукой. Поэтому разработчик мобильного приложения, в особенности предназначенного для сотовых телефонов, должен хорошо усвоить следующее правило: один дополни-тельный щелчок предпочтительнее набора текста. Для персонализации и оптимизации вывода приложения используйте имеющуюся информацию о пользователе (его имя, адрес электронной почты, профиль или даже местоположение). Структура формы должна быть как можно более простой и сжатой, с краткими, но понятными описаниями и единственным способом выполнения каждой задачи. Дан-
Программирование для мобильных устройств Глава 8 327 ные следует загружать малыми порциями, поскольку полоса пропускания приложения мала, а работа с приложением должна осуществляться путем прокрутки и нажатия программируемых клавиш, а также числовых клавиш на клавиатуре. Для мобильных приложений, требующих пользовательского ввода, хорошо подхо-дит интерфейс мастера. Очень удобно древовидное представление заданий и данных, поскольку оно позволяет предложить список вариантов, чтобы пользователь мог выбрать один из них или выйти. Имея все это в виду, перейдем к практике. Мобильные приложения в Visual Studio 2005 Visual Studio предлагает очень хорошие шаблоны проектов для таких типичных це-левых устройств, как Pocket PC 2003, SmartPhone 2003 и Windows CE 5.0. Во всех остальных случаях вы создаете обычный проект сайта и вместо Web-форм добавляете мобильные Web-формы. Важно также выбрать мобильную версию файла web.config, чтобы автоматически импортировать предопределенные фильтры устройств. Специальный дизайнер помогает вам создать мобильные формы и наполнить их элементами управления и кодом. Размер элементов управления изменять нельзя, поскольку эту задачу ASP.NET выполнит сама, когда будет генерировать разметку для конкретного устройства. Вам просто нужно организовать пользовательский ин-терфейс приложения в виде форм и предоставить несколько команд для перехода от одной формы к другой. Работа с эмуляторами По умолчанию для тестирования и отладки мобильных приложений Visual Studio 2005 использует Internet Explorer. Однако вы можете установить собственный эмулятор устройства и использовать его для работы с приложением. После загрузки и установки эмулятора вы регистрируете его в Visual Studio с помощью команды Browse With кон-текстного меню страницы. Она открывает диалоговое окно (рис. 8-10), позволяющее найти исполняемый файл эмулятора и назначить ему дружественное имя. После этого при отладке приложения Visual Studio будет загружать указанный вами эмулятор. Рис. 8-10. Диалоговое окно для регистрации эмулятора мобильного устройства в Visual Studio Примечание Хотя ASP.NET прекрасно абстрагирует языки разметки беспроводных устройств, разработчик тоже не остается без дела. Нужно понимать, что ASP.NET сама не может создать реальное приложение, которое будет хорошо работать на любом устройстве. Различия между устройствами слишком велики, поэтому вам, возможно, придется дополнить код, генерируемый ASP.NET для мобильных приложений, специали-зированными расширениями.
328 Часть II Специализированные средства ASP.NET Навигационная модель приложения Наше приложение CustomerFinder будет состоять из трех форм. Первые две служат для сужения области поиска клиента. Когда останется относительно небольшой их список, данные будут помещены в компонент ObjectList для более детального отобра-жения. Таким образом, пользователю нужно будет только нажимать кнопки, но не придется ничего вводить. Весь набор данных, в котором производится поиск, пред-ставлен в виде дерева, и при его обходе пользователь на каждом шаге осуществляет выбор дальнейшего пути. При этом на каждом шаге осуществляется загрузка очень маленького объема данных. Поскольку таблица клиентов используется во всех сеансах, дерево создается в памяти только раз и сохраняется в кэше ASP.NET для повышения производительности. Главная форма Первая форма приложения включает элемент управления List, отображающий четыре строки, которые вместе содержат 26 букв алфавита. Свойство Text объекта ListItem определяет диапазон, а свойство Value содержит буквы, разделенные запятыми. <mobile:form id="MainForm" runat="server"> <mobile:List id="Menu" runat="server" OnItemCommand="Menu_ItemCommand"> <Item Value="A,B,C,D,E,F" Text="A-F" /> <Item Value="G,H,I,J,K,L,M" Text="G-M" /> <Item Value="N,O,P,Q,R,S" Text="N-S" /> <Item Value="T,U,V,W,X,Y,Z" Text="T-Z" /> </mobile:List> <mobile:Label id="Desc" runat="server" Text="Select Customers" /> <mobile:TextBox id="Initials" runat="server" Size="5" /> <mobile:Command id="FindButton" runat="server" OnClick="FindButton_Click">Find</mobile:Command> </mobile:form> Внизу формы располагаются текстовое поле и командная кнопка. Когда пользова-тель щелкает эту кнопку, текст из поля ввода используется для выбора отображаемого в следующей форме подмножества клиентов. При выборе одного из элементов списка выполняется такой код: void Menu_ItemCommand(object sender, ListCommandEventArgs e) { string[] menuItems = e.ListItem.Value.Split(",".ToCharArray()); Session["AvailableInitials"] = menuItems; LetterList.DataSource = menuItems; LetterList.DataBind(); //Переход ко второй форме ActiveForm = SecondMenuForm; } Разделенный запятыми список букв превращается в массив строк и временно сохраняется в кэше сеанса. Позднее он понадобится для проверки текста, который пользователь должен ввести в текстовое поле Find для поиска. Тот же массив строк используется для заполнения другого объекта List. В данном случае экземпляр эле-мента управления связывается с динамически сгенерированными данными, а не со статическими. Для осуществления выбора пользователю нужно просто нажимать клавиши на цифровой клавиатуре. Однако если он предпочитает текстовый ввод, то может вос-
Программирование для мобильных устройств Глава 8 329 пользоваться текстовым полем для более точного поиска. На рис. 8-11 показана пос-ледовательность выводимых экранов приложения при работе пользователя, которому не нравится вводить текст. Рис. 8-11. Расширенная последовательность букв для сужения области поиска Свойство ActiveForm используется в классе страницы для выбора и определения текущей активной формы. Когда страница вводится в первый раз, активизируется и отображается первая ее форма. После возврата этой формы на экране может появить-ся вторая форма, активизированная либо программно, либо в результате перехода, осуществленного пользователем. Свойство ActiveForm является одним из важнейших элементов, используемых при разработке интерфейса, который строится по принципу мастера. В нашем примере после возврата формы свойству ActiveForm присваивается идентификатор второй формы-меню. Вторая форма-меню Следующая форма нашего приложения выводит буквы, перечисленные в свойстве Value выбранного элемента ListItem. Ее код приведен ниже: <mobile:form id="SecondMenuForm" runat="server"> <mobile:List id="LetterList" runat="server" /> <mobile:Label id="Desc" runat="server" Text="Select Customers" /> <mobile:TextBox id="CustName" runat="server" /> <mobile:Command id="FindCustomerButton" runat="server" text="Find" /> </mobile:form> Когда пользователь щелкает одну из букв, код подготавливает в памяти запрос и возвращает объект ADO.NET DataView, содержащий список клиентов, имена ко-торых начинаются с выбранной буквы. Этот список выводится с помощью элемента управления ObjectList. Если пользователь хочет ввести строку, чтобы сузить область поиска, он может это сделать в текстовом поле, расположенном в нижней части второй формы (рис. 8-12). Текст, который здесь вводится, подлежит проверке - принимаются только те строки, которые начинаются с указанной буквы.
330 Часть II Специализированные средства ASP.NET Рис. 8-12. Пользователь вводит текст для более точной идентификации клиента Форма со списком клиентов Теперь наступила очередь вывода списка клиентов. Для этой цели используется объект ObjectList, который связан с набором строк, извлеченных следующим кодом: DataView SelectCustomers(string filterString) { //Извлечение данных DataTable data = GetData(); DataView view = new DataView(data); //Фильтрация данных string cmdText = ""; string[] initials = filterString.Split(",".ToCharArray()); string opOR = ""; foreach(string s in initials) { cmdText += String.Format("{0} {2} LIKE '{1}%' ", opOR, s, "companyname"); opOR = " OR "; } //Возврат отфильтрованных данных view.RowFilter = cmdText; return view; } Код связывает объект-представление с глобальной таблицей клиентов, загружен-ной в начале работы приложения. Этот объект с предварительно отфильтрованными данными присваивается свойству DataSource элемента управления ObjectList: void LetterList_ItemCommand(object sender, ListCommandEventArgs e) { DataView view = SelectCustomers(e.ListItem.Value); CustomerList.DataSource = view; CustomerList.DataBind(); ActiveForm = CustomerForm; }
Программирование для мобильных устройств Глава 8 331 А структура третьей формы такова: <mobile:form id="CustomerForm" runat="server" paginate="true"> <mobile:ObjectList id="CustomerList" runat="server" Wrapping="nowrap" AutoGenerateFields="False" LabelField="Company"> <Field Name="Company" DataField="companyname" Visible="False" /> <Field Name="Address" DataField="address" /> <Field Name="City" DataField="city" /> <Field Name="Country" DataField="country" /> <Field Name="Phone" DataField="phone" /> </mobile:ObjectList> <mobile:Command id="BackMenuCommand" runat="server" text="Back" /> </mobile:form> В элементе управления ObjectList выводится список значений, связанных с ним посредством атрибута LabelField. Когда пользователь щелкает один из этих элементов, выводится детальная информация о выбранном клиенте (рис. 8-13) - ее состав опре-деляется элементами разметки <field>. В число отображаемых полей должно входить и поле, заданное в атрибуте LabelField, в нашем примере - поле Company. Если вы не хотите, чтобы оно выводилось, установите его атрибут Visible в false. Атрибут Name позволяет определить псевдоним для поля исходной таблицы данных. Рис. 8-13. Итог работы приложения - найденная информация о клиенте Представление, генерируемое элементом управления ObjectList, равно как и элемен-том управления List, может быть частично настроено с использованием шаблонов. Внимание! В WML Web-страница обычно именуется карточкой (card). Группа карточек называется колодой (deck). В большинстве браузеров WML-типа размер колоды, которую они могут получить, ограничен и определяется конкретным устройством. Поскольку это ограничение применяется к контенту, компилируемому шлюзом WAP, Web-приложению трудно определить, не велик ли размер колоды для конкретного устройства. Следствием его превышения может быть ошибка, вызванная переполнением колоды. Риск ее появ-ления особенно велик для динамических, связанных с данными, страниц. Заметьте, что ASP.NET не обрезает страницы, чтобы "вписаться" в рамки, установленные устройством. Поэтому программисту лучше использовать разбивку формы на страницы или рассчиты-вать примерно на 1200 символов как на вероятный порог браузера.
332 Часть II Специализированные средства ASP.NET Адаптивный рендеринг Мобильные приложения могут адаптировать внешний вид элементов управления к определенным устройствам или категориям устройств. Основываясь на знании возможностей устройств, нетрудно варьировать стили элементов управления и в процессе рендеринга формировать более богатый интерфейс для устройств, которые способны его поддерживать. Адаптивный рендеринг осуществляется с использовани-ем фильтров устройств. В разметке элемента управления фильтр представлен тэгом <DeviceSpecific>. Фильтры устройств Исполняющая среда ASP.NET абстрагирует код .aspx и генерирует разметку, под-ходящую для конкретного устройства. Однако в случае, когда для одного и того же элемента управления должен генерироваться разный код в зависимости от типа устройства, для приложения следует определить набор фильтров устройств и задать код, генерируемый каждым из фильтров. Фильтр задается с использованием тэгов <DeviceSpecific> и <Choice>. Элемент <DeviceSpecific> - это просто контейнер для хранения вариантов выбо-ра. Каждый из вариантов представлен набором пар, состоящих из названия характе-ристики устройства и соответствующего значения. Фильтры определяются в файле web.config. Рассмотрим фрагмент такого файла: <deviceFilters> <filter name="isHTML32" compare="PreferredRenderingType" argument="html32" /> <filter name="isWML11" compare="PreferredRenderingType" argument="wml11" /> <filter name="prefersGIF" compare="PreferredImageMIME" argument="image/gif" /> </deviceFilters> У элемента <filter> есть имя, используемое для связывания его с элементом <choice>. Атрибут compare определяет функцию устройства, в наличии которой вы хотите убедиться, а в атрибуте argument задается значение для проверки. Например, если вы хотите, чтобы на устройствах, поддерживающих язык WML 1.1, надпись выводилась курсивом, а на остальных - обычным шрифтом, напишите такой код: <mobile:Form runat="server"> <mobile:Label runat="server" text="Some text"> <DeviceSpecific> <choice filter="isWML11" font-italic="true" /> </DeviceSpecific> </mobile:Label> </mobile:Form> Подобный код может применяться только при условии, что в web.config опреде-лены необходимые фильтры. Варианты выбора оцениваются в порядке, в котором они представлены в структуре <DeviceSpecific>. Таким образом, данная технология позволяет декларативным способом проверять возможности устройства и соответс-твующим образом конфигурировать элемент управления.
Программирование для мобильных устройств Глава 8 333 Создание шаблонов элементов управления Фильтры устройств могут использоваться для изменения шаблона, используемого списочными элементами управления по умолчанию. Так, в описанном здесь примере выводится номер телефона выбранного пользователем клиента. Почему бы не свя-зать его с элементом управления PhoneCall? Тогда пользователь сможет позвонить клиенту, щелкнув этот элемент. Оба используемых в нашем приложении списочных элемента управления, List и ObjectList, позволяют изменять структуру применяемого по умолчанию шаблона. Следующий код показывает, как изменить шаблон, используемый для рендеринга элементов объекта List, применив элемент управления PhoneCall. <mobile:List id="CustomerList" runat="server" OnItemCommand="ItemCommand"> <DeviceSpecific> <Choice> <ItemTemplate> <mobile:PhoneCall runat="server" Text='<%# Eval("companyname") %>' PhoneNumber='<%# Eval("phone") %>'> </mobile:PhoneCall> </ItemTemplate> </Choice> </DeviceSpecific> </mobile:List> Если опустить свойство Filter, выбор будет осуществляться по умолчанию, что позволит вам изменять вывод некоторых встроенных элементов управления, исполь-зуя шаблоны. Управление Большинству Web-приложений необходимо сохранять состояние между последо-вательно выполняемыми запросами, и мобильные приложения не являются исключе-нием. ASP.NET предоставляет несколько сервисов для управления состоянием, среди которых важнейшую роль играют сервисы состояния представления и состояния сеанса. Состояние представления - это данные уровня страницы, которые сохраня-ются и загружаются для каждого запроса этой страницы, благодаря чему и становится возможной разработка целостных приложений поверх протокола, не сохраняюще-го состояние. Состояние представления Для страниц ASP.NET состояние представления записывается в скрытую переменную уникального серверного объекта формы. Оно передается между клиентом и сервером при каждом запросе. Мобильное приложение использует его точно так же, как и клас-сическое Web-приложение, хотя внутренняя реализация этого процесса различна. Чтобы приспособить приложение к работе с узкой полосой пропускания, ASP.NET не передает состояние представления мобильной страницы клиенту. Оно остается на сервере и сохраняется как часть состояния сеанса пользователя. Из-за этого кэширо-ванное состояние и реальное состояние страницы могут в какой-то момент оказаться различными. Предположим, что пользователь переходит к определенной странице и затем возвращается обратно, используя кнопку Back. В этот момент текущая страница не соответствует состоянию представления, хранящемуся на сервере. Учитывая возможность такой ситуации, ASP.NET хранит для мобильной страницы на сервере не просто состояние, а журнал состояний. Каждой странице присваивается 
334 Часть II Специализированные средства ASP.NET числовой идентификатор, который соответствует позиции информации о ней в журна-ле состояний. Размер массива журнала по умолчанию устанавливается равным шести, но, как следует из приведенного ниже кода, в файле web.config для него можно задать другое значение. Конечно, использование слишком больших значений нежелательно, поскольку ведет к напрасному расходу памяти сервера. <configuration> <system.web> <mobileControls sessionStateHistorySize="15" /> </system.web> </configuration> Поскольку состояние мобильных страниц и элементов управления хранится в объек-те Session, существует вероятность, что оно будет потеряно, если срок хранения состо-яния истечет или если процесс будет возвращен в пул. Когда состояние мобильной страницы восстановить невозможно, генерируется событие ViewStateExpire. В резуль-тате обычно выбрасывается исключение; однако если у приложения есть возмож-ность восстановить согласованное состояние в обработчике данного события, нужно переопределить метод OnViewStateExpire класса MobilePage и выполнить в нем код восстановления. Примечание Так же, как в классических Web-формах ASP.NET, использование состояния представления можно свести к минимуму, а если приложение с ним не работает, вообще отключить данную функцию. Этой цели служит атрибут EnableViewState директивы @Page; если вы хотите отключить состояние представления для отдельного элемента управления, используйте свойство EnableViewState программного интерфейса элемента управления. Приватное состояние представления Следует отметить, что даже в тех случаях, когда состояние представления отключе-но, мобильные элементы могут сохранять информацию состояния в скрытых полях на клиенте. Например, элемент управления MobilePage сохраняет индекс текущей активной формы в скрытом поле, реализация которого очень похожа на реализацию аналогичного поля Web-форм. Идентификатор журнала состояний также сохраняется в этом поле. Свойство ClientViewState возвращает строку, представляющую сериализованную версию приватного состояния представления. Приложения не могут добавлять сюда пользовательскую информацию. Приватное состояние представления используется только для хранения общей информации о состоянии, всегда сохраняется на клиенте и не может быть отключено. Примечание Возможность создания скрытых переменных в результирующей разметке обеспечивается наличием в составе класса MobilePage коллекции HiddenVariables. Хотя этот элемент не имеет ничего общего с приватным состоянием представления, он мо-жет служить довольно удобной его альтернативой. Мобильные элементы управления не поддерживают свое состояние так, как это делают серверные элементы управления. Состояние сеанса Состояние сеанса привязано к идентификатору сеанса в приложении. По умолча-нию этот идентификатор хранится в клиентском файле cookie и извлекается при каждом обращении к серверу. Использование cookie в мобильных приложениях про-блематично, поскольку некоторые устройства и шлюзы их не поддерживают. По-этому для таких приложений в ASP.NET применяется другой способ сохранения состояния сеанса. Суть его заключается в том, что браузер перенаправляется на другую страницу, с URL, включающим идентификатор, который затем удаляется, а то, что 
Программирование для мобильных устройств Глава 8 335 остается, составляет реальный URL страницы. Однако в таком случае особое внимание необходимо уделять устройствам, у которых применение таких нестандартных URL может вызвать затруднения. Когда без сохранения состояния сеанса невозможно обойтись, хорошей альтерна-тивой cookie-файлам являются скрытые переменные. Заключение Основные сложности, связанные с разработкой мобильных приложений, обуслав-ливаются различием моделей представления, используемых разными браузерами и шлюзами. Рынок беспроводных устройств сильно фрагментирован, причем в Европе сильнее, чем в других частях света. Следовательно, если вы хотите создать надежное и эффективное приложение, придется сделать его подходящим для широкого диапа-зона устройств. Написание нескольких приложений вместо одного - сомнительный выход, поскольку такой проект оказывается чересчур дорогостоящим. Однако в мире беспроводных устройств различия настолько существенны, что даже столь тщательно разработанная библиотека мобильных элементов управле-ния, как используемая в ASP.NET, не обеспечивает стопроцентной совместимости со всеми устройствами. Необходимость адаптации приложения к совершенно различ-ным устройствам с разными возможностями заставляет разработчиков внимательно относиться к выбору навигационных моделей и способов ввода данных, избегать применения команд, специфических для конкретных устройств. К счастью, мобиль-ные элементы управления ASP.NET прекрасно адаптируются к разным ситуациям и абстрагируют особенности представления контента, позволяя вам сосредоточиться на логике приложения. Только факты Мобильные элементы управления ASP.NET являются расширением ее серверных элементов управления. Мобильная страница должна содержать минимум одну форму, но их может быть и несколько, хотя в каждый конкретный момент времени активна и выводится на экран только одна. Разбивка на страницы - это механизм автоматического разделения контента формы на небольшие фрагменты кода разметки. Результирующий вывод такой страницы завершается стандартными элементами управления, служащими для перемещения от одной части страницы к другой. Элементы управления List, ObjectList и SelectionLis являются мобильными эквива-лентами списочных и итеративных элементов управления ASP.NET. В мобильных приложениях применение клавиатуры ограничивается возможнос-тями конкретного устройства. В общем случае пользователь мобильного устройства предпочтет выполнить лиш-ний щелчок, чем вводить текст. Между разными мобильными устройствами имеются существенные аппарат-ные и программные различия. И хотя в ASP.NET проделана огромная работа по абстрагированию этих различий, следует всегда тщательно тестировать приложе-ния на реальных устройствах. Фильтры устройств используются с целью декларативного определения разных элементов разметки для разных типов устройств. 
Глава 9 Работа с изображениями Как ни громко это звучит, но без изображений Всемирная паутина не была бы тем, чем она сейчас является. Благодаря поддержке графики браузерами Web превратилась в новый мультимедийный канал. В наши дни почти на каждой загружаемой из Web странице так много изображений, что она, пожалуй, больше напоминает рекламную страницу журнала, чем HTML-страницу. И уже трудно поверить, что всего лишь семь-восемь лет назад можно было создать сайт, используя только текстовый редактор да помощь друга, немного знакомого с Adobe Photoshop. Теперь подготовкой графики для Web и оформлением Web-страниц занимаются профессиональные дизайнеры, и программисты практически не принимают участия в этом процессе. Хотя изображения и являются плодом творческих усилий, а их раз-мещение на страницах сайта требует тщательного планирования, они практически всегда публикуются как статические файлы, и все, что нужно от программиста в такой ситуации, - это зарезервировать для них место на странице. Однако далеко не все изображения являются просто украшением сайта. Зачастую они служат информационным ресурсом, как в галереях изображений, графических банках данных, а также приложениях для финансового и экономического анализа. В таких приложениях изображения могут генерироваться автоматически (как графики и диаграммы) или перед публикацией подвергаться специальной обработке (скажем, на них могут наноситься водяные знаки или сообщения об авторском праве). Существуют и специальные инструментальные средства сторонних производите-лей для создания диаграмм и обработки изображений для Web. До появления .NET Framework обойтись без них было невозможно, но теперь, благодаря появлению в этой системе средств поддержки GDI+, приложения ASP.NET могут выполнять мно-гие подобные задачи самостоятельно, так что дополнительные инструментальные средства и библиотеки чаще всего не требуются. Вы будете удивлены, когда увидите, сколь многое возможно при грамотном использовании GDI+ и других функций .NET Framework. Доступ к изображениям из Web-страниц В HTML предусмотрен только один способ ссылки на изображение - с помощью тэга <img> , в котором задан URL графического файла. Поэтому для того чтобы изо-бражение можно было вывести на странице, оно должно быть идентифицировано посредством URL, а его биты должны выводиться в выходной поток, возвращаемый Web-сервером для этого URL. Во многих случаях URL указывает на статический ресурс, такой, как файл GIF или JPEG. Тогда Web-сервер обрабатывает запрос са-мостоятельно и предоставляет клиенту графический файл, не обращаясь к внешним компонентам. Однако то, что в Web многие тэги <img> связаны со статическими файлами, еще не говорит об отсутствии другого способа включения изображений в Web-страницы. Давайте вкратце рассмотрим основные принципы доступа к изображениям в Web.
Работа с изображениями Глава 9 337 Элемент <img> HTML-тэг <img> используется для вывода изображения на Web-странице. Он под-держивает несколько атрибутов, с помощью которых задается ширина, высота изоб-ражения и альтернативный текст, выводимый, когда оно не доступно. HTML-опре-деление этого элемента таково: <img id="control ID" alt="alternate text" align="top | middle | bottom | left | right" border="border width" height="image height" src="URL" width="image width" /> В ASP.NET рендеринг тэга <img> осуществляется классом HtmlImage. Кроме то го, данный тэг может быть сгенерирован с помощью элемента управления Image, пре-доставляющего более абстрактный интерфейс программирования, но не имеющий никаких дополнительных функций. Класс HtmlImage принадлежит к пространству имен System.Web.UI.HtmlControls, а Image - к пространству имен System.Web.UI.Web-Controls. Вывод изображений без использования серверных элементов управления Хотя в вашем распоряжении имеется два серверных элемента управления, представляю-щих тэг <img>, в хорошо оптимизированном приложении ASP.NET ни один из них не используется. Как ни просты они в обращении, при выполнении такой элементарной задачи, как вывод изображения, лучше обходиться без них, ведь они потребляют серверные ресурсы, а необходимости в этом нет никакой. Как правило, более эффек-тивным является простой рендеринг или связывание с данными. Следующий фрагмент кода выводит изображение без создания серверного эле-мента управления Image: <img src='<%# выражение, при вычислении которого получается URL изображения %>' /> Как это выражение работает без установки runat=server? Разве не должно оно выводиться в выходной поток как есть? Фокус заключается в том, что ASP.NET 2.0 преобразует все выражение в элемент управления DataBoundLiteralControl, содержа-щий статический и динамический текст. А поскольку у этого элемента управления есть метод DataBind, получающий доступ к #-выражению, выражение вычисляется правильно и его результат вставляется в тэг <img>. При конфигурировании тэга <img> на сервере следует уделять повышенное вни-мание URL изображения, особенно в случае, когда он является функцией пользова-тельского ввода. Такой URL может быть злонамеренно модифицирован пользователем таким образом, чтобы на сервере выполнился нежелательный сценарий. Для проверки URL не обязательно обращаться к серверу - можно вызвать локальную функцию с выражением связывания с данными. Динамические изображения Хотя тэг <img> используется главным образом со статическими файлами, с его помо-щью легко выводить изображения, хранящиеся в других контейнерах, например в базе данных, среди ресурсов сборки или даже в памяти Web-сервера. Структура тэга при этом остается неизменной, а меняется лишь расширение URL да идентификатор ти па контента в HTTP-ответе. Если тэг <img> будет указывать на страницу .aspx, Web-сер-вер запустит эту страницу и вернет браузеру результат. И если этот результат будет 
338 Часть I I Специализированные средства ASP.NET представлять собой изображение подходящего формата, браузер успешно выведет его на экран. Давайте посмотрим, как все это происходит. Ссылки на файлы, не являющиеся файлами изображений С точки зрения браузера Web-страница - это всего лишь длинная цепочка после-довательно обрабатываемых символов. Одни ее части он просто выводит на экран, другие, такие как <b>, интерпретирует определенным образом. Встретив тэг <img>, браузер знает, что ему нужно открыть еще один канал загрузки и запросить ресурс с заданным в этом тэге URL. Тип URL и протокол не имеют для браузера никакого значения, единственное, что для него важно, - это чтобы формат результата соот-ветствовал одному из типов данных MIME. Итак, запросив ресурс с заданным URL и получив результат, браузер выводит его на экран согласно правилам, диктуемым его MIME-типом и атрибутом, заданным в тэге <img>. Если же тип результата оказывается неподходящим, генерируется ошибка и выводится стандартная картинка, отмечающая место недостающего изображения. Чтобы вы лучше представили себе весь процесс, рассмотрим последовательность действий, выполняемых при отправке изображения браузеру из страницы .aspx. Внимание! Для вывода изображения, хранящегося в файловой системе, достаточно указать URL этого файла в тэге <img>. Если же байты изображения хранятся в другом месте (например, в базе данных или в памяти) либо вам нужно подвергнуть их перед выводом определенной обработке, следует связать тэг <img> с серверным обработчиком HTTP, который и вернет байты результирующего изображения. Идентификация типа содержимого Все ответные пакеты, направляемые браузеру, содержат заголовок Content-Type с ин-формацией о типе и формате содержащихся в пакете данных. Прочитав этот заголовок, бра узер решает, как ему обрабатывать данные. Ниже приведен блок заголовков ответа, который IIS возвращает браузеру, запросившему изображение в формате JPEG: HTTP/1.1 200 OK Server: Microsoft-IIS/6.0 Date: Thu, 24 Nov 2005 14:30:12 GMT X-Powered-By: ASP.NET X-AspNet-Version: 2.0.50727 Cache-Control: private Content-Type: image/jpeg Content-Length: 28521 В ASP.NET заголовок Content-Type в ответном пакете устанавливается объек-том HttpResponse. По умолчанию свойство ContentType этого объекта имеет значение text/html; другими его допустимыми значениями являются идентификаторы всех MIME-типов HTTP. Конечно, для того чтобы выгрузка страницы прошла успешно, тип выводимого страницей контента должен быть задан только один раз и до того, как эта страница направит какие-либо данные в выходной поток. Следующая строка показывает, как установить свойство ContentType для страницы, возвращающей изо-бражение в формате JPEG: Response.ContentType = "image/jpeg"; Вывод изображения в выходной поток Ниже приведен код демонстрационной страницы, которая выводит изображение, полученное от другой страницы ASP.NET: <%@Page Language="C#" %> <html>
Работа с изображениями Глава 9 339 <body> <form runat="server"> <img src="image.aspx" /> </form> </body> </html> Страница image.aspx получает доступ к байтам изображения и направляет их в вы-ходной поток: protected void Page_Load(object sender, EventArgs e) { string fileName = Server.MapPath(@"/proaspnet/images/slotmachine.jpg"); Response.ContentType = "image/jpeg"; Response.WriteFile(fileName); } Перед выводом байты изображения можно подвергнуть необходимой обработке. При всей своей простоте продемонстрированное решение открывает неограни-ченные возможности динамического манипулирования изображениями. Атрибуту src тэга <img> клиентская страница присваивает URL ресурса .aspx. Серверная страница извлекает либо генерирует байты изображения и записывает их в выходной поток, указав тип этого изображения. Внимание! Динамическое предоставление изображений посредством страниц ASP.NET - не самое эффективное решение. Гораздо лучше воспользоваться обработчиком HTTP, который не будет делать ничего лишнего. О том, как возвращать изображения с помощью обработчиков HTTP, я расскажу далее в этой главе. Загрузка изображений из ресурсов Управляемые сборки могут содержать ресурсы - изображения, локализованный текст, сценарии и другие вспомогательные файлы, упакованные вместе с откомпилиро-ванным кодом в один файл сборки, подлежащий установке на сервер. Например, system.web - сборка, являющаяся ключевым компонентом ASP.NET, - содержит в виде ресурсов весь код сценариев, который элементы управления могут вставлять в клиентские страницы (см. главу 6). Эта же сборка включает и множество изобра-жений, главным образом используемых для идентификации серверных элементов управления на панели инструментов Microsoft Visual Studio 2005. Включение изображений в проект в качестве ресурсов Для того чтобы включить файл в проект в качестве ресурса, его нужно добавить в этот проект как обычно, а затем выбрать для его свойства Build Action значение Embedded Resource (рис. 9-1). Заметьте, что этот прием действует лишь в проектах, предназна-ченных для создания динамических библиотек (DLL). Если же вы разрабатываете не библиотеку, а Web-приложение, у добавленного файла не будет свойства Build Action, поскольку данное свойство для такого проекта не имеет смысла. Имя ресурса должно соответствовать следующему соглашению: пространство_имен .имя_файла.расширение. Элемент пространство - это используемое по умолчанию пространство имен сборки, а элементы имя_файла и расширение - имя и расширение включенного в ее состав файла. Для файла, процесс добавления которого показан на рис. 9-1, имя ресурса в сборке - ProAspCompLib.SlotMachine.jpg (рис. 9-2).
340 Часть I I Специализированные средства ASP.NET Рис. 9-1. Включение изображения в сборку как встроенного ресурса Рис. 9-2. Просмотр ресурсов сборки с использованием утилиты .NET Reflector Ссылки на встроенные ресурсы Любой файл, встроенный в сборку в виде ресурса, доступен программно, и с ним мож-но работать точно так же, как с любым другим файлом того же типа. В частности, это означает, что вы можете встроить в сборку маленькие картинки специализированных элементов управления. Сборка такого элемента будет содержать все необходимое для его использования, и при этом элемент будет обладать полноценным графическим изображением. Как же ссылаться на подобные встроенные изображения в прило-жении? Это можно сделать двумя способами; какой из них предпочесть, зависит от характеристик файла ресурса. Встроенные изображения доступны только через URL, задаваемый внутри тэга <img>. Поэтому для извлечения битов изображения из сборки и отправки их браузеру требуется обработчик HTTP. Предположим, что такой обработчик у вас имеется; пусть его именем будет image.axd. В таком случае тэг <img>, используемый для вывода изо-бражения с помощью данного обработчика, может выглядеть следующим образом: <img src="image.axd?asm=...&res=..." />
Работа с изображениями Глава 9 341 Атрибут src содержит URL обработчика, дополненный аргументами строки за-проса, необходимыми для идентификации сборки и ресурса. Наш обработчик будет принимать имя ресурса и извлекать этот ресурс из файла сборки. Написать такой обработчик - задача несложная, и далее будет показано, как это делается, в контексте более обширного примера. А пока давайте рассмотрим код, составляющий основу обработчика, - тот, который извлекает поток ресурса из за-данной сборки. Доступ к потоку ресурса Изображения - не единственный вид ресурсов, которые можно включать в сборки; так же можно поступать и с файлами сценариев, строками текста и файлами XSLT. В од-них случаях ресурс нужно просто извлечь из сборки, в других - сначала обработать, а уже затем предоставить клиенту. Как же считывается из сборки нужный ресурс? Для этой цели используются два метода класса Assembly (определенного в про-странстве имен System.Reflection) - GetManifestResourceNames и GetManifestResource Stream. Первый из них возвращает массив строк, каждый элемент которого является именем одного из ресурсов сборки, а второй принимает одно из этих имен и возвра-щает поток соответствующего ресурса. Следующий код показывает, как заполнить раскрывающийся список ResourceNames именами ресурсов, содержащихся в сборке system.web: Assembly dll = Assembly.LoadWithPartialName("system.web"); string[] resources = dll.GetManifestResourceNames(); ResourceNames.DataSource = resources; ResourceNames.DataBind(); На рис. 9-3 продемонстрирован результат выполнения этого кода. Рис. 9-3. Список ресурсов, содержащихся в сборке system.web Для того чтобы прочитать байты ресурса, нужно воспользоваться методом GetManifest ResourceStream: private System.Drawing.Image LoadImageFromResources(string imageID) { Assembly dll = Assembly.LoadWithPartialName("system.web"); Bitmap img = new Bitmap(dll.GetManifestResourceStream(imageID)); return img; }protected void buttonSave_Click(object sender, EventArgs e) {
342 Часть I I Специализированные средства ASP.NET string resourceName = ResourceNames.SelectedValue; System.Drawing.Image img = LoadImageFromResources(resourceName); if (img != null) { string path = string.Format(@"c:\{0}", resourceName); StreamWriter bin = new StreamWriter(path); MemoryStream ms = new MemoryStream(); img.Save(ms, ImageFormat.Jpeg); img.Dispose(); ms.WriteTo(bin.BaseStream); ms.Close(); bin.Close(); //Вставка кода для уведомления пользователя string js = "alert('Done.');"; ClientScript.RegisterStartupScript(this.GetType(), "Alert", js, true); } } Метод GetManifestResourceStream возвращает поток, представляющий содержи-мое заданного ресурса. Прибегнув к API ввода-вывода .NET Framework, вы можете сохранить этот поток на диске. (Приведенный код работает только при условии, что процесс ASP.NET имеет разрешение на запись в целевую папку; по умолчанию для папки C:\ такое разрешение ему предоставлено.) Внимание! В ASP.NET 2.0 появилась возможность автоматизировать вывод изображений, хранящихся в откомпилированных сборках в виде ресурсов. Эта возможность представ-лена методом GetWebResourceUrl класса ClientScriptManager и атрибутом [WebResource], а предназначена она прежде всего для специализированных элементов управления и пользовательских классов страниц, явно откомпилированных в виде отдельных сборок. Я вернусь к этой теме в главе 13, когда буду рассказывать о специализированных сер-верных элементах управления. Доступ к изображениям, хранящимся в базе данных Вопрос о целесообразности применения баз данных для хранения изображений яв-ляется спорным. Одни специалисты считают такое решение вполне эффективным, другие говорят, что никогда не делали этого и не будут делать. Как бы там ни было, фактом остается то, что все популярные СУБД уже давным-давно поддерживают большие двоичные объекты - BLOB (binary large objects). Поля типа BLOB пред-назначены не только для изображений, в них могут храниться мультимедийные или просто большие текстовые файлы. Очевидно, что должна была существовать серьезная причина для обеспечения поддержки BLOB в Microsoft SQL Server, Oracle и других популярных СУБД. Работа с двоичными полями Чтение информации из двоичных полей таблиц баз данных выполняется так же, как из любых других полей, - с помощью классов ADO.NET. Ведь, в конце концов, BLOB - такой же тип данных, как любой другой. Если вам известно, что объект имеет не слишком большой размер (скажем, несколько десятков килобайтов), прочитать его можно за один раз. В противном случае, скорее всего, придется осуществить несколько последовательных операций чтения.
Работа с изображениями Глава 9 343 Для извлечения данных из поля типа BLOB очень удобно пользоваться объектом чтения данных (data reader) ADO.NET. Это не означает, что вы не можете сохранять содержимое больших двоичных объектов в объектах DataSet. Но не следует забывать, что DataSet представляет собой просто кэш данных в памяти, а кэширование данных такого объема в памяти Web-сервера - не лучшая идея. Данные типа BLOB следует считывать, использовать и удалять из памяти как можно скорее. Для начала давайте считать, что поле BLOB, с которым нам предстоит работать, содержится в базе данных SQL Server. Позднее я выскажу несколько дополнительных соображений относительно Oracle. Чтение изображений из полей типа BLOB Для того чтобы прочитать изображение из BLOB-поля с помощью ADO.NET, нужно выполнить соответствующую SQL-команду, а затем с помощью метода ExecuteScalar получить ее результаты и сохранить их в байтовом массиве. После этого массив можно отправить клиенту, осуществив запись двоичных данных в выходной поток. Давайте напишем обработчик HTTP, который будет возвращать изображение более эффектив-ным способом, чем при использовании обыкновенных страниц ASP.NET: public class DbImageHandler : IHttpHandler { public void ProcessRequest(HttpContext ctx) { //Убеждаемся, что аргумент ID, содержащийся в URL, //является числом int id = -1; bool result = Int32.TryParse(ctx.Request.QueryString["id"], out id); if (!result) ctx.Response.End(); string connString = "..."; string cmdText = "SELECT photo FROM employees WHERE employeeid=@id"; //Извлекаем массив байтов из поля BLOB byte[] img = null; SqlConnection conn = new SqlConnection(connString); using (conn) { SqlCommand cmd = new SqlCommand(cmdText, conn); cmd.Parameters.AddWithValue("@id", id); conn.Open(); img = (byte[])cmd.ExecuteScalar(); conn.Close(); } //Подготавливаем ответ для браузера if (img != null) { ctx.Response.ContentType = "image/jpeg"; ctx.Response.BinaryWrite(img); } } public bool IsReusable { get { return true; } } }
344 Часть I I Специализированные средства ASP.NET Этот код действует на основе ряда предположений. Мы считаем, что, во-первых, в поле с именем photo содержится изображение в формате JPEG, во-вторых, изобра-жения должны извлекаться из определенной таблицы базы данных с использованием заданной строки подключения, а в-третьих, URL, посредством которого вызывается наш обработчик, содержит параметр строки запроса с именем id. Обратите внимание на попытку приведения параметра id к целочисленному типу, осуществляемую перед выполнением запроса. Ее цель - убедиться, что значение, которое будет использоваться в запросе в качестве цифрового идентификатора, дей-ствительно является цифровым идентификаторам, для того чтобы воспрепятствовать злонамеренному искажению этого запроса. Последнее особенно вероятно, когда SQL-команда составляется с использованием данных, введенных пользователем. Филь-трация лишних символов и данных недопустимых типов - основная мера борьбы с подобными атаками. Запись массива байтов в выходной поток осуществляется методом BinaryWrite объекта HttpResponse. Внимание! Если вы имеете дело с базой данных Northwind (как в приведенном выше примере), для обеспечения правильной обработки изображений потребуется дополнитель-ное действие. По некоторым причинам в версии этой базы данных для SQL Server 2000 изображения в столбце photo таблицы Employees хранятся в виде OLE-объектов. Скорее всего, так получилось в результате преобразования, которому база данных Northwind подверглась при переносе из Microsoft Access в SQL Server. Как бы там ни было, факт остается фактом, и массив байтов, который вы получаете из данного поля, содержит 78-байтовый префикс, не имеющий никакого отношения к изображению. Эти байты - просто заголовок, создаваемый при добавлении изображения в базу данных в виде OLE-объекта. Хотя приведенный выше код будет прекрасно работать с обычными объектами BLOB, для использования его с базой данных Northwind с целью извлечения значения поля photo таблицы Employees придется внести в него такое изменение: Response.OutputStream.Write(img, 78, img.Length); Иными словами, вместо вызова BinaryWrite, который не позволяет задать начальную позицию в байтовом массиве, нужно использовать приведенный выше вызов. На рис. 9-4 показана демонстрационная страница, предназначенная для тестиро-вания операции доступа к BLOB-полю. Эта страница предлагает пользователю выбрать идентификатор сотрудника, после чего осуществляет возврат формы. При рендеринге страницы полученный идентифи-катор добавляется в URL, заданный в элементе управления Image: string url = String.Format("dbimage.axd?id={0}", EmpList.SelectedValue); Image1.ImageUrl = url; Как рассказывалось в главе 2, обработчик HTTP должен быть зарегистрирован в файле web.config и связан с общедоступной конечной точкой сайта. В данном случае такой конечной точкой является dbimage.axd, а сценарий, который нужно добавить в конфигурационный файл для регистрации обработчика, приведен ниже: <httpHandlers> <add path="dbimage.axd" verb="*" type="ProAspNet20.Components.DbImageHandler, ProAspCompLib"/> </httpHandlers>
Работа с изображениями Глава 9 345 Рис. 9-4. Загрузка изображений, хранящихся в BLOB-поле базы данных Загрузка изображений в BLOB-поля Для загрузки изображения в базу данных нужно подготовить и выполнить соответ-ствующую команду, INSERT или UPDATE, - все как при записи в базу данных любого другого значения. По своему усмотрению вы можете воспользоваться либо SQL-ко-мандой, либо хранимой процедурой. Если поле BLOB предназначено для хранения текста, значение можно передавать в строковом параметре, но если оно служит для хранения изображений, то есть имеет в SQL Server тип Image, тогда соответствующему параметру нужно будет присвоить массив байтов. На рис. 9-5 показана страница, позволяющая загрузить локальный файл на Web-сервер и оттуда - в базу данных SQL Server. Рис. 9-5. Пользователь выбирает файл изображения и загружает его на Web-сервер, где оно обрабатывается и копируется в базу данных SQL Server Структура таблицы базы данных описана в табл. 9-1.
346 Часть I I Специализированные средства ASP.NET Табл. 9-1. Схема демонстрационной таблицы Столбец Тип и описание ImageID Содержит уникальный идентификатор изображения; целочисленный столбец с автоинкрементированием значений Bits BLOB-поле типа Image, содержащее биты изображения Description Текстовое описание изображения ImageSize Размер изображения в байтах MIME Строка, представляющая MIME-тип изображения Uploader Внешний ключ для идентификации пользователя, загрузившего изображения UploadTime Момент времени, когда была произведена загрузка Демонстрационная страница содержит элемент управления FileUpload, обычно ис-пользуемый для загрузки файлов. Он является нововведением ASP.NET 2.0 и функцио-нально эквивалентен элементу управления HtmlInputFile из ASP.NET 1.x. Для того чтобы загрузка файлов стала возможной, необходимо установить для формы атрибут EncType, присвоив ему значение multipart/form-data. В ASP.NET 2.0 оба элемента управления, HtmlInputFile и FileUpload, обеспечивают установку этого атрибута, так что беспокоиться о ней вам не нужно. <asp:FileUpload ID="theFile" runat="server" /> Загруженный файл доступен на сервере через свойство PostedFile элемента управ-ления, осуществившего загрузку. Это свойство возвращает объект типа HttpPostedFile, обладающий свойствами ContentLength, ContentType и InputStream. Первые два из них задают длину и MIME-тип файла, а третье возвращает сам этот файл в виде потоко-вого объекта, который легко преобразовать в массив байтов. В следующем коде показано, как можно загрузить изображение в таблицу MyPics базы данных MyBlobs, функционирующей под управлением SQL Server: protected void UploadButton_Click(object sender, EventArgs e) { //"theFile" - это идентификатор, связанный //с объектом FileUpload в разметке int sizeOfFile = theFile.PostedFile.ContentLength; int recordsAffected = -1; //Подготавливаем SQL-команду string connString = ConfigurationManager.ConnectionStrings["MyBlobs"].ConnectionString; SqlConnection conn = new SqlConnection(connString); using (conn) { string cmdText = "INSERT INTO MyPics " + "(bits, description, uploader, uploadtime, imagesize, mime) " + "VALUES (@imageBits, @description, @uploader, @uploadTime, " + "@imageSize, @mimeType)"; SqlCommand cmd = new SqlCommand(cmdText, conn); //Задаем параметры cmd.Parameters.AddWithValue("@imageBits", GetImageBits(theFile.PostedFile.InputStream, sizeOfFile));
Работа с изображениями Глава 9 347 cmd.Parameters.AddWithValue("@description", theDesc.Text); cmd.Parameters.AddWithValue("@uploader", theUploader.SelectedItem.Value); cmd.Parameters.AddWithValue("@uploadTime", DateTime.Now); cmd.Parameters.AddWithValue("@imageSize", sizeOfFile); cmd.Parameters.AddWithValue("@mimeType", theFile.PostedFile.ContentType); //Копируем биты в таблицу conn.Open(); recordsAffected = cmd.ExecuteNonQuery(); conn.Close(); } //Выводим сообщение для пользователя string msg = (recordsAffected != -1 ? "Successfully done!" : "Something went wrong..."); string js = String.Format("alert('{0}');", msg); ClientScript.RegisterStartupScript(this.GetType(), "Alert", js, true); return; }private byte[] GetImageBits(Stream fs, int size) { byte[] img = new byte[size]; fs.Read(img, 0, size); return img; } Доступ к содержимому полученного от клиента файла осуществляется посред-ством свойства InputStream класса HttpPostedFile. Полученный поток превращается в массив байтов, который используется в качестве значения параметра SQL-команды, помещающей изображение в BLOB-поле. Информация о типе содержимого и длине файла извлекается из самого файла. Остальная информация (описание изображения, сведения о том, кто его загрузил) считывается из полей формы. Примечание До появления ASP.NET для загрузки файла на сервер необходимо было, чтобы на нем выполнялся специальный фоновый процесс, который вызывался для осу-ществления этой операции. Теперь такой процесс не требуется, поскольку данную задачу берет на себя исполняющая среда ASP.NET. Примеры приложений На практике информация, которую вам нужно прочитать из базы данных, нередко бывает представлена данными нескольких типов, например текстовыми и двоичными. Предложенное выше решение построено таким образом, что для извлечения таких данных вам потребуется выполнить два запроса к базе данных; кроме того, в нем не предусмотрено никаких мер на случай, если извлекаемое изображение окажется чересчур большим. Оптимизация запроса к базе данных Очевидно, что с изображениями, размер которых потенциально велик, нужно работать аккуратно и нельзя допускать кэширования их в памяти. Однако описанные ресурсы .aspx и .axd, связанные с тэгами <img>, осуществляют одно лишнее обращение к базе 
348 Часть I I Специализированные средства ASP.NET данных. При выполнении первого вызова извлекается текстовая информация, а при выполнении второго - изображение. Если такой способ работы вас не устраивает, данное решение можно оптимизиро-вать. Для этого нужно создавать во временной папке копии изображений и прежде чем обращаться к базе данных, заглядывать в эту папку, чтобы избежать выполнения ненужных запросов. Такой подход особенно целесообразен при работе с большими изображениями - он позволяет как минимум сэкономить полосу пропускания меж-ду Web-сервером и сервером базы данных. Поскольку значения полей базы данных являются глобальными ресурсами, совместно используемыми всеми сеансами, сле-дует выработать соглашение об их именовании. Кроме того, нужно модифицировать исходный код вызывающей страницы таким образом, чтобы он содержал ссылку на существующее изображение, а не на серверную страницу. В таком случае доступ к изображениям будет осуществляться быстрее, поскольку IIS сможет разрешать за-просы на их получение, не обращаясь к ASP.NET. Если позволяют размер и количество изображений, доступ к базе данных можно оптимизировать еще одним способом - за счет кэширования. Для этого вам нуж-но будет запросить все поля и затем достаточно долго кэшировать значение поля BLOB, чтобы запрос на получение изображения мог быть обработан успешно. Для того чтобы при этом объект слишком не задерживался в памяти, можно хранить его в кэше и определить такую политику устаревания объектов, при которой они будут периодически уничтожаться. Оптимизация использования памяти Метод ExecuteScalar, которым мы пользовались для чтения содержимого BLOB-объектов, загружает данные, как только они становятся доступны. При этом объект считывается за один раз, причем вместе с остальными данными строки, из-за чего потребляется больше памяти, чем это необходимо. Очевидно, что применение метода ExecuteScalar или используемого по умолчанию объекта reader не является оптималь-ным решением. С BLOB-объектами можно работать иначе - особенно когда известно, что они могут содержать сотни мегабайтов данных. Поведение командных объектов ADO.NET можно контролировать с помощью дополнительного параметра, передаваемого методу ExecuteReader. Таким параметром является значение перечислимого типа CommandBehavior. Особенно интересно в этом отношении значение SequentialAccess, при использовании которого объект reader воз-вращает данные по мере поступления, а не все вместе одной строкой. Иными словами, он не дожидается, пока станут доступными данные всех столбцов строки. При конфигурировании указанного объекта для последовательного чтения важен порядок доступа к полям строки. Объект reader - это просто однонаправленный курсор, и он не может возвращаться назад, к тем данным, которые уже прочитал. Например, после того как вы получили третье поле, первое и второе поля становятся недоступными. Для чтения данных из поля BLOB следует пользоваться методом GetBytes объекта reader и заполнять этими данными массив. bytesRead = reader.GetBytes(colIndex, startPos, buf, 0, bufSize); while (bytesRead == bufSize) { //Обработка байтов ProcessBytes(buf); //Смещение начального индекса
Работа с изображениями Глава 9 349 startPos += bufSize; bytesRead = reader.GetBytes(colIndex, startPos, buf, 0, bufSize); }//Обработка оставшихся в буфере данных ProcessBytes(buf); Метод GetBytes принимает начальную позицию и размер буфера и возвращает количество успешно прочитанных байтов данных. Выполняя последовательное чте-ние с использованием метода GetBytes, вы экономите ресурсы системы и тем самым уменьшаете отрицательный эффект работы с чересчур большими BLOB-объектами. Соображения относительно SQL Server SQL Server хранит изображения в поле типа Image, которое может использоваться для любых двоичных объектов объемом от 8 Кбайт до 2 Гбайт. И хотя SQL Server поддерживает такие замечательные команды T-SQL, как UPDATETEXT, READTEXT и WRITETEXT, работать с большими изображениями все равно сложно. Если вы находите, что все сказанное выше - общие слова, и нуждаетесь в более конкретном совете по поводу того, как работать с изображениями, могу предложить вам следующее простое правило. Используйте файловую систему, когда имеете дело с изображениями, размер которых превышает 1 Мбайт, а также в случае, когда изобра-жений много, несколько сотен тысяч и более. Если же ваши изображения по размеру меньше 1 Мбайта и их число не превышает нескольких сотен тысяч, можно использо-вать для их хранения базу данных SQL Server. В граничном случае оба решения равно допустимы. Но какое бы решение вы не приняли, обязательно протестируйте прило-жение на предмет производительности и при необходимости оптимизируйте его. Не забудьте принять во внимание и такой важный параметр, как топология сети. В случае с Web-фермой удобнее хранить данные централизованно, то есть в базе данных SQL Server, а не в файловой системе. SQL Server обеспечивает очень быстрое чтение данных с диска и имеет прекрасный механизм кэширования, но протокол TDS (Tabular Data Stream - поток табличный данных), используемый им для передачи данных по сети, явно не рассчитан на передачу больших BLOB-объектов. Соображения относительно Oracle Oracle предлагает для работы с большими двоичными объектами два типа данных - BFILE и LOB. Оба поддерживают значения размером до 4 Гбайт, но при использовании первого из них данные хранятся в отдельном файле операционной системы, а не в базе данных. Есть у этих двух типов данных и другие отличия. В частности, при копиро-вании данных BFILE копируется только ссылка на файл данных, но не сам этот файл. Тип данных BFILE следует применять для работы с очень большими двоичными объектами, которые нецелесообразно хранить в базе данных. Однако его применение связано с определенными издержками, поскольку для синхронизации базы данных, файла и клиентского приложения требуются дополнительные операции обмена ин-формацией. В общем случае BFILE лучше использовать тогда, когда предполагается извлекать из базы данных небольшое количество информации. Если же вы собираетесь считывать все имеющиеся там данные, все же лучше остановиться на типе LOB. Следует ли хранить изображения в базе данных Лет десять назад я работал над одним из первых интернет-проектов - банком изоб-ражений. Предполагалось, что в банке будут содержаться изображения разного раз-мера и разрешения, предоставляемые зарегистрированным пользователям. Каждый элемент банка данных хранился в виде коллекции изображений - от миниатюры до полноразмерного изображения с высочайшим разрешением. При этом размер самого 
350 Часть I I Специализированные средства ASP.NET большого изображения составлял около 4 Мбайт. Каждое изображение хранилось в виде архива размером 6 Мбайт. База данных работала не на платформе Microsoft, но поддерживала поля типа BLOB. Мы решили хранить описания изображений и другие сведения из каталога в базе данных, а сами изображения - в отдельных файлах. Информация, необходимая для нахождения этих файлов, также содержалась в базе данных. Приложение было ориентировано на относительно небольшое число зарегистрированных пользователей, проблем с его масштабированием никогда не возникало, и ни члены команды, ни его пользователи никогда не жаловались на недостаточную производительность. Может ли данный пример, особенно с учетом давности событий, рассматриваться как свидетельство превосходства решения, основанного на хранении изображений в файлах, а не в базе данных? Конечно же, нет, но, читая между строк о том, как совре-менные СУБД реализуют BLOB-поля, я решил использовать этот опыт в подтверж-дение своей идеи относительно хранения изображений и баз данных. Так стоит ли хранить изображения в базе данных? Если вам нужно часто их редак-тировать, я предлагаю хранить их в отдельных файлах на жестком диске сервера. Тот же совет дам я и в случае, когда изображения очень велики (имеют размер порядка сотен мегабайтов). Если же они используются главным образом для чтения, относи-тельно статичны и при этом невелики (то есть их размер измеряется килобайтами), следует подумать о том, чтобы хранить их в базе данных. Динамическое генерирование изображений Как известно, одна иллюстрация стоит тысячи слов. Поэтому некоторые Web-сайты, скажем, финансовой или статистической направленности, выводят запрошенную пользователем информацию в графической, а не текстовой форме. Соответствующие диаграммы динамически генерируются на сервере и предоставляются браузеру в виде байтового потока в составе ответа, имеющего обычную структуру. До сих пор мы говорили о возврате изображений, прочитанных из файла или базы данных. Но в случае с динамически создаваемыми изображениями главный вопрос заключается не в том, как вернуть их клиенту, - эта задача давно решена практиче-ски для всех языков и платформ. Вопрос в том, как наиболее эффективно создавать и обрабатывать изображения на сервере. В решении этой задачи Web-приложения обычно полагаются на специализированные библиотеки и графические подсистемы других приложений, таких как приложения Microsoft Office. Но разработчикам приложений ASP.NET тут повезло больше, поскольку в их рас-поряжении есть мощная интегрированная графическая подсистема, предоставляющая объектную модель для генерирования изображений. Она называется GDI+. Краткий обзор классов GDI+ GDI+ - это графическое ядро Microsoft Windows XP, доступное и для других 32-и 64-разрядных платформ, в частности Windows 2000 и Windows 2003. Система GDI+, как следует из ее имени, является наследницей всем известной GDI (Graphics Device Interface - интерфейс графических устройств), входившей в состав предыдущих версий операционной системы Windows. .NET Framework инкапсулирует ключевые функции GDI+ в наборе управляемых классов и делает их доступными для прило-жений Web, Windows Forms и Web-сервисов. Большую часть сервисов GDI+ можно отнести к одной из двух категорий: двумер-ная векторная графика и операции с изображениями. К первой относятся средства 
Работа с изображениями Глава 9 351 рисования простых фигур, таких как линии, кривые и многоугольники; что касается второй категории, то сюда относятся функции для вывода растровых и векторных изображений, манипулирования ими, их сохранения и преобразования. Есть еще и функции, принадлежащие к третьей категории, - типографические; они обеспечивают вывод текста различными шрифтами. Имея в виду динамическое создание изображений на Web-сервере, мы сосредо-точимся на рисовании фигур и текста, а также сохранении результатов в файлах формата JPEG или GIF. Класс Graphics Центральным элементом модели программирования Win32 GDI является контекст устройства. Так называется структура данных, используемая для хранения инфор-мации о возможностях конкретного устройства отображения. Контекст устройства ассоциируется с поверхностью для рисования, такой как окно, бумага в принтере или блок памяти. Программы Win32 получают дескриптор контекста устройства и передают его всем вызываемым функциям GDI. В составе контекста устройства поддер-живается список установленных графических атрибутов - цвета фона и рисования, кисть, перо и шрифт. Можно сказать, что контекст устройства является связующим звеном между высокоуровневым API и драйверами устройств. Первое, что должно сделать приложение GDI+, - это создать или получить новый контекст устройства. Представляющий его класс Graphics не имеет конструктора. И хотя объект этого класса можно получить несколькими способами, в приложениях ASP.NET применяется только один из них - вызов метода Graphics.FromImage. Данный метод создает объект Graphics, основываясь на предоставленном вами графическом объекте .NET. Каждая операция, выполняемая над объектом Graphics, отображается на связанном с ним изображении. Внимание! Каким бы способом вы не создали объект Graphics, обязательно удалите его после использования, вызвав метод Dispose. Сборщик мусора не работает с управляемыми объектами GDI+, поскольку это просто оболочки для неуправляемых объектов GDI+. Класс Bitmap Класс Bitmap инкапсулирует растровое изображение GDI+, он содержит пикселы самого изображения плюс несколько атрибутов. В GDI+ поддерживается три типа растровых изображений - битовые карты, значки и метафайлы. Все три соответ-ствующих класса являются производными от абстрактного класса Bitmap. Заметьте, что экземпляр класса Bitmap вовсе не обязательно представляет файл с расширением .bmp; это универсальный контейнер пиксельных данных, которые можно сохранить в виде изображения формата BMP или JPG, - как вы сочтете нужным. Создавая объект Graphics, вы связываете его с определенным холстом. Как уже упоминалось, для Web-приложения этим холстом может быть только растровое изоб-ражение в памяти. Приведенный ниже код показывает, как создается экземпляр объек-та Bitmap заданного размера, а потом на его основе - графический контекст: Bitmap bmp = new Bitmap(100, 100); Graphics g = Graphics.FromImage(bmp); После выполнения этого кода любые графические примитивы, вызываемые для объекта Graphics, будут воздействовать на объект Bitmap. По окончании работы с изображением объект Bitmap можно сохранить в подходящем формате, например PNG, JPEG, BMP или GIF. Заметьте, что класс Bitmap имеет методы, позволяющие 
352 Часть I I Специализированные средства ASP.NET выполнять поворот и отражение изображения, а также создавать изображение на основе существующего файла. Заполнение прямоугольников Для создания заполненного прямоугольника вам потребуется указать лишь вид кис-ти и размеры прямоугольника. Метод, которым вы будете пользоваться, называется FillRectangle, а рабочую область для него можно задать либо непосредственно в виде координат, либо с использованием структуры RectangleF: g.FillRectangle(brush, area); В данном вызове brush - это объект-кисть, используемый для рисования прямо-угольника. GDI+ поддерживает множество разных видов кисти, в том числе сплош-ную, градиентную и текстурную. Следующий код показывает, как можно нарисовать и заполнить прямоугольник: //Рисуем границу Pen p = new Pen(Color.Black); g.DrawRectangle(p, 0, 0, width, height); //Заполняем Brush brInterior = new SolidBrush(Color.SkyBlue); g.FillRectangle(brInterior, 1, 1, width-2, height-2); Кроме того, в GDI+ есть специальный метод для рисования границы прямоуголь-ника. Это тот же метод DrawRectangle, но принимающий перо вместо кисти. GDI+ поддерживает две разновидности градиентов - линейный и градиент по пути. Первый идентифицируется двумя цветами и двумя точками (определяющими его начало и конец) и представлен классом LinearGradientBrush. Вот как создается прямоугольник с горизонтальной градиентной заливкой: //Заполняем прямоугольник градиентной заливкой Rectangle area = new Rectangle(0, 0, width, height); LinearGradientBrush brInterior; brInterior = new LinearGradientBrush(area, Color.SkyBlue, Color.AntiqueWhite, LinearGradientMode.Horizontal); g.FillRectangle(brInterior, area); brInterior.Dispose(); В линейном градиенте интенсивность цвета не обязательно меняется пропорци-онально по всей его длине, у вас есть возможность указать, как именно она должна меняться. Для этой цели применяется свойство Blend, позволяющее задать массив значений интенсивности цвета и соответствующих позиций в интервале от 0 до 1. //Задаем значения интенсивности цвета //и соответствующие относительные позиции float[] relativeIntensities = {0.0f, 0.6f, 1.0f}; float[] relativePositions = {0.0f, 0.1f, 1.0f}; //Создаем объект Blend и назначаем его кисти Blend blend = new Blend(); blend.Factors = relativeIntensities; blend.Positions = relativePositions; brInterior.Blend = blend;
Работа с изображениями Глава 9 353 У данного градиента будет три ключевых точки интенсивности, две из которых - это начало и конец заполняемой области. Стандартная заливка линейного градиента описывается таким кодом: float[] relativeIntensities = {0.0f, 1.0f}; float[] relativePositions = {0.0f, 1.0f}; Приведенный выше код указывает, что местами максимальной и минимальной интенсивности цвета являются начало и конец заполняемой области. Код, который мы рассмотрели перед этим, указывал, что 60 % цветового перехода должны приходиться на 10 % заполняемой области. Теперь обратимся к текстурной кисти, позволяющей заполнить фигуру шаблоном, хранящимся в растровом файле. Текстурной кистью можно рисовать линии, фигуры и даже текст. Вот пример: //Заполняем прямоугольник текстурой Image img = Image.FromFile("pattern.bmp"); TextureBrush brInterior = new TextureBrush(img); g.FillRectangle(brInterior, area); brInterior.Dispose(); Рисование текста Метод DrawString объекта Graphics принимает текстовую строку, которую ему нужно вывести, объект, представляющий шрифт, и кисть, которой этот текст будет нарисо-ван. Кроме того, вы можете задать прямоугольник, в который необходимо вписать текст, способ выравнивания (по вертикали или по горизонтали) и указать, что делать, если текст не поместится в заданную область, - обрезать его или выйти за пределы области. Воспользовавшись структурой StringFormat, можно задать все эти параметры одновременно. StringFormat sf = new StringFormat(); sf.Alignment = StringAlignment.Center; sf.LineAlignment = StringAlignment.Center; //Рисуем текст Font f = new Font("Tahoma", 16); g.DrawString("Hello, world", f, new SolidBrush(Color.White), new Rectangle(0, 0, width, height), sf); Возможности GDI+ гораздо, шире, чем мы здесь описали, они отнюдь не огра-ничены выполнением нескольких простых операций. Однако полное рассмотрение функций этой системы выходит за рамки данной книги. Вывод изображений В ASP.NET для записи изображения в дисковые файлы может потребоваться настрой-ка безопасности. Обычно рабочий процесс ASP.NET выполняется от имени учетной записи пользователя ASPNET или NETWORK SERVICE. В случае анонимного досту-па с отключенной функцией имперсонализации, а именно такой режим установлен в ASP.NET по умолчанию, рабочий процесс передает собственный токен идентификации и безопасности потоку, выполняющему пользовательский запрос создания файла. Что касается ситуации, которая имеет место по умолчанию, то в случае, когда учетная запись пользователя ASPNET или NETWORK SERVICE не имеет необходимых разре-шений на запись в виртуальные папки, выбрасывается исключение "Access denied".
354 Часть I I Специализированные средства ASP.NET Таким образом, для того чтобы реализовать кэширование изображений в файлах, можно создать новую папку и предоставить учетной записи ASP.NET полный контроль над этой папкой. Однако ASP.NET и GDI+ предоставляют интересную альтернативу записи в файлы на диск - генерирование изображений в памяти. Иными словами, созданное в памяти изображение может быть в требуемом формате записано непо-средственно в выходной поток. Поддерживаемые форматы изображений GDI+ поддерживает достаточно много форматов изображений, включая самые распро-страненные из них: JPEG, GIF, BMP и PNG. Полный набор форматов изображений содержится в структуре ImageFormat. Находящийся в памяти объект Bitmap можно сохранить в любом поддерживаемом формате, используя одну из перегруженных версий метода Save: bmp.Save(outputStream, ImageFormat.Gif); Когда вы пытаетесь записать изображение в выходной поток или дисковый файл, система ищет кодер для запрошенного формата. Этим кодером является модуль GDI+, преобразующий данные в указанный формат. Учтите, что кодер реализован в виде неуправляемого кода, функционирующего на платформе Win32. Как правило, ко-дер позволяет задать не только формат данных, но и дополнительные установки, такие, например, как степень сжатия изображения JPEG. Мы вернемся к этой теме чуть позже. Запись в изображение сведений об авторском праве Основываясь на изложенной выше информации, рассмотрим пример. В нем показано, как загрузить изображение, добавить в него сведения об авторском праве и передать пользователю его модифицированную версию. Мы будем загружать изображение в объект Bitmap, получать для него объект Graphics и записывать информацию об авто-рском праве, используя графические примитивы. В конце результат будет выводиться в выходной поток страницы с указанием его MIME-типа. Демонстрационная страница нашего примера очень проста: <html> <body> <img id="picture" src="dynimage.ashx?url=images/pic1.jpg" /> </body> </html> Код ASP.NET, необходимый для вывода изображения, содержится в тэге <img>. Изображение предоставляется обработчиком HTTP dynimage.ashx. Он считывает изображение из файла, указанного в строке запроса, и производит его обработку. Ниже приведен код метода ProcessRequest данного обработчика. public void ProcessRequest (HttpContext context) { object o = context.Request["url"]; if (o == null) { context.Response.Write("No image found."); context.Response.End(); return; } string file = context.Server.MapPath((string)o); string msg = "Courtesy of 'Programming Microsoft ASP.NET 2.0
Работа с изображениями Глава 9 355 Applications--Advanced Topics'"; if (File.Exists(file)) { Bitmap bmp = AddCopyright(file, msg); context.Response.ContentType = "image/jpeg"; bmp.Save(context.Response.OutputStream, ImageFormat.Jpeg); bmp.Dispose(); } else { context.Response.Write("No image found."); context.Response.End(); } } Заметьте, что серверный код выполняет две разные задачи. Во-первых, он записы-вает на холст изображения информацию об авторском праве, во-вторых - преобразует изображение из его исходного формата в формат JPEG. Bitmap AddCopyright(string file, string msg) { //Загрузка изображения из файла Bitmap bmp = new Bitmap(file); Graphics g = Graphics.FromImage(bmp); //Определение выравнивания текста StringFormat strFmt = new StringFormat(); strFmt.Alignment = StringAlignment.Center; //Создание кисти для написания текста //(зеленый текст на черном фоне) SolidBrush btmForeColor = new SolidBrush(Color.PaleGreen); SolidBrush btmBackColor = new SolidBrush(Color.Black); //Для вычисления координат записи определяем размеры //текста с учетом гарнитуры и размера шрифта Font btmFont = new Font("Verdana", 7); SizeF textSize = new SizeF(); textSize = g.MeasureString(msg, btmFont); //Рассчитываем координаты прямоугольника и заполняем его float x = ((float) bmp.Width-textSize.Width-3); float y = ((float) bmp.Height-textSize.Height-3); float w = ((float) x + textSize.Width); float h = ((float) y + textSize.Height); RectangleF textArea = new RectangleF(x, y, w, h); g.FillRectangle(btmBackColor, textArea); //Рисуем текст и освобождаем ресурсы g.DrawString(msg, btmFont, btmForeColor, textArea); btmForeColor.Dispose(); btmBackColor.Dispose(); btmFont.Dispose(); g.Dispose(); return bmp; }
356 Часть I I Специализированные средства ASP.NET Конечный результат показан на рис. 9-6. Заметьте, что добавленный текст включен в состав изображения. Если пользователь сохраняет изображение, используя команду браузера Save Picture As, текст сохраняется вместе с ним. Рис. 9-6. Хранящееся на сервере изображение перед отправкой браузеру было модифицировано Создание миниатюр GDI+ предоставляет и другие полезные возможности, такие как возможность сге-нерировать пиктограмму изображения. Хотя браузер и сам вполне может вписать изображение в заданную область, растянув его или сжав, как вы пожелаете, нет ника-кого смысла возвращать большое изображение, когда можно вернуть маленькое. Вам пришлось бы платить двойную цену: увеличить потребляемую полосу пропускания и заставить браузер делать лишнюю работу. На Web-сайтах, которые служат коммерческими банками изображений, обычно для каждого изображения хранится его миниатюра. В других случаях миниатюры можно генерировать на лету, используя метод GetThumbnailImage класса Bitmap: Bitmap GetThumbnail(string file) { Bitmap bmp = new Bitmap(file); Bitmap newImg = (Bitmap) bmp.GetThumbnailImage(bmp.Width/3, bmp.Height/3, null, IntPtr.Zero); return newImg; } Создавая миниатюру, вы можете указать, либо во сколько раз следует уменьшить изображение, либо какими должны быть его результирующие размеры. В последнем случае учтите, что заданные вами ширина и высота будут интерпретироваться как абсолютные значения, то есть пропорции изображения система сохранять не будет. Миниатюру, созданную приведенным выше кодом, вы видите на рис. 9-7.
Работа с изображениями Глава 9 357 Рис. 9-7. Перед выводом изображение уменьшено Управление сжатием изображений, сохраняемых в формате JPEG При сохранении изображения в формате JPEG оно сжимается по специальному алго-ритму - изображение разбивается на блоки 8?8 пикселов, и затем цвета каждого блока сглаживаются с целью минимизации общего количества цветов в изображении. При этом часть исходных значений цвета утрачивается без возможности восстановления. Далее блоки пикселов сжимаются по алгоритму, похожему на тот, который использу-ется в архиваторах zip-типа. При выводе изображения на экран оно распаковывается, но такое распакованное изображение отличается от исходного из-за проведенной перед сжатием цветовой коррекции. Однако поскольку формат JPEG используется главным образом для хранения фотографий, потеря качества остается незаметной для человеческого глаза. Для хранения одного пиксела в JPEG-изображении отводится 24 бита, чем обеспечивается возможность отображения 16 млн цветов. При этом прозрачность и анимация не поддерживаются. Уровень сжатия изображений JPEG можно настраивать - чем он выше, тем меньше размер файла. Однако уменьшение размера достигается за счет потери данных исходного изображения, так что качество сильно сжатого изображения оставляет желать лучшего. Оптимального коэффициента сжатия, который подходил бы для любой ситуации, не существует. Как правило, по-тери качества при сжатии 15:1 остаются незаметными для глаза, но при этом какое-то изображение можно сжать и вдвое сильнее, получив результат не хуже. Для того чтобы задать коэффициент сжатия JPEG-изоражения в GDI+, нужно вы-брать подходящий кодер, для чего вам придется в цикле среди элементов коллекции ко-деров найти тот, свойство MimeType которого соответствует интересующему вас типу. //Поиск кодера JPEG string mimeType = "image/jpeg"; ImageCodecInfo[] encoders; ImageCodecInfo jpegEncoder = null; //Перебор всех известных GDI+ кодеров encoders = ImageCodecInfo.GetImageEncoders(); for(int j=0; j < encoders.Length; j++) { if(encoders[j].MimeType == mimeType) jpegEncoder = encoders[j]; } Найдя нужный кодер, вы устанавливаете его параметры, в частности добавляете новый параметр, определяющий качество результирующего изображения: //Создание параметра для задания качества кодирования EncoderParameter paramRatio; paramRatio = new EncoderParameter(Encoder.Quality,ratio);
358 Часть I I Специализированные средства ASP.NET Значение, которое вы передаете конструктору, определяет желаемое качество изображения. Это не коэффициент сжатия. Чем больше данное значение, тем выше качество изображения и тем больше его размер. //Добавляем только что созданный параметр в коллекцию параметров кодера EncoderParameters jpegParams; jpegParams = new EncoderParameters(1); //только один параметр jpegParams.Param[0] = paramRatio; //Отправляем изображение Response.ContentType = "image/jpeg"; bmp.Save(Response.OutputStream, jpegEncoder, jpegParams); bmp.Dispose(); Кэширование изображений Для динамического создания изображений необходим обработчик HTTP. Способ получения битов передаваемого клиенту изображения зависит от его внутренней реализации: биты изображения могут храниться в базе данных, в кэше ASP.NET, они могут также динамически генерироваться с использованием GDI+. Выбор решения на базе кэша ASP.NET означает, что изображение сначала должно быть извлечено из файла или базы данных либо создано на лету. Изображение, храня-щееся в кэше, не занимает места на диске, и для его получения не нужно выполнять операцию чтения данных с диска. Вместе с тем такое изображение занимает память рабочего процесса ASP.NET. Создание приложения, генерирующего диаграммы Давайте сложим все части головоломки и создадим демонстрационное приложение, автоматически генерирующее диаграммы с использованием описанных выше техно-логий. Начнем с создания страницы, содержащей пару тэгов <img> со ссылками на обработчики, возвращающие генерируемые на сервере диаграммы: <table> <tr><td><img runat="server" id="bar"></td></tr> <tr><td><img runat="server" id="pie"></td></tr> </table> В обработчике события Load тэги <img> конфигурируются таким образом, чтобы они указывали на нужный URL. В данном случае динамическое связывание необхо-димо для передачи аргументов странице. Следующий код показывает, как на самом деле инициализируются элементы управления страницы: void Page_Load(object sender, EventArgs e) { bar.Src = "chart.ashx?Type=bar&Data=Sales"; pie.Src = "chart.ashx?Type=pie&Data=Sales"; } Обработчик, генерирующий диаграмму, содержит всю необходимую для ее созда-ния логику. Данные для ее построения извлекаются с использованием подключаемого внешнего провайдера, имя которого записано в разделе <appSettings> файла web.config. Получение данных для построения диаграммы Обработчик HTTP chart.ashx поддерживает два параметра строки запроса: Type, оп-ределяющий тип диаграммы (круговая или гистограмма), и Data, идентифицирую-
Работа с изображениями Глава 9 359 щий запись в разделе <appSettings> файла web.config, используемую для получения доступа к провайдеру данных. В основе функционирования обработчика HTTP лежит относительно простая провайдерная модель (обсуждавшаяся в главе 4) - он извлекает данные, используя провайдерный компонент. Базовый класс этого провайдера определяет контракт для обмена данными между провайдером и генератором диаграммы. Вот определение этого класса: public abstract class ChartDataProvider { public abstract DataTable GetData(); public abstract string DataLabelField { get; } public abstract string DataField { get; } } Предполагается, что провайдерный класс вернет объект DataTable как минимум с двумя полями, содержащими значения данных и соответствующие надписи. Предпо-ложим, что вы создали пользовательский класс SalesChartDataProvider, возвращающий объект DataTable со столбцами Employee и Sales. В столбце Employee содержатся фами-лии сотрудников, а в столбце Sales - данные о количестве проданного ими товара. Провайдер данных регистрируется в разделе <appSettings> конфигурационного файла: <appSettings> <add key="Sales" value="SalesChartDataProvider,ProAspCompLib" /> </appSettings> Значение атрибута key задается в параметре Data обработчика, формирующего диаграмму. Примечание Когда вы разрабатываете пользовательский сервис, используя модель провайдеров, создавайте пользовательские конфигурационные разделы для хранения необходимых данных. Возможно, вы захотите создать для этого сервиса специализи-рованный раздел, в одном из подразделов которого будут перечислены все доступные провайдеры, а используемый по умолчанию провайдер зададите в атрибуте этого раздела. При этом узел каждого провайдера может содержать любое количество пользовательских атрибутов. Архитектура обработчика, генерирующего диаграмму Как уже упоминалось, наш генератор реализован в виде обработчика HTTP с именем chart.ashx. Вот его метод ProcessRequest: public void ProcessRequest(HttpContext context) { //Обработка аргументов string type = "bar"; string dataProvider = String.Empty; object arg1 = context.Request["Type"]; object arg2 = context.Request["Data"]; if (arg1 != null) type = (string) arg1; if (arg2 == null) context.Response.End(); else dataProvider = (string) arg2;
360 Часть I I Специализированные средства ASP.NET //Извлечение информации о провайдере данных string info = ConfigurationManager.AppSettings[dataProvider]; string[] typeInfo = info.Split(','); string cls = typeInfo[0]; string asm = typeInfo[1]; ObjectHandle handle = Activator.CreateInstance(asm, cls); ChartDataProvider prov = (ChartDataProvider)handle.Unwrap(); //Рисование диаграммы Bitmap bmp; Graphics g; if (type == "bar") { bmp = new Bitmap(700, 200); g = Graphics.FromImage(bmp); DrawBarChart(g, prov); } else { bmp = new Bitmap(300, 300); g = Graphics.FromImage(bmp); DrawPieChart(g, prov); } //Отправка ответа context.Response.ContentType = "image/png"; MemoryStream ms = new MemoryStream(); bmp.Save(ms, ImageFormat.Png); ms.WriteTo(context.Response.OutputStream); bmp.Dispose(); g.Dispose(); } Сначала метод обрабатывает аргументы из строки запроса и определяет тип диа-граммы, которую ему предстоит создать. Затем он определяет, какой элемент раздела <appSettings> содержит информацию, необходимую для создания провайдера данных. Этот провайдер идентифицируется разделенной запятыми строкой, в которой задан тип провайдера и имя сборки. Экземпляр провайдера создается с помощью вызова Activator.CreateInstance. Внимание! При использовании перегруженной версии метода Activator.CreateInstance, принимающей имена типа и сборки, вы получаете не экземпляр только что созданно-го класса, а объект ObjectHandle, содержащий ссылки для маршаллинга по значению. Объект ObjectHandle предназначен для передачи объектов между доменами приложений без загрузки метаданных каждого передаваемого объекта в каждый AppDomain. В дан-ном примере никакие объекты между доменами приложений не передаются, и я просто продемонстрировал, как следует действовать при написании приложений .NET Remoting. Объект извлекается из оболочки с помощью метода Unwrap. Далее мы создаем объект Graphics, предназначенный для рисования диаграммы, и взываем код, который собственно и будет заниматься ее созданием. Закончив, мы записываем изображение в выходной поток в формате PNG.
Работа с изображениями Глава 9 361 Рисование круговой диаграммы Получив данные, которые должны быть представлены в виде диаграммы, мы при-ступаем к ее рисованию. Для начала рассмотрим процесс формирования круговой диаграммы. Для того чтобы нарисовать ее сегмент, нужно определить величину и цвет сегмента. Цикл начинается с нулевого угла и затем по очереди рисует сегменты, углы которых пропорциональны значениям данных. //Получаем из столбца DataTable ("data") общий объем продаж float total = Convert.ToSingle(data.Compute("Sum(sales)", "")); //Вычисляем угол очередного сегмента float sweep = Convert.ToSingle(value) /total * 360; Для рисования сегмента используется метод FillPie, а для вычерчивания его гра-ницы - метод DrawEllipse. Оба метода предоставляются объектом Graphics: g.FillPie(new SolidBrush(wedgeColor), rectChart, angle, sweep); g.DrawEllipse(new Pen(Color.DarkGray, 1), rectChart); Чтобы диаграмма выглядела более профессионально, можно добавить тень. Со-ответствующей поддержки графическая система не предоставляет, поэтому можно просто несколько раз нарисовать сегмент с небольшим смещением. Для улучшения внешнего вида результата можно воспользоваться штриховой кистью. В следующем коде показано, как можно нарисовать круговую диаграмму с трехмерной тенью: for(int j=ShadowDepth; j>0; j--) { for(int i=0; i<data.Rows.Count; i++) { //Вычисляем величину угла, //соответствующую значению данных float sweep = Convert.ToSingle(data.Rows[i]["Sales"])/total*360; //Выбираем цвет wedgeColor = colors[i]; //Рисуем тень Rectangle shadowArea = new Rectangle(area.Location, area.Size); shadowArea.Offset(j, j); g.FillPie(new HatchBrush(HatchStyle.Percent50, wedgeColor), shadowArea, angle, sweep); //Рисуем сегмент g.FillPie(new SolidBrush(wedgeColor), area, angle, sweep); g.DrawEllipse(new Pen(Color.DarkGray, 1), area); //Вычисляем координаты центра сегмента //для последующего вывода надписи Point center = GetPoint(angle + sweep/2, area.Width, area.Height); center.X = (int) ((area.Right -area.Left) /2 + center.X) /2; center.Y = (int) ((area.Bottom -area.Top) /2 + center.Y) /2; centers[i] = center;
362 Часть I I Специализированные средства ASP.NET //Увеличиваем угол для следующей итерации angle += sweep; } } Для круговой диаграммы задачи выбора цвета и вывода надписей не так триви-альны, как кажется. В частности, задача выбора цвета является частным случаем более сложной задачи - раскрашивания схем. Доказано, что для этой цели никогда не требуется более четырех цветов, ведь достаточно, чтобы друг от друга отличались смежные области. В нашем случае хватило бы и двух цветов. Но что если число сегментов оказалось бы нечетным? С учетом этого требуются три цвета, но дальше встает вопрос эстетики и визуального восприятия. Практика показывает, что лучше использовать большее количество цветов, скажем, десять, и выбирать их циклически, следя за тем, чтобы при замыкании круга рядом не оказались сегменты одинаковых цветов. В случае совпадения можно использовать дополнительный цвет, не содержа-щийся в списке, или просто выбрать любой другой цвет из списка. Чтобы вывести внутри сегмента надпись, необходимо знать, где находится его середина. Тут вам пригодятся школьные знания из области тригонометрии. Если считать, что диаграмма круглая, координаты нужной точки вы получите по таким формулам: //width - это ширина прямоугольника, в который можно вписать круг int radius = width /2; //Получаем радиус. Здесь angle - это величина угла сегмента double rad = Math.PI * 2 * angle /360; //Получаем координаты точки с учетом смещения Point pt = new Point(); pt.X = (int) (radius * Math.Cos(rad)) + radius; pt.Y = (int) (radius * Math.Sin(rad)) + radius; Полученная таким образом точка находится на дуге, которая служит границей сегмента. Чтобы сместить ее к центру диаграммы, производим такие вычисления: pt.X = (int) ((rcChart.Right -rcChart.Left) /2 + pt.X) /2; pt.Y = (int) ((rcChart.Bottom -rcChart.Top) /2 + pt.Y) /2; centers[i] = pt; Координаты центра вычисляются в процессе генерирования диаграммы, но надпись при этом еще не выводится. Эти координаты сохраняются в массиве, который позднее будет использоваться для вывода текста. Поскольку надписи могут в сегментах не помещаться, рисуя их в цикле, мы рискуем их частично перекрыть. Поэтому откла-дываем эту задачу до окончания процесса рисования диаграммы. for(int i=0; i<dt.Rows.Count; i++) { g.DrawString(data.Rows[i]["Employee"].ToString(), new Font("Tahoma", 8), new SolidBrush(Color.Black), centers[i].X, centers[i].Y); } Конечный результат вы видите на рис. 9-8.
Работа с изображениями Глава 9 363 Рис. 9-8. Динамически сгенерированная трехмерная диаграмма с надписями внутри Рисование гистограммы Гистограмму рисовать, конечно, легче - не нужно возиться со всякими там углами, радиусами и прочими тригонометрическими штучками. Столбик гистограммы пред-ставляет собой обыкновенный прямоугольник с двумя надписями: значением - вверху и легендой - внизу. Будем считать, что все координаты x и y столбцов гистограммы уже сформиро-ваны. Тогда с помощью следующего кода рисуем трехмерную гистограмму с тенями столбиков: //Выводим верхнюю надпись со значением g.DrawString(String.Format("{0:c}", data.Rows[i]["Sales"]), new Font("Tahoma", 8), new SolidBrush(Color.Blue), xBarPos, yCaptionPos); //Создаем прямоугольник Rectangle rcBar = new Rectangle(xBarPos, yBarPos, barWidth, barHeight); //Создаем тень Rectangle rcShadow = new Rectangle(rectBar.Location, rectBar.Size); rectShadow.Offset(j, -j); //Рисуем тень g.FillRectangle(new HatchBrush(HatchStyle.Percent50, Color.Orange), rectShadow); //Рисуем прямоугольник g.FillRectangle(new LinearGradientBrush(rectBar, Color.Orange, Color.Yellow, LinearGradientMode.Horizontal), rectBar); //Выводим нижнюю надпись Font fnt = new Font("Tahoma", 8, FontStyle.Bold);
364 Часть I I Специализированные средства ASP.NET g.DrawString(dt.Rows[i]["Employee"].ToString(), fnt, new SolidBrush(Color.Blue), xBarPos, yBarBottom); Результат работы этого кода вы видите на рис. 9-9. Рис. 9-9. Динамически созданная трехмерная гистограмма Примечание В этой главе для демонстрации возможностей .aspx в отношении динами-ческого создания изображений и диаграмм использовались обработчики HTTP. Однако учтите, что обработчики - не самое лучшее средство создания сложных диаграмм. Они хороши для вывода изображений, выбираемых с учетом условий времени выполнения. А для динамического создания диаграмм лучше применять серверные элементы управ-ления, созданные на базе тэга <img>. Именно такой подход реализован во многих ком-мерческих библиотеках, предназначенных для формирования диаграмм. Заключение В наше время никто не станет оспаривать тот факт, что изображения - один из фун-даментальных элементов Web. Хотя они не являются частью ее инфраструктуры и их применение не влияет на функциональность сайтов, во многом благодаря богатому графическому оформлению Web завоевала столь широкую популярность как исклю-чительно мощная и выразительная информационная среда. Но несмотря на ту важную роль, которую изображения играют в Web, язык HTTP не имеет других средств их поддержки, кроме тэга <img>. Этот тэг можно связывать только с URL, и для загрузки изображений с его помощью требуется дополнительное обращение к серверу. Если связать тэг <img> со страницей .aspx, а еще лучше - с обработчиком HTTP, вы сможете сгенерировать изображение динамически или прочитать его из базы данных. Для динамического генерирования изображения нужно правильно устано-вить тип содержимого HTTP-ответа и вывести биты изображения в выходной поток. В ASP.NET процесс генерирования изображений очень упрощен за счет применения графического ядра GDI+. GDI+ - это графическая библиотека Windows XP, доступная и для других 32-и 64-разрядных платформ Windows. В .NET Framework поддержка GDI+ реализована в виде набора управляемых классов-оболочек, предназначенных для определения поверхности для рисования и инструментов для алгоритмического рисования изо-бражений. В этой главе продемонстрированы различные приемы создания и редактирования изображений, а также отправки их браузеру. В частности, мы поговорили о том, как можно включать в состав изображений информацию об авторском праве, извлекать из 
Работа с изображениями Глава 9 365 базы данных BLOB-объекты и динамически создавать изображения. Типичным при-мером динамически генерируемого изображения является диаграмма. Мы создали две диаграммы - круговую и гистограмму, - применив пользовательский провайдер дан-ных в полном соответствии с моделью провайдеров, поддерживаемой в ASP.NET. Только факты Единственным средством вывода изображений на Web-страницах является тэг <img>, в котором задается URL для поиска и загрузки изображения. Для манипулирования изображением перед его выводом, а также для его про-чтения из источника, отличного от файловой системы, нужно связать тэг <img> не с файлом изображения, а с активным ресурсом, таким как страница .aspx или обработчик HTTP. Для динамического выбора или формирования изображения обработчик HTTP подходит больше страницы, поскольку при его выполнении не производятся ни-какие лишние действия. Для обработки запроса на получение изображения нужно задать в заголовке ответа MIME-тип контента, а затем вывести в выходной поток биты изображения. Изображения можно считывать с диска и программно модифицировать перед отправкой. Можно также считывать их из BLOB-полей базы данных. Ничто не мешает вам динамически отредактировать изображение на сервере или даже создать его с нуля, воспользовавшись примитивами GDI+. 
Глава 10 Навигация по сайту Реальные Web-сайты обычно имеют сложную структуру, содержат сотни страниц, ко-торые группируются и фильтруются согласно бизнес-правилам и правилам членства. Поэтому очень важно, чтобы у сайта была детальная карта, помогающая пользователям сориентироваться, определить, в каком месте его иерархии находится текущая стра-ница и как попасть на другие страницы. Кроме того, наличие карты сайта позволяет разработчику привязать к ней интерфейс домашней страницы и без особых усилий отражать на этой странице любые изменения, вносимые в структуру сайта. В ASP.NET 2.0 появился новый навигационный API, позволяющий создать карту сайта, декларативно описав его схему, - определить иерархию страниц и сгруппиро-вать их, образовав разделы и подразделы сайта. ASP.NET кэширует эту информацию и обеспечивает возможность программного доступа к ней во время выполнения. Таким образом, у вас появляется возможность централизованно хранить ссылки на страни-цы и при необходимости связывать их с навигационными элементами управления, такими как TreeView и Menu. Итак, вы можете создать карту, описывающую структуру сайта, создать провайдер для ее интерпретации, установить правила доступа и с помощью различных элементов управления разместить информацию этой карты на страницах сайта. Из настоящей главы вы узнаете, как определить и сконфигурировать карту сайта и как с ней ра-ботать. Определение карты сайта Для того чтобы использовать навигационные средства ASP.NET, нужно в первую очередь определить структуру сайта, то есть составить перечень его страниц с ука-занием их взаимосвязей. Оформленные стандартным способом, эти данные могут использоваться навигационными элементами управления и быть представлены на страницах сайта. По умолчанию определение карты сайта, то есть описание иерархии его страниц, хранится в XML-файле. Однако навигационную систему можно сконфигурировать таким образом, чтобы она работала с другим источником данных. Создание карты сайта Единственное назначение файла карты сайта - облегчить создание навигационной системы большого сайта. Очевидно, что построение навигационной системы такого сайта при отсутствии его централизованно хранящейся карты - чересчур сложная задача, требующая постоянного изменения и обновления данных и синхронизации гиперссылок с URL страниц. Внутренняя структура карты сайта зависит от конкретного приложения и опреде-ляется специально разрабатываемым компонентом - провайдером карты сайта. Этот компонент регистрируется в исполняющей среде ASP.NET и отвечает за предостав-ление информации карты сайта, которую он считывает из определенного хранилища. 
Навигация по сайту Глава 10 367 Как уже упоминалось, используемый по умолчанию провайдер извлекает данные из XML-файла; этот файл имеет стандартное имя - web.sitemap. Используемый по умолчанию провайдер карты сайта Провайдер карты сайта, используемый по умолчанию, задается в корневом конфигу-рационном файле и является экземпляром класса XmlSiteMapProvider. <siteMap> <providers> <add name="AspNetXmlSiteMapProvider" siteMapFile="web.sitemap" type="System.Web.XmlSiteMapProvider, System.Web, ... " /> </providers> </siteMap> Как видно из приведенного фрагмента кода, у провайдера есть атрибут siteMapFile, указывающий имя файла, из которого можно прочитать информацию карты сайта. Несмотря на расширение, это должен быть XML-файл, а его содержимое должно строго соответствовать определенной схеме. Заметьте, что класс XmlSiteMapProvider не работает с файлами, расширение которых отлично от .sitemap. Также важно знать, что этот класс отслеживает вносимые в исходный файл изменения и динамически обновляет карту сайта. Файл web.sitemap Хранящийся в корневом каталоге приложения файл web. sitemap содержит описание иерархии его страниц. В нем обычно имеются ссылки на другие провайдеры карты сайта или иные ее файлы, находящиеся в подкаталогах приложения. Ниже приведен пример карты, представляющей структуру книги. <siteMap> <siteMapNode title="Моя книга" url="default.aspx"> <siteMapNode title="Введение" url="intro.aspx" /> <siteMapNode title="Благодарности" url="ack.aspx"> <siteMapNode title="Ссылки" url="ref.aspx" /> </siteMapNode> <siteMapNode title="Главы" url="toc.aspx"> <siteMapNode title="Модель компиляции" url="ch01.aspx" /> <siteMapNode title="Обработчики и модули HTTP" url="ch02.aspx" /> </siteMapNode> <siteMapNode title="Приложение" url="appendix.aspx"> <siteMapNode title="Демонстрационный код" url="samples.aspx"> </siteMapNode> </siteMapNode> </siteMap> XML-файл карты сайта состоит из раздела <siteMap> и набора вложенных эле-ментов <siteMapNode>. Каждая страница сайта представлена одним элементом <siteMapNode>, а иерархия страниц определяется путем вложения этих элементов друг в друга, как в приведенном выше примере. В большинстве случаев корневой раздел содержит только один дочерний элемент <siteMapNode>, но это не являет-ся строгим правилом, определенным в схеме файлов карты. Все URL, указанные в таком файле, должны принадлежать тому приложению, которое использует данный файл. Точнее говоря, вы можете задать ссылки на страницы других приложений, но 
368 Часть I I Специализированные средства ASP.NET при этом следует знать, что навигационный API не будет проверять их целостность. Внутренние же ссылки приложения навигационный API проверяет и, обнаружив, что та или иная ссылка указывает на несуществующую страницу, возвращает сообщение об ошибке времени разработки. Атрибуты элемента <siteMapNode> перечислены в табл. 10-1. Табл. 10-1. Атрибуты элемента <siteMapNode> Атрибут Описание description Текстовое описание страницы. Этот текст выводится в виде всплывающей под-сказки, появляющейся при наведении указателя мыши на ссылку на страницу в элементе управления SiteMapPath, а также используется для документирования provider Строка, идентифицирующая провайдер карты сайта, с помощью которого запол-няется данный узел resourceKey Имя ключа ресурса, используемого для локализации данного узла сайта roles Строка с перечнем ролей, членам которых разрешено просматривать данную страницу siteMapFile Имя файла карты сайта, содержащего данные для заполнения текущего узла title Текст ссылки на страницу url URL страницы Атрибут roles предназначен для предотвращения доступа неавторизированных поль-зователей к защищенным страницам (эта функция системы называется site map security trimming - обрезание карты сайта системой безопасности). Помимо атрибутов, перечисленных в табл. 10-1, можно задавать и пользователь-ские атрибуты, однако включать в файл карты пользовательские узлы нельзя. Файл .sitemap может содержать узлы <siteMapNode> и корневой узел <siteMap>. Провайдеры навигации Подсистема навигации сайта построена по модели провайдеров, а это значит, что для определения содержимого карты можно применять пользовательские провайдеры. Такой провайдер считывает информацию карты из другого хранилища - XML-файла с нестандартной схемой, текстового файла или, скажем, базы данных. Как рассказыва-лось в главе 4, пользовательский провайдер представляет собой класс, наследующий SiteMapProvider или StaticSiteMapProvider. Интересно отметить, что одновременно могут применяться несколько провайде-ров. Например, когда имя провайдера задано в атрибуте provider определенного узла <siteMapNode> , навигационная подсистема использует этот провайдер для извлечения информации, которая должна быть вставлена в данное место иерархии. <siteMap> <siteMapNode title="Intro" url="intro.aspx" > <siteMapNode title="Acknowledgements" url="ack.aspx" /> <siteMapNode title="References" url="ref.aspx" /> </siteMapNode> <siteMapNode provider="SimpleTextSiteMapProvider" /> </siteMap> Дополнительный провайдер нужно зарегистрировать в конфигурационном файле, указав всю информацию, необходимую ему для доступа к источнику данных: <system.web> <siteMap defaultProvider="XmlSiteMapProvider">
Навигация по сайту Глава 10 369 <providers> <add name="SimpleTextSiteMapProvider" type="SimpleTextSiteMapProvider, Samples" siteMapFile="MySiteMap.txt" /> </providers> </siteMap> </system.web> Узел <siteMapNode>, связанный с компонентом SimpleTextSiteMapProvider, будет содержать узлы, определенные в файле MySiteMap.txt. Таким образом, в данном при-мере карта сайта формируется двумя провайдерами: используемым по умолчанию XmlSiteMapProvider и SimpleTextSiteMapProvider. Конфигурирование карты сайта Существуют еще две возможности конфигурирования карты сайта. Предположим, что вам нужно, во-первых, соединить два разных файла карты сайта, локализовать заго-ловок карты и описания страниц, а во-вторых, предоставить каждому пользователю такую карту, которая соответствовала бы его ролям в инфраструктуре безопасности приложения. Рассмотрим каждую из этих задач в отдельности. Использование нескольких файлов карты сайта Как уже упоминалось, стандартный провайдер карты сайта считывает информацию из файла web. sitemap, находящегося в корневом каталоге приложения. При этом для описания отдельных частей сайта могут использоваться дополнительные файлы .sitemap с такой же схемой. В каждом элементе <siteMapNode> определяется поддерево сайта - либо явно, путем перечисления дочерних узлов, либо неявно, с помощью ссылки на внешний файл .sitemap, как в следующем примере: <siteMap> <siteMapNode title="My Book" url="default.aspx"> <siteMapNode siteMapFile="introduction.sitemap" /> <siteMapNode siteMapFile="chapters.sitemap" /> <siteMapNode siteMapFile="appendix.sitemap" /> </siteMapNode> </siteMap> Содержимое каждого дочернего файла вставляется в формируемое древовидное представление данных в файле web.sitemap на место узла, содержащего ссылку на этот файл. Дочерние файлы могут располагаться в том же каталоге, что и родитель-ский, или же в подкаталогах приложения. Значением атрибута siteMapFile является виртуальный путь к файлу в контексте текущего приложения. Заметьте, что все файлы карты сайта обрабатываются в данном случае одним провайдерным компонентом - используемым по умолчанию XmlSiteMapProvider. В предыдущем разделе мы рассматривали случай, когда для обработки разных раз-делов карты вызываются разные провайдеры. Индивидуальные карты сайта для разных категорий пользователей На многих Web-сайтах, особенно если они не являются публичными, действуют ог-раничения доступа, то есть каждому пользователю сайта разрешается просматривать лишь определенное подмножество его страниц. Но как реализовать соответствующие ограничения при работе с картой сайта? Наиболее эффективное решение основыва-ется на применении ролей. Для каждого узла карты задается список ролей, члены 
370 Часть I I Специализированные средства ASP.NET которых авторизированы на доступ к соответствующим страницам, а инфраструктура ASP.NET гарантирует, что ни одну страницу сайта никогда не увидят неавторизиро-ванные пользователи. Этот подход имеет то преимущество, что роли определяются и назначаются пользователям лишь однажды и используются во всех случаях, когда необходима информация о правах того или иного пользователя, в том числе и при работе с картой сайта. Упомянутая выше функция обрезания карты сайта системой безопасности обеспе-чивает удаление из карты навигационных ссылок на те страницы, доступ к которым пользователю запрещен. Таким образом система адаптирует карту для каждого конк-ретного пользователя. Однако учтите, что при этом не блокируется доступ пользова-телей посредством ввода URL в адресной строке браузера или перехода по ссылкам с других страниц. Чтобы гарантировать невозможность неавторизированного доступа к страницам сайта, необходимо сконфигурировать роли и связать их с учетной записью каждого пользователя. (Подробнее об этом рассказывалось в главе 15 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference".) Защита карты сайта ASP.NET По умолчанию доступ к файлам .sitemap, осуществляемый не программным спосо-бом, запрещен, и при попытке такого доступа выбрасывается исключение ASP.NET "forbidden resource". Однако учтите, что данное ограничение не распространяется на пользовательские файлы карты сайта, имеющие другое расширение, и если вы созда-ете такие файлы, не забудьте защитить их, явно задав соответствующие установки для IIS. Чтобы усилить защиту, предоставьте учетной записи ASP.NET (NETWORK SERVICE или ASPNET) право доступа к пользовательским файлам карты сайта только для чтения. Если карта сайта хранится в базе данных, лучше максимально ограничить доступ к соответствующим таблицам. Примечание Если карта сайта очень велика, для ее хранения и обработки требуется много памяти и процессорного времени. Это не только сказывается на производитель-ности сайта, но и создает угрозу его безопасности, поскольку ухудшается защита от атак на отказ. Локализация информации карты сайта Локализации подлежат свойства Title, Description, а также пользовательские свойства элементов карты. Она осуществляется посредством явного или неявного применения выражений. Прежде всего включите функцию локализации, установив для корневого узла карты атрибут enableLocalization: <siteMap enableLocalization="true"> </siteMap> После этого свяжите свойства с выражениями, содержащими ссылки на ресурсы. (О $-выражениях рассказывалось в главе 5.) Вы можете либо явно связать атрибут с глобальным ресурсом, либо неявно ассоциировать его со значением, получаемым с использованием ключа локального ресурса. Вот пример выражения для явного связывания: <siteMap enableLocalization="true"> <siteMapNode url="~/homepage.aspx" title="$Resources:MyLocalizations,HomePage" /> </siteMap>
Навигация по сайту Глава 10 371 В данном случае использовано выражение $Resources, указывающее на глобальный файл .resx, из которого должен быть извлечен ресурс с заданным именем. Если файл MyLocalizations.resx содержит ресурс с именем HomePage, значение этого ресурса будет прочитано и присвоено атрибуту title. Если же такого ресурса не окажется, бу-дет действовать неявное выражение. Тогда система извлечет значение из локального файла ресурсов. При неявном связывании узла <siteMapNode> с ключом ресурса необходимо, чтобы все локализуемые свойства этого узла были определены в файле .resx с использова-нием такого синтаксиса: [ключ_ресурса].[атрибут] Следующий фрагмент карты сайта показывает, как использовать неявные выра-жения: <siteMap enableLocalization="true"> <siteMapNode resourceKey="Home" url="~/homepage.aspx" description=" default " title=" default " /> </siteMap> По умолчанию файл ресурсов имеет то же имя, что и файл .sitemap, но с расши-рением .resx. В стандартном случае он называется web.sitemap.resx. Предполагается, что файл ресурсов содержит элементы с именами Home.description и Home.title. Если таковые имеются, их значения будут присваиваться атрибутам description и title. В про-тивном случае используются значения атрибутов, заданные в файле .sitemap (опять же, если таковые имеются), без всякой локализации. Примечание Файл .resx содержит значения ресурсов для используемой по умолчанию культуры. Для того чтобы задать ресурсы, соответствующие другим языку и культуре, скажем, французским, нужно изменить расширение файла на fr.resx, поскольку иденти-фикатор fr соответствует французской культуре. Локализация навигационной структуры сайта Что если вы хотите изменять не только названия узлов, но и саму навигационную структуру сайта, с учетом определенной культуры? К сожалению, свойство Url не мо-жет быть локализовано тем способом, каким локализуются свойства Title и Description. Если вы хотите изменить URL или структуру сайта, нужно создать отдельную карту для каждой культуры и зарегистрировать все эти карты в конфигурационном файле: <siteMap defaultProvider="XmlSiteMapProvider"> <providers> <add name="DefaultSiteMap" type="System.Web.XmlSiteMapProvider" siteMapFile="default.sitemap" /> <add name="FrenchSiteMap" type="System.Web.XmlSiteMapProvider" siteMapFile="fr.sitemap" /> <add name="ItalianSiteMap" type="System.Web.XmlSiteMapProvider" siteMapFile="it.sitemap" />
372 Часть I I Специализированные средства ASP.NET </providers> </siteMap> В результате получится несколько регистрационных записей для одного и того же провайдера, но в каждой из них будет указан свой файл карты сайта. При про-граммном доступе к информации карты сайта вы сможете указать, какую конкретно карту хотите использовать. Внимание! Использовать файлы .resx для локализации карты сайта можно только в том случае, если применяются используемый по умолчанию провайдер и XML-файл .sitemap. В случае же применения пользовательского провайдера, работающего с другим храни-лищем данных, за конфигурирование механизма локализации отвечаете вы сами. Обработка информации карты сайта Создание карты сайта - лишь первый шаг. Необходимо еще сделать так, чтобы со-держащаяся в ней информация была доступна пользователю и приложению. Как правило, эту информацию выводят с помощью специализированных элементов управ-ления, однако полезно изучить и класс, который является ее контейнером. Во время работы приложения ASP.NET информация карты сайта доступна через глобальный экземпляр класса SiteMap. Класс SiteMap Определенный в пространстве имен System.Web и одноименной сборке класс SiteMap имеет только статические члены. Он предоставляет доступ к коллекции объектов-узлов и их свойствам. Экземпляр данного класса создается и заполняется данными при запуске приложения. За обновление этих данных отвечает провайдер. В частности, используемый по умолчанию провайдер отслеживает вносимые в исходный файл карты изменения и отражает их в объекте SiteMap. Члены класса SiteMap Свойства класса SiteMap описаны в табл. 10-2. Помимо них в составе данного класса определено событие SiteMapResolve, которое генерируется при обращении к свойству CurrentNode. В каких конкретно случаях генерируется данное событие и происходит ли оно вообще, зависит от используемого провайдера. Провайдер, вызываемый по умолчанию, генерирует его всегда. Табл. 10-2. Свойства класса SiteMap Член Описание CurrentNode Объект SiteMapNode, представляющий текущую запрошенную страницу Enabled Указывает, активизирован ли провайдер карты сайта Provider Объект SiteMapProvider - провайдер данной карты Providers Предназначенная только для чтения коллекция объектов SiteMapProvider, доступных приложению RootNode Объект SiteMapNode, представляющий корневую страницу навигаци-онной структуры сайта Когда производится обращение к свойству CurrentNode, класс SiteMap запраши-вает соответствующую информацию у провайдера. Если для указанной страницы не существует узла карты сайта, возвращается значение null, как и в том случае, когда текущий пользователь не имеет права доступа к этому узлу.
Навигация по сайту Глава 10 373 Члены класса SiteMapNode Класс SiteMapNode представляет узел карты сайта. У него есть несколько свойств, описывающих страницу сайта, и несколько методов, предназначенных для извлечения дочерних узлов и управления ими. Члены данного класса перечислены в табл. 10-3. Табл. 10-3. Свойства класса SiteMapNode Свойство Вид доступа Описание ChildNodes Чтение/запись Дочерние узлы текущего узла, полученные от соответству-ющего провайдера карты сайта Description Чтение/запись Описание текущего узла HasChildNodes Чтение Указывает, имеет ли текущий узел дочерние узлы Item Чтение/запись Пользовательский атрибут текущего узла Key Чтение Строка, представляющая ключ поиска текущего сайта NextSibling Чтение Следующий узел, расположенный на том же уровне иерар-хии, что и текущий ParentNode Чтение/запись Родительский узел текущего узла PreviousSibling Чтение Предыдущий узел, расположенный на том же уровне иерар-хии, что и текущий Provider Чтение Провайдер, ответственный за текущий узел ReadOnly Чтение Указывает, разрешена ли модификация данного узла ResourceKey Чтение/запись Ключ ресурса, используемого для локализации данного узла Roles Чтение/запись Коллекция ролей, связанных с данным узлом RootNode Чтение Корневой узел иерархии карты сайта Title Чтение/запись Надпись текущего узла Url Чтение/запись URL страницы, которую представляет текущий узел Большая часть этих свойств соответствует перечисленным в табл. 10-1 атрибутам элемента <siteMapNode> из файла .sitemap. Методы класса SiteMapNode В табл. 10-4 описаны методы класса SiteMapNode. Табл. 10-4. Методы класса SiteMapNode Метод Описание Clone Создает копию текущего узла GetAllNodes Возвращает доступную только для чтения коллекцию дочерних узлов текущего узла GetDataSourceView Возвращает объект представления источника данных, связанный с текущим узлом GetHierarchicalDataSourceView Извлекает объект иерархического представления источника данных, связанный с текущим узлом IsAccessibleToUser Возвращает значение, указывающее, разрешено ли текущему пользователю видеть данный узел IsDescendantOf Возвращает значение, указывающее, является ли текущий узел дочерним узлом или потомком заданного узла Судя по данной таблице, у класса SiteMapNode довольно богатый интерфейс про-граммирования.
374 Часть I I Специализированные средства ASP.NET Переход к нужному узлу Для программного доступа к текущему узлу карты сайта предназначено свойство CurrentNode класса SiteMap. Следующий фрагмент кода демонстрирует, как выполнить проход по дочерним узлам заданного узла карты: if (SiteMap.CurrentNode.HasChildNodes) { foreach(SiteMapNode node in SiteMap.CurrentNode.ChildNodes) { //Обработка информации узла } } При каждом обращении к свойству CurrentNode класс SiteMap генерирует событие SiteMapResolve, обработав которое, страница или элемент управления могут постро-ить пользовательское представление карты сайта без помощи специализированного провайдера. Программная модификация узлов карты сайта в памяти Карта сайта - относительно статичный объект, но это не означает, что ее нельзя модифицировать в памяти. Предположим, что страницы некоторого сайта динами-чески добавляются в ответ на действия пользователей. Классический пример такого сайта - группа новостей или форум, где для каждого нового постинга создается но-вая страница. Как представить путь к такой странице от домашней страницы сайта? (Чуть позже вы узнаете, какие элементы управления ASP.NET предоставляет для рендеринга пути к странице сайта.) Созданная страница содержит текст пользовательского постинга. Если у сайта имеется карта, данная страница в ней, конечно, не отражена. Нужно ли модифициро-вать карту сайта для каждого постинга? Имейте в виду, что файл карты сайта трудно модифицировать программным способом, поскольку ASP.NET не предоставляет для этого надежного API, так что вам придется написать для этой цели собственный провайдер. Существует более эффективное решение - отображать постинги на одной и той же странице, как это делается во многих приложениях ASP.NET, предназначенных для поддержки форумов. Пусть эта страница называется showpost.aspx. Нам нужно написать для нее обработчик события SiteMapResolve, который будет возвращать временный узел со ссылкой на нужный URL: void Page_Load(object sender, EventArgs e) { SiteMap.SiteMapResolve += new SiteMapResolveEventHandler(ResolveNode); }SiteMapNode ResolveNode(object sender, SiteMapResolveEventArgs e) { //Создаем копию текущего узла и всех его предков SiteMapNode tempNode = SiteMap.CurrentNode.Clone(true); //Получаем идентификатор постинга int postID = GetPostID(); //Формируем узел, содержащий путь к запрошенной странице tempNode.Url += "?ID=" + postID; return tempNode;
Навигация по сайту Глава 10 375 }string GetPostID() { return HttpContext.Current.QueryString["ID"].ToString(); } Таким образом, URL страницы showpost.aspx обновляется путем добавления в него динамически формируемых параметров строки запроса. Мы вернемся к этому примеру после того, как я расскажу об элементе управления SiteMapPath. Элемент управления SiteMapPath На многих сайтах для пользователя выводится подсказка в виде последовательности ссылок, показывающей, в каком месте иерархии сайта расположена текущая страница (рис. 10-1). В ASP.NET эта последовательность называется путем по карте сайта (site map path). Для ее вывода используется очень удобный элемент управления SiteMapPath, имеющий много параметров настройки. Рис. 10-1. Путь по карте сайта В предыдущих версиях ASP.NET такую последовательность ссылок приходилось формировать вручную, обычно путем отслеживания URL, по которым пользователь переходил от одной страницы к другой. Члены элемента управления SiteMapPath Элемент управления SiteMapPath занимает на странице совсем мало места и позволяет пользователю одним щелчком перейти на любую из страниц-предков текущей стра-ницы. Нужные этому элементу данные предоставляются объектом SiteMap. Свойства элемента управления SiteMapPath описаны в табл. 10-5. Табл. 10-5. Свойства элемента управления SiteMapPath Свойство Описание CurrentNodeStyle Стиль для вывода названия текущего узла CurrentNodeTemplate Шаблон для представления текущего узла в навигационном пути сайта NodeStyle Стиль для вывода названий всех узлов в навигационном пути сайта NodeTemplate Шаблон для представления всех узлов в навигационном пути сайта ParentLevelsDisplayed Количество отображаемых уровней родительских узлов PathDirection Порядок вывода узлов в навигационном пути PathSeparator Строка, используемая для разделения узлов в навигационном пути PathSeparatorStyle Стиль для вывода разделителя PathSeparatorTemplate Шаблон для вывода разделителя (см. след. стр.)
376 Часть I I Специализированные средства ASP.NET Свойство Описание Provider Объект провайдера карты сайта, ассоциированный с элементом управления (чтение/запись) RenderCurrentNodeAsLink Если это свойство установлено, элемент управления выводит название текущего узла как гиперссылку RootNodeStyle Стиль для вывода названия корневого узла RootNodeTemplate Шаблон для вывода корневого узла навигационного пути сайта ShowToolTips Если это свойство установлено, то при задержке указателя мыши на названии узла выводится всплывающая подсказка SiteMapProvider Имя объекта провайдера карты сайта, используемого для ренде-ринга навигационного элемента управления SkipLinkText Значение, используемое для рендеринга альтернативного текста, чтобы агенты поисковых машин пропускали содержимое элемента управления Каждый узел, отображаемый элементом управления SiteMapPath, заключается в оболочку - экземпляр контейнерного класса SiteMapNodeItem. При его создании генерируется событие ItemCreated. А когда элемент-узел связывается с данными, генерируется событие ItemDataBound. Отображение местоположения текущей страницы Элемент управления SiteMapPath получает URL текущей страницы и заполняет экзем-пляр класса SiteMapNode информацией, полученной из карты сайта. Эта информация включает URL, заголовок, описание и местоположение страницы в навигационной иерархии. Для того чтобы воспользоваться элементом управления SiteMapPath, вам не при-дется писать ни строчки кода. Просто поместите в исходный файл .aspx следующую разметку: <asp:SiteMapPath ID="SiteMapPath1" runat="server" RenderCurrentNodeAsLink="True" PathSeparator=" : " > <PathSeparatorStyle Font-Bold="True" /> <NodeStyle Font-Bold="True" /> <RootNodeStyle Font-Bold="True" /> </asp:SiteMapPath> Безусловно, стилевые свойства в этом коде не являются его существенной час-тью - элемент управления будет работать и без них. Итоговый вывод получится таким, как на рис. 10-1. Элемент управления SiteMapPath запрашивает информацию о текущем узле у объек-та SiteMap. Страница, зарегистрировавшая обработчик события SiteMapResolve, может перехватить это событие и вернуть узел, отличный от того, который бы вернул объект карты сайта. Именно это мы и делали выше, в разделе "Программная модификация узлов карты сайта в памяти". Мы продвинемся еще на шаг вперед - создадим поль-зовательский компонент пути по карте сайта. Разработка пользовательского компонента пути по карте сайта Наиболее полезным и логичным способом вывода пути по карте сайта является ото-бражение последовательности ссылок или хотя бы надписей, указывающих местона-хождение пользователя. Именно так действует элемент управления SiteMapPath, и едва Табл. 10-5. (окончание) 
Навигация по сайту Глава 10 377 ли вам потребуется нечто большее. Однако с учебной целью мы все же выясним, как можно создать собственный такой компонент. Рассмотрим следующий код: void Page_Load(object sender, EventArgs e) { RenderCustomSiteMapPath(TreeView1); }void RenderCustomSiteMapPath(TreeView tv) { for (SiteMapNode node=SiteMap.CurrentNode; node != null; node=node.ParentNode) { TreeNode tn = new TreeNode(node.Title, node.Title, "", node.Url, ""); tv.Nodes.AddAt(0, tn); } } Когда приходит время вывода компонента, мы организуем цикл от текущего URL вверх по иерархии до корневого узла карты сайта. В функции, написанной на C#, можно воспользоваться оператором for с переменной-итератором типа SiteMapNode. На каждом шаге цикла итератору присваивается значение свойства ParentNode. Когда данное свойство вернет null, это будет означать, что достигнут корневой узел сайта, и цикл завершится. Каждый найденный узел содержит информацию, которую можно вывести в выход-ной поток. В данном примере мы просто добавляем новый узел в элемент управления TreeView, размещая его выше имеющихся там узлов, чтобы на экране они располага-лись в естественном порядке, то есть чтобы корневой узел сайта выводился сверху. Результат вы видите на рис. 10-2. Рис. 10-2. Пользовательский компонент пути по карте сайта, созданный на базе элемента управления TreeView Элемент управления SiteMapDataSource Элемент управления SiteMapPath имеет полный доступ к информации карты сайта, но отображает только список URL, составляющих логический путь от домашней страницы сайта к текущей. Главным достоинством этого элемента является то, что он позволяет пользователю одним щелчком переключиться на любую из страниц-предков текущей страницы. Однако путь по карте сайта - это только один из возможных путей от корневого узла сайта к данному листовому. А как же остальная информация карты? Вывести ее нам поможет элемент управления, представляющий источник данных.
378 Часть I I Специализированные средства ASP.NET В ASP.NET 2.0 элемент управления, представляющий источник данных (data source control), - это серверный элемент управления, предназначенный для взаимодействия с элементами управления, связанными с данными, и скрывающий сложности про-цедуры связывания с данными. Элементы управления, представляющие источники данных, не имеют визуального представления; их основная задача - обеспечивать выборку данных из источника и выполнять другие связанные с данными операции, такие как вставка, удаление, обновление и сортировка. Каждый такой компонент слу-жит оболочкой для определенного провайдера данных, работающего с реляционной СУБД, пользовательским хранилищем или XML-документом. Элементы управления, представляющие источники данных, делятся на две группы: табличные и иерархи-ческие - в зависимости от того, с данными какой структуры они работают, плоской или иерархической. В главе 9 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005) приведен глубокий анализ элементов управления, представляющих источники данных, с акцентом на табличные элементы управления. В рамках этой главы нас интересует главным образом иерархический элемент управления SiteMapDataSource, предоставляющий информацию, содержащуюся в хранилище данных карты сайта. Обычно его экземпляр связывают с иерархическим элементом управления, таким как TreeView или Menu, который в результате автома-тически заполняется содержимым карты сайта. Члены элемента управления SiteMapDataSource Иерархический элемент управления SiteMapDataSource, представляющий источник данных, является производным от класса HierarchicalDataSourceControl и реализу-ет интерфейс IDataSource, посредством которого осуществляется доступ к внут-реннему представлению данных. Свойства класса SiteMapDataSource перечислены в табл. 10-6. Табл. 10-6. Свойства элемента управления SiteMapDataSource Свойство Описание Provider Ссылка на объект провайдера карты сайта, связанный с элементом управления. Свойство доступно для записи ShowStartingNode Указывает, должен ли в состав карты входить узел, представляющий текущую страницу. По умолчанию данное свойство имеет значение true SiteMapProvider Имя провайдера карты сайта, связанного с элементом управления. Свойство доступно для записи StartFromCurrentNode Указывает, должен ли корневым узлом отображаемой карты быть узел, представляющий текущую страницу. По умолчанию данное свойство имеет значение false StartingNodeOffset Положительное или отрицательное значение смещения начального узла выводимой карты от начального узла полной карты сайта. По умолчанию значение данного свойства равно нулю StartingNodeUrl Определяет URL начального узла выводимой карты Элемент управления SiteMapDataSource работает с провайдером карты сайта, ис-пользуемым по умолчанию. Если вы захотите, чтобы он работал с другим провайдером, присвойте имя последнего строковому свойству SiteMapProvider элемента управления. После этого ссылка на объект провайдера, хранящаяся в свойстве Provider, обновится автоматически.
Навигация по сайту Глава 10 379 Использование элемента управления SiteMapDataSource Элемент управления SiteMapDataSource расположен на вкладке Data панели инстру-ментов Microsoft Visual Studio 2005. Все, что вам нужно сделать, это перетащить эле-мент управления в Web-форму, а потом открыть и протестировать страницу. Причем, скорее всего, вам даже не потребуется менять установки, заданные по умолчанию. <asp:SiteMapDataSource ID="SiteMapDataSource1" runat="server" /> Если нужно связать элемент управления с конкретным провайдером, задайте имя этого провайдера в атрибуте SiteMapProvider. Чтобы связать объект SiteMapDataSource с иерархическим элементом управления, скажем, с TreeView, свойству DataSourceID элемента управления TreeView присваивают идентификатор элемента управления SiteMapDataSource, как в следующем примере: <asp:TreeView ID="TreeView1" runat="server" DataSourceID="SiteMapDataSource1" ImageSet="WindowsHelp"> </asp:TreeView> Разметка для вывода карты сайта в виде меню практически идентична. Корневым узлом выводимой карты, предоставляемой элементом управления SiteMapDataSource, по умолчанию является корневой узел исходной карты, то есть домашняя страница сайта, но вы можете задать и любой другой узел. Определение начального узла Уменьшить количество возвращаемых узлов позволяют три свойства: StartFromCurrentNo de, StartingNodeOffset и StartingNodeUrl. Вам следует учитывать то обстоятельс-тво, что свойства StartFromCurrentNode и StartingNodeUrl являются взаимоисключаю-щими, то есть StartingNodeUrl можно использовать, только когда StartFromCurrentNode содержит значение false, в противном случае будет выброшено исключение. Началь-ный узел выводимой карты задается либо его позицией относительно указанного начала карты, либо непосредственно URL. Смещение может быть как положительным, так и отрицательным. Приведем пример: <asp:SiteMapDataSource ID="SiteMapDataSource1" runat="server" StartFromCurrentNode="true" StartingNodeOffset="-1" /> В данном случае карта будет начинаться с узла, который является родительским по отношению к текущей странице. Совет При создании полной навигационной системы сайта заданные по умолчанию установки элемента управления SiteMapDataSource обычно не меняют. А вот если вы хотите выводить карту на каждой странице, тогда имеет смысл отображать лишь ее часть, задавая URL либо смещение начального узла. Сравнение SiteMap и SiteMapDataSource Выше рассказывалось о двух объектах, позволяющих получить доступ к информации карты сайта, - SiteMap и SiteMapDataSource, второй из которых является элементом управления без пользовательского интерфейса. Класс SiteMap разрабатывался как открытый API для доступа к полной информации карты сайта. Элемент управления SiteMapDataSource использует объект данного класса для доступа к карте, но сам этот элемент предназначен исключительно для отображения информации карты сайта посредством элементов управления, имеющих пользовательский интерфейс, таких как TreeView и Menu. У него есть специальные свойства, облегчающие выделение 
380 Часть I I Специализированные средства ASP.NET информации, которую вы хотите отобразить, и это позволяет, например, построить дерево, начинающееся с узла текущей страницы. Вывод информации карты сайта Основное назначение карты сайта - уничтожить зависимость между динамически изменяющейся структурой сайта и ссылками, размещенными на его домашней стра-нице, а также других страницах. Если построить вручную меню с жестко заданными в нем ссылками, то при каждом перемещении или переименовании страницы эти ссылки нужно будет корректировать. Вам придется потрудиться и в том случае, если вы пожелаете фильтровать ссылки с учетом ролей текущего пользователя. В ASP.NET 2.0 карта сайта позволяет централизованно хранить информацию о структуре файла. Но сам по себе файл карты бесполезен, если нет серверных эле-ментов управления, способных выводить на странице содержащиеся в нем данные. Именно такими элементами являются TreeView и Menu. Будучи размещенным на домашней странице сайта, каждый из этих элементов (как и любой специализиро-ванный иерархический элемент управления, который вы пожелаете разработать) извлекает информацию карты сайта и формирует соответствующий пользовательский интерфейс. Вы можете свободно переименовывать и перемещать страницы, внося соответствующие изменения в файл карты, и интерфейс, формируемый упомянутыми элемента управления, будет меняться соответствующим образом. Связь между иерархическим элементом управления и данными карты сайта уста-навливается через элемент управления SiteMapDataSource. Чтобы понять, что собой представляют элементы управления с древообразным интерфейсом, взгляните на рис. 10-3. Рис. 10-3. Карта сайта, выведенная с помощью элемента управления TreeView Каждый узел элемента управления TreeView связан с узлом карты сайта. Благодаря применению элемента управления SiteMapDataSource связывание осуществляется автоматически. Внимание! В ASP.NET 2.0 информация, получаемая с помощью иерархических элементов управления, которые представляют источники данных, доступна только для чтения. Элемент управления TreeView Отметим, что элемент управления TreeView является нововведением ASP.NET 2.0. Будучи предназначенным для вывода в древообразной форме иерархических дан-ных, таких как содержание документа или карта сайта, данный элемент управления обладает широким набором функций, включая поддержку связывания данных, за-полнения узлов на стороне клиента, применения тем, настройки узлов и, конечно же, навигации по сайту.
Навигация по сайту Глава 10 381 Вывод элемента управления TreeView состоит из узлов и элементов, служащих для их свертывания и развертывания путем возврата формы или с использованием клиентского сценария. Каждый узел представлен объектом TreeNode и может иметь родительские и дочерние узлы. Члены элемента управления TreeView У элемента управления TreeView, помимо свойств, унаследованных им от базовых классов, имеется и несколько собственных. Я разделил их на три группы: визуаль-ные, поведенческие и стилевые. Визуальные свойства элемента управления TreeView описаны в табл. 10-7. Табл. 10-7. Визуальные свойства элемента управления TreeView Свойство Описание CollapseImageToolTip Всплывающая подсказка кнопки свертывания узла CollapseImageUrl URL пользовательского изображения для кнопки свертывания узла ExpandImageToolTip Всплывающая подсказка кнопки развертывания узла ExpandImageUrl URL пользовательского изображения для кнопки развертывания узла ImageSet Группа изображений для рендеринга пользовательского интерфейса элемента управления NoExpandImageUrl URL пользовательского изображения для неразвертываемого узла NodeIndent Величина отступа дочернего узла (в пикселах) NodeWrap Указывает, будет ли текст узла, не поместившийся в строку, переноситься на следующую строку ShowCheckBoxes Определяет, для каких типов узлов (leaf, parent, root) будут выводиться флажки ShowExpandCollapse Определяет, должны ли выводиться индикаторы, показывающие, что узлы являются развертываемыми ShowLines Указывает, следует ли выводить линии, соединяющие дочерние узлы с родительскими Как видно из этой таблицы, узел элемента управления TreeView состоит из не-скольких конфигурируемых элементов. Во-первых, это изображения, используемые в качестве кнопок свертывания/развертывания узлов, во-вторых, текст самого узла, который по вашему желанию может выводиться в виде гиперссылки или обычной надписи. Дочерние узлы обычно выводят с отступом, а при желании еще и соединяют линиями с родительскими узлами, чтобы лучше отразить иерархию. В табл. 10-8 перечислены свойства, описывающие поведение элемента управления TreeView и его объектную модель. Табл. 10-8. Поведенческие свойства элемента управления TreeView Свойство Описание AutoGenerateDataBindings Указывает, будет ли элемент управления автоматически генериро-вать связи узлов CheckedNodes Возвращает коллекцию объектов TreeNode, представляющих узлы, для которых выводятся флажки DataBindings Возвращает коллекцию объектов TreeNodeBinding, определяющих соответствие между элементами данных и узлами элемента управ-ления (см. след. стр.)
382 Часть I I Специализированные средства ASP.NET Свойство Описание EnableClientScript Указывает, будет ли элемент управления выводить клиентский сценарий для обработки событий свертывания/развертывания. По умолчанию данное свойство имеет значение true ExpandDepth Количество уровней, автоматически развертываемых при выводе элемента управления TreeView MaxDataBindDepth Максимальное количество уровней дерева для связывания Nodes Возвращает коллекцию объектов TreeNode, представляющих узлы элемента управления PathSeparator Символ, используемый для разделения элементов в пути каждого узла. По умолчанию это косая черта (/) PopulateNodesFromClient Указывает, будет ли узел заполняться данными по требованию клиента. По умолчанию данное свойство имеет значение true SelectedNode Возвращает объект TreeNode, представляющий выделенный узел элемента управления SelectedValue Возвращает значение выделенного узла Элемент управления TreeView часто используется для вывода большого количес-тва данных. Но когда и как эти данные с ним связываются? Следует ли выполнять связывание с данными один раз при загрузке элемента или лучше заполнять его по требованию? И что эффективнее: выполнение возврата формы или обратный вызов сценария? Для связывания элемента управления TreeView с данными можно использовать свойство DataSourceID или DataSource. В обоих случаях желательно, чтобы источ-ник данных был иерархическим, таким как документ XML или карта сайта. (Объект IEnumerable с элементом управления TreeView связать нельзя.) Связывание TreeView с данными может производиться декларативно или программно, путем заполнения коллекции DataBindings. Связи между узлами и данными представляют объекты клас-са TreeNodeBinding или элементы разметки <asp:TreeNodeBinding>. Для заполнения дерева можно также воспользоваться коллекцией Nodes, куда разрешается добавлять значения явно, а не путем связывания с данными. Узел представляется экземпляром класса TreeNode или элементом разметки <asp:TreeNode>. В случае связывания с источником данных, используемым по умолчанию, заполне-ние производится по требованию, с применением клиентского сценария и технологии обратного вызова сценария ASP.NET (см. главу 6). В табл. 10-9 описаны стилевые свойства элемента управления TreeView. Табл. 10-9. Стилевые свойства элемента управления TreeView Свойство Описание HoverNodeStyle Стиль узла, на который наведен указатель мыши LeafNodeStyle Стиль листового узла LevelStyles Возвращает коллекцию объектов Style, содержащих стили узлов разных уровней NodeStyle Стиль всех узлов, применяемый по умолчанию ParentNodeStyle Стиль родительского узла RootNodeStyle Стиль корневого узла SelectedNodeStyle Стиль выделенного узла Табл. 10-8. (окончание)
Навигация по сайту Глава 10 383 Стиль узла - это объект типа TreeNodeStyle. Данный класс наследует класс Style, но имеет собственные атрибуты, позволяющие управлять отступами и символьным запол-нением узлов. Стили применяются в определенном порядке: сначала NodeStyle, затем RootNodeStyle, за ним ParentNodeStyle или LeafNodeStyle, что зависит от типа узла. На этом же этапе применяются стили LevelStyles, и если они определены, то им отдается предпочтение. Далее используются стили SelectedNodeStyle и HoverNodeStyle. Примечание У элемента управления TreeView есть пара методов: ExpandAll и FindNode. Первый осуществляет рендеринг элемента управления со всеми развернутыми узлами, а второй находит и возвращает объект TreeNode узла, соответствующего заданному пути. Оба метода предназначены для применения в серверном коде. Древообразное представление сайта Связывание элемента управления с картой сайта осуществляется очень просто: доста-точно поместить элементы управления TreeView и SiteMapDataSource в форму - и дело сделано. Вы можете разве что подобрать стили TreeView по своему вкусу. Если карта сайта хранится в пользовательском формате, то для нее должен быть написан поль-зовательский провайдер, который просто подменяет стандартный, и все работает как обычно. Наличие связи между элементами управления TreeView и SiteMapDataSource облегчает создание страниц, в которых область слева зарезервирована для навигации, а осталь-ная часть страницы предназначена для вывода основного ее содержимого. Интересным свойством элемента управления TreeView является ImageSet. Оно позволяет задать группу изображений для узлов элемента управления. Набор изоб-ражений может быть представлен значениями перечислимого типа TreeViewImageSet или непосредственно графическими ресурсами из сборки system.web. Например, на странице, показанной на рис. 10-3, использован набор изображений Simple2, а на дру-гой странице, представленной на рис. 10-4, применяется еще несколько стандартных наборов изображений. (Заметьте, что набор изображений можно получить во время разработки с помощью мастера AutoFormat.) Рис. 10-4. Древообразное представление карты сайта
384 Часть I I Специализированные средства ASP.NET Ниже приведен код, позволяющий связать значения перечислимого типа с раскры-вающимся списком и изменить набор изображений в древообразном представлении для выделенного диапазона узлов: void Page_Load(object sender, EventArgs e) { if (!IsPostBack) { Type t = typeof(TreeViewImageSet); DropDownList1.DataSource = Enum.GetValues(t); DropDownList1.DataBind(); } }void DropDownList1_SelectedIndexChanged(object sender, EventArgs e) { Type t = typeof(TreeViewImageSet); string imageSet = DropDownList1.SelectedValue; TreeView1.ImageSet = (TreeViewImageSet) Enum.Parse(t, imageSet); } Внимание! Когда вы выводите информацию карты сайта на странице и, особенно, ког-да пользуетесь элементом управления SiteMapDataSource, убедитесь, что эта страница включена в карту сайта. После развертывания приложения это не имеет значения, но в процессе разработки могут возникнуть проблемы. Элемент управления Menu Меню - типичный элемент интерфейса любого Windows-приложения. До появления ASP.NET 2.0 множество сторонних производителей и бессчетное количество разработ-чиков тратили силы и средства на создание компонента многократного использования, похожего на обычные меню Windows-приложений. И вот, наконец, ASP.NET 2.0 явила миру столь долгожданный элемент управления под названием Menu. Элемент управления Menu позволяет вывести на странице группу элементов, щелкая которые, пользователь может переходить к другим страницам или запускать некоторый код. Внешний вид, ориентацию и содержимое элемента управления Menu можно задавать декларативно, с использованием связывания данных, а также про-граммно, жестко закодировав их в .aspx-файле либо формируя динамически. Элемент управления Menu состоит из объектов MenuItem, каждый их которых представляет элемент меню. Когда пользователь щелкает элемент меню, происходит переход к другой страни-це или возврат формы, в зависимости от того, как это меню сконфигурировано. По умолчанию новая страница выводится в том же окне или фрейме, что и исходная. ASP.NET 2.0 поддерживает два вида меню: статическое и динамическое. Стати-ческое меню является интегральной частью страницы и всегда выводится при ее отображении. Динамическое же меню появляется на экране только тогда, когда поль-зователь наводит указатель мыши на элемент, содержащий динамическое подменю, а потом исчезает с экрана. Члены элемента управления Menu Помимо свойств, унаследованных от базовых классов, элемент управления Menu имеет несколько собственных. Большинство из них определяют внешний вид элементов статического или динамического меню (табл. 10-10).
Навигация по сайту Глава 10 385 Табл. 10-10. Визуальные свойства элемента управления Menu Свойство Описание DynamicBottomSeparatorImageUrl URL изображения, выводимого в динамическом меню в качестве разделителя элементов под элементом меню DynamicEnableDefaultPopOutImage Указывает, должно ли выводиться встроенное изобра-жение, показывающее, что у элемента динамического меню есть подменю DynamicHorizontalOffset Смещение динамического меню по горизонтали отно-сительно его родительского меню (в пикселах) DynamicItemFormatString Строка форматирования элементов динамического меню DynamicPopOutImageTextFormatString Альтернативный текст для изображения, выводимого для элементов динамического меню, у которых имеется подменю DynamicPopOutImageUrl URL изображения, которое выводится для элемента динамического меню, имеющего подменю DynamicItemTemplate Шаблон, содержащий пользовательский контент для рендеринга динамического меню DynamicTopSeparatorImageUrl URL изображения, выводимого в динамическом меню в качестве разделителя элементов над элементом меню DynamicVerticalOffset Смещение динамического меню по вертикали относи-тельно его родительского меню (в пикселах) ScrollDownImageUrl URL изображения, которое выводится в динамичес-ком меню и указывает, что пользователь, выполнив прокрутку вниз, увидит дополнительные элементы ScrollDownText Альтернативный текст для изображения, заданного в свойстве ScrollDownImageUrl ScrollUpImageUrl URL изображения, которое выводится в динами-ческом меню и указывает, что пользователь, вы-полнив прокрутку вверх, увидит дополнительные элементы ScrollUpText Альтернативный текст для изображения, заданного в свойстве ScrollUpImageUrl StaticBottomSeparatorImageUrl URL изображения, выводимого в статическом меню в качестве разделителя элементов под элементом меню StaticDisplayLevels Количество уровней меню, отображаемых в статическом меню StaticEnableDefaultPopOutImage Указывает, должно ли выводиться встроенное изображение, показывающее, что у элемента статического меню есть подменю StaticItemFormatString Строка форматирования элементов статического меню StaticItemTemplate Шаблон, содержащий пользовательский контент для рендеринга статического меню StaticPopOutImageTextFormatString Альтернативный текст для изображения, выводимого для элементов статического меню, у которых имеется подменю StaticPopOutImageUrl URL изображения, которое выводится для элемента статического меню, имеющего подменю StaticSubMenuIndent Смещение подменю относительно его родительского элемента (в пикселах) StaticTopSeparatorImageUrl URL изображения, выводимого в статическом меню в качестве разделителя элементов над элементом меню
386 Часть I I Специализированные средства ASP.NET Элемент меню обычно состоит из текста и URL для перехода. Рядом с ним может выводиться значок, показывающий, что данный элемент предназначен для раскрытия подменю. Структура статических и динамических меню может быть в значительной степени модифицирована с использованием шаблонов. В табл. 10-11 перечислены свойства элемента управления Menu, влияющие на его поведение. Табл. 10-11. Поведенческие свойства элемента управления Menu Свойство Описание DataBindings Возвращает коллекцию объектов MenuItemBinding, определяющих связи между элементами данных и элементами меню DisappearAfter Определяет время (в миллисекундах), в течение которого динамическое меню должно оставаться на экране после того, как указатель мыши выйдет за пределы этого меню Items Возвращает объект MenuItemCollection, содержащий все элементы меню ItemWrap Указывает, должен ли текст элемента меню переноситься на следующую строку, если на одной он не помещается MaximumDynamicDisplayLevels Число уровней для рендеринга динамического меню Orientation Определяет направление рендеринга динамического меню PathSeparator Определяет символ, используемый в качестве разделителя пути к элементу меню SelectedItem Возвращает выделенный элемент меню SelectedValue Возвращает значение выделенного элемента меню Проще всего построить меню страницы ASP.NET, составив его из статических элементов. Вы заполняете коллекцию Items элемента управления Menu програм-мно или декларативно, создавая экземпляры класса MenuItem или добавляя в контей-нер <Items> тэги <asp:MenuItem>. Подменю создаются путем вложения элементов <asp:MenuItem>. Элемент управления Menu полностью поддерживает связывание с данными; в час-тности, его можно связать с уже знакомым вам компонентом, представляющим карту сайта. Для связывания Menu с элементом управления, представляющим источник данных, используется свойство DataSourceID, а для связывания с иерархическими объектами - свойство DataSource. В коллекцию DataBindings можно программно или декларативно добавлять связи между элементами меню и элементами данных. Примечание Как видите, программный интерфейс и принцип действия элементов уп-равления TreeView и Menu практически одинаковы, особенно что касается связывания с данными. Хотя оба элемента управления можно связывать с данными разными спо-собами, наиболее распространенным и эффективным подходом остается связывание с картой сайта с использованием элемента управления SiteMapDataSource. В таком случае, во-первых, у вас есть централизованное хранилище данных, отделенное от страницы, на которой находится навигационный элемента управления, а во-вторых, действует механизм защиты на базе ролей. Внешний вид меню можно настраивать с использованием тем, изображений, пользовательских шаблонов и, конечно, стилей. В табл. 10-12 перечислены стилевые свойства, поддерживаемые элементом управления Menu.
Навигация по сайту Глава 10 387 Табл. 10-12. Стилевые свойства элемента управления Menu Стиль Описание DynamicHoverStyle Стиль элемента динамического меню, на которой наведен указатель мыши DynamicMenuItemStyle Стиль элемента динамического меню DynamicMenuStyle Стиль динамического меню DynamicSelectedStyle Стиль выделенного элемента динамического меню LevelMenuItemStyles Возвращает коллекцию объектов Style, представляющих стили элементов для меню разных уровней LevelSelectedStyles Возвращает коллекцию объектов Style, представляющих стили выделенного элемента для меню разных уровней LevelSubMenuStyles Возвращает коллекцию объектов Style, представляющих стили элементов динамического подменю для меню разных уровней StaticHoverStyle Стиль элемента статического меню, на который наведен указатель мыши StaticMenuItemStyle Стиль элемента статического меню StaticMenuStyle Стиль статического меню StaticSelectedStyle Стиль выделенного элемента статического меню Стиль элемента меню представлен объектом типа MenuItemStyle. Данный класс является производным от Style и имеет ряд собственных атрибутов, управляющих выводом элемента меню. Стили применяются в определенном порядке: сначала StaticMenuStyle, затем StaticMenuItemStyle. За ним следует стиль LevelMenuItemStyles или LevelSubMenuStyles - если они определены, им отдается предпочтение. Далее при-ходит очередь StaticSelectedStyle и LevelSelectedStyles, а после них - HoverNodeStyle. Примечание У элемента управления Menu также имеется один метод, FindItem, и пара интересных событий. Метод FindItem находит и возвращает элемент меню, соответству-ющий заданному пути меню. Путь меню - это строка с заданным символом-разделите-лем, содержащая путь от корневого элемента меню до текущего. Символ-разделитель задается в свойстве PathSeparator. События данного элемента управления называются MenuItemClick и MenuItemDataBound. Первое генерируется, когда пользователь щелкает элемент меню, а второе - когда происходит связывание элемента меню с данными. Представление структуры сайта в виде меню Связать карту сайта с элементом управления Menu так же просто, как с элементом управления TreeView: <asp:SiteMapDataSource ID="SiteMapDataSource1" runat="server" /> <asp:Menu ID="Menu1" runat="server" DataSourceID="SiteMapDataSource1" DynamicHorizontalOffset="2" StaticSubMenuIndent="10px"> </asp:Menu> На рис. 10-5 показано меню, созданное на базе демонстрационной карты сайта, которая приводилась ранее в этой главе. Заметьте, что элементы управления Menu и TreeView генерируют разметку и код сценария, одинаково хорошо работающие в браузерах Internet Explorer и Mozilla.
388 Часть I I Специализированные средства ASP.NET Рис. 10-5. Карта сайта в виде меню Совет Как именно выводить информацию карты сайта, - в виде дерева или меню, - дело вкуса. Можно даже создать две разные эталонные страницы и предоставить поль-зователю возможность выбора между ними, сохраняя его предпочтения в пользователь-ском профиле. Для того чтобы для каждой страницы правильно выбиралась эталонная страница, можно создать пользовательский класс Page и в обработчике события PreInit (единственном месте, где можно программно задать эталонную страницу) осуществлять выбор, а все страницы сайта сделать производными от данного класса. Это первый шаг в направлении создания страниц с обложками (skin), то есть страниц, темы и рас-положение элементов которых задает пользователь. За дополнительной информацией о страницах ASP.NET, эталонных страницах и пользовательских профилях вы опять-таки можете обратиться к главам 3 и 5 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference". Вывод меню с учетом ролей пользователей Как мы уже говорили, в реальных приложениях обычно действует защита на уровне ролей. В ASP.NET 2.0 информация о ролях пользователя автоматически связывается с идентификационным объектом и доступна коду посредством объекта User. Раньше, в ASP.NET 1.x, такую связь приходилось программировать вручную, но объект User также имел метод для проверки принадлежности пользователя определенной роли. За дополнительной информацией о ролях вы можете обратиться к главе 15 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference". Предположим, что у приложения имеется ряд зарегистрированных пользователей, которым назначены роли. Давайте посмотрим, как можно обеспечить фильтрацию карты сайта, с тем чтобы каждый пользователь видел ссылки только на те страницы, к которым ему разрешен доступ. Интересно, что нам не потребуется вносить изменений ни в источник данных карты сайта, ни в элемент управления, в котором выводится ее информация, будь то TreeView или Menu. Необходимую фильтрацию выполняет провайдер карты сайта, а элементы управления просто выводят то, что он предоставил. Чтобы провайдер выполнял обрезание выдаваемой им информации карты сайта с учетом ролей текущего пользователя, нужно включить данную функцию в файле web.config. И, конечно, это сработает, лишь при условии, что провайдер поддерживает данную функцию. <siteMap defaultProvider="XmlSiteMapProvider" enabled="true"> <providers>
Навигация по сайту Глава 10 389 <add name="XmlSiteMapProvider" description="Default SiteMap provider." type="System.Web.XmlSiteMapProvider " siteMapFile="Web.sitemap" securityTrimmingEnabled="true" /> </providers> </siteMap> В файле карты сайта в атрибуте roles узла <siteMapNode> задается список ролей, членам которых разрешен просмотр данного узла. Этот список имеет вид разделен-ной запятыми строки, в которой каждый элемент является именем роли. Следующий фрагмент кода определяет узел, доступный только членам роли Editor: <siteMapNode title="Introduction" roles="Editor"> </siteMapNode> На рис. 10-6 и 10-7 показана одна и та же страница при просмотре пользователями, принадлежащими к разным ролям. Рис. 10-6. Карта сайта при просмотре членом роли Editor Рис. 10-7. Карта сайта при просмотре членом роли Reader (узел Introduction отсутствует) Примечание Когда активизирована функция обрезания карты сайта, узлы, у которых нет атрибута roles, становятся недоступными для просмотра. Поэтому для узлов, которым защита не требуется, этому атрибуту можно присвоить значение '*'.
390 Часть I I Специализированные средства ASP.NET Заключение Когда Web-сайт разрастается и становится трудно отслеживать связи между страни-цами, это означает, что настало время для создания документа с картой сайта. В нем перечисляются все страницы сайта и описывается их логическая взаимосвязь. С какой целью? Просто ради документирования? Конечно же, нет. В ASP.NET 2.0 карта сайта является основой работы навигационных элементов управления SiteMapPath, TreeView и Menu. С помощью этих элементов с удивительной легкостью можно создать меню сайта или его древообразную схему, а также показать пользователю, где он в данный момент находится. Файл карты сайта является просто источником данных, и его связывание со всеми этими элементами управления невозможно без специального программного компо-нента - провайдера карты сайта, считывающего ее информацию из XML-файла или любого другого хранилища, которому вы отдаете предпочтение, и формирует на ее основе объект в памяти приложения. Только факты Карта сайта - это документ, описывающий структуру сайта и логические связи между его страницами. По умолчанию карта сайта хранится в XML-документе web.sitemap, в корневой папке этого сайта. Определив новый пользовательский провайдер, можно считывать информацию карты сайта из любого другого источника, включая XML-файл с иной схемой и таблицы базы данных. Когда карта сайта определена, для любой страницы известен путь к ней по карте от корневой страницы сайта. Этот путь можно показать пользователю с помощью элемента управления SiteMapPath. Содержимое карты сайта загружается в память в начале работы приложения и про-граммно доступно посредством статических членов класса SiteMap. SiteMapDataSource - это иерархический элемент управления, представляющий источник данных, предназначенный для вывода содержимого карты с использо-ванием специализированных элементов управления TreeView и Menu. Если провайдер карты сайта поддерживает защиту на базе ролей, а карта сайта содержит информацию о ролях пользователей, которым разрешен доступ к каж-дому из узлов, элементы управления TreeView и Menu отображают только те узлы, которые доступны текущему пользователю. 
Часть III Элементы управления ASP.NET Глава 11. Итеративные элементы управления ASP.NET ................................................. 392 Глава 12. Пользовательские элементы управления ASP.NET ......................................... 418 Глава 13. Создание специализированных элементов управления ASP.NET ................. 446 Глава 14. Элементы управления, связанные с данными и использующие шаблоны ................................................................................. 487 Глава 15. Поддержка специализированных элементов управления во время разработки .......................................................................................... 533
Глава 11 Итеративные элементы управления ASP.NET В свое время для разработчиков приложений ASP.NET 1.0 настоящим подарком стало связывание с данными и связанные с данными элементы управления. В ASP.NET 2.0 механизм связывания с данными был значительно усовершенствован, прежде всего с целью упростить для разработчиков решение наиболее типичных задач. О связывании с данными и соответствующих элементах управления я уже рассказывал в главе 9 кни-ги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005), а ее главы 10 и 11 посвящены детальному анализу возможностей элементов управления GridView, DetailsView и FormView из ASP.NET 2.0. Единственная тема, которую я тогда не осветил, - это итеративные элементы управления, ее мы сейчас и рассмотрим. Итеративные элементы управления отличает наличие поддержки совместимых с ASP.NET источников данных и механизма создания произвольного пользователь-ского интерфейса на базе шаблонов. Такие элементы управления применяются при создании сложных и гибко настраиваемых клиентских приложений баз данных. Ите-ративные элементы управления поддерживаются всеми версиями ASP.NET. Понятие итеративного элемента управления Связанный с данными элемент управления ASP.NET называется итеративным, если он перебирает элементы набора данных, с которым он связан, и применяет к каждому из них заданный вами шаблон ASP.NET. На каждой итерации цикла генерируется специ-фический для элемента управления объект, содержащий элемент данных и информацию, необходимую для его отображения. Он выводится как индивидуально конфигурируе-мый независимый объект со своим собственным набором свойств, методов и событий. В ASP.NET 2.0 есть два итеративных элемента управления: Repeater и DataList. Чтобы вам легче было понять, для каких ситуаций они предназначены, давайте сравним их с другими элементами управления, связанными с данными, - списочными и табличными. Сравнение итеративных элементов управления со списочными Списочные элементы управления, примерами которых являются DropDownList, ListBox, CheckBoxList и BulletedList, предназначены для отображения списка элементов с ис-пользованием фиксированного пользовательского интерфейса. К списочному типу можно отнести все элементы управления, имена которых содержат слово List, за исключением DataList. Элемент управления DropDownList выглядит, как раскрывающийся список; способ отображения его элементов вы изменить не можете, не считая, разве что, применения каскадных таблиц стилей. Элемент управления CheckBoxList представляет собой набор флажков, причем и значения его элементов, и текст их надписей могут быть связаны с источником 
Итеративные элементы управления ASP.NET Глава 11 393 данных. К такому списку можно применять простейшее HTML-форматирование, од-нако полный список параметров рендеринга вам недоступен - разве что вы замените целиком сам механизм рендеринга. Если, скажем, вы пожелаете выводить отдельные элементы набора флажков полу-жирным шрифтом, то вам придется модифицировать текст самих выводимых элемен-тов, заключив его внутрь тэга <b>. Конечно, это лучше чем ничего, но для приложения со сложным и гибким интерфейсом данной возможности явно недостаточно. Итеративные элементы управления отличаются от списочных возможностью более гибкого управления рендерингом. К каждой строке выводимых данных итеративного элемента можно индивидуально применить подходящий шаблон ASP.NET, тогда как шаблон списочного элемента управления фиксирован и возможность настройки такого элемента ограничена изменением отображаемого текста. Интерфейс программирования Как мы уже сказали, итеративные элементы управления более гибкие, чем списочные, однако работать с ними сложнее. Списочный элемент нужно всего лишь связать с дан-ными, то есть задать для него источник данных либо объект IEnumerable. Итеративный же элемент требует от вас определения одного или нескольких шаблонов. Шаблон ASP. NET - это фрагмент кода разметки, нечто вроде встроенной фор-мы, в которой обозначены места для вывода данных; форма встраивается в элемент управления Repeater или DataList. Для того чтобы определить такой шаблон, нужно написать достаточно много декларативного кода, а при программном выполнении данной задачи - определить класс, реализующий интерфейс ITemplate, или загру-зить шаблон из внешнего файла пользовательского элемента управления. О пользо-вательских элементах управления (определяемых в файлах *.ascx) рассказывается в следующей главе. Списочный элемент управления очень легко использовать повторно, ведь это само-достаточный компонент, почти не связанный со страницей, а связанный только с кодом, необходимым для извлечения данных. Повторное же использование решения на основе итеративного элемента управления - задача не столь простая, поскольку информация шаблона, которая обычно является его ключевой составляющей, обычно содержится в странице, на которой этот элемент размещен. Чтобы устранить такую зависимость, вы можете сделать свой элемент зависимым от внешнего файла (пользовательского элемента управления) или же написать программный код, определяющий шаблон по-средством интерфейса ITemplate. (Последний метод мы рассмотрим позднее.) Сравнение итеративных элементов управления с элементами-представлениями Элементами-представлениями являются GridView, DetailsView, FormView и наш старый знакомый - DataGrid. Все они действуют итеративно, применяя к выводимым на странице данным шаблоны, которые отчасти можно настраивать. Однако возможности такой настройки очень ограничены и не позволяют выйти за рамки предопределен-ной формы вывода данных. Это делает элементы-представления очень похожими на списочные элементы управления. Табличные элементы управления Элементы управления DataGrid и GridView являются более сложными, чем Repeater и DataList, поскольку поддерживают разбивку данных на страницы и сортировку дан-ных. С другой стороны, в отношении рендеринга они не столь гибки, как итеративные 
394 Часть III Элементы управления ASP.NET элементы управления. В определенном смысле табличные элементы управления мож-но назвать готовыми специализированными версиями итеративных элементов. С помощью элемента управления Repeater можно создать таблицу данных, причем сделать это даже проще, чем посредством элемента управления DataList. Однако не всякую таблицу, которую можно сформировать с помощью элемента Repeater или DataList, вы сможете создать, используя табличные элементы управления. В табл. 11-1 перечислены отличия табличных, итеративных и списочных элементов управления. Табл. 11-1. Сравнение табличных, итеративных и списочных элементов управления Категория элементов управления Как осуществляется рендеринг В каких случаях применяются Табличные Цикл по элементам данных и создание их табличного представления с примене-нием к каждому столбцу индивидуального шаблона Необходимо отобразить табличные дан-ные; если данные изначально не являются табличными, но могут быть отображены как таковые, стоит подумать о примене-нии итеративного элемента управления Итеративные Цикл по элементам данных с применением пользова-тельских шаблонов Данные должны отображаться в виде монолитной структуры произвольной формы Списочные Цикл по элементам данных с применением стандарт-ного для данного элемента управления шаблона Индивидуальной настройки отображения каждого элемента данных не требуется; вполне подходит стандартный пользова-тельский интерфейс Элементы управления, отображающие отдельные записи Если табличные элементы управления служат для отображения всех записей, возвра-щенных запросом, то элементы управления DetailsView и FormView имеют иное назна-чение. DetailsView выводит в две колонки названия полей и их значения, и изменить его структуру довольно сложно. Элемент управления FormView составляет исключение из общего правила. Это полностью итеративный элемент, предоставляющий вам полную свободу выбора пользовательского интерфейса. Однако в каждый момент времени в нем выводится только одна запись, и работает он как специализированная версия элемента управ-ления Repeater, выполняющая перебор полей строки данных. Элемент управления Repeater Repeater является связанным с данными элементом управления, который отображает информацию способом, определяемым разработчиком. Этот элемент применяет задан-ный шаблон ASP.NET к каждому элементу выводимого на экран списка. Собственного встроенного шаблона или средств определения стилей у него нет. Вся информация о форматировании и размещении элементов должна быть явно задана с использова-нием тэгов HTML и классов ASP.NET. Интерфейс программирования элемента управления Repeater Класс Repeater является производным от Control и действует как контейнер имен, реализуя маркерный интерфейс INamingContainer. Свойства этого элемента управ-ления, не считая тех, что унаследованы им от базового класса Control, перечислены в табл. 11-2.
Итеративные элементы управления ASP.NET Глава 11 395 Табл. 11-2. Свойства элемента управления Repeater Свойство Описание AlternatingItemTemplate Шаблон, используемый для рендеринга четных элементов DataMember Таблица источника данных, связанная с элементом управления DataSource Источник данных типа IEnumerable для заполнения списка DataSourceID Имя элемента управления, представляющего источник данных для заполнения списка FooterTemplate Шаблон для рендеринга нижнего колонтитула HeaderTemplate Шаблон для рендеринга верхнего колонтитула Items Объект RepeaterItemCollection - коллекция объектов RepeaterItem, каждый из которых представляет одну строку данных ItemTemplate Шаблон для рендеринга элементов данных SeparatorTemplate Шаблон для рендеринга разделителей элементов Как видите, большая часть этих свойств служит для определения шаблонов, на осно-ве которых формируется пользовательский интерфейс элемента управления. Свойство Items содержит список дочерних элементов, связанных с каждой отображаемой стро-кой данных. Элемент управления Repeater заполняет указанный список объектами данных, содержащимися в связанном с ним источнике данных. Каждому объекту из этого источника, ставится в соответствие объект RepeaterItem, который и добавляется в коллекцию. Класс RepeaterItem позволяет представить любую из составляющих элемента управ-ления (верхний или нижний колонтитул, разделитель), его применение не ограничено только представлением элементов данных. Интерфейс программирования RepeaterItem составляют свойства, перечисленные в табл. 11-3. Табл. 11-3. Свойства элемента RepeaterItem Свойство Описание DataItem Возвращает объект данных из связанного источника данных, соот-ветствующий отображаемому элементу. У элементов RepeaterItem, не связанных с данными, таких как нижний и верхний колонтитулы, это свойство содержит значение null ItemIndex Возвращает 0-базированный индекс выводимого элемента ItemType Возвращает значение перечислимого типа ListItemType, определяю-щее тип выводимого элемента. Допустимы значения Header, Footer, Item, AlternatingItem и Separator Заметьте, что перечисление ListItemType используется многими итеративными и списочными элементами управления и не является типом, специфическим для эле-мента управления Repeater. Ниже приведено его определение - как видите, не все значения имеют отношение к объектам RepeaterItem: public enum ListItemType { Header, Footer, Item, AlternatingItem, SelectedItem, EditItem,
396 Часть III Элементы управления ASP.NET Separator, Pager } Важно отметить, что свойство DataItem класса RepeaterItem для элементов, свя-занных с данными, устанавливается не всегда. Если обратиться к нему до того, как элемент будет действительно связан с данными, это свойство вернет null. Связывание элемента управления Repeater с данными Подобно любому другому элементу управления ASP.NET, связанному с данными, Repeater генерирует пользовательский интерфейс только в случае, когда вызывается его метод DataBind, а в ASP.NET 2.0 еще и тогда, когда он связан с источником дан-ных. DataBind - единственный собственный метод интерфейса класса Repeater, если не считать тех, которые он наследует от родительских классов. Вызов данного метода заставляет элемент управления перестроить свою иерархию элементов. Примечание Как и все остальные связанные с данными элементы управления из преды-дущих версий ASP.NET, Repeater поддерживает связывание с использованием элементов управления, представляющих источники данных. Иными словами, Repeater не содержит специализированного кода для обновления или удаления записей в источнике данных. Вызов метода DataBind необходим для генерирования HTML-кода элемента управления и записи его в выходной поток. Помимо событий, определенных в ро-дительском классе, элемент управления Repeater генерирует три дополнительных события: ItemCreated, ItemCommand и ItemDataBound (табл. 11-4). Заметьте, что собы-тие DataBinding, определенное в родительском классе Control, генерируется до всех событий, перечисленных в табл. 11-4. Табл. 11-4. События элемента управления Repeater Событие Когда генерируется ItemCommand Пользователь щелкнул кнопку в элементе управления Repeater ItemCreated Элемент управления Repeater создан. В это время свойство DataItem всегда возвращает значение null ItemDataBound Элемент управления Repeater связан с данными. Теперь свойство DataItem возвращает непустое значение, как и свойства, представля-ющие элементы, связанные с данными Обработчикам событий ItemCreated и ItemDataBound передается ссылка на со-зданный объект RepeaterItem. Любое вносимое в этот объект изменение отражается на итоговом выводе элемента управления Repeater. Как элемент управления Repeater формирует свой вывод Выходные данные, генерируемее элементом управления Repeater, формируются с ис-пользованием нескольких шаблонов. Соответствующая логика содержится в переопре-деляемом методе CreateControlHierarchy. Если вы хотите изменить поведение элемента управления Repeater, создать производный от него класс, иначе осуществляющий рендеринг, именно этот метод вам нужно будет переопределить. Метод CreateControlHierarchy подключается к источнику данных и перебирает элементы связанной коллекции. Процесс формирования вывода элемента управления Repeater иллюстрирует следующий псевдокод: //Создание заголовка if (headerTemplate != null) CreateItem(ListItemType.Header);
Итеративные элементы управления ASP.NET Глава 11 397 int _counter = 0; RepeaterItem _repItem; //Создание четных и нечетных элементов foreach(object _dataItem in DataSource) { if (useSeparator && _counter > 0) CreateItem(ListItemType.Separator); if (_counter % 2) _repItem = CreateItem(_counter, ListItemType.Item, _dataItem); else _repItem = CreateItem(_counter, ListItemType.AlternatingItem, _dataItem); Items.Add(_repItem); _counter ++; }//Создание нижнего колонтитула if (footerTemplate != null) CreateItem(ListItemType.Footer); Сначала Repeater применяет шаблон верхнего колонтитула, если таковой имеется. Затем он перебирает в цикле элементы коллекции связанных объектов и применяет шаблоны ItemTemplate и AlternatingItemTemplate. Элементы должны чередоваться с разделителями, если таковые заданы. Наконец, по окончании цикла применяется шаблон нижнего колонтитула. Процедура CreateItem создает новый объект RepeaterItem и инициализирует его значениями по умолчанию. Затем генерируется событие ItemCreated и объект добав-ляется в коллекцию Items. В заключение происходит связывание данных с элементом и генерируется событие ItemDataBound. Шаблоны элемента управления Repeater Шаблон - это блок серверных элементов управления, литералов и фрагментов HTML-текста, используемый как монолитный элемент. Можно представлять его себе как динамически генерируемый элемент управления ASP.NET с составным интерфейсом, определяемым либо декларативно (с использованием клиентских и серверных тэгов), либо программно (путем написания специализированного класса). Элемент управления Repeater как минимум должен предоставлять шаблон Item-Template. Остальные шаблоны можно не задавать; однако если не указать шаблон ItemTemplate, вывод Repeater будет пустым. Пример шаблона элемента В большинстве случаев шаблон определяют декларативно. В следующем коде пока-зано, как генерируется вывод, напоминающий DataGrid: <asp:Repeater ID="Repeater1" runat="server" DataSourceID="SqlDataSource1"> <HeaderTemplate> <table> <thead> <td> <b>ID</b> </td> <td> <b>First Name</b> </td> <td> <b>Last Name</b> </td> </thead> </HeaderTemplate>
398 Часть III Элементы управления ASP.NET <ItemTemplate> <tr> <td bgcolor="white"> <%# Eval("EmployeeID") %></td> <td bgcolor="white"> <%# Eval("FirstName")%></td> <td bgcolor="white"> <%# Eval("LastName") %></td> </tr> </ItemTemplate> <AlternatingItemTemplate> <tr> <td bgcolor="#eeeeee"> <%# Eval("EmployeeID") %></td> <td bgcolor="#eeeeee"> <%# Eval("FirstName")%></td> <td bgcolor="#eeeeee"> <%# Eval("LastName") %></td> </tr> </AlternatingItemTemplate> <FooterTemplate> </table> </FooterTemplate> </asp:Repeater> На рис. 11-1 вы видите, как выглядит вывод такого элемента управления Repeater. Этот элемент по функциональности может заменить DataGrid, хотя обратное неверно. Рис. 11-1. Вывод элемента управления Repeater В данном случае источником данных элемента управления Repeater является эле-мент управления SqlDataSource: <asp:SqlDataSource ID="SqlDataSource1" runat="server" ConnectionString="<%$ ConnectionStrings:LocalNWind %>" SelectCommand="SELECT employeeid, firstname, lastname FROM employees"> </asp:SqlDataSource> Итоговый вывод Repeater - это объединение HTML-кода, генерируемого каждым из составляющих его шаблонов. Как показывает приведенный выше пример, элемент управления Repeater позволяет распределить HTML-тэг между несколькими шаб-лонами. Например, тэг <table> открывается в верхнем колонтитуле, а закрывается в нижнем.
Итеративные элементы управления ASP.NET Глава 11 399 Интерфейс ITemplate Класс Repeater взаимодействует с шаблоном посредством его интерфейса ITemplate, а это значит, что свойству, представляющему шаблон, можно присвоить экземпляр только такого класса, который реализует данный интерфейс. Но несмотря на это вам позволено задавать шаблоны, используя серверные и HTML-тэги. Как это возможно? При компиляции страницы каждый фрагмент, определяемый в шаблонном блоке, компилируется во внутренний объект, реализующий интерфейс ITemplate. Этот ин-терфейс состоит из единственного метода - InstantiateIn: void InstantiateIn(Control container); Данный метод создает все дочерние элементы управления, которые используются в шаблоне, и добавляет их в коллекцию Controls контейнера, а также, если требует-ся, связывает их с источником данных, включая в их состав обработчики события DataBinding. Загрузка шаблонов из пользовательских элементов управления Существует два способа программной установки свойств, представляющих шаблоны. Простейший из них заключается в применении метода LoadTemplate класса Page. У это-го метода всего один аргумент - имя файла пользовательского элемента управления с расширением .ascx: Repeater1.ItemTemplate = Page.LoadTemplate("item_template.ascx"); Содержащийся в файле шаблон может быть написан на любом из языков .NET, не обязательно на том, который задан для страницы. Метод LoadTemplate может ис-пользоваться для загрузки кода разметки любого свойства, представляющего шаблон, включая HeaderTemplate и FooterTemplate. Ниже показано, как можно написать элемент управления .ascx, имитирующий поведение элементов данных, представленных на рис. 11-1. <%@Control Language="C#" %> <tr> <td bgcolor="white"> <%# Eval("EmployeeID")%> </td> <td bgcolor="white"> <%# Eval("FirstName") %> </td> <td bgcolor="white"> <%# Eval("LastName") %> </td> </tr> Заметьте, что в ASP.NET 2.0 использование функции Eval очень упрощает коди-рование. Продемонстрированный синтаксис не будет работать в ASP.NET 1.x, где придется применить несколько иной подход: <%# DataBinder.Eval((RepeaterItem) Container.DataItem, "LastName") %> Приведение к типу RepeaterItem необходимо в файле пользовательского элемента уп-равления, но его не обязательно выполнять, когда код содержится в файле страницы. Программное создание шаблонов Если свойство, представляющее шаблон, устанавливается программным путем, необ хо-дим класс, реализующий интерфейс ITemplate. Присвоение свойству экземпляра этого 
400 Часть III Элементы управления ASP.NET класса эквивалентно загрузке шаблона из файла .ascx с помощью метода LoadTemplate. Вот пример такого класса: public class MyItemTemplate : ITemplate { public void InstantiateIn(Control container) { //Создаем элемент <tr> TableRow row = new TableRow(); //Добавляем <td> employeeID TableCell empID = new TableCell(); empID.DataBinding += new EventHandler(BindEmpID); row.Cells.Add(_empID); //Добавляем <td> lastname TableCell lname = new TableCell(); lname.DataBinding += new EventHandler(BindLastName); row.Cells.Add(_lname); //Добавляем <td> firstname TableCell fname = new TableCell(); fname.DataBinding += new EventHandler(BindFirstName); row.Cells.Add(fname); //Добавляем строку в контейнер container.Controls.Add(row); } public void BindEmpID(object sender, EventArgs e) { TableCell cell = (TableCell) sender; RepeaterItem container = (RepeaterItem) cell.NamingContainer; object data = DataBinder.GetPropertyValue(container.DataItem, "EmployeeID"); cell.Text = data.ToString(); } public void BindLastName(object sender, EventArgs e) { TableCell cell = (TableCell) sender; RepeaterItem container = (RepeaterItem) cell.NamingContainer; object data = DataBinder.GetPropertyValue(container.DataItem, "LastName"); cell.Text = data.ToString(); } public void BindFirstName(object sender, EventArgs e) { TableCell cell = (TableCell) sender; RepeaterItem container = (RepeaterItem) cell.NamingContainer; object data = DataBinder.GetPropertyValue(container.DataItem, "FirstName"); cell.Text = data.ToString(); } }
Итеративные элементы управления ASP.NET Глава 11 401 Заметьте, что тип элемента данных зависит от источника данных, связанного с эле-ментом управления Repeater. Аргумент sender в приведенном выше коде указывает на элемент управления, связываемый с данными, - TableCell. Свойство NamingContainer служит для получения ссылки на родительский объект Repeater. В данном случае Repeater является контейнером имен ячеек. Примечание В ASP.NET 2.0 элементы управления можно связывать с данными либо посредством элемента управления, представляющего источник данных, либо через объект, реализующий интерфейс IEnumerable. Данный интерфейс, однако, содержит только методы для перебора членов коллекции, а методов для чтения значений в его составе нет. Как итеративные элементы управления могут работать с такими разными перечис-лимыми объектами, как DataTable, DataSet, DataView и пользовательские коллекции? Для извлечения значения, хранящегося в заданном свойстве определенного объекта, можно пользоваться методом DataBinder.GetPropertyValue (см. приведенный выше код). Однако для этого свойство должно быть открытым и должно иметь аксессор get. Когда свойство реализовано в виде поля, данный метод к нему неприменим. Работа с элементом управления Repeater Мы выяснили, что выводом элемента управления Repeater является HTML-код, полу-ченный путем повторения заданных шаблонов ASP.NET для каждой строки источника данных. Оформить этот вывод вы можете по собственному вкусу: в виде HTML-таб-лицы или сплошного текста. Элемент управления Repeater не предоставляет никаких специальных средств форматирования или стилевого оформления вывода, так что все необходимое для его оформления вам придется закодировать самостоятельно. Давайте разработаем страницу, выводящую информацию о клиентах, которая хра-нится в базе данных Northwind Microsoft SQL Server. Вывести такую информацию с помощью табличного элемента управления - сущий пустяк, но в этом случае поль-зовательский интерфейс будет определяться табличным элементом управления. Мы же в этом примере хотим определить пользовательский интерфейс по своему вкусу, а такую возможность предоставляет только элемент управления Repeater, которым мы и воспользуемся. Наша задача - вывести минимальный набор сведений о кли-ентах и напротив каждого клиента поместить флажок. При обновлении страницы все отмеченные пользователем элементы будут выводиться другим цветом и с более подробной информацией. Ключевым компонентом элемента управления Repeater, определяющим, как будут выводиться данные, является шаблон элемента. Кроме того, нашему объекту Repeater потребуется шаблон верхнего колонтитула, обычно используемый для описания дан-ных, которые выводятся ниже. Шаблон разделителя удобно использовать для визу-ального отделения элементов друг от друга. Особенно важно (с точки зрения профес-сионального оформления) задать его в том случае, когда определены разные шаблоны четных и нечетных элементов. В данном примере разделителем будет служить просто горизонтальная линия, созданная с помощью элемента <hr>. В тех случаях, когда нужно выводить промежуточные итоги, разделитель может быть более сложным. Создание страницы Страница, которую мы намерены создать, показана на рис. 11-2, а ее код приведен в следующем листинге. <asp:repeater runat="server" id="Repeater1"> <HeaderTemplate> <div style="background-color:yellow;">Customers</div> </HeaderTemplate>
402 Часть III Элементы управления ASP.NET <ItemTemplate> <span style="display:none;"> <%# m_checkBox = (CheckBox) FindCheckBox(Container) %> </span> <asp:checkbox runat="server" id="ExpandButton" /> <%# ShowHeader(Container.DataItem) %><br> <%# ShowInfoBar(Container.DataItem) %> <%# ShowAddressBar(Container.DataItem) %> </ItemTemplate> <SeparatorTemplate> <hr style="border:dashed 1px black;height:1px;" /> </SeparatorTemplate> </asp:repeater> Рис. 11-2. Информация из базы данных Northwind, выведенная с помощью элемента управления Repeater Шаблон верхнего колонтитула применяется только однажды, тогда как разделитель выводится перед каждым элементом за исключением первого. Мы изменили задавае-мый по умолчанию стиль элемента <hr>, чтобы ввести тончайшую линию - толщиной всего в один пиксел. Основой страницы является раздел <ItemTemplate>. Рассмотрим его подробнее. Создание шаблона элемента Шаблон элемента начинается со скрытого тэга <span>, о назначении которого речь пойдет чуть ниже. Далее следует флажок и три дополнительные функции, вызываемые из блоков кода, связанных с данными, <%# . %>. Как видно на рис. 11-2, для каждого отмеченного клиента выводится его адрес. При этом отмеченные записи - синие, хотя на черно-белой иллюстрации этого и не видно. Методы ShowHeader, ShowInfoBar и ShowAddressBar выводят блоки информации, составляющие форму клиента. Так, ShowHeader полужирным шрифтом выводит строку, 
Итеративные элементы управления ASP.NET Глава 11 403 содержащую код и имя клиента, ShowInfoBar генерирует курсивную строку с контак-тной информацией, а ShowAddressBar выводит адрес клиента и другие личные данные, такие как номер телефона. Все эти функции принимают элемент данных и возвращают HTML-строку, помещаемую в выходной поток страницы. protected string ShowHeader(object dataItem) { //Определяем, какой цвет применить string color = (m_checkBox.Checked ? "blue" : "black"); //Задаем шаблон для HTML-строки string output = "<b style='color:{0};'>{1}&nbsp;-&nbsp;{2}</b>"; //Заполняем подстановочные параметры output = String.Format(output, color, DataBinder.GetPropertyValue(dataItem, "customerid"), DataBinder.GetPropertyValue(dataItem, "companyname")); //Возвращаем получившуюся строку return output; }Доступ к дочерним элементам управления Для каждого элемента создается собственная копия флажка, и хотя все флажки имеют один и тот же идентификатор, они принадлежат к разным контейнерам именования. Чтобы получить нужный экземпляр флажка, необходимо найти ссылку на соответс-твующий контейнер. Именно это и делает метод FindCheckBox. А глобальная перемен-ная m_checkBox служит просто для кэширования ссылки на флажок, чтобы ею могли пользоваться все методы одного и того же шаблона. <ItemTemplate> <span style="display:none;"> <%# m_checkBox = (CheckBox) FindCheckBox(Container) %> </span> </ItemTemplate> Поскольку тэг <span>, в котором устанавливается переменная m_checkBox, неви-дим, никакой дополнительный вывод не генерируется. private CheckBox FindCheckBox(Control container) { //Извлекаем экземпляр флажка, относящийся к данному элементу CheckBox ctl = (CheckBox) container.FindControl("ExpandButton"); if (ctl == null) return null; //Обновляем состояние элемента ctl.Checked = (Page.Request[ctl.UniqueID]=="on"); //Возвращаем экземпляр элемента return ctl; } Как вы помните, нам важно знать, установлен ли флажок. Наиболее надежный способ это определить - прочитать значение прямо из объекта Repeater. Для этого нужно знать уникальный идентификатор флажка.
404 Часть III Элементы управления ASP.NET Обратите внимание на то, что вызов метода FindControl класса Page не сработает, поскольку этот метод анализирует только поддерево контейнера именования. Обработка событий возврата формы Если шаблон элемента содержит кнопку или другой элемент управления, который может выполнять возврат формы, как тогда осуществляется перехват события возвра-та? В этом нам поможет событие ItemCommand. Рассмотрим слегка переработанную версию приведенного выше примера: <ItemTemplate> <asp:Button runat="server" id="ExpandButton" CommandName="Expand" /> <%# ShowHeader(Container.DataItem) %><br> <asp:panel runat="server" id="ExtraInfo" visible="false"> <%# ShowInfoBar(Container.DataItem) %> <%# ShowAddressBar(Container.DataItem) %> </asp:panel> </ItemTemplate> Кнопке ExpandButton присвоен атрибут CommandName, чтобы отличать ее от дру-гих кнопок того же шаблона. Информация, выводимая по требованию, такая как адрес, первоначально скрыта на невидимой панели. Когда пользователь щелкает кнопку, выполняется возврат формы и запускается обработчик события ItemCommand: void Repeater1_ItemCommand(object source, RepeaterCommandEventArgs e) { Panel p = (Panel) e.Item.FindControl("ExtraInfo"); p.Visible = !p.Visible; } Метод FindControl помогает получить ссылку на экземпляр класса Panel, где был выполнен щелчок. Найдя его, мы переключаем свойство Visible, чем достигается эф-фект развертывания панели с дополнительной информацией (рис. 11-3). Рис. 11-3. Отображение ранее скрытой дополнительной информации
Итеративные элементы управления ASP.NET Глава 11 405 Элемент управления DataList DataList - это связанный с данными элемент управления, область применения кото-рого начинается там, где оканчиваются возможности элемента управления Repeater, и распространяется до области применения табличных элементов управления. В от-дельных очень простых случаях можно даже взять некий код, в котором используется элемент управления Repeater, заменить последний элементом управления DataList и не заметить разницы. Однако обратившись к программному интерфейсу DataList, вы найдете его гораздо более приближенным к интерфейсу табличного элемента управ-ления, чем к минималистичному интерфейсу Repeater. Несмотря на сходство с элементом управления Repeater, DataList обладает важны-ми особенностями и уникальным набором возможностей, благодаря которым на нем однозначно останавливается выбор в определенных ситуациях. Большая часть этих возможностей, отличающих DataList от Repeater, лежит в области его графического представления. Например, данный элемент поддерживает направленный рендеринг, то есть позволяет размещать элементы по горизонтали и по вертикали, когда нужно сформировать определенное число столбцов. Кроме того, DataList подобно элементу управления DataGrid позволяет извлечь ключевое значение, связанное с текущей строкой данных, и имеет встроенную подде-ржку выделения и редактирования данных. Наконец, DataList поддерживает больше шаблонов, чем Repeater, и может генерировать больше событий. А вот способ связы-вания с данными и общее поведение DataList такие же, как у Repeater. Интерфейс программирования элемента управления DataList Элемент управления DataList "умнее", чем Repeater, и работает, основываясь на оп-ределенных предположениях относительно ожидаемых результатов. Для вас как для программиста в этом есть положительные и отрицательные моменты. С одной стороны, в некоторых случаях вам придется писать меньше кода, но с другой стороны, чтобы управлять этим элементом управления, необходимо знать все нюансы его функцио-нирования. Например, DataList рассчитывает на то, что ни один HTML-тег не будет разделен между несколькими шаблонами. Сделать так несложно, но в результате может получиться плохо организованный или вообще неожиданный HTML-вывод. Кроме того, по умолчанию DataList выводит данные в виде HTML-таблицы, а это значит, что вам не придется возиться с отдельными элементами <table> или <td>. Но в то же время, если такое поведение вас не устраивает, DataList задает вам лишнюю работу. Элемент управления DataList объявляется так: public class DataList : BaseDataList, INamingContainer, IRepeatInfoUser Он наследует класс BaseDataList и реализует интерфейсы INamingContainer и IRepeatInfoUser. Последний определяет свойства и методы, которые должны быть реализованы любым списочным элементом управления. Этот интерфейс поддержи-вается также элементами управления CheckBoxList и RadioButtonList. Свойства элемента управления DataList В табл. 11-5 перечислены свойства элемента управления DataList, за исключением тех, которые унаследованы им от классов Control и WebControl. Свойства ShowFooter и ShowHeader по умолчанию установлены в true, но их значе-ния учитываются только в том случае, когда свойства FooterTemplate и HeaderTemplate (соответственно) не содержат null.
406 Часть III Элементы управления ASP.NET Табл. 11-5. Свойства элемента управления DataList Свойство Доступ Описание AlternatingItemStyle Чтение Стилевые свойства нечетных строк AlternatingItemTemplate Чтение/запись Шаблон нечетных строк CellPadding Чтение/запись Расстояние (в пикселах) между границей ячейки и текстом CellSpacing Чтение/запись Расстояние (в пикселах) между двумя последова-тельными ячейками по горизонтали и по вертикали Controls Чтение Коллекция всех дочерних элементов управления DataKeyField Чтение/запись Ключевое поле связанного источника данных DataKeys Чтение Коллекция ключевых значений отображаемых записей. Ключевой столбец указан в свойстве DataKeyField DataMember Чтение/запись Строка, идентифицирующая таблицу в многотаб-личном источнике данных, с которой связан эле-мент управления. Данное свойство используется совместно с DataSource. Если последнему присвоен объект DataSet, то DataMember содержит имя дочер-ней таблицы, предназначенной для связывания DataSource Чтение/запись Объект, представляющий источник данных для заполнения списка DataSourceID Чтение/запись Имя элемента управления, представляющего источ-ник данных для заполнения списка EditItemIndex Чтение/запись 0-базированный индекс элемента, выбранного для редактирования EditItemStyle Чтение Стилевые свойства редактируемого элемента EditItemTemplate Чтение/запись Шаблон элемента, выбранного для редактирования ExtractTemplateRows Чтение/запись Флаг, указывающий, что DataList должен извлечь строки из HTML-таблиц, содержащихся в шабло-нах. Эти строки затем соединяются для создания единой HTML-таблицы, вмещающей все данные. По умолчанию имеет значение false FooterStyle Чтение Стилевые свойства нижнего колонтитула FooterTemplate Чтение/запись Шаблон нижнего колонтитула GridLines Чтение/запись Флаг, указывающий, следует ли рисовать границы ячеек. Если свойство RepeatLayout имеет значение RepeatLayout.Flow, то значение свойства GridLines игнорируется HeaderStyle Чтение Стилевые свойства верхнего колонтитула HeaderTemplate Чтение/запись Шаблон верхнего колонтитула HorizontalAlign Чтение/запись Выравнивание текста в списке по горизонтали Items Чтение Коллекция элементов, отображаемых в данный момент ItemStyle Чтение Стилевые свойства элементов списка ItemTemplate Чтение/запись Шаблон элементов списка RepeatColumns Чтение/запись Количество выводимых столбцов RepeatDirection Чтение/запись Значение, указывающие, как должны выводиться элементы списка: по горизонтали или по вертикали RepeatLayout Чтение/запись Значение, указывающие, как будет осуществляться рендеринг элемента управления: в виде автомати-чески создаваемой таблицы или потока. В послед-нем случае текст выводится в свободной форме
Итеративные элементы управления ASP.NET Глава 11 407 Свойство Доступ Описание SelectedIndex Чтение/запись Индекс выбранного пользователем элемента SelectedItem Чтение Шаблон выбранного пользователем элемента SelectedItemStyle Чтение Стилевые свойства выбранного пользователем эле-мента SelectedItemTemplate Чтение/запись Шаблон выбранного пользователем элемента SeparatorStyle Чтение Стилевые свойства разделителя последовательных элементов SeparatorTemplate Чтение/запись Шаблон разделителя последовательных элементов ShowFooter Чтение/запись Значение, указывающее, должен ли выводиться нижний колонтитул ShowHeader Чтение/запись Значение, указывающее, должен ли выводиться верхний колонтитул Процесс связывания элемента управления DataList с данными практически иден-тичен аналогичному процессу элемента управления Repeater, и генерирование им вывода происходит по тем же правилам. Однако интерфейс программирования эле-мента управления DataList богаче и позволяет управлять двумя дополнительными состояниями элемента: выбран и редактируется. Выбранный пользователем элемент идентифицируется свойствами SelectedIndex и SelectedItem properties, а редактируе-мый - свойством EditItemIndex. События элемента управления DataList В табл. 11-6 перечислены события, генерируемые элементом управления DataList, за исключением тех, которые он унаследовал от базовых классов Control и WebControl (например, Load и DataBinding). Табл. 11-6. События, генерируемые элементом управления DataList Событие Когда генерируется CancelCommand Для отображаемого элемента выполнен щелчок кнопки с именем команды Cancel DeleteCommand Для отображаемого элемента выполнен щелчок кнопки с именем команды Delete EditCommand Для отображаемого элемента выполнен щелчок кнопки с именем команды Edit ItemCommand В элементе управления пользователь щелкнул кнопку ItemCreated Элемент управления DataList создан ItemDataBound Элемент управления DataList связан с данными SelectedIndexChanged В элементе управления DataList выбран новый элемент UpdateCommand Для отображаемого элемента выполнен щелчок кнопки с именем команды Update Все события за исключением ItemCreated и ItemDataBound относятся к выполнению той или иной команды. Главным командным событием является ItemCommand, которое генерируется перед более специализированными событиями, такими как EditCommand или DeleteCommand. Можно считать командным и событие SelectedIndexChanged, уве-домляющее о том, что пользователь щелкнул кнопку с зарезервированным именем команды Select. Табл. 11-5. (окончание)
408 Часть III Элементы управления ASP.NET Примечание Командные кнопки не обязательно должны быть связаны с конкретными элементами. Любой кнопке, входящей в состав пользовательского интерфейса элемента управления DataList, можно назначить желаемое имя команды, такое как Edit или Delete. Конечно, если такая кнопка не связана с конкретным элементом данных, приложение должно содержать логику для выбора необходимого действия. Элемент управления DataList обычно сам генерирует командные кнопки Update и Cancel, когда конкретный элемент списка переводится в режим редактирования. За-метьте, что класс DataList предоставляет константы для идентификации имен команд, переданных в качестве параметров. Этими константами являются CancelCommandName, DeleteCommandName, EditCommandName, SelectCommandName и UpdateCommandName. Возможности форматирования Как уже упоминалось, элемент управления Repeater является итератором общего на-значения, и вся его работа заключается в генерировании вывода на основе заданных шаблонов, без применения каких-либо правил форматирования. В отличие от него элемент управления DataList позволяет управлять рендерингом списка. В частности, он может вывести элементы, определяемые шаблонами, в виде таблицы. Такое его пове-дение дает возможность формировать более сложный и дружественный для пользова-теля интерфейс, написав совсем немного кода. Используемыми при этом ключевыми свойствами являются RepeatColumns, RepeatDirection и RepeatLayout. Они позволяют указать количество столбцов и направление вывода элементов данных. Табличный и потоковый вывод Свойство RepeatLayout принимает значения перечислимого типа RepeatLayout: Table (по умолчанию) и Flow. Когда оно имеет значение Flow, элемент управления DataList заключает шаблонный элемент в тэг <span>, а затем автоматически добавляет тэг <br>, если элементы выводятся по вертикали. В случае же горизонтального вывода текст просто добавляется в конец HTML-строки. Далее приведен пример вывода элемента управления для вертикального рендеринга с установкой Flow. <span id="DataList1"> <span> шаблон верхнего колонтитула </span> <br> <span> шаблон элемента </span> <br> <span> шаблон разделителя </span> <span> шаблон нижнего колонтитула </span> </span> Режим Table избавляет вас от необходимости HTML-кодирования табличной раз-метки. Вот как выглядит вывод элемента управления DataList в этом режиме: <table id="DataList1"> <tr> <td> шаблон верхнего колонтитула </td> </tr> <tr> <td> шаблон элемента </td> </tr> <tr> <td> шаблон разделителя </td> </tr> <tr>
Итеративные элементы управления ASP.NET Глава 11 409 <td> шаблон нижнего колонтитула </td> </tr> </table> При горизонтальном рендеринге раскладка таблицы получается несколько иной. Таблица состоит всего из трех строк: верхнего колонтитула, всех элементов данных, выведенных в одной строке, и нижнего колонтитула: <table id="DataList1"> <tr> <td> шаблон верхнего колонтитула </td> </tr> <tr> <td> шаблон элемента </td> <td> шаблон разделителя </td> </tr> <tr> <td> шаблон нижнего колонтитула </td> </tr> </table> Когда свойство ExtractTemplateRows установлено в true, элемент управления DataList извлекает строки таблицы из всех объявленных шаблонов и объединяет их в одну таб-лицу. Однако для того чтобы использовать это свойство, необходимо предварительно выполнить кое-какую работу. В частности, для каждого шаблона, который вы хотите использовать для вывода данных, нужно задать правильно структурированный эле-мент управления Table (тэг <asp:Table>). Если определить таблицу, используя HTML-тэг <table> или элемент управления ASP.NET HtmlTable (<table runat="server">), будет выброшено исключение. Учтите также, что все шаблоны должны быть созданы с использованием тэга Table и что выведены будут только строки таблиц. Весь осталь-ной контент шаблонов элемент управления DataList проигнорирует. Следующий код показывает, как определяется таблица в шаблоне элемента. <ItemTemplate> <asp:table runat="server"> <asp:tablerow runat="server"> <asp:tablecell runat="server"> <%# Eval("Name") %> </asp:tablecell> </asp:tablerow> </asp:table> </ItemTemplate> Свойство ExtractTemplateRows действительно полезно только в том случае, когда создается сложная структура, объединяющая таблицы с разными шаблонами. Для управления количеством строк и столбцов, которые займет ячейка объединенных данных, можно пользоваться свойствами ColumnSpan и RowSpan. Примечание Когда свойство ExtractTemplateRows установлено в true, свойства RepeatColumns, RepeatDirection и RepeatLayout игнорируются и не влияют на вне-шний вид элемента управления DataList. Извлечение строк шаблона Давайте рассмотрим типичную ситуацию, в которой может быть полезным свойство ExtractTemplateRows. Допустим, что нам нужно создать шаблон, в котором информа-ция каждого элемента данных занимает несколько строк. Пусть речь идет о таблице 
410 Часть III Элементы управления ASP.NET клиентов и для каждого из клиентов требуется вывести в первой строке его иденти-фикатор и ФИО, а во второй - адрес. Можно сделать это с помощью элемента управления Repeater, определив таблицу в шаблоне верхнего колонтитула и добавив в нее несколько строк для каждого элемен-та. Это вполне удовлетворительное решение, если вы не возражаете против использо-вания элемента управления Repeater. Однако вспомним, что у элемента управления DataList имеются средства стилевого оформления и форматирования, и предположим, что мы хотим ими воспользоваться. Но DataList не позволяет помещать составляющие HTML-элементов в разные шаблоны, то есть вы не сможете поместить открывающийся тэг таблицы в верхний колонтитул, а закрывающийся - в нижний. Элемент управления требует, чтобы в каждом шаблоне использовалась своя табли-ца. Например, можно задать одну таблицу для верхнего колонтитула и еще одну для элементов. Если же вы установите свойство ExtractTemplateRows в true, эти таблицы будут объединены. <asp:datalist runat="server" id="list" extracttemplaterows="true"> <AlternatingItemStyle backcolor="palegoldenrod" /> <headerstyle backcolor="brown" forecolor="white" font-size="larger" font-bold="true" horizontalalign="center" /> <HeaderTemplate> <asp:table runat="server"> <asp:tablerow runat="server"> <asp:tablecell runat="server">Customer</asp:TableCell> <asp:tablecell runat="server">Contact</asp:TableCell> </asp:tablerow> </asp:table> </HeaderTemplate> <ItemTemplate> <asp:table runat="server"> <asp:tablerow runat="server" font-bold="true"> <asp:tablecell runat="server"> <%# Eval("CustomerID") %> </asp:tablecell> <asp:tablecell runat="server"> <%# Eval("ContactName") %> </asp:tablecell> </asp:tablerow> <asp:tablerow runat="server"> <asp:tablecell runat="server" columnspan="2"> <%# Eval("Address") + " -" + Eval("City") %> </asp:tablecell> </asp:tablerow> </asp:table> </ItemTemplate> </asp:datalist> Формируя результат, DataList объединит два объекта Table и удалит все элементы таблиц, не являющиеся экземплярами класса TableRow. Результирующая таблица будет содержать два столбца, и каждая ее запись будет выводиться в две строки, причем вторая строка будет состоять из одной ячейки шириной в два столбца. Элементу управления DataList достаточно интеллектуальности, чтобы согласовать визуальные установки исходных таблиц (например, стили нечетных элементов). Результат его работы в данном примере показан на рис. 11-4.
Итеративные элементы управления ASP.NET Глава 11 411 Рис. 11-4. Элемент управления DataList выводит таблицу, каждые две строки которой составляют одну запись Примечание Необходимостью слияния нескольких таблиц объясняется требование пользоваться только тэгом <asp:table> (который соответствует объекту Table). Элемент управления формирует в памяти объект результирующей таблицы, и если вы восполь-зуетесь тэгом <table> без атрибута runat, он будет выведен как есть, без какой-либо обработки. При использовании тэга <table> с установленным атрибутом runat будет создан другой объект ASP.NET (а именно, HtmlTable), и вы не получите ожидаемого результата, поскольку не будет произведена требуемая обработка. Вывод данных в несколько столбцов Вывод элемента управления DataList может быть отформатирован в виде нескольких столбцов - их количество задается в свойстве RepeatColumns. По умолчанию текст выводится в один столбец. Для случаев, когда их должно быть несколько, подходит и табличный, и потоковый рендеринг, но табличный, конечно, удобнее. <asp:datalist runat="server" id="list" RepeatColumns="3"> </asp:datalist> На рис. 11-5 показан результат установки свойства RepeatColumns и несколько ти-пичных дефектов. Рис. 11-5. Элемент управления DataList вывел данные в три столбца
412 Часть III Элементы управления ASP.NET Например, текст столбцов не выравнивается, и с этим ничего нельзя поделать. В таб-лице, где вы имеете полный контроль над параметрами, можно выровнять все ячейки строки так, чтобы они располагались на одном уровне. Шаблоны элемента управления DataList Помимо шаблонов, поддерживаемых элементом управления Repeater, элемент управле-ния DataList поддерживает два новых шаблона - SelectedItemTemplate и EditItemTemplate. Первый из них служит для управления содержимым и функционированием выделен-ного элемента, а второй связан с редактированием: он определяет пользовательский интерфейс, активизируемый на время редактирования элемента данных. Шаблон SelectedItemTemplate Процесс выделения активизируется, когда пользователь щелкает командную кнопку, помеченную именем команды Select. Если вы хотите что-либо сделать при выделении элемента, например вывести дополнительную информацию или элементы управления, то можете заменить используемый по умолчанию шаблон своим собственным. Шаблон для выделенного элемента задается в тэге <SelectedItemTemplate> . Для программного доступа к выделенному элементу используется свойство SelectedItem, которое возвра-щает соответствующий объект DataListItem. Для каждой выводимой строки коллекция DataKeys содержит значение столбца, определяемого свойством DataKeyField. При возврате страницы, происходящем вследствие выделения, генерируется со-бытие SelectedIndexChanged. Следующий код сначала извлекает ключи, идентифици-рующие выделенные элементы, а потом с их помощью получает дополнительные дан-ные, относящиеся к выделенной записи, которые он выводит на странице. Ключевые значения извлекаются из столбца, заданного в свойстве DataKeyField. //Получаем ключ выделенной записи и //запрашиваем дополнительные данные int key = (int) list.DataKeys[list.SelectedIndex]; GetChildData(key); Элементы могут быть выделены программно путем установки 0-базированного свойства SelectedIndex. Значение -1 указывает, что ни один элемент в данный момент не выделен. Заметьте, что значение свойства SelectedIndex сохраняется в состоянии представления и не меняется при последующих запросах той же страницы. Поэтому его следует сбрасывать при отображении новой страницы данных. Шаблон EditItemTemplate Свойство EditItemTemplate используется для управления содержимым элемента, вы-деленного для редактирования. Внешний вид этого элемента определяется значением свойства EditItemStyle, а в свойстве EditItemIndex находится 0-базированный индекс редактируемого элемента. Это значение, как и значение SelectedIndex, сохранятся в состоянии представления, поэтому при изменении набора данных, связанного с эле-ментом управления, его нужно сбрасывать. Когда пользователь щелкает кнопку, которой назначена команда Edit, элемент управления DataList генерирует событие EditCommand. Однако в режим редактирова-ния элемент управления входит только при условии, что обработчик этого события присваивает нужное значение свойству EditItemIndex (как и все остальные - 0-бази-рованному). Первоначально это свойство имеет значение -1. В режиме редактирова-ния DataList выводит для текущего элемента содержимое шаблона EditItemTemplate. Когда пользователь щелкает кнопку, предназначенную для сохранения изменений, генерируется событие UpdateCommand. В ответ вы должны извлечь текущие значения 
Итеративные элементы управления ASP.NET Глава 11 413 из полей ввода, пользуясь методом FindControl, и выполнить действия, необходимые для их сохранения. Работа с элементом управления DataList Рассмотрим подробно операции, выполняемые с использованием элемента управления DataList в некоторых типичных случаях. Как можно разрешить выделение элемента Для того чтобы обеспечить возможность выделения элемента, сначала нужно добавить командную кнопку, помеченную специальным ключевым словом Select. Эта кнопка может, конечно, иметь любое имя, но имя Select распознается элементом управления, и когда пользователь щелкает такую кнопку, выполняется определенный встроенный код. В частности, к выбранному элементу применяется стиль, заданный в свойстве SelectedItemStyle, и обновляется свойство SelectedIndex. Если по какой-либо причине вам требуется больший контроль над процессом выделения, вы можете присвоить элементу, на котором производится щелчок, произвольное имя команды и, когда бу-дет сгенерировано событие ItemCommand, перехватить его и обработать. При этом не забудьте установить свойство SelectedIndex, ведь теперь за вас никто этого не сделает. Представьте себе набор кнопок, каждая из которых представляет одну букву ал-фавита. Используя элемент управления DataList, можно создать такие кнопки для начальных букв названий компаний из столбца companyname таблицы Customers: SELECT DISTINCT substring(companyname, 1, 1) AS Initial FROM customers Вот как создаются такие кнопки: <asp:datalist runat="server" id="Picker" repeatlayout="flow" repeatdirection="horizontal" OnItemCommand="ItemCommand"> <ItemTemplate> <asp:button ID="Button1" runat="server" backcolor='<%# GetBackColor(Container.DataItem) %>' forecolor='<%# GetForeColor(Container.DataItem) %>' text='<%# Eval("Initial")%>' commandname='<%# Eval("Initial")%>' /> </ItemTemplate> </asp:datalist> Обработчик события ItemCommand использует надпись кнопки, которую щелкнул пользователь, для выполнения второго запроса, выбирающего записи обо всех клиен-тах, имена которых начинаются с данной буквы. Результат вы видите на рис. 11-6. Список клиентов выводится во втором элементе управления DataList: <asp:datalist runat="server" id="Customers" RepeatLayout="flow" DataKeyField="customerid"> <SelectedItemStyle backcolor="cyan" width="100%" /> <HeaderTemplate> <div><big><b><%# SetHeader() %></b></big></div> </HeaderTemplate> <ItemTemplate> <span id='<%# Eval("customerid") %>'> <span style="display:none;">
414 Часть III Элементы управления ASP.NET <%# m_checkBox = (CheckBox) FindCheckBox(Container) %> </span> <asp:checkbox runat="server" id="ExpandButton" /> <asp:linkbutton ID="Link1" runat="server" commandname="select" text='<%# Eval("companyname") %>' /> <br> </span> </ItemTemplate> <FooterTemplate> </div> </FooterTemplate> </asp:datalist> Рис. 11-6. Элемент управления DataList с выбираемыми элементами Точно такой же код мы уже анализировали, когда речь шла об элементе управления Repeater. В качестве кнопки с именем команды Select выводится ссылка (linkbutton) с названием компании. Когда пользователь ее щелкает, соответствующая строка окрашивается в голубой цвет: <SelectedItemStyle backcolor="cyan" width="100%" /> Теперь у нас есть полнофункциональная инфраструктура для обработки события вы-деления элемента. Для того чтобы можно было выполнять над выделяемым элементом то или иное действие, нужно зарегистрировать обработчик события SelectedIndexChanged и включить в него код, обновляющий пользовательский интерфейс. Поддержка разбивки на страницы Пользовательский интерфейс элемента управления DataList отличается от интерфейса табличных элементов управления тем, что имеет свободную форму. Одно только это делает его очень привлекательным для тех разработчиков, которым нужно созда-вать интерактивные отчеты, интерфейс которых не укладывается в жесткие рамки 
Итеративные элементы управления ASP.NET Глава 11 415 табличных элементов управления. Например, последние трудно заставить выводить информацию одного элемента данных в несколько строк, то есть вывод, представлен-ный на рис. 11-4, с их помощью получить непросто. Зато DataList позволяет сделать это без особого труда. Но и у него есть недостаток - он не поддерживает разбивки данных на страницы. Напомню, что разбивка данных на страницы - это популярный способ отображе-ния больших таблиц, при котором весь массив строк разбивается на блоки одинакового размера. Текущий блок отображается на странице, а для перехода к первому, послед-нему, следующему и предыдущему блокам выводятся специальные ссылки. Элемен-ты управления DataGrid и GridView имеют интегрированную панель листания, но у DataList ничего похожего нет. Поэтому функцию разбивки на страницы и листания, если вам таковая требуется, приходится реализовывать самостоятельно. Рендеринг страниц данных Для реализации разбивки на страницы данных элемента управления DataList нам потребуется переменная, объявленная на уровне страницы, где мы будем хранить индекс текущей страницы. Кроме того, нужно создать пару кнопок для перехода к следующей и предыдущей страницам. В приведенном ниже коде показано, как устанавливается индекс и обновляется содержимое элемента управления DataList в обработчиках событий этих кнопок. private void OnPreviousPage(object sender, EventArgs e) { CurrentPageIndex -= 1; RefreshPage(); }private void OnNextPage(object sender, EventArgs e) { CurrentPageIndex += 1; RefreshPage(); } Код корректирует индекс страницы (значение переменной CurrentPageIndex) и свя-зывает данные с элементом управления DataList. RefreshPage - это определенная для страницы вспомогательная функция, которая извлекает данные из базы данных или, что логичнее, из кэша сервера. Значение переменной CurrentPageIndex должно сохраняться между последовательными запросами, для чего используется состояние представления. Это необходимо в любом случае независимо от того, реализовали вы листание в файле кода страницы или написали специализированный элемент управления. В нашем примере метод RefreshPage работает с контейнером DataTable: private void RefreshPage() { DataTable data = GetData(); AdjustPageIndex(data.Rows.Count); CurrentPage.Text = (CurrentPageIndex +1).ToString(); list.DataSource = GetPage(data, CurrentPageIndex); list.DataBind(); }private DataTable GetData()
416 Часть III Элементы управления ASP.NET { //Пытаемся получить данные из кэша сеанса DataTable data = (DataTable) Session["MyData"]; //Если они недоступны, считываем их из базы данных if (data == null) data = LoadData(); return data; } Метод GetPage отвечает за получение подмножества строк, которые будут выво-диться на странице. Эти строки он возвращает в виде объекта DataTable, привязыва-емого к элементу управления DataList: private DataTable GetPage(DataTable dt, int pageIndex) { if (dt==null) { CurrentPageIndex = 0; dt = LoadData(); } int firstIndexInPage = (CurrentPageIndex*PageSize); DataRowCollection rows = dt.Rows; DataTable target = dt.Clone(); for (int i=0; i<PageSize; i++) { int index = i+firstIndexInPage; if (index < rows.Count) target.ImportRow(rows[i+firstIndexInPage]); else break; } return target; } Функция клонирует исходную таблицу данных и записывает в нее строки, соот-ветствующие заданному индексу страницы. Метод Clone создает новый пустой таблич-ный объект, имеющий такую же структуру, как и исходный объект. Метод ImportRow копирует строки из одного объекта DataTable в другой. Заметьте, что необходимо физическое копирование данных, а не просто копирование ссылок, поскольку объект ADO.NET не может одновременно содержаться в двух родительских объектах. В ASP.NET 2.0 есть возможность привязать элемент управления DataList к эле-менту управления ObjectDataSource и воспользоваться возможностями разбивки на страницы, реализованными в слое доступа к данным, если таковые имеются. Об объек-те ObjectDataSource я подробно рассказывал в главе 9 книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Заключение В этой главе мы проанализировали характеристики двух итеративных элементов управления, поддерживаемых ASP.NET, - Repeater и DataList. Они отличаются от списочных элементов управления наличием в них встроенной поддержки шаблонов и гибкостью механизма рендеринга. В то же время у итеративных и списочных элемен-тов управления много общего. И те и другие привязываются к данным и отображают список элементов.
Итеративные элементы управления ASP.NET Глава 11 417 Repeater - простейший из всех элементов управления данного типа, но и наибо-лее гибкий; табличные элементы управления имеют большой набор настраиваемых характеристик, однако не позволяют выйти за рамки традиционного табличного пред-ставления. DataList находится где-то посередине, но все-таки ближе к табличным элементам. Подобно элементу управления Repeater элемент управления DataList вы-водит данные, руководствуясь шаблонами ASP.NET. И подобно табличным элементам управления он поддерживает выбор и редактирование элементов; его внешний вид можно настраивать с использованием стилевых свойств. Элемент управления DataList обладает более широкими, по сравнению с Repeater, возможностями форматирования, и у него есть предопределенный интерфейс. Но в отличие от табличных элементов управления ему недостает встроенной функции разбивки данных на страницы, что, впрочем, не мешает разработчику реализовать ее самостоятельно. В этой главе неоднократно упоминались пользовательские элементы управления. О том, что они собой представляют, пойдет речь в следующей главе. Только факты В ASP.NET элементы управления, связанные с данными, называются итератив-ными, если они циклически перебирают элементы данных, применяя к каждому из них заданный вами шаблон. В ASP.NET определены два стандартных итеративных элемента управления: Repeater и DataList. Списочные элементы управления отличаются от итеративных тем, что они обла-дают стандартным пользовательским интерфейсом, который нельзя изменить. Элементы-представления, такие как GridView, DetailsView, FormView и DataGrid, работают итеративно, циклически применяя заданный шаблон. Однако мы относим их к категории списочных, поскольку возможности их настройки не позволяют выйти за рамки жестко заданного табличного представления. Элемент управления Repeater обладает базовыми итеративными возможностями, но не имеет собственного пользовательского интерфейса, а также свойств, пред-назначенных для настройки стилей и форматирования. Шаблоны для элемента управления Repeater можно задавать программно, загру-жая их из файлов пользовательских элементов управления или определяя классы, реализующие интерфейс ITemplate. Элемент управления DataList поддерживает направленный рендеринг, то есть позволяет выводить элементы управления по горизонтали или по вертикали, фор-мируя при этом заданное количество столбцов. DataList поддерживает концепцию "выделенного элемента" и позволяет редакти-ровать строки данных. 
Глава 12 Пользовательские элементы управления ASP.NET На высшем уровне абстракции существуют две возможности расширения компонен-тной базы ASP.NET: создание специализированных и пользовательских элементов управления. Специализированные (custom) элементы управления создаются путем наследования базовых классов (например, Control или WebControl) или расширения классов существующих элементов управления. Они предназначаются для размеще-ния на странице или в родительском элементе управления и действуют так же, как встроенные элементы управления, а создают их в тех случаях, когда нужно реализо-вать ту или иную недостающую функциональную возможность. Пользовательский интерфейс специализированных элементов управления формируется программным способом: ваш код либо выводит в выходной поток собственную HTML-разметку, либо объединяет несколько существующих элементов управления, создавая из них более сложный составной элемент. Подробнее о специализированных элементах управления я расскажу в следующих двух главах. Что касается пользовательских (user) элементов управления, то при их разработ-ке применяется противоположный подход. Вы соединяете существующие элементы управления, HTML-разметку и литеральный текст в особый составной компонент, обладающий собственным пользовательским интерфейсом и скрывающий информа-цию о своих дочерних элементах. Хотя пользовательские элементы управления трудно назвать в полной мере объектно-ориентированными, результатом разработки такого элемента все же является класс, созданный на базе класса UserControl из ASP.NET. Что такое пользовательский элемент управления Прежде всего, пользовательский элемент управления является Web-формой, создан-ной из серверных и клиентских элементов управления в сочетании с литеральным текстом, серверным кодом и клиентскими сценариями. Типичный пользовательский элемент управления имеет богатый пользовательский интерфейс и может предо-ставлять объектную модель для программного доступа к некоторым из инкапсули-рованных им компонентов. Подобно ActiveX-компонентам из Microsoft Visual Basic, пользовательский элемент управления защищает все свои составляющие элементы, делая их недоступными извне, если только в нем самом не реализован открытый интерфейс для доступа к отдельным членам этих элементов. На мой взгляд, наиболее емким и понятным определением пользовательского элемента управления является выражение "встраиваемая Web-форма". Такой эле-мент является чем-то вроде страницы ASP.NET, которую можно размещать на других страницах. Аналогия между пользовательскими элементами управления и страница-ми не случайна, в ранние времена ASP.NET 1.0 их даже называли pagelets (от англ. page - страница). Дело в том, что пользовательский элемент управления создается точно так же, как Web-форма. Сформировав раскладку страницы и написав ее код, вы 
Пользовательские элементы управления ASP.NET Глава 12 419 присваиваете ее файлу расширение .ascx, в результате чего он превращается в файл пользовательского элемента управления. После этого элемент можно включать в состав страниц ASP.NET. Странице новый элемент управления представляется са-мостоятельным монолитным компонентом, с которым можно работать так же, как с любым встроенным элементом управления. При этом создать пользовательский элемент управления обычно бывает гораздо проще, чем специализированный. Таким образом, пользовательские и специализированные элементы управления - это два разных вида элементов, создаваемых разработчиком в разных, редко пересе-кающихся ситуациях. Класс UserControl Пользовательские элементы управления - это серверные файлы с расширением .ascx, на которые можно ссылаться в страницах ASP.NET. Они предлагают разработчикам простой и эффективный способ повторного использования элементов пользователь-ского интерфейса (и связанного с ними кода), общих для ряда страниц или прило-жений. Подобно страницам и элементам управления ASP.NET, пользовательские элементы управления компилируются при первом к ним обращении и на их основе создаются сборки, которые кэшируются для ускорения обслуживания последующих запросов. Как и страницы, пользовательские элементы управления можно разрабаты-вать с использованием встроенного кода либо классов отделенного кода. (Встроенный код элемента управления, то есть находящийся в его основном файле, как обычно, заключается внутрь тэга <script runat="server">.) Однако в отличие от страниц пользовательские элементы управления не могут быть запрошены сами по себе из браузера (путем задания в адресной строке) или программным способом. При инсталляции ASP.NET IIS конфигурируется таким образом, чтобы он блокировал подобные запросы и не предоставлял ресурсы с рас-ширением .ascx. Таким образом, пользовательские элементы управления доступны только страницам .aspx и другим пользовательским элементам управления, которые в этих страницах содержатся. Примечание В своей простейшей форме пользовательские элементы управления могут рассматриваться как более гибкая альтернатива серверным включаемым файлам (serverside includes, SSI). Но в то же время считать их всего лишь более интеллектуальной формой SSI неправильно, поскольку они не являются просто фрагментами статической HTML-разметки, а имеют собственную объектную модель с открытым интерфейсом. Это настоящие объекты, и они могут использоваться так же, как любые другие серверные элементы управления ASP.NET. UserControl - это класс .NET Framework, вызываемый из страницы ASP.NET и осу-ществляющий загрузку элемента управления из .ascx-файла. Он наследует базовый абстрактный класс TemplateControl, реализующий основы функциональности классов Page и UserControl (чем и обуславливается структурное сходство Web-страниц и поль-зовательских элементов управления). public class UserControl : TemplateControl Класс UserControl реализует набор внутренних интерфейсов, среди которых наи-более важным является INamingContainer. Наличие этого интерфейса говорит о том, что элемент управления является контейнером именования для всех своих дочерних элементов управления, а значит, их идентификаторам назначается префикс - иден-тификатор родительского элемента управления. Данный класс имеет три дополнительных метода, которых нет у класса Control: LoadControl, LoadTemplate и ParseControl. Первый из них загружает из внешнего файла 
420 Часть III Элементы управления ASP.NET .ascx пользовательский элемент управления, а второй - шаблон. Метод ParseControl выполняет разбор переданной ему строки и формирует экземпляр стандартного или пользовательского элемента управления. Базовые свойства пользовательских элементов управления В табл. 12-1 перечислены свойства класса UserControl, за исключением тех, которые он унаследовал от класса TemplateControl. Табл. 12-1. Свойства класса UserControl Свойство Описание Application Возвращает объект HttpApplicationState, связанный с текущим запросом Attributes Возвращает коллекцию атрибутов, объявленных в тэге пользователь-ского элемента управления Cache Возвращает объект Cache, связанный с текущим приложением CachePolicy Возвращает объект ControlCachePolicy, определяющий параметры кэширования элемента управления. Свойство доступно только для чтения, но параметры можно конфигурировать программно, уста-навливая свойства объекта ControlCachePolicy. В ASP.NET 1.x данное свойство недоступно IsPostBack Указывает, впервые ли загружен пользовательский элемент управле-ния или в результате возврата формы Request Возвращает объект HttpRequest, связанный с текущим запросом Response Возвращает объект HttpResponse, связанный с текущим запросом Server Возвращает объект HttpServerUtility, связанный с текущим запросом Session Возвращает объект HttpSessionState, связанный с текущим запросом Trace Возвращает объект TraceContext, связанный с текущим запросом Как видите, в составе класса UserControl имеются свойства, предназначенные для доступа к внутренним объектам приложения ASP.NET, а также свойство IsPostBack, содержащее информацию, исключительно важную для всех компонентов ASP.NET. Кроме того, пользовательский элемент управления поддерживает все разновидности свойств, содержащих идентификаторы (ID, ClientID и UniqueID), и служит контейне-ром именования для всех своих дочерних элементов управления. Как обычно, список дочерних элементов управления доступен через коллекцию Controls. Базовые методы пользовательских элементов управления Класс UserControl имеет всего несколько методов, если не считать тех, которые он унаследовал от базовых классов. К числу его наиболее часто используемых унас-ледованных методов относятся DataBind, FindControl и LoadTemplate, а собственные методы этого класса описаны в табл. 12-2. Табл. 12-2. Методы класса UserControl Метод Описание DesignerInitialize Выполняет инициализацию пользовательского элемента управления, необходимую для его использования в RAD-дизайнере InitializeAsUserControl Завершает инициализацию декларативно созданного объекта UserControl MapPath Возвращает физический путь к файлу, соответствующий заданному виртуальному пути. При этом метод определяет путь к файлу .ascx, а не .aspx
Пользовательские элементы управления ASP.NET Глава 12 421 Методы DesignerInitialize и InitializeAsUserControl редко вызываются из страниц и предназначены главным образом для внутреннего использования .NET Framework. В частности, метод InitializeAsUserControl обеспечивает правильную инициализацию пользовательского элемента управления, в том числе связывание обработчиков с со-бытиями. Иными словами, этот метод гарантирует, что методы Page_Load и Page_Init, если таковые имеются, будут вызываться в ответ на события Load и Init элемен-та управления. События, которые поддерживаются данным классом, перечислены в табл. 12-3. Табл. 12-3. События, поддерживаемые классом UserControl Событие (обработчик) Когда происходит Page_AbortTransaction (OnTransactionAbort) Пользователь отменил транзакцию Page_CommitTransaction (OnTransactionCommit) Пользователь сохранил транзакцию Page_DataBinding Элемент управления связан с источником данных Page_Error Выброшено необработанное исключение Page_PreInit Перед началом инициализации элемента управления. В ASP.NET 1.x данное событие недоступно Page_Init Элемент управления инициализирован Page_InitComplete Инициализация элемента управления завершена. В ASP.NET 1.x данное событие недоступно Page_PreLoad Перед загрузкой элемента управления. В ASP.NET 1.x данное событие недоступно Page_Load Элемент управления загружен Page_LoadComplete Загрузка элемента управления завершена. В ASP.NET 1.x данное событие недоступно Page_PreRender Началась стадия предрендеринга элемента управления Page_PreRenderComplete Завершилась стадия предрендеринга элемента управления и сейчас начнется его рендеринг Page_SaveStateComplete Завершилось сохранение состояния представления элемента управления Page_Unload Перед выгрузкой элемента управления из памяти Перечисленные в этой таблице события поддерживаются всеми пользовательски-ми элементами управления. Они генерируются на определенных этапах жизненного цикла страницы. Превращение страниц в пользовательские элементы управления Пользовательские элементы управления и страницы имеют так много общего, что их нетрудно превращать друг в друга. Однако в большинстве случаев выполняется преобразование только в одном направлении, а именно страницы в пользовательский элемент управления. Как вы сейчас увидите, сделать это очень просто. Для начала убедитесь, что страница не содержит тэгов <html>, <body> и <form>. Удаление этих тэгов поможет избежать конфликтов, поскольку в выводимой странице разметка элемента управления будет объединена с разметкой хост-страницы, а тэги <html> и <body>, как известно, могут присутствовать в составе страницы лишь в единственном экземпляре. Что касается тэга <form>, то, хотя таких тэгов и может быть несколько, только один из них разрешено помечать атрибутом runat. Так что удалите из исходной страницы элемента управления тэг <form runat="server">, если 
422 Часть III Элементы управления ASP.NET он там имеется. Если же страница содержит HTML-формы (то есть тэги <form> без атрибута runat), удалять их нет надобности. Удалив указанные тэги HTML, переименуйте файл, сменив расширение на .ascx. Это ключевой момент процесса, обеспечивающий интерпретацию файла как пользо-вательского элемента управления. После этого, если страница содержала директиву @Page, замените ее директивой @Control. Директива @Control Директивы @Control и @Page имеют несколько общих атрибутов. Полный список атрибутов, поддерживаемых пользовательскими элементами управления, приведен в табл. 12-4. Табл. 12-4. Атрибуты директивы @Control Атрибут Описание AutoEventWireup Указывает, выполняется ли автоматическая привязка событий к методам с определенными именами. По умолчанию имеет значение true ClassName Псевдоним имени класса, который будет создан для рендеринга пользова-тельского элемента управления. Может использоваться любое допустимое имя класса без указания пространства имен CodeBehind Оставлен для обеспечения обратной совместимости с ASP.NET 1.x. Определяет имя откомпилированного файла, содержащего класс, ассоциированный с элементом управления CodeFile В ASP.NET 2.0 определяет имя откомпилированного файла, содержащего класс, ассоциированный с элементом управления. В ASP.NET 1.x данный атрибут не поддерживается CodeFileBaseClass Необязательный базовый класс отделенного кода элемента управления. Если этот атрибут установлен, должен быть также установлен и атрибут CodeFile. В ASP.NET 1.x данный атрибут не поддерживается CompilationMode Указывает, подлежит ли элемент управления компиляции. В ASP.NET 1.x данное свойство недоступно CompilerOptions Последовательность ключей командной строки, используемых при компи-ляции класса элемента управления Debug Указывает, следует ли включать в компилируемый файл отладочную информацию. Если этот атрибут имеет значение true, исходный код класса не удаляется и его можно извлечь способом, описанным в главе 1 Description Предоставляет текстовое описание элемента управления EnableTheming Указывает, должны ли к элементу управления применяться темы. В ASP.NET 1.x данный атрибут не поддерживается EnableViewState Указывает, должно ли поддерживаться сохраняемое от запроса к запросу состояние представления элемента управления. По умолчанию данный атрибут имеет значение true Explicit Определяет, будет ли страница с кодом на языке Visual Basic .NET компи-лироваться в режиме Option Explicit. В случае использования других язы-ков программирования атрибут игнорируется. По умолчанию он имеет значение false Inherits Класс отделенного кода, наследуемый элементом управления. Этот класс должен быть производным от UserControl Language Язык программирования, на котором написан код элемента управления Strict Определяет, будет ли страница с кодом на языке Visual Basic .NET компи-лироваться в режиме Option Strict. В случае использования других языков программирования данный атрибут игнорируется. По умолчанию он имеет значение false
Пользовательские элементы управления ASP.NET Глава 12 423 Атрибут Описание Src Имя файла отделенного кода, динамически компилируемого при обращении к данному элементу управления TargetSchema Имя схемы для проверки контента элемента управления. Данный атрибут игнорируется анализатором и имеет описательное назначение. В ASP.NET 1.x он не поддерживается WarningLevel Уровень предупреждения, выдав которое, компилятор должен прекратить компиляцию пользовательского элемента управления В элементе управления не разрешается устанавливать свойства, влияющие на общее поведение страницы. Например, вы не можете включать и отключать функции трассировки и управления состоянием сеанса. Можно изменять только те свойства, которые управляют функционированием самого элемента управления. Примечание Благодаря директиве @Control код элемента управления и формы можно писать на разных языках программирования (например, для элемента управления ис-пользовать Visual Basic.NET, а для вызывающей страницы - C#). Взаимодействие между страницей и элементом управления происходит на уровне откомпилированных классов с использованием общего промежуточного языка (intermediate language). Настоятельно рекомендуется назначать пользовательскому элементу управления псевдоним в атрибуте ClassName, хотя это и не обязательно. При наличии такого ат-рибута элемент управления, программно добавляемый в контейнер, является строго типизированным. Кэширование вывода Пользовательские элементы управления поддерживают оптимизированную версию особой функции, обеспечивающей ускорение доступа к страницам Web Forms и назы-ваемой кэшированием вывода. При использовании данной функции вывод страницы кэшируется системой для ускорения обслуживания последующих запросов с тем же URL. IIS 6.0 поддерживает эту функцию на уровне Web-сервера, благодаря чему она доступна для всех Web-приложений. За дополнительной информацией вы можете об-ратиться к главе 14 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Кэширование вывода может осуществляться на одном из двух уровней: страницы и ее части. Пользовательский элемент управления - наименьшая часть страницы, для которой может производиться кэширование вывода. Для того чтобы кэшировалась вся страница, нужно поместить директиву @OutputCache в файл .aspx - в таком случае весь вывод страницы будет кэшироваться в соответствии с заданными вами параметрами. Если же вы захотите кэшировать часть страницы, то ее нужно будет выделить в пользовательский элемент управления и поместить в получившийся файл .ascx директиву @OutputCache. Для кэширования вывода пользовательского элемента управления необходимо установить как минимум два атрибута: Duration и VaryByParam. Следующий код по-казывает, как включить кэширование и задать его длительность равной 60 с. <% @OutputCache Duration="60" VaryByParam="None" %> Система кэширования достаточно интеллектуальна, чтобы сохранять разные варианты вывода, даже вывод, который формируется с учетом параметров строки запроса GET. Табл. 12-4. (окончание)
424 Часть III Элементы управления ASP.NET Внимание! Специализированные и пользовательские элементы управления - это два разных вида элементов управления, определяемых пользователем. Каждый из них име-ет свои достоинства и недостатки, и какой из этих двух видов выбрать - зависит от конкретной ситуации. Пользовательские элементы управления идеальны для случаев, когда нужно инкапсулировать богатый и сложный пользовательский интерфейс и хранить его определение отдельно от страницы. Это определение может быть разделено на два файла, разметки и отделенного кода. Специализированный элемент управления реализуется в сборке и имеет как пользо-вательский интерфейс, так и программно доступную объектную модель. В отличие от пользовательского элемента управления он лучше отвечает принципам объектно-ориен-тированного программирования, поскольку создается на базе существующих классов и от него, в свою очередь, можно образовывать новые классы. Пользовательский же элемент управления сложно сделать производным от существующего элемента управления (из-за наличия отдельного файла разметки), хотя технически такая возможность существует. Разработка пользовательских элементов управления Структура пользовательского элемента управления мало отличается от структу-ры обычной Web-страницы. В его файле содержится раздел директив, встроенный код и разметка, определяющая его интерфейс. Встроенный код, то есть блок <script runat="server">, может отсутствовать, если элемент управления имеет файл отделен-ного кода. Хотя ничто не мешает создать пользовательский элемент управления без пользовательского интерфейса, последний является наиболее важной частью элемента управления, который обычно именно ради него и создается. Ниже приведена типичная структура файла .ascx: <%@Control Language="C#" %> <script runat="server"> //Поместите код сюда либо //в файл отделенного кода </script> <!--Здесь разместите контент --> У многих сайтов имеются части пользовательского интерфейса, повторяющиеся на многих страницах. Типичными примерами могут служить заголовки и колонтитулы, формы входа и поиска данных, меню и панели. Форме входа не требуется сложная объектная модель, более того, обычно она вообще не нужна. Но в других случаях мо-жет быть необходим логический слой, обеспечивающий возможность программного доступа к элементу управления. Мы начнем практическое изучение пользовательских элементов управления с разработки элемента управления TabStrip со сравнительно простой объектной моделью. Создание элемента управления TabStrip Типичный элемент управления TabStrip состоит из нескольких расположенных в одной строке кнопок, представляющих корешки вкладок. Когда пользователь щелкает такую кнопку, элемент управления выбирает вкладку и генерирует событие для хост-стра-ницы, которая в ответ обновляет свой пользовательский интерфейс. Пример формы, содержащей элемент управления TabStrip, показан на рис. 12-1. Пользовательский интерфейс нашего элемента управления генерируется с исполь-зованием элемента управления Repeater и состоит из однострочной HTML-таблицы, каждая ячейка которой содержит кнопку.
Пользовательские элементы управления ASP.NET Глава 12 425 Рис. 12-1. Элемент управления TabStrip на демонстрационной странице Под таблицей размещается тонкая пустая панель, отделяющая корешки вкладок от остальной части страницы. Элемент управления действует как селектор и не со-держит сложного кода обработки щелчков мыши. Когда пользователь щелкает один из корешков, генерируется событие для страницы. За создание вкладок отвечает страница. В данном примере вкладки не содержат ничего кроме надписей на кореш-ках, но в реальном коде вам, скорее всего, потребуется специализированный класс, представляющий вкладку с клавишей быстрого доступа, всплывающей подсказкой, флагом доступа (доступна/недоступна) и, возможно, URL. <%@Control Language="C#" CodeFile="Tabstrip.ascx.cs" %> <asp:Repeater runat="server" id="__theTabStrip"> <headertemplate> <table cellpadding="0" cellspacing="0" border="0" ><tr> </headertemplate> <itemtemplate> <td> <asp:button runat="server" id="__theTab" text='<%# Container.DataItem %>' /> </td> </itemtemplate> <footertemplate> </tr></table> </footertemplate> </asp:Repeater> <asp:panel runat="server" id="__theSep" width="100%" backcolor="gray" /> Класс отделенного кода содержит несколько свойств и методов: public ArrayList Tabs = new ArrayList(); protected void Page_Load(object sender, EventArgs e) { if (!IsPostBack) BindData(); }private void BindData() { __theTabStrip.DataSource = Tabs;
426 Часть III Элементы управления ASP.NET __theTabStrip.DataBind(); } Массив Tabs содержит строки, выводимые на корешках вкладок. Он инициализи-руется при инициализации пользовательского элемента управления и используется на этапе его рендеринга. Вызывающая страница обычно заполняет этот массив в об-работчике события Page_Load: protected void Page_Load(object sender, EventArgs e) { menu.Tabs.Add("Welcome"); menu.Tabs.Add("Developer"); menu.Tabs.Add("Download"); menu.Tabs.Add("Contact Us"); } Далее мы немного усовершенствуем наш элемент управления, но сначала давайте посмотрим, что нужно для его размещения на Web-странице. Размещение пользовательского элемента управления на странице Пользовательский элемент управления размещается на странице с помощью спе-циального тэга, помеченного атрибутом runat. У экземпляра элемента управления имеется идентификатор, который можно использовать для программного доступа к нему. Серверный тэг делится на две части: префикс и имя. В следующем фрагменте кода префиксом является expo, а именем - tabstrip. (Заметьте, что имя тэга поль-зовательского элемента управления не обязательно должно соответствовать имени класса этого элемента.) <expo:tabstrip runat="server" id="menu" /> Если присвоить элементу префикс asp или вообще не присваивать ему никакого префикса, исполняющая среда ASP.NET будет искать его класс только в сборке system. web. Поскольку пользовательские элементы управления содержатся не там, будет выброшено исключение. Как же зарегистрировать имя тэга и префикс для пользова-тельского элемента управления и как связать их с файлом .ascx? Директива @Register Директива @Register связывает псевдонимы с пространствами имен и классами, обес-печивая возможность ссылаться с помощью этих псевдонимов на пользовательские элементы управления в Web-страницах. Атрибуты указанной директивы перечислены в табл. 12-5. Табл. 12-5. Атрибуты директивы @Register Атрибут Сборка Assembly Сборка, в которой определено пространство имен, ассоциированное с префиксом тэга. Имя сборки не должно содержать расширения Namespace Пространство имен, ассоциируемое с префиксом тэга Src Относительное или абсолютное местоположение файла пользовательского элемента управления, который следует связать с префиксом и именем тэга. Имя файла должно иметь расширение .ascx TagName Имя тэга, которое будет псевдонимом пользовательского элемента управления (в приведенном выше фрагменте кода - tabstrip); таким именем может служить произвольная строка
Пользовательские элементы управления ASP.NET Глава 12 427 Атрибут Сборка TagPrefix Префикс тэга, который будет псевдонимом пространства имен пользовательского элемента управления (в приведенном выше фрагменте кода - expo); им может служить произвольная строка Директиву @Register можно применять для регистрации как пользовательских, так и специализированных элементов управления. В первом случае она имеет такой синтаксис: <%@Register tagprefix="..." namespace="..." assembly="..." %> Пользовательский элемент управления с помощью директивы @Register регист-рируется так: <%@Register tagprefix="..." tagname="..." src="..." %> Префикс тэга (tagprefix) - это пользовательская строка, идентифицирующая пространство имен, а следовательно, сборку, в которой находится код элемента уп-равления. Для пользовательских элементов управления по умолчанию используется префикс ASP, а имя класса задается в атрибуте ClassName. Если такого атрибута нет, тогда именем класса считается имя файла элемента управления, в котором точка за-менена символом подчеркивания (_). Так, в нашем примере, если присвоить атрибуту ClassName значение TabStrip, класс будет иметь имя ASP.TabStrip, а в противном случае, то есть когда атрибут ClassName отсутствует, класс получит имя ASP.tabstrip_ascx (мы считаем, что файл элемента управления имеет имя tabstrip.ascx). Сборка пользовательского элемента управления динамически создается при пер-вом к нему обращении. При этом в разных страницах для ссылки на него могут ис-пользоваться разные имена тэгов. Что касается специализированных элементов управления, то для их использования нужно указать пространство имен и сборку, а также задать по своему усмотрению префикс пространства имен. Имя же тэга фиксировано и должно соответствовать имени класса специализированного элемента управления. Регистрация пользовательского элемента управления для страницы Хотя для регистрации пользовательского элемента управления может использоваться абсолютный путь, я советую вам всегда задавать только относительные имена. Сле-дует также знать, что для кода данного элемента управления базовым URL будет считаться URL этого элемента. Иными словами, если пользовательскому элементу управления потребуется доступ к изображению из папки Images приложения, вы не сможете задать относительный путь, как в следующем примере: <img src="images/logo.gif" /> Вам придется либо переместить одну или несколько папок, либо, что конечно же лучше, указать относительный путь, начинающийся с корневого каталога приложения. Каталог, расположенный уровнем выше текущего, обозначается двумя точками (..), а корневой каталог приложения обозначается символом тильды (~). Вот такая ссылка на упомянутое выше изображение будет правильной: <img src="~/images/logo.gif" /> Для регистрации нашего элемента управления TabStrip следует воспользоваться такой директивой: <%@Register TagPrefix="expo" TagName="TabStrip" Src="tabstrip.ascx" %> Табл. 12-5. (окончание)
428 Часть III Элементы управления ASP.NET Экземпляр пользовательского элемента управления создается при загрузке стра-ницы. Как и класс страницы, класс такого элемента создается на лету и кэшируется во временной папке ASP.NET. Любые обновления исходного кода (в файле .ascx или в файле отделенного кода) немедленно обнаруживаются системой, и сборка ста-новится недействительной. Компилировать пользовательский элемент управления самостоятельно не требуется. (Строго говоря, существует ситуация, когда это нужно сделать, но о ней я расскажу далее в этой главе, в разделе "Реалистичный пример пользовательского элемента управления".) Регистрация элементов управления в файле web.config В ASP.NET 1.x можно регистрировать элементы управления только на уровне стра-ницы, но в ASP.NET 2.0 появилась новая возможность - делать это на уровне сай-та, приложения или дочерней папки, помещая указанную ниже установку в раздел <controls> соответствующего файла web.config. <controls> <add tagPrefix="expo" tagName="Tabstrip" src="tabstrip.ascx" /> </controls> Раздел <controls> должен находиться в разделе <pages>, который, как вы уже знае-те из главы 3, содержит конфигурационные установки страниц. В нем регистрируются специализированные и пользовательские элементы управления и импортируемые пространства имен. Создание объектной модели пользовательского элемента управления Все свойства и методы пользовательского элемента управления, объявленные как public, доступны извне и являются частью его объектной модели. В следующем приме-ре объявляются два доступных для чтения и записи свойства, которые представляют цвет фона и цвет текста невыбранной вкладки: public Color BackColor { get { object o = ViewState["BackColor"]; if (o == null) return Color.Silver; return (Color)o; } set { ViewState["BackColor"] = value; } }public Color ForeColor { get { object o = ViewState["ForeColor"]; if (o == null) return Color.White; return (Color)o; } set { ViewState["ForeColor"] = value; } }
Пользовательские элементы управления ASP.NET Глава 12 429 Квалификатор public играет здесь ключевую роль - без него свойства не будут доступны извне, например из хост-страницы. Обратите внимание на использование коллекции ViewState в качестве контейнера значений свойств. Примечание Когда речь идет о классе .NET Framework, свойством называют средство получения и установки того или иного значения. Это абстракция пары необязательных методов get и set. Если свойство представляет значение (как чаще всего бывает), то это значение должно где-то храниться. В отличие от поля, свойство не является переменной, и для хранения данных ему требуется вспомогательная структура. Обычно значение свойс-тва хранится в закрытом поле объекта. Однако когда свойство определено для серверного или пользовательского элемента управления, локальная переменная для указанной цели не подходит. Чтобы значение свойства можно было прочитать и после возврата формы, его нужно хранить в постоянном контейнере, таком как Cache, Session или коллекция ViewState самого элемента управления. Коллекция ViewState лучше всего подходит для хранения значений свойств, поскольку не занимает места в памяти Web-сервера. Если вы просто выводите на уровень пользовательского элемента управления свойство одного из составляющих его элементов, скажем, свойство Text дочерней кнопки, то обращаться к состоянию представления вам не требуется. public string Caption { get { return TextBox1.Text; } set { TextBox1.Text = value; } } В данном случае встроенный элемент управления сам заботится о сохранении значения своего свойства. Имя Caption используется для ссылки на свойство Text элемента TextBox1 из хост-среды пользовательского элемента управления. Дочерние элементы пользовательского элемента управления защищены от доступа извне ука-занного элемента. Применяя описанный подход, вы можете открывать вызывающему коду доступ к отдельным составляющим пользовательских элементов управления. Добавление свойств У нашего элемента управления должны иметься как минимум свойства, позволяющие добавлять вкладки и узнавать индекс текущей вкладки. Набор вкладок элемента содер-жится в коллекции Tabs. Свойство CurrentTabIndex, определение которого приведено ниже, позволяет узнать индекс текущей вкладки. public int CurrentTabIndex { get { object o = ViewState["CurrentTabIndex"]; if (o == null) return 0; return (int) o; } } Определяя свойство, вы можете написать для него аксессор get, мутатор set или оба эти метода. Аксессором называется специальная подпрограмма, которая возвращает значение свойства, а мутатором - аналогичная подпрограмма, позволяющая его установить. Параметр мутатора - это то самое значение, которое вызывающий код присвоил свойству в операторе присваивания. При отсутствии аксессора свойство доступно только для записи, а при отсутствии мутатора - только для чтения. Таким 
430 Часть III Элементы управления ASP.NET образом, в приведенном выше примере свойство CurrentTabIndex доступно только для чтения. Внимание! Обратите внимание на то, как действует аксессор свойства CurrentTabIndex: он сначала извлекает значение свойства, а затем проверяет, не пустое ли оно. Если оно равно null, аксессор возвращает значение по умолчанию. Такая схема работы типична для встроенных элементов управления ASP.NET. В дополнение к упомянутым свойствам BackColor и ForeColor элемент управления TabStrip должен иметь свойства SelectedBackColor и SelectedForeColor, реализация которых аналогична. Свойства пользовательских элементов управления можно устанавливать как декла-ративно, так и программно. В первом случае имя свойства используется как атрибут тэга элемента управления: <expo:tabstrip runat="server" id="menu" selectedbackcolor="cyan" /> При этом для задания значений можно использовать только строки. Так, чтобы задать цвет фона, нужно воспользоваться строкой, представляющей требуемый цвет. ASP.NET попытается преобразовать заданную строку в допустимое значение ожида-емого типа. А вот при программном доступе к свойству задается значение, тип которого, как и положено, соответствует типу свойства: void Page_Load(object sender, EventArgs e) { //Поскольку коллекция Tabs не хранится в состоянии представления, //ее приходится заполнять при каждом возврате формы. Данный код //должен находиться вне условного оператора, проверяющего IsPostBack menu.Tabs.Add("Welcome"); menu.Tabs.Add("Developer"); menu.Tabs.Add("Download"); menu.Tabs.Add("Contact Us"); if (!IsPostBack) { //Выполните здесь те действия, которые должны //производиться только при первой загрузке //элемента управления в страницу, например выберите //вкладку, которая будет активна по умолчанию } //Устанавливаем цвета программно menu.SelectedBackColor = Color.Green; menu.SelectedForeColor = Color.White; menu.BackColor = Color.LightGray; menu.ForeColor = Color.Black; } Экземпляр пользовательского элемента управления идентифицируется значением его свойства ID. Если вы имеете дело со свойствами, которые не работают с состоянием представления, то вам придется конфигурировать их при каждом возврате формы, не различая первую загрузку и последующие. Выделенная вкладка выводится другими цветами, задаваемыми с применением выражения связывания с данными, как показано ниже (о выражениях типа связыва-ния с данными рассказывалось в главе 5): <itemtemplate> <td>
Пользовательские элементы управления ASP.NET Глава 12 431 <asp:button runat="server" id="__theTab" BorderWidth="1px" BorderStyle="solid" BorderColor='<%# GetBorderColor(Container) %>' text='<%# Container.DataItem %>' font-bold='<%# (Container.ItemIndex == CurrentTabIndex) %>' backcolor='<%# GetBackColor(Container) %>' forecolor='<%# GetForeColor(Container) %>' /> </td> </itemtemplate> Функции GetXXX - это внутренние члены класса TabStrip; они сравнивают индекс текущей вкладки с индексом создаваемого элемента и решают, какой цвет следует вернуть. protected Color GetBackColor(object elem) { RepeaterItem item = (RepeaterItem)elem; if (item.ItemIndex == CurrentTabIndex) return SelectedBackColor; return BackColor; }protected Color GetForeColor(object elem) { RepeaterItem item = (RepeaterItem)elem; if (item.ItemIndex == CurrentTabIndex) return SelectedForeColor; return ForeColor; }protected Color GetBorderColor(object elem) { RepeaterItem item = (RepeaterItem)elem; if (item.ItemIndex == CurrentTabIndex) return SelectedBackColor; return Color.Black; } Все свойства пользовательского элемента управления TabStrip, за исключением Tabs, имеют аксессоры и/или мутаторы и сохраняют свои значения в состоянии пред-ставления элемента управления. Свойство Tabs не имеет ни аксессора, ни мутатора по той причине, что оно реализовано как поле. При каждом обратном вызове его значение утрачивается и должно формироваться повторно. Собственно, ничто не мешает сохранять значение этого свойства в состоянии представления, и мы делали бы это, если бы в том была необходимость. В состоянии представления можно сохра-нять любой объект, допускающий сериализацию или имеющий менеджер состояния. (О менеджерах состояния рассказывается в следующей главе.) Вопрос здесь в другом: действительно ли это необходимо? Если сохранения значения свойства в состоянии представления можно избежать, то лучше так и поступить, чтобы ускорить загрузку страницы и возврат формы. Однако тут возникает проблема: если вы не сохраняете значение свойства в состоянии представления, разработчик, использующий ваш эле-мент управления, должен иметь это в виду. Все-таки пользователи вправе рассчитывать на то, что элемент управления будет самодостаточным и позаботится о сохранении своих данных. Так что решение остается за вами, но в любом случае обязательно как следует задокументируйте поведение своего элемента управления.
432 Часть III Элементы управления ASP.NET У встроенных элементов управления код сериализации содержится в классе кол-лекции и не делегируется инфраструктуре состояния представления. Таким образом, состояние представления остается более компактным. Я вернусь к этому вопросу в главах 13 и 14, когда буду рассказывать о специализированных серверных элементах управления. Добавление методов Следующим шагом нашего процесса разработки функционального и повторно исполь-зуемого элемента управления TabStrip является добавление метода для программного выбора вкладки. До сих пор выбор вкладки мог осуществлять только пользователь, щелкающий на ее корешке. Метод Select, который мы теперь добавим, будет делать это программным способом. Вот прототип этого метода: public void Select(int index) Метод принимает целочисленный аргумент - им является 0-базированный индекс вкладки, которую требуется выбрать. Он устанавливает индекс текущей вкладки и повторно выполняет связывание данных. public void Select(int index) { //Проверяем, допустимое ли значение индекса нам передали. //Если нет, выбираем первую вкладку if (index <0 || index >Tabs.Count) index = 0; //Обновляем текущий индекс. Необходимо записать его //в состояние представления, поскольку свойство //CurrentTabIndex доступно только для чтения ViewState["CurrentTabIndex"] = index; //Назначаем нижней панели цвет выделенного элемента __theSep.BackColor = SelectedBackColor; //Обновляем пользовательский интерфейс BindData(); } Метод пользовательского элемента управления - это обыкновенный открытый метод, определенный либо во встроенном коде, либо в классе отделенного кода. За-метьте, что метод Select не может установить индекс текущей вкладки, используя свойство CurrentTabIndex, поскольку оно предназначено только для чтения, то есть для него определен лишь аксессор. Поэтому мы непосредственно обращаемся к объекту ViewState, где хранятся значения свойств. Теперь мы можем разместить на нашей демонстрационной странице элементы интерфейса для программного выбора вкладок. Приведенный далее код показывает, как создать текстовое поле, куда можно будет ввести индекс вкладки, подлежащей выделению, и кнопку-ссылку для выполнения кода (рис. 12-2): <asp:textbox runat="server" id="tabIndex" /> <asp:linkbutton runat="server" text="Select tab" onclick="OnSelectTab" /> Обработчик события OnSelectTab просто вызывает метод Select нашего элемента управления: void OnSelectTab(object sender, EventArgs e) {
Пользовательские элементы управления ASP.NET Глава 12 433 int index = -1; Int32.TryParse(tabIndex.Text, out index); menu.Select(index); }Рис. 12-2. Новая кнопка-ссылка служит для выделения заданной вкладки Метод Select действует как мутатор свойства CurrentTabIndex. Если нужно про-читать индекс текущей вкладки, используется это свойство, а если его необходимо установить - тогда метод Select. Обработка событий пользовательских элементов управления Пока наш пользовательский элемент управления TabStrip имеет пользовательский ин-терфейс и позволяет выбирать вкладки, но ключевая функция, необходимая элементу подобного рода, в нем еще не реализована. Ведь он должен уведомлять хост-страницу о том, что пользователь щелкнул вкладку, для того чтобы данная страница могла акти-визировать контент этой вкладки. Страница может генерировать для каждой вкладки свой контент, переадресовывать пользователя на дочернюю страницу, открываемую внутри фрейма, или же просто выполнять переход по новому URL. Итак, мы должны снабдить наш элемент управления событием. Добавление события SelectionChanged Смена выделенной вкладки происходит у создаваемого элемента в двух случаях: когда пользователь щелкает корешок одной из вкладок или когда страница вызывает метод Select. Мы определим для этих случаев событие с именем SelectionChanged: public event SelectionChangedEventHandler SelectionChanged; Событие - это особое свойство, связанное с делегатом. Делегатом же называется ссылка на сигнатуру метода. Экземпляр делегата является просто указателем на функ-цию с известной сигнатурой, а необходим он для того, чтобы вызовы событий были строго типизированными. (В случае, если в вызове события передается параметр неверного типа или, наоборот, не передается требуемый параметр, такой вызов завер-шается выбросом исключения.) ASP.NET предоставляет для обработчиков событий универсальный делегат - класс EventHandler. Вот его прототип: public delegate void EventHandler(object sender, EventArgs e); Делегат EventHandler представляет все методы, которые принимают аргументы типа object и EventArgs и сами имеют тип void. Этот предопределенный делегат подхо-дит для тех случаев, когда вам не нужно передавать обработчику события пользова-тельские данные. Иными словами, его следует использовать для событий, служащих просто уведомлениями.
434 Часть III Элементы управления ASP.NET Однако в нашем случае серверу для обработки необходимо передавать индекс выделенной вкладки, то есть нам требуется не просто уведомление, а вызов с пере-дачей данных, поэтому делегат EventHandler не подходит. Что ж, тогда определим собственный делегат и собственную структуру данных события, которая позволит нам передавать индекс выделенной вкладки обработчику события: public delegate void SelectionChangedEventHandler( object sender, SelectionChangedEventArgs e); Пользовательский делегат, предназначенный для обработки события, отличается от делегата EventHandler тем, что типом его аргумента, представляющего событие, является пользовательская структура. По общему соглашению имя события (в данном случае - SelectionChanged) добавляется в качестве префикса и в имя обработчика этого события, и в имя структуры данных. public class SelectionChangedEventArgs : EventArgs { public int SelectedIndex //0-based index of the selected tab } Структура SelectionChangedEventArgs наследует класс EventArgs, но содержит дополнительное целочисленное свойство, представляющее 0-базированный индекс выделенной вкладки. Экземпляр этой структуры данных будет создан и инициа-лизирован, когда в пользовательском элементе управления произойдет событие SelectionChanged. Благодаря введению в .NET Framework 2.0 родовых типов упростилась задача определения делегатов пользовательских событий. Вы можете ограничиться родовой версией типа EventHandler - EventHandler<T>. public event EventHandler<SelectionChangedEventArgs> SelectionChanged; Параметром родового типа в данном случае является тип второго параметра обра-ботчика события. В ASP.NET 2.0 два приведенных определения событий эквивалент-ны, и я нахожу второе, основанное на применении родового типа, более изящным. Генерирование пользовательского события Для обработки пользовательского события необходимо определить вспомогательную процедуру, подобную приведенной в конце этого подраздела. Вы можете присво-ить ей любое имя и по своему усмотрению задать квалификаторы метода (protected, virtual). Однако объявление такой процедуры как защищенной и переопределяемой считается более правильным решением, и именно так это обычно делается в самой .NET Framework. Я предлагаю объявить ее как protected и virtual, следуя правилу, применяемому в .NET Framework. //Вспомогательная функция, генерирующая событие //путем выполнения пользовательского кода protected virtual void OnSelectionChanged(SelectionChangedEventArgs e) { //SelectionChanged - это свойство-событие. //Нужно проверить, определил ли его пользователь if (SelectionChanged != null) SelectionChanged(this, e); } Как видите, работы у данной процедуры немного: она просто удостоверяется, что свойство-событие определено, а затем вызывает его. Однако так вы создаете допол-
Пользовательские элементы управления ASP.NET Глава 12 435 нительный слой кода, который, будучи переопределяемым, позволяет производным классам модифицировать поведение элемента управления. Примечание Вспомогательная функция просто гарантирует, что код события опреде-лен, а затем генерирует это событие. В C# такую функцию обычно создают для того, чтобы инкапсулировать вызов события. В Visual Basic.NET особой необходимости в ее создании нет, поскольку в этом языке имеется встроенный оператор RaiseEvent, предна-значенный для генерирования события и выполняющий необходимую проверку. Однако важно понимать, что наличие метода OnEventName, который определен как защищенный и переопределяемый, делает ваш код более гибким, так что есть смысл добавлять его независимо от того, каким языком программирования вы пользуетесь. Теперь, для того чтобы сгенерировать событие, нужно просто инициализировать структуры данных и вызвать вспомогательную функцию. Событие генерируется ме-тодом Select: public void Select(int index) { //Убеждаемся, что передан допустимый индекс if (index <0 || index >Tabs.Count) index = 0; //Назначаем нижней панели цвет выделенного элемента __theSep.BackColor = SelectedBackColor; //Обновляем пользовательский интерфейс BindData(); //Генерируем событие для клиента SelectionChangedEventArgs ev = new SelectionChangedEventArgs(); ev.SelectedIndex CurrentTabIndex; OnSelectionChanged(ev); } Когда пользователь щелкает вкладку, используемый нами элемент управления Repeater генерирует событие ItemCommand. Встроенный обработчик этого события перенаправляет вызов методу Select. private void ItemCommand(object sender, RepeaterCommandEventArgs e) { //Выбор соответствующей вкладки Select(e.Item.ItemIndex); } Итак, наш пользовательский элемент управления "научился" генерировать со-бытия, а нам осталось написать для страницы код, который бы его перехватывал и обрабатывал. Обработка пользовательского события Компонент .NET, который желает обрабатывать события, генерируемые элементом управления, должен иметь обработчик, прототип которого соответствует делегату события. Способ связывания обработчика с событием конкретного экземпляра эле-мента управления зависит от языка программирования. Например, на C# создается новый экземпляр класса обработчика события и добавляется в свойство-событие компонента: //YourHandler - имя обработчика в вашем коде menu.SelectionChanged += new SelectionChangedEventHandler(YourHandler);
436 Часть III Элементы управления ASP.NET В Visual Basic.NET можно использовать ключевое слово AddHandler: ' YourHandler - имя обработчика в вашем коде AddHandler menu.SelectionChanged, AddressOf YourHandler Пользоваться этими способами в приложениях ASP.NET не всегда нужно, пос-кольку последняя позволяет регистрировать обработчики событий декларативно, с применением атрибута OnXXX, где XXX - имя свойства-события. <expo:TabStrip runat="server" id="menu" SelectedBackColor="cyan" OnSelectionChanged="SelectionChanged" /> Приведем обработчик события SelectionChanged: void SelectionChanged(object sender, SelectionChangedEventArgs e) { msg.Text = "Selected tab #" + e.Position.ToString(); } Примечание В ASP.NET 2.0 для реализации специализированного элемента управления TabStrip можно использовать новый элемент управления MultiView, позволяющий задать любое количество "представлений", под которыми понимаются шаблоны ASP.NET. Эле-мент MultiView имеет свойство-индекс, доступное для записи, и автоматически выводит выбранный шаблон. Однако данный элемент управления не имеет пользовательского интерфейса для вывода списка доступных шаблонов и предоставления пользователю возможности выбора элемента этого списка. Вы можете переписать элемент управления TabStrip с использованием элемента MultiView. Пример усовершенствованного пользовательского элемента управления Реальные специализированные и пользовательские элементы управления обычно связаны с данными. Поэтому мы продолжим работу над нашим демонстрационным элементом, и сделаем так, чтобы он выполнял SQL-запрос и автоматически генери-ровал вкладки по его результатам. Связывание пользовательского элемента управления с данными Пользовательский элемент управления, связанный с данными, как правило, мало чем отличается от независимого элемента с аналогичным пользовательским интерфейсом. Единственное различие между ними заключается в том, что у первого имеется не-сколько дополнительных свойств, которые используются для взаимодействия с объек-том, представляющим источник данных и реализующим интерфейс IEnumerable - как правило, но не обязательно, объектом ADO.NET. Мы разработаем новый элемент управления с именем ButtonList, похожий на TabStrip, но создающий вкладки с ин-формацией из источника данных. Пользовательский элемент управления ButtonList Структура элемента управления ButtonList очень проста: он содержит элемент управ-ления Repeater, перебирающий в цикле элементы данных и создающий для каждого их них кнопку. Под элементом Repeater располагается однострочная таблица, поме-щенная сюда просто для красоты. <%@Control Language="C#" AutoEventWireup="true" CodeFile="ButtonList.ascx.cs" Inherits="ButtonList" %>
Пользовательские элементы управления ASP.NET Глава 12 437 <asp:repeater runat="server" id="__theMenu"> <HeaderTemplate> <table border="0" cellspacing="0" cellpadding="0"><tr> </HeaderTemplate> <ItemTemplate> <td valign="bottom"> <asp:button runat="server" id="TheButton" style="border:solid 1px gray" /> </td> </ItemTemplate> <FooterTemplate> </tr></table> </FooterTemplate> </asp:repeater> <asp:panel runat="server" id="__theSep" width="100%" /> Файл .ascx содержит только каркас пользовательского интерфейса элемента уп-равления. Как видите, тут пока нет ни выражения связывания с данными, ни обра-ботчика события. Интерфейс программирования элемента управления ButtonList Элемент управления ButtonList имеет несколько свойств (табл. 12-6), относящихся главным образом к механизму связывания с данными, который использует данные элемента управления Repeater. Табл. 12-6. Свойства элемента управления ButtonList Свойство Описание ButtonWidth Ширина кнопки (в пикселах) CurrentButtonIndex 0-базированный индекс выделенной кнопки (только чтение) DataSource Имя источника данных для заполнения элемента управления DataTextField Имя столбца источника данных, содержащего надписи кнопок DataValueField Имя столбца источника данных, содержащего команды, связанные с кнопками Свойство DataSource имеет то же назначение, что и одноименное свойство стан-дартных элементов управления, связанных с данными. В нем задается коллекция элементов данных, на основе которых элемент управления будет формировать свой пользовательский интерфейс. Два столбца из этого источника данных содержат над-писи для кнопок и соответствующие команды. Имя команды объекта Button - это строка, идентифицирующая данную кнопку и используемая для детектирования собы-тий. Привязывая данные к такому элементу управления, нужно связать его свойство DataValueField со столбцом, содержащим уникальные значения. Учтите, что эти зна-чения будут преобразовываться в строки. Все свойства, за исключением DataSource, кэшируются в состоянии представления. Содержимое свойства DataSource кэшируется во внутреннем объекте ASP.NET с именем Cache. Это не составит для нас проблемы, поскольку с элементом управления ButtonList будет связано небольшое количество данных. public object DataSource {
438 Часть III Элементы управления ASP.NET get { object o = Cache[ID]; if (o == null) { RefreshDataEventArgs ev = new RefreshDataEventArgs(); OnRefreshData(ev); o = ev.DataSource; } return o; } set { Cache[ID] = value; } } Значение свойства DataSource кэшируется в слоте с уникальным именем, которым служит идентификатор пользовательского элемента управления. Тем самым мы га-рантируем, что несколько экземпляров элемента управления, размещенных на одной странице, будут работать корректно и без конфликтов. Обычно серверные элементы управления ASP.NET, связанные с данными, не кэ-шируют свои источники данных, а заставляют хост-страницу повторно выполнять связывание с данными при каждом обратном вызове. Однако я решил сделать наш элемент управления более интеллектуальным. Учтите только, что данные, хранящиеся в объекте Cache, как и в состоянии сеанса, не всегда являются доступными - когда памяти не хватает, сервер очищает кэш. Поэтому аксессор свойства DataSource про-веряет слот данных на значение null и, обнаружив, что данных там нет, генерирует событие для хост-страницы, запрашивая новые данные. public event EventHandler<RefreshDataEventArgs> RefreshData; Структура RefreshDataEventArgs определяется следующим образом: public class RefreshDataEventArgs : EventArgs { public object DataSource; } Как уже было сказано, все остальные свойства кэшируются в состоянии пред-ставления элемента управления, которое, в свою очередь, записывается в состояние представления страницы. Ниже приведена реализация демонстрационного свойства DataTextField: public string DataTextField { get { object o = ViewState["DataTextField"]; if (o == null) return String.Empty; return (string) o; } set { ViewState["DataTextField"] = value; } } Состояние представления у каждого элемента управления свое, так что нет не-обходимости разрабатывать схему уникальных имен. При написании аксессора свой-ства всегда нужно следить за тем, чтобы прочитанное значение не было равным null 
Пользовательские элементы управления ASP.NET Глава 12 439 (оно будет таким, если значение свойства предварительно не сохранить в состоянии представления). Механизм связывания элемента управления ButtonList с данными в целом аналоги-чен тому, который используется в элементе управления Repeater. В частности, метод BindData, предназначенный для заполнения пользовательского интерфейса элемента управления ButtonList, это не что иное, как оболочка: private void BindData() { __theMenu.DataSource = DataSource; __theMenu.DataBind(); } Метод BindData вызывается дважды: в обработчике события Page_Load при ини-циализации элемента управления и для обновления пользовательского интерфейса, когда пользователь щелкает кнопку: protected void Page_Load(object sender, EventArgs e) { if (!IsPostBack) BindData(); } Когда пользователь щелкает кнопку, генерируется событие ButtonClicked. Клиент-ская страница получает пользовательскую структуру, содержащую индекс и команду кнопки. Рассмотрим этот момент более подробно. Генерирование вывода Когда элемент управления инициализируется (то есть после вызова конструктора), он регистрирует несколько обработчиков событий, генерируемых входящим в его состав элементом управления Repeater: private void HookUpEvents() { __theMenu.ItemCommand += new RepeaterCommandEventHandler(ItemCommand); __theMenu.ItemCreated += new RepeaterItemEventHandler(ItemCreated); __theMenu.ItemDataBound += new RepeaterItemEventHandler(ItemBound); } В обработчике события ItemCreated необходимо позаботиться о внешнем виде каждой кнопки, приняв решения относительно ее цвета, рамки и размера. В частности, выделенная кнопка должна быть больше остальных и отличаться от них цветом. protected void ItemCreated(object sender, RepeaterItemEventArgs e) { if (e.Item.ItemType != ListItemType.Item && e.Item.ItemType != ListItemType.AlternatingItem) return; //Получаем создаваемый элемент RepeaterItem item = e.Item; bool isSelected = IsSelectedItem(item); Button btn = (Button) item.FindControl("TheButton"); //Настраиваем его внешний вид if (isSelected) { btn.BackColor = SelectedBackColor; btn.ForeColor = SelectedForeColor; btn.Height = Unit.Pixel(SELECTEDBUTTONHEIGHT);
440 Часть III Элементы управления ASP.NET btn.Width = Unit.Pixel(ButtonWidth*150/100); } else { btn.BackColor = BackColor; btn.ForeColor = ForeColor; btn.Height = Unit.Pixel(BUTTONHEIGHT); btn.Width = Unit.Pixel(ButtonWidth); } } Хотя цвета здесь не реализованы как открытые свойства, они используются так, будто являются открытыми. (Если вы захотите доработать элемент управления, реа-лизовать данную возможность, учитывая ваш предыдущий опыт работы с элементом управления TabStrip, будет нетрудно.) Проверяйте тип создаваемого элемента и вы-ходите из обработчика события ItemCreated, если объект Repeater не создал элемент типа Item или AlternatingItem. Когда генерируется событие ItemCreated, элемент еще не связан с данными. По-этому, для того чтобы вывести надписи и определить имена команд кнопок, нужно подождать наступления события ItemDataBound. protected void ItemBound(object sender, RepeaterItemEventArgs e) { if (e.Item.ItemType != ListItemType.Item && e.Item.ItemType != ListItemType.AlternatingItem) return; //Получаем элемент, предназначенный для связывания с данными RepeaterItem item = e.Item; Button btn = (Button) item.FindControl("TheButton"); //Связываем его с данными btn.Text = DataBinder.GetPropertyValue(item.DataItem, DataTextField).ToString(); btn.CommandName = DataBinder.GetPropertyValue(item.DataItem, DataValueField).ToString(); } Для связывания свойств с данными используется класс DataBinder. Заметьте, что класс отделенного кода (где находится весь приводимый мною код) ничего не знает об ADO.NET и перечислимых коллекциях данных. С ними работает объект DataBinder, которому мы просто передаем значения DataTextField и DataValueField и получаем соответствующие данные. Когда пользователь щелкает одну из кнопок, элемент управления Repeater гене-рирует событие ItemCommand. protected void ItemCommand(object sender, RepeaterCommandEventArgs e) { //Обновляем внутреннее состояние CurrentButtonIndex = e.Item.ItemIndex; //Генерируем событие ButtonClicked для клиента ButtonClickedEventArgs ev = new ButtonClickedEventArgs(); ev.ButtonCommand = e.CommandName;
Пользовательские элементы управления ASP.NET Глава 12 441 ev.ButtonIndex = CurrentButtonIndex; OnButtonClicked(ev); //Обновляем пользовательский интерфейс BindData(); } Объект класса RepeaterCommandEventArgs содержит индекс элемента, который щелкнул пользователь, и имя команды данного элемента. Эти сведения упаковыва-ются в структуру типа ButtonClickedEventArgs и передаются клиентскому обработчику события. Формирование клиентской страницы Итак, наш элемент управления ButtonList готов к работе, так что давайте посмотрим, как можно создать клиентскую страницу с его использованием. Следующая директива регистрирует элемент управления для страницы: <%@Register TagPrefix="expo" TagName="ButtonList" Src="buttonlist.ascx" %> Заметьте, что вы можете по своему желанию изменять содержимое атрибутов TagName и TagPrefix. В следующем коде объявляется пара элементов управления ButtonList с общим обработчиком события ButtonClicked: <expo:buttonlist runat="server" id="initialStrip" onbuttonclicked="ButtonClicked" /> <expo:buttonlist runat="server" id="yearStrip" onbuttonclicked="ButtonClicked" /> Страница отвечает за загрузку данных из источника и связывание с ними элемента управления. void Page_Load(object sender, EventArgs e) { if (!IsPostBack) { BindInitials(); BindYears(); } }private void BindInitials() { DataTable data = GetData_Initials(); initialStrip.DataSource = data; initialStrip.DataTextField = "Initial"; initialStrip.DataValueField = "Initial"; initialStrip.DataBind(); }private void BindYears() { DataTable data = GetData_Years(); yearStrip.DataSource = data; yearStrip.DataTextField = "Year"; yearStrip.DataValueField = "Year";
442 Часть III Элементы управления ASP.NET yearStrip.DataBind(); }private DataTable GetData_Years() { DataTable data = new DataTable(); SqlDataAdapter adapter = new SqlDataAdapter(m_cmdYears, m_connString); adapter.Fill(data); return data; }private DataTable GetData_Initials() { DataTable data = new DataTable(); SqlDataAdapter adapter = new SqlDataAdapter(m_cmdInitial, m_connString); adapter.Fill(data); return data; } В демонстрационном коде, который мы рассматриваем, функции BindInitials и BindYears выполняют следующие запросы к базе данных NorthWind: --Получение первой буквы имени каждого клиента SELECT DISTINCT substring(companyname, 1, 1) AS Initial FROM customers --Получение списка лет, в которые был сделан хоть один заказ SELECT DISTINCT year(orderdate) AS Year FROM orders Следующий код показывает, как инициализировать элементы управления initialStrip; инициализация элемента управления yearStrip выполняется аналогично. initialStrip.DataSource = data; initialStrip.DataTextField = "Initial"; initialStrip.DataValueField = "Initial"; initialStrip.DataBind(); Созданная страница показана на рис. 12-3. Код, обрабатывающий событие ButtonClicked обоих элементов управления, при-веден ниже. //Пространство имен "ProAspNet.CS.Ch10" импортировано void ButtonClicked(object sender, ButtonClickedEventArgs e) { string t1 = "Customer names that fall under the <b>{0}.</b> " + "tab named <b>'{1}'</b>."; string t2 = "Order information that falls under the <b>{0}.</b> " + "tab named <b>'{1}'</b>." //Распознаем отправителя и обновляем элемент управления label. //Если бы для каждого элемента управления ButtonList был написан //свой обработчик события, эта проверка была бы ненужна if (sender.Equals(initialStrip)) msg1.Text = String.Format(t1, 1 + e.ButtonIndex, e.ButtonCommand);
Пользовательские элементы управления ASP.NET Глава 12 443 else msg2.Text = String.Format(t2, 1 + e.ButtonIndex, e.ButtonCommand); }Рис. 12-3. Демонстрационная страница с элементами управления ButtonList Поскольку мы реализовали свойство DataSource с использованием объекта Cache, важно, чтобы в составе хост-страницы был определен обработчик события RefreshData, генерируемого пользовательским элементом управления, когда он не может найти данные для связывания. Ниже приведена реализация данного обработчика для при-мера, продемонстрированного на рис. 12-3. protected void RefreshData(object sender, RefreshDataEventArgs e) { if (sender.Equals(initialStrip)) e.DataSource = GetData_Initials(); else e.DataSource = GetData_Years(); }Динамическая загрузка элементов управления Подобно любым другим серверным элементам управления ASP.NET, пользователь-ские элементы управления можно создавать программным способом. Однако в коде страницы для этой цели применяется не оператор new, а метод LoadControl. Метод LoadControl Метод LoadControl определен в базовом классе TemplateControl. Он загружает объект Control из файла, путь к которому указан в качестве аргумента. Control ctl = LoadControl("ButtonList.ascx"); Метод возвращает ссылку на родовой объект Control, и вам нужно привести ее к соответствующему типу, чтобы получить возможность работать с элементом уп-равления и устанавливать его свойства. Атрибут ClassName директивы @Control яв-ляется единственным средством, позволяющим задать имя класса пользовательского элемента управления. Для приведения объекта к строгому типу нужно иметь ссылку на сборку, которая содержит откомпилированный код элемента управления. Данной цели служит директива @Reference. Примечание Если элемент управления поддерживает кэширование, типом объекта, возвращаемого методом LoadControl, является не Control, а PartialCachingControl.
444 Часть III Элементы управления ASP.NET Директива @Reference Когда вы создаете пользовательский элемент управления программно, его строгий тип становится доступным странице только после того, как вы создадите на него ссылку. Следующий код создает ссылку на пользовательский элемент управления ButtonList, определенный в файле buttonlist.ascx: <%@Reference Control="buttonlist.ascx" %> Цель использования этой директивы - сделать доступным странице тип задан-ного элемента управления. Если пользовательский элемент управления не содержит атрибута ClassName, этот тип называется ASP.buttonlist_ascx, в противном случае его имя ASP.XXX, где XXX - значение атрибута ClassName. Директива @Reference указывает, что заданный пользовательский элемент уп-равления (или страница) должен быть динамически откомпилирован и связан с те-кущей страницей либо с текущим элементом управления. Директива поддерживает только два взаимоисключающих атрибута: Page и Control. В обоих задается URL и идентификатор Web-элемента, который необходимо связать с текущей страницей или элементом. Создав ссылку на файл .ascx, вы можете программным способом создавать экземпляры пользовательского элемента управления: ButtonList btn = (ButtonList) LoadControl("buttonlist.ascx"); В общем случае директива @Register применяется для регистрации объявленных в составе страницы пользовательских элементов управления, экземпляры которых создаются системой. А директива @Reference используется в тех случаях, когда вы создаете элементы управления программным способом. Заключение Пользовательские элементы управления - это род серверных элементов управле-ния, создаваемых программистом тем же способом, каким создаются Web-страницы. Обычно при этом приходится писать совсем немного кода, а в некоторых случаях элемент управления и вовсе его не имеет. На возможности и функции таких элементов управления не налагаются никакие ограничения, а количество и сложность их кода зависят только от ваших целей. Такого рода элементы управления позволяют без труда выделять и повторно ис-пользовать части пользовательского интерфейса приложения и являются идеальным решением для ситуаций, когда необходима такая возможность. Код пользовательских элементов управления компилируется на лету, подобно коду Web-страниц, и точно так же может быть либо встроенным, либо содержащимся в файле отделенного кода. А вот для ситуаций, когда требуется разработать иерархию элементов управления, строго придерживаясь объектно-ориентированной модели, пользовательские элементы управления не подходят. Хотя их наследование и возможно, наличие разметки за-трудняет решение этой задачи. Вы можете выделить код пользовательского элемента управления в отдельный класс и использовать его повторно, но разметка останется отдельным компонентом, которым трудно управлять программно. Для таких случаев существует иное решение - создать специализированный элемент управления. Но это тема следующих двух глав. Мы начали данную главу с разработки простейшего интерактивного элемента уп-равления, демонстрирующего то, как рассматриваемая технология обеспечивает пов-торное использование частей интерфейса сайта. После этого была создана объектная модель элемента управления. А в завершение мы установили связь элемента управ-ления с данными. Вы уже можете представить, как, следуя приведенным указаниям, 
Пользовательские элементы управления ASP.NET Глава 12 445 можно разработать элемент управления, обладающий сложным пользовательским интерфейсом в соединении с бизнес-логикой и логикой доступа к данным. Только факты По своей природе пользовательский элемент управления является Web-формой, построенной из клиентских и серверных элементов управления, литералов, сер-верного кода и клиентских сценариев. Пользовательский элемент управления реализуется в виде серверного файла с рас-ширением .ascx, и ссылка на этот файл включается в страницы и другие пользо-вательские элементы управления, где он используется. Подобно страницам и элементам управления ASP.NET, пользовательские элементы управления компилируются при первом к ним обращении, в результате чего созда-ются сборки, кэшируемые для ускорения обработки последующих запросов. Страница ASP.NET может быть без особых усилий превращена в пользовательский элемент управления - для этого достаточно удалить из нее тэги <html>, <body> и <form>, а директиву @Page заменить на @Control. Пользовательский элемент управления - наименьшая часть страницы с кэши-руемым выводом. Так что если вы хотите кэшировать вывод определенной части страницы, превратите эту часть в такой элемент управления. 
Глава 13 Создание специализированных элементов управления ASP.NET Специализированный элемент управления Microsoft - это компилируемый серверный компонент, инкапсулирующий пользовательский интерфейс и ту или иную функцио-нальность. Такие элементы отличаются от стандартных серверных элементов управ-ления ASP.NET лишь тем, что разрабатываются программистами, нуждаются в явной регистрации и развертывании и у их тэгов другие префиксы. Специализированные элементы управления могут иметь собственные объектные модели и генерировать события. Более того, в конструкторе Microsoft Visual Studio 2005 они выглядят так же, как стандартные элементы управления, они представлены на панели инструментов, их свойства отражаются в окне Properties, а значения этих свойств формируются с помощью построителей свойств, причем работать со специализированными элемен-тами управления можно с помощью визуальных средств конструктора. Не следует путать специализированные элементы управления с пользователь-скими, описанными в предыдущей главе. Последние компилируются динамически, их нельзя добавлять на панель инструментов Visual Studio, а их поддержка времени разработки минимальна. Когда вы добавляете такой элемент на страницу, конструк-тор вводит вместо него стандартное изображение, показывающее, где он размещен, и только. Наконец, пользовательские элементы управления развертываются в виде исходного кода, если осуществляется предкомпиляция всего приложения (см. гла-ву 1). В последнем случае вы можете извлечь динамическую сборку, созданную для пользовательского элемента управления, и использовать ее в нескольких разных приложениях. Специализированные элементы управления ASP.NET - это откомпилированный код. После компиляции такой элемент можно добавить на панель инструментов, чтобы воспользоваться преимуществами визуальной среды разработки Visual Studio 2005. После инсталляции единственной откомпилированной копии специализированного элемента управления в глобальный кэш сборок (GAC) этот элемент становится до-ступным всем приложениям; можно также поместить его в папку \Bin одного прило-жения и тем самым сделать доступным только этому приложению. Специализированный элемент управления - это класс, производный от некото-рого ба зового класса. Стоящая перед вами задача и логика, реализованная в базовом классе, определяют, как много кода вам придется писать в производном классе. Так что если вы найдете существующий элемент управления, хотя бы отчасти соответс-твующий вашим требованиям, пусть даже ему недостает определенной функциональ-ности, проще всего сделать новый класс производным от него и дописать требуемые функции. При этом вы сможете переопределить те или иные свойства, методы и события, а также добавить новые. Ну а если ни один из существующих серверных элементов управления вам не подходит, тогда вам придется самим создавать элемент управления с нуля, сделав его производным от одного из базовых классов элемен-
Создание специализированных элементов управления ASP.NET Глава 13 447 тов управления - Control или WebControl. Эти классы реализуют лишь те функции, которые делают класс элементом управления, а всю прикладную часть (рендеринг, стили, состояние представления и управление состоянием) вы должны будете писать самостоятельно. Существует и еще одно решение, которое мы подробно рассмотрим в этой гла-ве, - создание составного элемента управления. Так называют элемент управления, созданный путем объединения нескольких существующих элементов. Составные и производные элементы управления различаются главным образом своей структурой и механизмом ренедринга. Внимание! На функциональные возможности элементов управления ASP.NET могут налагаться некоторые ограничения, связанные с языком разметки и объектной моде-лью HTML, которые поддерживает целевой браузер. Если вам требуется определенная функциональность, не реализованная ни одним существующим элементом управления, то сначала следует выяснить, возможна ли вообще ее реализация в HTML-окружении и какой поддержки можно ожидать от целевого браузера. Например, не существует стандартного элемента управления, который выводит редактируемое раскрывающееся меню, подобное меню, используемым в Windows Forms. И хотя реализовать его возможно (некоторые сторонние производители это сделали), для работы такого элемента нужно, чтобы на стороне клиента поддерживалась богатая объектная модель DHTML, а так бывает не всегда. Расширение существующих элементов управления Если вы решили, что для выполнения определенной задачи вам требуется специали-зированный элемент управления, задумайтесь над тем, действительно ли эту задачу можно выполнить лишь с использованием HTML, литералов и кода JavaScript. Если вы знаете, как решить ее на чистом HTML, то вам останется только наилучшим обра-зом обеспечить повторное использование необходимой функциональности и сделать элемент наиболее эффективным. Выбор базового класса Любой специализированный элемент управления явно или неявно наследует класс Control - корневой класс серверных элементов управления приложения ASP.NET. Однако лишь немногие элементы управления наследуют его непосредственно, чаще они являются производными от промежуточных классов, реализующих то или иное предопределенное поведение. Наследование базового класса Каждый серверный элемент управления ASP.NET, не помеченный как скрытый, можно наследовать и дорабатывать, делая его все более специализированным. В табл. 13-1 перечислены все классы, которые в ASP.NET представляют ту или иную базовую функциональность. Каждый из них является основой целого семейства элементов управления. Табл. 13-1. Базовые классы, доступные в ASP. NET Класс Версия Реализованные функциональные элементы BaseDataBoundControl 2.0 Базовый механизм и объектная модель для связывания данных. Наследует WebControl BaseDataList 1.x Табличные возможности, такие как сложный рендеринг, шаблоны, разбивка на страницы. Наследует WebControl (см. след. стр.)
448 Часть III Элементы управления ASP.NET Класс Версия Реализованные функциональные элементы CompositeControl 2.0 Механизм создания составных элементов управле-ния в части построения дерева элементов. Наследует WebControl CompositeDataBoundControl 2.0 Механизм создания составных элементов управления в части управления состоянием представления и построения дерева элементов. Наследует DataBoundControl DataBoundControl 2.0 Поддержка элементов управления, представляю-щих источники данных; в этом классе переопреде-лены некоторые абстрактные методы родительско-го класса. Наследует BaseDataBoundControl HierarchicalDataBoundControl 2.0 Поддержка иерархических элементов управле ния, представляющих источники данных; в этом классе переопределены некоторые абстрактные методы родительского класса. Наследует BaseDataBoundControl ListControl 1.x Поддержка специальной объектной модели для списочных элементов управления, таких как Check-BoxList и DropDownList. Введенный в ASP.NET 1.x, этот класс был в ASP.NET 2.0 переработан. Явля-ется производным от DataBoundControl WebControl 1.x Реализация связанных с оформлением элемента свойств, определяющих стили, цвета, шрифты и рамки К числу наиболее часто используемых элементов управления, непосредственно наследующих Control, относятся Repeater, Substitution, MultiView, Placeholder и LiteralControl. Все остальные элементы управления ASP.NET являются произ-водными от них. Расширение базового класса Базовый класс Control реализует несколько важных функций, доступных во всех производных от него элементах управления. Прежде всего это функции контейне-ра именования, управления состоянием представления, идентификации элемента управления, поддержки времени разработки, а в ASP.NET 2.0 также поддержки тем, состояния представления и адаптивного рендеринга. Если вы решите создавать эле-мент как производный от одного из классов, перечисленных в табл. 13-1, то будьте готовы к написанию большого количества кода, поскольку исходный элемент обладает довольно скромной функциональностью. Как правило, один из этих классов наследуется в случаях, когда нужно написать элемент, представляющий уникальные возможности, отсутствующие у других эле-ментов управления ASP.NET. Практически такое решение мало чем отличается от создания элемента управления с нуля. Заметьте, что большинство классов, перечис-ленных в табл. 13-1, предназначены для создания элементов управления, связанных с данными; эту тему мы подробно рассмотрим в следующей главе. Если вы решите, что будет наследоваться класс конкретного элемента управления, то есть такого, у которого имеется определенное поведение и пользовательский интер-фейс, то, скорее всего, вы будете добавлять новые возможности или переопределять имеющиеся, не внося существенных изменений в структуру и поведение элемента. Табл. 13-1. (окончание)
Создание специализированных элементов управления ASP.NET Глава 13 449 Усовершенствование элемента управления HyperLink Давайте начнем с простого пользовательского элемента управления, расширяющего возможности встроенного элемента HyperLink. По умолчанию последний выводит якорный тэг <a>, содержащий определенный URL. Щелчок якорного тэга (выпол-ненный пользователем) обрабатывается браузером, который осуществляет переход к заданной странице, и возврат формы не производится. Следовательно, для того чтобы отслеживать щелчки определенного якоря, придется расширить функции элемента управления HyperLink. Это мы сейчас и сделаем. Разработка сценария использования Идея, которую мы собираемся реализовать в усовершенствованном элементе управ-ления HyperLink, заключается в том, чтобы, не меняя исходного поведения этого элемента, добавить механизм отслеживания щелчков якоря. Классическим примером ситуации, в которой будет полезна такая возможность, является необходимость реа-лизовать на сайте счетчик посещений страницы. Мониторинг активности пользовате-лей - важная задача, и каждый администратор согласится, что данные мониторинга помогают усовершенствовать структуру и наполнение сайта. Как же реализовать такой счетчик, который бы подсчитывал количество щелчков на ссылках, указывающих на конкретный ресурс (например, рекламу)? Можно связать каждый кнопочный элемент управления страницы (Button, HyperLink, ImageButton, LinkButton, AdRotator) с дополнительным слоем кода, кото-рый будет отслеживать щелчки, выполнять необходимые ответные действия, а после этого воспроизводить стандартную реакцию элемента управления. Для элементов управления, инициирующих возврат формы, это несложно. Возьмем, к примеру, класс LinkButton. Потребуется всего лишь создать производный от него элемент управления и переопределить в нем защищенный член OnClick: protected virtual void OnClick(EventArgs e) { //Отслеживаем событие //Выполняем действия по умолчанию base.OnClick(e); } Ну а как быть с элементом управления HyperLink? Ведь он не инициирует возврат формы. Именно эту функцию нам и нужно как-то для него реализовать. Редиректор для элемента управления HyperLink Решить нашу проблему можно очень просто: связать с элементом управления URL вспомогательной страницы, которая будет выполнять необходимые действия, а потом перенаправлять пользователя на ту страницу, которая была запрошена. using System; using System.Web.UI.WebControls; namespace ProAspNet20.Advanced.CS.Components { public class Hyperlink : System.Web.UI.WebControls.HyperLink { public string RedirectPage { get { object o = ViewState["RedirectPage"];
450 Часть III Элементы управления ASP.NET if (o == null) return "redir.aspx"; else return (string)o; } set { ViewState["RedirectPage"] = value; } } public new string NavigateUrl { get { return base.NavigateUrl; } set { string url = "{0}?page={1}"; url = String.Format(url, RedirectPage, value); base.NavigateUrl = url; } } } } Мы снабдили элемент управления новым свойством RedirectPage и переопределили существующее свойство NavigateUrl. В свойстве RedirectPage задается URL промежу-точной страницы, куда пользователь ненадолго перенаправляется для выполнения специализированной задачи, такой как учет щелчков ссылки. Ниже приведено со-держимое файла кода промежуточной страницы. public partial class Redir : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { //Перехватываем исходный запрос страницы string url = String.Empty; object o = Request["Page"]; if (o != null) { url = (string) o; if (String.IsNullOrEmpty(url) return; } //Выполните здесь необходимые действия, такие как увеличение счетчика //Перенаправляем пользователя на запрошенную страницу Response.Redirect(url); } } Мы предполагаем, что наш специализированный элемент управления HyperLink вызывает страницу-редиректор, передав в строке запроса параметр Page, содержащий исходный URL. Конечно, вы можете придумать и какое-нибудь другое решение. URL для перехода по гиперссылке задается в свойстве NavigateUrl. Вы же долж-ны обеспечить его подмену. Скажем, если в разметке страницы будет задан URL http://www.asp.net, то его нужно заменить такой строкой: redir.aspx?page=http://www.asp.net
Создание специализированных элементов управления ASP.NET Глава 13 451 Тогда пользователь сначала попадет на страницу redir.aspx, а оттуда будет пере-направлен по адресу http://www.asp.net. Чтобы вы могли переопределить мутатор (или аксессор) свойства элемента управ-ления, это свойство должно быть помечено в каком-то месте цепочки наследования как virtual. У элемента управления HyperLink имеется виртуальное свойство Text и несколько открытых, но не являющихся виртуальными свойств, к числу которых отно-сятся Target и NavigateUrl. Если свойство не помечено как virtual, переопределить его нельзя, но можно полностью заменить его реализацию. Для этого в C# используется модификатор new, а в Microsoft Visual Basic .NET - модификатор Shadows. public new string NavigateUrl { get { return base.NavigateUrl; } set { string url = "{0}?page={1}"; url = String.Format(url, RedirectPage, value); base.NavigateUrl = url; } } Модификатор new указывает компилятору, что новая реализация свойства должна заменить ту, которая имеется в базовом классе. Если вы попытаетесь переопределить свойство NavigateUrl без этого ключевого слова, компилятор выдаст предупреждение о том, что вы скрываете существующий член класса, и порекомендует применить ключевое слово new, если это было сделано намеренно. Создание элементов управления с нуля Специализированные элементы управления разработчик создает в двух случаях: когда нужного ему элемента просто не существует и когда имеющемуся элементу не хватает важной функции. В последнем случае просто создается производный элемент управления, и в нем эта функция реализуется. Рассмотрим процесс создания элемента управления с нуля. Базовый класс и интерфейсы Разработка пользовательских элементов управления в ASP.NET имеет два важных аспекта. Во-первых, в системе определены два базовых класса, Control и WebControl, и вам нужно выбрать из них наследуемый класс. Кроме того, существует ряд интер-фейсов, наследование которых помогает определить поведение и модель программиро-вания элемента управления. Среди них наиболее важными являются INamingContainer, IPostBackDataHandler, IPostBackEventHandler и имеющийся только в ASP.NET 2.0 интерфейс ICallbackEventHandler. Базовые классы элементов управления были перечислены в табл. 13-1. Поскольку тема связывания элементов управления с данными рассматривается в следующей главе, сейчас мы поговорим об элементах управления Control и WebControl. Сравнение элементов управления Control и WebControl Класс Control определяет свойства, методы и события, общие для всех серверных элементов управления. К их числу относятся методы и события, определяющие жиз-ненный цикл элемента управления, и несколько свойств, таких, как ID, UniqueID, Parent, ViewState и коллекция дочерних элементов управления Controls.
452 Часть III Элементы управления ASP.NET Класс WebControl является производным от Control и имеет несколько дополни-тельных свойств и методов, главным образом связанных со стилями. К числу этих свойств относятся ForeColor, BackColor, Font, Height и Width. Данный класс является базовым для многих элементов управления ASP.NET. При разработке нового элемента управления ASP.NET в первую очередь нужно следовать такому правилу. Если ваш элемент управления имеет пользовательский интерфейс, лучше сделать его производным от WebControl. Если же вы разрабатываете компонент, не имеющий пользовательского интерфейса, то лучше взять за основу класс Control. Хотя в большинстве случаев эти правила эффективны, из них есть исключения, так что в конечном счете все будет зависеть от ситуации. Например, можно сделать класс производным от Control, если вы хотите реализовать некото-рое подмножество элементов пользовательского интерфейса. Создавая составные элементы управления, содержащие в себе несколько самостоятельных элементов, в ASP.NET 2.0 лучше выбрать базовым класс CompositeControl, а в ASP.NET 1.x, где этого нового класса нет, - Control. И никогда не следует делать специализированные элементы управления производными от UserControl. Связанные интерфейсы Исходя из назначения элемента управления, вы можете определить для него дополни-тельные интерфейсы. Как правило, серверный элемент управления реализует следу-ющие четыре интерфейса. INamingContainer - это маркерный интерфейс, не содержащий методов, он просто уведомляет исполняющую среду ASP.NET о том, что элемент управления, имею-щий данный интерфейс, должен рассматриваться как контейнер именования. Тогда к значению свойства UniqueID дочерних элементов управления, содержащихся в контейнере именования, добавляется префикс - идентификатор контейнера. Таким образом обеспечивается уникальность имен дочерних элементов управле-ния в пределах всей страницы, где используется элемент-контейнер, играющий роль пространства имен. По этой причине интерфейс INamingContainer является существенным компонентом составных элементов управления, а также элементов управления, содержащих шаблоны. (О шаблонах я подробнее расскажу в следу-ющей главе.) IPostBackDataHandler - это интерфейс, необходимый в тех случаях, когда специа-лизированный элемент управления должен анализировать данные, полученные при возврате формы. Если пользователь выполнил действие, отражающееся на состоя-нии элемента, то данные возврата формы вам необходимы. Например, хотя элемент управления TextBox сохраняет свою конфигурацию в состоянии представления, вам необходим и тот текст, который пользователь ввел в браузере. Вот тут и приходит вам на помощь интерфейс IPostBackDataHandler. Его метод LoadPostData позво-ляет проанализировать полученные от клиента значения. Кроме того, интерфейс полезен, когда нужно генерировать на сервере события, связанные с изменением данных (метод RaisePostDataChanged). Опять таки, хорошим примером является поведение элемента управления TextBox: если между последовательными возвра-тами формы его данные изменились, генерируется также событие TextChanged. IPostBackEventHandler - интерфейс, позволяющий перехватывать клиентские со-бытия, которые вызывают возврат формы (такие как щелчок мыши). При возврате формы исполняющая среда ASP.NET генерирует события, сигнализирующие об изменении данных, а затем ищет пользовательский элемент управления, значе-ние свойства UniqueID которого соответствует имени возвращенного значения (например, имени кнопки, которую щелкнул пользователь). Если соответствие 
Создание специализированных элементов управления ASP.NET Глава 13 453 найдено и элемент управления реализует интерфейс IPostBackEventHandler, ASP. NET вызывает единственный метод данного интерфейса - RaisePostBackEvent. Действия, выполняемые элементом управления в этом методе, зависят от типа элемента. Например, элемент Button генерирует в нем событие Click. ICallbackEventHandler - интерфейс, наличие которого дает возможность использо-вать элемент управления как целевой объект обратного вызова клиентского сцена-рия (см. главу 6). В главе 7 демонстрировался элемент управления Web Part, реа-лизующий обратные вызовы с использованием интерфейса ICallbackEventHandler, хотя я и не упоминал об этом факте. Выбор способа рендеринга Единственной задачей серверного элемента управления обычно является вывод раз-метки. Сначала, конечно, он ее генерирует, на что нацелена вся его объектная модель, но конечным результатом является именно выводимая разметка. Выполнять эту задачу элемент управления может по-разному. Метод Render Как правило, элемент управления выводит результаты своей работы с помощью метода Render. Поэтому для получения полного контроля над процессом рендеринга нужно переопределить этот метод. Сигнатура метода Render такова: protected override void Render(HtmlTextWriter writer) Объект записи HTTP-текста ( HtmlTextWriter) - это нечто вроде буфера, где накап-ливается выводимый текст. Вы составляете разметку, используя методы объек та HtmlTextWriter либо просто формируете выводимую строку. Запись текста в объект HtmlTextWriter - обычно простейший способ генерирования разметки, но, к сожале-нию, код, который выполняет такую запись, нельзя назвать удобочитаемым. Если вы будете пользоваться этим объектом для вывода сложного элемента управления, то у вас получится запутанная конструкция из массы вложенных условных операторов, так что код будет трудно читать и сопровождать. Есть еще один аспект, связанный с непосредственным выводом разметки. Рассмот-рим следующий фрагмент кода: protected override void Render(HtmlTextWriter writer) { writer.Write("<input type=text id=\"TextBox1\" />"); } В результате его выполнения страница будет содержать поле для ввода текста, имеющее идентификатор TextBox1. Но серверное окружение ничего не знает об этом элементе и не сможет правильно обрабатывать для него серверные события. Все это означает, что непосредственно выводить разметку в выходной поток можно только для тех элементов, которые выводят чистый HTML, не имеющий эквивалентных сервер-ных элементов управления и не нуждающихся в генерировании и обработке серверных событий, таких как возврат формы и события, связанные с изменением данных. Если вы выводите серверный элемент управления, который выполняет рендеринг бегущей строки или таблицы данных, то можно просто записывать его в буферный объект. Но если элемент управления должен состоять из других элементов управления, лучше программным способом построить его дерево элементов. Построение дерева элементов Когда элемент управления имеет дочерние элементы управления, он называется со-ставным. Для такого элемента рекомендуется программным способом строить дерево 
454 Часть III Элементы управления ASP.NET элементов, переопределив метод CreateChildControls класса Control. В нем вы должны будете добавить все дочерние элементы управления в коллекцию Controls. Вот пример реализации метода CreateChildControls: protected override void CreateChildControls() { //Очищаем коллекцию дочерних элементов управления Controls.Clear(); //Строим дерево элементов управления CreateControlHierarchy(); //Очищаем состояние представления дочерних элементов управления ClearChildViewState(); } ClearChildViewState - это метод класса Control, удаляющий информацию состоя-ния представления, связанную с каждым из дочерних элементов управления. Метод CreateControlHierarchy определяется пользователем и строит дерево элементов управ-ления. Хот он может иметь произвольное имя, в большинстве составных элементов управления ASP.NET этот метод называется CreateControlHierarchy; в них он является защищенным и переопределяемым. Ниже приведен пример реализации данного ме-тода, создающего текстовое поле с надписью. Заметьте, что произвольным является не только имя метода, но и его прототип. protected void CreateControlHierarchy() { //Добавляем надпись Label lbl = new Label(); lbl.Text = "Some text"; Controls.Add(lbl); //Добавляем пустой литерал, //чтобы сделать отступ Controls.Add(new LiteralControl("&nbsp;&nbsp;")); //Добавляем текстовое поле TextBox txt = new TextBox(); txt.Text = String.Empty; Controls.Add(txt); //Указываем, что дочерние элементы управления созданы ChildControlsCreated = true; } Задача метода CreateControlHierarchy - заполнить коллекцию Controls текущего элемента управления дочерними элементами управления, правильно определив для них позиции в иерархии. Булево свойство ChildControlsCreated, определенное в классе Control, указывает, все ли дочерние элементы управления созданы. Если элемент управления составной, вам не нужно переопределять метод Render, но рекомендуется реализовать маркерный интерфейс INamingContainer, чтобы обеспечить для ASP.NET возможность распознавать события возврата формы, инициированные дочерними элементами управления.
Создание специализированных элементов управления ASP.NET Глава 13 455 Совет В ASP.NET 2.0 обязательно делайте составной элемент управления производным от класса CompositeControl. Таким образом будет сэкономлено время при работе в ди-зайнере Visual Studio 2005 и гарантирован правильный рендеринг элемента управления во время выполнения, а также правильное его отображение во время разработки. И без такого базового класса элемент будет правильно работать во время выполнения, но в Web-форме в дизайнере вы его не увидите. В ASP.NET 1.x можно было решить этот воп-рос, переопределив метод Render так, чтобы он явно перестраивал иерархию в режиме дизайна. Наконец нужно упомянуть и о методе EnsureChildControls. Он проверяет, все ли дочерние элементы созданы, и если нет - создает их. Однако как элементу управле-ния об этом узнать? Он просто читает значение булева свойства ChildControlsCreated и вызывает метод CreateChildControls, если дочерние элементы управления еще не созданы. Ниже показано, как работает этот метод. protected virtual void EnsureChildControls() { if (!ChildControlsCreated) { try { CreateChildControls(); } finally { ChildControlsCreated = true; } } }Элемент управления SimpleGaugeBar Чтобы разобраться в том, как создаются новые элементы управления ASP.NET, давай-те создадим элемент, имеющий совсем не много данных состояния, но обладающий мощным механизмом рендеринга. Этот элемент, который мы назовем SimpleGaugeBar, будет выводить визуальный индикатор выполнения операции. Определение объектной модели Нашему элементу управления потребуются как минимум два свойства: одно будет представлять выводимое значение, в второе - величину шкалы. Кроме того, мы дадим пользователю возможность определить, как должна выглядеть шкала, и задать формат текста, представляющего текущее и максимальное значения. В табл. 13-2 перечислены свойства элемента управления SimpleGaugeBar. Табл. 13-2. Свойства элемента управления SimpleGaugeBar Свойство Описание FormatString Формат строки, которую элемент управления будет выводить рядом с индика-тором. Эта строка может содержать два подстановочных параметра для вывода текущего и максимального значений. По умолчанию строка имеет такой вид: {0} /{1} GridLines Указывает, должны ли выводиться вертикальные разделители секций Maximum Максимальное значение, заданное для индикатора. По умолчанию данное свойство имеет значение 100 Segments Количество сегментов, на которые нужно разделить шкалу индикатора. По умолчанию данное свойство имеет значение 4 (см. след. стр.)
456 Часть III Элементы управления ASP.NET Свойство Описание Value Текущее значение, представляемое индикатором. Это свойство по умолчанию имеет значение 0 и не может превышать заданный максимум Мутатор свойства Value корректирует присваиваемое свойству значение таким об-разом, чтобы оно не превышало заданного максимума - значения свойства Maximum. Строка форматирования текста элемента управления может содержать два параметра: Value ({1}) и Maximum ({2}). В ней можно задавать любое HTML-форматирование и указывать параметры в любом порядке. Вот два примера: GaugeBar1.FormatString = "{0} ({1})"; GaugeBar2.FormatString = "Maximum is {1}. Value is <b>{0}</b>"; Элемент управления SimpleGaugeBar не имеет методов и не генерирует событий. Реализация объектной модели Для создания визуального индикатора наш элемент управления использует HTML-таб-лицу. Значения свойств Value и Maximum он переводит в проценты. На рис. 13-1 показано, как элемент управления SimpleGaugeBar выглядит в дизайнере Visual Studio 2005. Рис. 13-1. Элемент управления SimpleGaugeBar в дизайнере Visual Studio Сегменты шкалы, которые вы видите на рисунке, - это просто ячейки таблицы, так что для их создания достаточно задать для таблицы количество столбцов, равное значению свойства Segments. Следующий код показывает, как реализованы свойства элемента управления. public class SimpleGaugeBar : CompositeControl { private int _dividerCell; public SimpleGaugeBar() { } //Значение, представленное индикатором public float Value { get { object o = ViewState["Value"]; if (o == null) return 0; return (float) o; } set { ViewState["Value"] = value; if (value > Maximum) ViewState["Value"] = Maximum; } Табл. 13-2. (окончание)
Создание специализированных элементов управления ASP.NET Глава 13 457 } //Максимальное значение public float Maximum { get { object o = ViewState["Maximum"]; if (o == null) return 100; return (float) o; } set { ViewState["Maximum"] = value; } } //Количество сегментов public int Segments { get { object o = ViewState["Segments"]; if (o == null) return 4; return (int) o; } set { ViewState["Segments"] = value; if( value < 1) ViewState["Segments"] = 1; } } //Строка форматирования значения public string FormatString { get { object o = ViewState["FormatString"]; if (o == null) return "<b>{0}</b> /<b>{1}</b>"; return (string) o; } set { ViewState["FormatString"] = value; } } //Признак наличия сегментов public bool GridLines { get { object o = ViewState["GridLines"]; if (o == null) return true; return (bool) o; } set { ViewState["GridLines"] = value; } } }
458 Часть III Элементы управления ASP.NET Свои данные наш элемент управления держит в коллекции ViewState. Поскольку все его свойства открытые, можно обойтись и без использования состояния представ-ления, явно устанавливая свойства при загрузке страницы. Внимание! Страница может отключить поддержку состояния представления для всех или некоторых своих элементов управления. Однако учтите, что в случае если элемент управления хранит в состоянии представления свои закрытие или защищенные свойства, отключение поддержки состояния представления может привести к потере функцио-нальности такого элемента. Ведь закрытые и защищенные свойства нельзя программно устанавливать из хост-страницы. Формирование индикатора Шкала нашего индикатора делится на сегменты равной величины, которые заполня-ются пропорционально текущему отображаемому значению. Каждый сегмент - это одна ячейка таблицы. Первоначально все сегменты, кроме первого, пусты. Заполнение сегментов осуществляется путем смены фонового цвета ячейки таблицы. Пустые ячейки выводятся текущим фоновым цветом, а заполненные - текущим цветом текста. Одна ячейка, называемая разделительной, содержит дочернюю однострочную таблицу с двумя столбцами, первый из которых окрашен цветом текста, а второй - цветом фона элемента управления. В следующем HTML-коде демонстрируется разметка в тот момент, когда выполнено 52 % операции. Шкала в данном примере поделена на четыре сегмента. <table><tr> <td bgcolor=orange width=25%></td> <td bgcolor=orange width=25%></td> <td> <table><tr> <td bgcolor=orange width=2%></td> <td bgcolor=white width=98%></td> </tr></table> </td> <td bgcolor=white width=25%></td> </tr></table> На рис. 13-2 внизу показано, как выглядит элемент управления в разные моменты времени и с разными значениями свойств. Рис. 13-2. Элемент управления SimpleGaugeBar с разными значениями свойств
Создание специализированных элементов управления ASP.NET Глава 13 459 Настройка внешнего вида элемента управления Как вы, вероятно, уже догадались, помимо свойств, перечисленных в табл. 13-2, у на-шего элемента управления есть и другие свойства. В частности, это два цветовых свойства, BackColor и ForeColor, а также размеры шкалы, Width и Height. Значения всех этих свойств можно задавать как программно, так и в дизайнере Visual Studio. Заметьте, что приведенная выше реализация свойств предполагает наличие возмож-ности установки только предопределенных цветов. Рендеринг элемента управления Пользовательский интерфейс нашего элемента управления формируется с использо-ванием чистого HTML. Как уже упоминалось, генерировать его можно либо с помо-щью специального объекта для записи HTML, либо путем формирования в памяти объектного представления вывода с использованием серверных элементов управления, которые сами осуществят свой рендеринг. Давайте подробнее рассмотрим обе эти возможности. Генерирование HTML-кода С точки зрения производительности вывод разметки в объект для записи HTML, безусловно, предпочтительнее, поскольку в этом случае не приходится создавать эк-земпляры серверных элементов управления. Однако такое решение имеет несколько недостатков, главный из которых заключается в том, что код, осуществляющий вызовы объекта для записи HTML, обычно получается сложным и неудобочитаемым, что влечет за собой лишние затраты на его сопровождение. Рассмотрим пример. Для записи содержимого строки в ячейку таблицы необходимо выполнить сле-дующий код: output.WriteFullBeginTag("table"); output.WriteFullBeginTag("tr"); output.WriteFullBeginTag("td"); output.Write(text); output.WriteEndTag("td"); output.WriteEndTag("tr"); output.WriteEndTag("table"); Если вам не нужно осуществлять рендеринг атрибутов, то приведенный код можно сократить: output.Write("<table><tr><td>"); output.Write(text); output.Write("</td></tr></table>"); Однако оба эти подхода не оптимальны, и в общем случае рекомендуется их со-четать. Первый плох тем, что выполняется слишком много вызовов, а второй требует повышенного внимания программиста и чреват ошибками. Вспомним теперь, что в ASP.NET каждый элемент HTML-кода может быть пред-ставлен на сервере экземпляром соответствующего класса, чем обеспечивается ис-ключительная гибкость и простота разработки страниц. Однако и здесь есть свои недостатки: вам приходится создавать экземпляры множества элементов управления, что, конечно, сказывается на производительности приложения. Примечание В общем случае использование серверных элементов управления в ASP.NET все же является более предпочтительным решением. Однако не следует выбирать его в ситуациях, когда элемент управления совсем уж прост. Если нужно вывести констан-тный текст, нет никакой веской причины для того, чтобы создавать экземпляр элемента управления Label вместо вывода этого текста в объект writer.
460 Часть III Элементы управления ASP.NET Рендеринг с использованием дочерних элементов управления Специализированные элементы управления нередко представляют собой сложную инфраструктуру, сформированную из вложенных таблиц и других элементов. В таких случаях, безусловно, имеет смысл построить в памяти дерево элементов управления и затем осуществить рендеринг, вызвав метод RenderContents для его корневого элемен-та. Обычно для элементов со сложной иерархией и богатым стилевым оформлением переопределяют метод Render, как показано ниже: protected override void Render(HtmlTextWriter output) { //Пользовательский метод, который должен обеспечить //правильное оформление всех элементов. PrepareControlForRendering(); //Рендеринг содержимого элемента управления base.RenderContents(output); } Реализация метода PrepareControlForRendering будет описана далее в этой главе. Элемент управления SimpleGaugeBar выводит нетривиальную табличную структу-ру, которую гораздо легче сформировать с использованием дерева элементов управ-ления. protected override void CreateChildControls() { Controls.Clear(); CreateControlHierarchy(); ClearChildViewState(); }protected virtual void CreateControlHierarchy() { //Создаем внешнюю таблицу-контейнер Table outer = new Table(); TableRow outerRow = new TableRow(); outer.Rows.Add(outerRow); //Ячейка шкалы TableCell rulerCell = new TableCell(); outerRow.Cells.Add(rulerCell); BuildGaugeBar(rulerCell); //Текстовая ячейка TableCell textCell = new TableCell(); if (!_textStyle.DisplayTextAtBottom) { outerRow.Cells.Add(textCell); BuildLabel(textCell); } //Сохраняем дерево элементов - добавляем таблицу как дочернюю Controls.Add(outer); //Создаем надпись if (!_textStyle.RenderInsideTable && _textStyle.DisplayTextAtBottom) BuildLabel(null);
Создание специализированных элементов управления ASP.NET Глава 13 461 }void BuildGaugeBar(TableCell container) { //Создаем таблицу с одной или двумя строками: шкала и надпись Table t = new Table(); TableRow ruler = new TableRow(); t.Rows.Add(ruler); //Формируем строку шкалы BuildRuler(ruler); //Формируем надпись if (_textStyle.RenderInsideTable) BuildLabelIntoTable(t); //Сохраняем дерево элементов container.Controls.Add(t); } Вывод элемента управления SimpleGaugeBar состоит из внешней однострочной таблицы с двумя ячейками, первая из которых содержит шкалу, а вторая - необяза-тельный текст (см. рис. 13-2). Если бы текст выводился ниже шкалы, он мог бы разме-щаться во второй строке таблицы или в отдельном элементе управления Label. Стили для рендеринга текста определяются в пользовательском свойстве TextStyle, о котором я расскажу чуть ниже, а сейчас сконцентрируйте свое внимание на шкале. Шкала выводится в виде набора ячеек таблицы, каждая из которых соответствует одному сегменту. Количество сегментов, как вы помните, определяется свойством Segments, а текущее и максимальное отображаемое на шкале значения - свойствами Value и Maximum. Исходя из текущего значения, наш код решает, в какой из двух цветов окрасить каждую из ячеек. При этом ячейка-разделитель может быть поделена на две части, как показано на рис. 13-3. В таком случае она выводится как вложенная таблица с двумя ячейками. void BuildRuler(TableRow ruler) { //Вычисляем значение, которое нужно представить float val = GetValueToRepresent(); float valueToRepresent = 100f * val /Maximum; int numOfSegments = GetNumOfSegments(); int segmentWidth = 100 /numOfSegments; bool finished = false; for (int i = 1; i <= numOfSegments; i++) { if (valueToRepresent < i * segmentWidth) { if (finished) { //Осталось TableCell stillToDo = new TableCell(); ruler.Cells.Add(stillToDo); stillToDo.Width = Unit.Percentage(segmentWidth); } else {
462 Часть III Элементы управления ASP.NET //Ячейка, подлежащая разделению _dividerCell = i -1; //нужен 0-базированный индекс TableCell cell = new TableCell(); ruler.Cells.Add(cell); cell.Width = Unit.Percentage(segmentWidth); cell.Height = Unit.Percentage(100); //Добавляем в ячейку дочернюю таблицу Table child = new Table(); child.Width = Unit.Percentage(100); child.Height = Unit.Percentage(100); cell.Controls.Add(child); child.CellPadding = 0; child.CellSpacing = 0; TableRow childRow = new TableRow(); child.Rows.Add(childRow); float fx = (100 * (valueToRepresent -segmentWidth * (i -1)) /segmentWidth); if (valueToRepresent > (i -1) * segmentWidth) { TableCell left = new TableCell(); childRow.Cells.Add(left); left.Width = Unit.Percentage(fx); } TableCell right = new TableCell(); childRow.Cells.Add(right); right.Width = Unit.Percentage(100 -fx); finished = true; } } else { //Готово TableCell done = new TableCell(); ruler.Cells.Add(done); done.Width = Unit.Percentage(segmentWidth); } } }Рис. 13-3. Ячейка-разделитель в элементе управления SimpleGaugeBar Текст может выводиться справа от шкалы или под ней. Во втором случае он ли бо включается в таблицу, либо выводится в отдельном элементе управления. Функция 
Создание специализированных элементов управления ASP.NET Глава 13 463 BuildLabel выводит текст в виде дополнительного элемента управления или в крайней справа ячейке, а функция BuildLabelIntoTable записывает его во вторую строку таблицы под шкалой, и тогда он наследует визуальные свойства шкалы. void BuildLabel(TableCell container) { //Вычисляем значение, которое нужно представить float buf = GetValueToRepresent(); //Получаем строку для вывода string msg = GetTextToRepresent(); Label lbl = new Label(); if (container is TableCell) container.Controls.Add(lbl); else Controls.Add(lbl); lbl.Text = String.Format(msg, buf, Maximum); }//Строит дерево элементов управления для надписи void BuildLabelIntoTable(Table t) { //Вычисляем значение, которое нужно представить float buf = GetValueToRepresent(); int numOfSegments = GetNumOfSegments(); //Получаем строку для вывода string msg = GetTextToRepresent(); if (_textStyle.DisplayTextAtBottom) { //Добавляем нижнюю строку TableRow label = new TableRow(); t.Rows.Add(label); TableCell lblCell = new TableCell(); label.Cells.Add(lblCell); lblCell.ColumnSpan = numOfSegments; lblCell.Text = String.Format(msg, buf, Maximum); } } Примечание В приведенном коде используется пара методов, назначение которых я еще не объяснял: GetValueToRepresent и GetTextToRepresent. Эти методы в нашем простом примере возвращают значения свойств Value и FormatString. Однако в следующей главе мы расширим возможности элемента управления SimpleGaugeBar, чтобы его можно было связывать с данными. Большая часть изменений, которые мы при этом внесем, будет касаться методов GetValueToRepresent и GetTextToRepresent. Два описанных подхода не имеют функциональных различий, выбор между ними - вопрос личного предпочтения. А теперь давайте разберемся, как осуществляется управление стилями выводимого текста. Для этой цели применяется новое стилевое свойство. Стили элемента управления Элемент управления SimpleGaugeBar неявно наследует WebControl и имеет несколько визуальных свойств, таких как BackColor, Font и BorderStyle. Но что если мы захотим выводить текст другими цветами и в другой рамке? Тогда нам придется добавить 
464 Часть III Элементы управления ASP.NET еще один, аналогичный набор свойств. Однако существует альтернатива: мы можем определить одно стилевое свойство, которое будет включать в себя набор взаимосвя-занных визуальных свойств. Для создания подобных свойств предназначены два специальных базовых клас-са - Style и TableItemStyle. Класс для свойства, которое будет включать несколько пользовательских визуальных свойств, можно сделать производным от одного из них. У нашего элемента управления SimpleGaugeBar будет свойство TextStyle, имеющее такую реализацию: private TextItemStyle _textStyle; [PersistenceMode(PersistenceMode.InnerProperty)] public TextItemStyle TextStyle { get { if (_textStyle == null) _textStyle = new TextItemStyle(); if (IsTrackingViewState) ((IStateManager)_textStyle).TrackViewState(); return _textStyle; } } Свойство TextStyle сохраняет свое значение в закрытой переменной с именем _textStyle. Однако глядя на приведенный выше код, трудно понять, как это значение сохраняется между возвратами формы. Проанализируем данный момент. Заметьте, что атрибут [PersistenceMode], несмотря на свое имя, не имеет ничего общего с сохранением значения свойства. Он просто предписывает Visual Studio 2005 сохранять стилевой объект в исходный файл .aspx с использованием вложенно-го тэга. Функция сохранения стилей запрограммирована в исходном коде класса TextItemStyle. public class TextItemStyle : TableItemStyle, IStateManager { private bool _renderInsideTable; private bool _displayTextAtBottom; public TextItemStyle() { _displayTextAtBottom = true; _renderInsideTable = false; } //Открытые члены public bool RenderInsideTable { get { return _renderInsideTable; } set { _renderInsideTable = value; } } public bool DisplayTextAtBottom {
Создание специализированных элементов управления ASP.NET Глава 13 465 get { return _displayTextAtBottom; } set { _displayTextAtBottom = value; } } } Реализуя интерфейс IStateManager, класс сообщает механизму сохранения состоя-ния представления, в каком виде он желает сохранять свои данные. Иными словами, данный интерфейс действует как пользовательский сериализатор. Без него экземпляр класса сохранялся бы в состоянии представления только при условии, что он подлежит сериализации, и для этой цели использовался бы класс BinaryFormatter. Последний разрабатывался для других ситуаций, и использовать его в нашем случае, значит соглашаться на лишние издержки. Вот как реализован интерфейс IStateManager для нашего элемента управления SimpleGaugeBar: bool IStateManager.IsTrackingViewState { get { return base.IsTrackingViewState; } }void IStateManager.TrackViewState() { base.TrackViewState(); }object IStateManager.SaveViewState() { object[] state = new object[2]; state[0] = base.SaveViewState(); object[] extraData = new object[2]; extraData[0] = _renderInsideTable; extraData[1] = _displayTextAtBottom; state[1] = (object)extraData; return state; }void IStateManager.LoadViewState(object state) { if (state == null) return; object[] myState = (object[])state; base.LoadViewState(myState[0]); object[] extraData = (object[])myState[1]; _renderInsideTable = (bool)extraData[0]; _displayTextAtBottom = (bool)extraData[1]; } Интерфейс IStateManager состоит из четырех членов, описанных в табл. 13-3. В методе SaveViewState вы обычно создаете массив, состоящий из двух элементов. Первому элементу присваивается значение, возвращенное методом SaveViewState базового класса. Второй элемент - это вложенный массив (или другой подобный объект, такой как комбинация объектов Pair и Triplet), содержащий данные класса, подлежащие сохранению. Метод LoadViewState получает этот объект и выполняет обратную операцию.
466 Часть III Элементы управления ASP.NET Табл. 13-3. Члены интерфейса IStateManager Член Описание IsTrackingViewState Указывает, выполняется ли отслеживание изменений состояния пред-ставления LoadViewState Заполняет новый экземпляр класса данными, сохраненными в состоя-нии представления SaveViewState Сохраняет текущие данные класса в состоянии представления в виде одного объекта. Этот объект при следующем возврате формы будет передан методу LoadViewState TrackViewState Начинает отслеживание изменений состояния представления Стилевые свойства устанавливаются с использованием интерфейса Visual Studio 2005 (рис. 13-4). Как видите, все открытые свойства класса SimpleGaugeBar выводятся в ок-не Properties. Любые значения, которые вы здесь задаете, сохраняются в исходном файле .aspx в дочернем элементе <TextStyle>. Рис. 13-4. Установка свойств в Visual Studio 2005 Применение стилей Разрабатывая составной элемент управления, лучше не включать в иерархию его элементов стилевую информацию. Эту информацию предпочтительно добавлять непосредственно перед рендерингом. protected override void Render(HtmlTextWriter output) { PrepareControlForRendering(); base.RenderContents(output); } PrepareControlForRendering - это пользовательский метод, структура и прототип которого абсолютно произвольны. protected virtual void PrepareControlForRendering() { if (Controls.Count < 1) return;
Создание специализированных элементов управления ASP.NET Глава 13 467 //Получаем таблицу Table outer = (Table)Controls[0]; Table t = (Table)outer.Rows[0].Cells[0].Controls[0]; //Применяем базовые стилевые атрибуты t.CopyBaseAttributes(this); //Конфигурируем дополнительные свойства всей таблицы t.CellPadding = 0; t.CellSpacing = 0; //Устанавливаем цвета ячеек for (int i = 0; i < Segments; i++) { TableCell cell = t.Rows[0].Cells[i]; if (GridLines) { cell.BorderColor = BorderColor; cell.BorderStyle = BorderStyle; cell.BorderWidth = BorderWidth; } if (i < _dividerCell) cell.BackColor = ForeColor; if (i >= _dividerCell) cell.BackColor = BackColor; if (i == _dividerCell) { Table inner = (Table)cell.Controls[0]; if (inner.Rows[0].Cells.Count > 1) { inner.Rows[0].Cells[0].BackColor = ForeColor; inner.Rows[0].Cells[1].BackColor = BackColor; } else inner.Rows[0].Cells[0].BackColor = BackColor; } } //Применяем стиль к тексту if (!_textStyle.DisplayTextAtBottom) outer.Rows[0].Cells[1].ApplyStyle(TextStyle); else if (_textStyle.RenderInsideTable && _textStyle.DisplayTextAtBottom) { //Нижняя строка TableRow row = t.Rows[1]; row.ApplyStyle(TextStyle); } else { //Текст внизу Label lbl = (Label)Controls[1]; lbl.ApplyStyle(TextStyle); } }
468 Часть III Элементы управления ASP.NET В методе PrepareControlForRendering вы находите каждый дочерний элемент уп-равления, к которому необходимо применить стили, и делаете это. Поиск элементов управления производится путем обхода дерева. Индикатор в действии После компиляции элемент управления SimpleGaugeBar можно инсталлировать на панель инструментов Visual Studio 2005 и оттуда перетаскивать его на создаваемые страницы Web Forms. Элемент будет автоматически регистрироваться и демонстри-ровать свой будущий вывод. <expo:SimpleGaugeBar id="GaugeBar1" runat="server" Width="500px" Height="15px" FormatString="<b>{0}</b> out of <b>{1}</b>" Segments="10" Value="65"> <TextStyle Font-Bold="True" Font-Names="Verdana" Font-Size="8pt" /> </expo:SimpleGaugeBar> Свойства элемента, имеющие простые типы, можно устанавливать в окне Properties; для сложных типов, таких как классы, необходимо написать конвертеры и конфигурировать соответствующие свойства в дизайнере Visual Studio. Следующий код показывает, как программно устанавливаются свойства элемента управления SimpleGaugeBar. private void Button1_Click(object sender, EventArgs e) { GaugeBar1.Maximum = 200; GaugeBar1.Value = 55; } Свойство Maximum лучше устанавливать первым, чтобы элемент управления мог автоматически проверить значение свойства Value. Оба эти значения хранятся в со-стоянии представления и автоматически восстанавливаются при возврате формы. Если хост-страница отключит функцию поддержки состояния представления, вам придется модифицировать код, связанный с элементом управления, чтобы свойства устанавливались при каждом запросе. Разработка элементов управления с богатыми функциональными возможностями В ASP.NET 1.x элемент управления Panel является просто серверной абстракцией тэга <div>. Он работает как контейнер серверных элементов управления, а также HTML-элементов и литералов, размещенных и визуально сгруппированных в одном разделе страницы. В ASP.NET 2.0 данный элемент был дополнен функцией поддержки полос прокрутки, и теперь он выводится как набор полей с заголовочной надписью. Однако и новому элементу управления Panel недостает способности отображать свое содержимое по требованию. Хорошо бы заключить это содержимое в струк-туру с заголовком и кнопкой свертывания/развертывания. Щелкнув эту кнопку, пользователь сможет отобразить или скрыть содержимое панели подобно тому, как выводится и сворачивается раскрывающийся список. Чтобы создать такой элемент управления, нужно решить вопросы, связанные с графикой, состоянием, щелчками мыши и рендерингом.
Создание специализированных элементов управления ASP.NET Глава 13 469 Раскрывающаяся панель Наш новый элемент управления будет наследовать встроенный элемент управления Panel, который мы дополним несколькими свойствами, необходимыми для реализа-ции описанной функциональности. Рендеринг этого элемента будет осуществляться в форме таблицы с двумя строками: верхняя содержит заголовок и кнопку для со-крытия/отображения содержимого панели, а нижняя - стандартный вывод базового элемента управления Panel. Вот структура этой таблицы: <table> <tr> <td>Caption</td> <td>Drop-down button</td> </tr> <tr> <td colspan="2">Standard contents</td> </tr> </table> Базовый серверный элемент управления Panel определяется как группа дочерних элементов управления, заключенных в тэг Panel: <asp:Panel runat="server"> <!--Дочерние элементы управления --> </asp:Panel> Все дочерние элементы управления автоматически анализируются и добавляются как дочерние объекты в коллекцию Controls элемента управления Panel. Он не явля-ется составным, и хотя мы переопределим метод CreateChildControls с целью создания собственного дерева элементов, наш код будет несложным. Стандартный механизм рендеринга ASP.NET обеспечивает заполнение коллекции Controls элемента управ-ления Panel при вызове метода Render. Рендеринг - иное дело. Чтобы он служил нашим целям, то есть добавлял механизм обработки события, состоящего в том, что пользователь щелкнул кнопку сокрытия/отображения содержимого, придется отчасти переписать процедуру рендеринга. Для начала рассмотрим новые свойства элемента управления. Интерфейс программирования Элемент управления является производным от класса System.Web.UI.WebControls.Panel и имеет то же имя, но определенное в другом пространстве имен: namespace ProAspNet20.Advanced.CS.Components { public class Panel : System.Web.UI.WebControls.Panel, INamingContainer { } } Новые свойства, которые созданы для элемента управления Panel, перечислены в табл. 13-4. Главное здесь - свойство EnableDropDown, которое по умолчанию установлено в false, то есть элемент управления ведет себя, как обычная панель. Когда же это свойство установлено в true, активизируется новый механизм рендеринга, генериру-ющий табличную структуру с кнопкой свертывания/развертывания.
470 Часть III Элементы управления ASP.NET Табл. 13-4. Свойства раскрывающегося элемента управления Panel Свойство Описание Caption Заголовок CaptionBackColor Фоновый цвет заголовка CaptionForeColor Цвет текста заголовка EnableClientScript Указывает, должна ли функция свертывания/развертывания быть реали-зована с использованием клиентского сценария. По умолчанию данное свойство имеет значение false EnableDropDown Указывает, должен ли элемент управления работать в режиме свертыва-ния/развертывания. По умолчанию данное свойство имеет значение false ShowExpanded Указывает, должен ли элемент управления первоначально выводиться развернутым. По умолчанию данное свойство имеет значение true Кнопка может либо генерировать событие возврата формы, либо инициировать выполнение клиентского сценария, в зависимости от установки, заданной в свойстве EnableClientScript. По умолчанию оно равно false, то есть щелчок обрабатывается на сервере. Кнопка выводится в виде изображения, которое встраивается как ресурс в ту же сборку, где содержится элемент управления. Таким образом мы сразу решаем в от-ношении изображения проблему развертывания. Оно становится частью двоичного файла элемента управления и устанавливается вместе с ним. Новая панель показана на рис. 13-5. Рис. 13-5. Новый элемент управления Panel При желании можно расширить интерфейс программирования элемента управ-ления, включив в него свойство ButtonUrl, которое позволит пользователю задавать значок для кнопки программно. Свойство Caption определяет текст, выводимый в строке заголовка; цвета этого текста задаются свойствами CaptionBackColor и CaptionForeColor. Разумеется, вы мо-жете добавить и другие визуальные свойства. Состояние элемента управления Все свойства нашего нового элемента управления Panel сохраняются в состоянии представления, как показывает следующее определение свойства EnableDropDown. public bool EnableDropDown { get { object o = ViewState["EnableDropDown"]; if (o == null)
Создание специализированных элементов управления ASP.NET Глава 13 471 return false; return (bool) o; } set { ViewState["EnableDropDown"] = value; } } Каким должно быть поведение элемента управления при выполнении содержащей его страницей возврата формы? Следует сохранить состояние свертывания/развер-тывания или вернуться к исходному режиму, заданному в свойстве ShowExpanded? Очевидно, что состояние нужно сохранять, а для этого оно должно записываться в не-который закрытый член. Подходит ли для этого состояние представления? Его можно использовать, но состояние элемента управления, пожалуй, будет лучшим выбором. Введенное в ASP.NET 2.0, состояние элемента управления представляет собой подмножество состояния представления, которое должно сохраняться независимо от установок хост-страницы. Напомню, что состояние представления сохраняется между возвратами формы, но только при условии, что эта функция не отключена для хост-страницы или отдельных ее элементов из соображений повышения произ-водительности. Для открытых свойств элемента управления такое отключение не составляет проблемы, поскольку их можно явно задавать при каждом возврате формы. Однако внутренние свойства, которые представляют информацию о стоянии, могут также быть важны для работы элемента. Чтобы их значения сохранялись, эти свой-ства нужно включить в состояние элемента управления, которое нельзя отключить программно. Но это целесообразно делать только для действительно важных свойств, без которых элемент не сможет правильно работать. Флаг, указывающий, развернута ли наша панель, как раз является таким важным свойством. Информация состояния элемента управления хранится в открытом объекте-коллек-ции - свойстве ViewState. В отличие от состояния представления состояние элемента может поддерживаться строго типизированным способом с использованием группы закрытых и защищенных членов, имена и типы которых являются произвольными: private bool _panelDisplayed; protected override object SaveControlState() { Pair p = new Pair(); p.First = base.SaveControlState(); p.Second = _panelDisplayed; return p; }protected override void LoadControlState(object savedState) { if (savedState == null) return; Pair p = (Pair) savedState; base.LoadControlState(p.First); _panelDisplayed = (bool)p.Second; } Состояние элемента управления Panel включает единственное значение булева типа, указывающее, развернута ли панель. Оно сохраняется в таком же скрытом поле, как состояние представления, но для его сохранения и восстановления нужна пара особых методов. Если элемент управления должен сохранять свое состояние, вам следует переопределить методы SaveControlState и LoadControlState.
472 Часть III Элементы управления ASP.NET Метод SaveControlState возвращает объект, содержащий состояние, которое вы хотите сохранить, а метод LoadControlState получает этот объект в качестве аргумента, распаковывает и инициализирует содержащимися в нем данными закрытые члены. Для более эффективной упаковки данных вы можете использовать коллекцию Pair или Triplet либо, если требуется хранить больше двух или трех элементов, массив Object. Типичная реализация метода SaveControlState создает объект Pair и сохраняет возвращаемое значение базового метода в первом слоте. Во второй слот помещается объект, который заключает в себе все данные состояния элемента управления. Формат этих данных выбирается произвольно. Метод LoadControlState просто извлекает эти данные и устанавливает внутренние члены элемента управления. В отличие от поддержки состояния представления поддержка состояния элемента управления не является обязательной. Поэтому элемент, которому она требуется, дол-жен сообщить об этом хост-странице. Тогда она будет вызывать методы LoadControlState и SaveControlState на соответствующих этапах своего жизненного цикла. protected override void OnInit(EventArgs e) { base.OnInit(e); Page.RegisterRequiresControlState(this); }protected override void OnLoad(EventArgs e) { if (!Page.IsPostBack) _panelDisplayed = ShowExpanded; } О необходимости сохранения своего состояния элемент управления сообщает в обработчике события Init, вызывая метод RegisterRequiresControlState класса Page. Заметьте, что раскрывающийся элемент управления Panel также должен инициали-зировать внутренний член _panelDisplayed, который будет входить в состав его со-стояния. Данная инициализация происходит при загрузке элемента управления для страницы в обработчике события Load - при условии, что свойство IsPostBack имеет значение false. При следующем возврате страницы значение свойства _panelDisplayed восстанавливается из состояния элемента. Добавление поддержки тем В ASP.NET 2.0 появилась поддержка тем страниц и элементов управления. Тема - это файл уровня приложения, в котором определяется внешний вид HTML-элементов и серверных элементов управления. Темы являются надмножеством каскадных таблиц стилей (CSS) и реализуют тот же подход к оформлению элементов страниц. Подроб-нее о них рассказывалось в главе 5 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference". Темы ASP.NET состоят из файлов двух видов: CSS и обложек. Обложка (skin) - это коллекция установок, используемых по умолчанию для группы серверных элементов управления. Эти установки автоматически применяются ко всем элементам опреде-ленных типов, расположенным на странице или используемым в приложении. Ниже приведен пример сценария, определяющего обложку нашего элемента управления Panel. <%@Register TagPrefix="expo" Namespace="ProAspNet20.CS.Components" Assembly="ProAspCompLib" %>
Создание специализированных элементов управления ASP.NET Глава 13 473 <expo:Panel runat="server" Width="300px" BorderWidth="1px" Font-Bold="True" Font-Names="Verdana" Font-Size="Small" HorizontalAlign="Left" BackColor="#FFFF80" CaptionBackColor="Teal"> </expo:Panel> Темы применяются не ко всем свойствам. Эмпирическое правило гласит, что их имеет смысл применять только к пользовательскому интерфейсу элемента управле-ния, включая его поведенческие свойства. Как указать, применяются к свойству темы или нет? Этой цели служит атрибут [Themeable]. По умолчанию темы применяются ко всем свойствам. Для того чтобы исключить свойство из данной категории, нужно объявить его так: [Themeable(false)] public bool EnableDropDown { } Понятно, что свойствам EnableDropDown, EnableClientScript и ShowExpanded темы не нужны. Примечание Каков предпочтительный способ определения графических свойств специ-ализированного элемента управления? Следует ли создавать отдельные свойства, такие как CaptionBackColor, или лучше группировать их в стилевые объекты? Это уж как вам больше нравится. Лично я предпочитаю стилевые свойства. Однако стилевое свойство обычно сохраняется как дочерний элемент, что может представлять собой некоторую проблему, если у элемента управления есть и другие дочерние элементы. Именно так обстоит дело с раскрывающейся панелью. Впрочем, данная проблема решаема, поскольку можно сконфигурировать формат сериализации стилевого свойства. Но если индивиду-альных свойств у элемента всего несколько, их можно использовать вместо стиля. Механизм рендеринга Как уже не раз упоминалось, разметка элемента управления создается одним из двух способов: она выводится в виде текста или формируется дерево серверных элементов управления. В последнем случае за преобразование этих элементов управления в разметку отвечает механизм рендеринга ASP.NET. Вывод с использованием объекта writer выполняется быстрее, но зато решение на основе дерева элементов является более гибким, что особенно важно для элементов, выполняющих возврат формы и взаимодействующих с инфраструктурой исполняющей среды ASP.NET. Базовый элемент управления Panel просто выводит тэг <div> и его атрибуты и предоставляет каждому своему дочернему элементу управления самостоятельно осу-ществлять рендеринг своего контента. Но для раскрывающегося элемента управления Panel нам нужно будет динамически строить дерево элементов управления, содержа-щее строку заголовка с кнопкой и все дочерние элементы управления. Сформировать необходимый вывод с помощью объекта writer, конечно, возможно, но для правильной обработки возврата формы требуется полное дерево элементов управления. Давайте переопределим метод CreateChildControls. Расширение стандартной разметки Механизм рендеринга встроенного элемента управления Panel основан на стандартной реализации метода Render. Этот метод перебирает в цикле все дочерние элементы управления и выводит разметку каждого из них. При вызове метода Render коллек-ция Controls элемента управления Panel заполняется элементами, число которых 
474 Часть III Элементы управления ASP.NET равняется числу дочерних элементов тэга <asp:panel>. Такое поведение сохранится и у нового класса Panel. Для того чтобы добавить родительскую таблицу и построить структуру, показанную на рис. 13-5, нам нужно создать дерево элементов управления. За заполнение коллекции Controls любого серверного элемента управления отвечает метод CreateChildControls. Ниже показано, как можно переписать его для раскрывающейся панели Panel. protected override void CreateChildControls() { if (EnableDropDown) { base.CreateChildControls(); CreateControlHierarchy(); } else base.CreateChildControls(); } Если свойство EnableDropDown имеет значение false, элемент управления ве-дет себя традиционно и ничем не отличается от своего базового элемента управ-ления Panel. В противном случае осуществляется вызов метода CreateChildControls базового элемента управления, а после этого вызывается пользовательский метод CreateControlHierarchy. CreateControlHierarchy - это внутренний метод элемента управления, добавляющий в коллекцию Controls элементы, необходимые для формирования его новой структу-ры. Имя и сигнатура этого метода произвольны. Однако большинство встроенных составных элементов управления ASP.NET имеют метод с таким же именем и анало-гичным поведением. Более того, в некоторых случаях данный метод даже помечается как защищенный и виртуальный. Построение дерева элементов управления Метод CreateControlHierarchy создает таблицу с двумя строками, во второй из которых выводятся дочерние элементы, находящиеся в коллекции Controls на момент вызова этого метода. Вот пример его кода: protected virtual void CreateControlHierarchy() { //Создаем контейнерный элемент Table t = new Table(); //Добавляем строку заголовка TableRow row1 = new TableRow(); t.Rows.Add(row1); //Создаем ячейку заголовка TableCell cell1 = new TableCell(); row1.Cells.Add(cell1); cell1.Text = Caption; //Создаем ячейку для кнопки (изображение будет добавлено позднее) TableCell cell2 = new TableCell(); row1.Cells.Add(cell2); cell2.HorizontalAlign = HorizontalAlign.Right;
Создание специализированных элементов управления ASP.NET Глава 13 475 //Создаем строку контента TableRow row2 = new TableRow(); t.Rows.Add(row2); //Создаем ячейку контента TableCell body = new TableCell(); body.ID = "Body"; row2.Cells.Add(body); body.ColumnSpan = 2; //Добавляем в ячейку контента существующие элементы управления Control[] children = new Control[Controls.Count]; Controls.CopyTo(children, 0); foreach (Control ctl in children) body.Controls.Add(ctl); //Заменяем коллекцию Controls элемента управления Controls.Clear(); Controls.Add(t); } Когда вызывается этот метод, коллекция Controls содержит ссылки на дочерние элементы управления панели. Эти ссылки временно помещаются в массив объектов Control и затем включаются в создаваемую таблицу. В конце коллекция Controls очи-щается и заменяется только что созданной таблицей. На рис. 13-6 показано новое дерево элементов управления, выведенное утилитой трассировки ASP.NET. Рис. 13-6. Дерево элементов управления раскрывающейся панели Существует одна важная причина, по которой мы строим дерево элементов управ-ления. Она заключается в том, что в результате каждый компонент страницы по лучает серверное представление и может обрабатывать события на протяжении ее жизненного цикла. Если элементу, который вы создаете, не требуется обрабатывать серверные события, то его можно выводить с использованием объекта записи HTML и не во-зиться с созданием элементов управления для каждого запроса (а также не нагружать этим ASP.NET). Если же элемент управления нуждается во взаимодействии с ASP. NET (например, он содержит элемент, со щелчком которого должно быть связанно серверное событие), то тогда вы должны гарантировать, что ASP.NET найдет сервер-ный элемент управления с нужным идентификатором. А это произойдет только в том 
476 Часть III Элементы управления ASP.NET случае, если вы добавите такой элемент в коллекцию Controls. Мы еще вернемся к этому моменту чуть позже. Исходный код метода CreateControlHierarchy, который мы привели выше, неполон. В частности, в нем недостает кода, который бы добавлял кнопку с изображением в верхнюю строку. Это может быть элемент управления ImageButton, если поддержива-ется возврат формы, или Image, если функция свертывания/развертывания должна быть реализована на клиенте. Значение свойства EnableClientScript определяет выбор между этими двумя решениями. Использование встроенного изображения Во второй ячейке верхней строки таблицы содержится кнопка с изображением. Сле-дующий код показывает, как она создается: WebControl img; if (!EnableClientScript) { img = new ImageButton(); ((ImageButton)img).Click += new ImageClickEventHandler(OnClick); }else { img = new System.Web.UI.WebControls.Image(); //Добавьте сюда код сценария для обработки щелчка }//cell2 - это вторая ячейка верхней строки (см. предыдущий листинг) cell2.Controls.Add(img); //Показывает/скрывает дочерние элементы ShowChildControls(_panelDisplayed); //Изменяет изображение соответственно ShowImageButton(_panelDisplayed); По умолчанию кнопка свертывания/развертывания реализуется в виде объекта с предопределенным обработчиком события Click - методом OnClick, который вызы-вается при возврате формы, когда пользователь щелкает изображение. Где устанавливается URL изображения? Внутренний член элемента управления ShowImageButton получает текущее значение состояния свертывания/развертывания и обновляет свойство ImageUrl элемента управления ImageButton или Image. Заметь-те, что ImageButton является производным от Image, а это значит, что полиморфное решение в данном случае вполне допустимо и является весьма эффективным. void ShowImageButton(bool display) { //Убеждаемся, что имеются элементы управления, //с которыми нам предстоит работать if (Controls.Count != 1) return; //Извлекаем ячейку кнопки Table t = (Table)Controls[0]; TableRow r = t.Rows[0]; TableCell icon = r.Cells[1];
Создание специализированных элементов управления ASP.NET Глава 13 477 //Это может быть Image либо ImageButton в зависимости //от значения свойства EnableClientScript //(ImageButton наследует Image) Image img =(Image) icon.Controls[0]; string imageName = "ProAspNet20.Advanced.CS.Components.Expand.bmp"; if (display) imageName = "ProAspNet20.Advanced.CS.Components.Collapse.bmp"; img.ImageUrl = Page.ClientScript.GetWebResourceUrl( this.GetType(), imageName); } Метод ShowImageButton сначала извлекает ячейку таблицы, в которой находится объект-изображение, а затем определяет имя изображения, которое нужно вывести для кнопки. Изображения хранятся в виде ресурсов в сборке элемента управления (см. главу 9). Чтобы встроить изображение в сборку в виде ресурса, вы сначала добавляете его в проект Visual Studio, в рамках которого создается элемент управления, а затем присваиваете свойству проекта Build Action значение Embedded Resources. Заметьте, что имя изображения получит префикс - имя используемого по умолчанию простран-ства имен сборки. В файле assemblyinfo.cs (или assemblyinfo.vb) вы можете добавить следующие атрибуты: [assembly: WebResource("ProAspNet20.Advanced.CS.Components.Expand.bmp", "image/jpg")] [assembly: WebResource("ProAspNet20.Advanced.CS.Components.Collapse.bmp", "image/jpg")] Чтобы программным способом извлечь изображение из сборки, нужно вызвать метод GetWebResourceUrl объекта ClientScript страницы. Этому методу передается тип элемента управления и экспортируемое имя ресурса. Метод возвращает URL, который можно присвоить свойству ImageUrl элемента управления, представляющего изображение, а в конечном счете - свойству src элемента <img>. Как рассказыва-лось в главе 6, этот URL указывает на системный обработчик HTTP WebResource. axd. Обработчик HTTP считывает байты ресурса из сборки и возвращает их, указав MIME-тип, заданный в атрибуте [WebResource]. Примечание В ASP.NET 2.0 можно создать пользовательскую сборку элемента управ-ления, просто поместив его исходный код в папку App_Code Web-сайта, на котором этот элемент будет использоваться. В таком случае Visual Studio 2005 не позволит вам добавить в сборку изображения. Если же вам важно, чтобы сборка содержала встроенные изображения, создайте элемент управления в виде отдельного проекта или библиотеки классов. Сборка, содержащая раскрывающийся элемент управления Panel, включает два изображения, которые имеют вид кнопки поля со списком из Microsoft Windows XP. На рис. 13-7 показано, как эта кнопка изменяется в зависимости от состояния свер-тывания/развертывания элемента управления. Рис. 13-7. Изображение кнопки меняется при свертывании/развертывании элемента управления
478 Часть III Элементы управления ASP.NET Главным достоинством поддерживаемых ASP.NET 2.0 сборок, содержащих встро-енные изображения, является возможность инсталлировать их как самодостаточные файлы. В ASP.NET 1.x вы тоже можете создавать элементы управления с богатым графическим интерфейсом, но вместе с ними приходится устанавливать дополни-тельные файлы ресурсов. Добавление стилей Работа над визуальной структурой раскрывающейся панели почти завершена. Пре-жде чем мы приступим к моделированию ее поведения, давайте поговорим немного о стилевых атрибутах нашего элемента. Когда вы создаете элемент управления путем объединения нескольких существующих элементов, то есть переопределяете метод CreateChildControls, следует избегать применения стилей и других визуальных свойств непосредственно к элементам, представленным в иерархии. Иерархия элементов и сти-ли должны быть разделены насколько это возможно. В методе CreateControlHierarchy вы просто формируете иерархию элементов, опре-деляя между ними отношения родительский/дочерний. Затем вы переопределяете метод Render, как показано ниже, и применяете стили перед самым рендерингом: protected override void Render(HtmlTextWriter writer) { PrepareControlForRendering(); base.Render(writer); }protected virtual void PrepareControlForRendering() { //Убеждаемся в наличии элементов, с которыми нам предстоит работать if (Controls.Count != 1) return; //Применяем табличный стиль if (!EnableDropDown) return; Table t = (Table) Controls[0]; t.CopyBaseAttributes(this); if (ControlStyleCreated) t.ApplyStyle(ControlStyle); //Отступы ячеек задаем для всей таблицы t.CellPadding = 1; t.CellSpacing = 0; //Определяем стиль строки заголовка TableRow row1 = t.Rows[0]; row1.BackColor = CaptionBackColor; row1.ForeColor = CaptionForeColor; } PrepareControlForRendering - это внутренний член нашего элемента, имя и сигна-тура данного члена произвольны. Точно так же не являются обязательными модифи-каторы protected и virtual, и вы можете их изменить. Задача нашего метода - извлечь ключевые элементы коллекции Controls и к каждому применить собственный набор стилей и графических свойств. Первым элементом коллекции является внешняя таблица.
Создание специализированных элементов управления ASP.NET Глава 13 479 Эта таблица наследует базовые атрибуты, определенные для элемента управления в Visual Studio 2005. Например, если вы установите свойство BackColor раскрываю-щегося элемента управления Panel, то ваша установка будет передана объекту Table, служащему контейнером разметки элемента управления Panel. Кроме того, вы можете задавать стили отдельных дочерних элементов управления, используя значения сти-левых свойств или отдельных графических свойств. Метод PrepareControlForRendering не добавляет в элемент управления новых фун-кциональных возможностей, он просто позволяет сделать код элемента управления более рациональным. Генерирование событий возврата формы Главным преимуществом раскрывающегося элемента Panel перед одноименным клас-сическим элементом управления является то, что пользователь может щелкнуть на кнопке, чтобы скрыть или отобразить его содержимое. Состояние дочерних элемен-тов управления сохраняется между возвратами формы, как и состояние свертыва-ния/развертывания. Иными словами, если пользователь развернет панель, а затем щелкнет какой-нибудь ее элемент, инициирующий возврат формы, панель останется развернутой. В общем случае щелчок кнопки вызывает возврат формы. Однако выбор между клиентским и серверным событием должен осуществляться с учетом ожидаемого результата этого щелчка. В данном случае щелчок служит указанием того, что поль-зователь хочет скрыть или отобразить вторую строку контейнерной таблицы. Пере-ключение состояния видимости элемента HTML - это операция, которую можно выполнять и на сервере, и на клиенте. Как разработчик элемента управления вы можете предоставить обе возможности, чтобы автор страницы сам решал, какая из них ему больше подходит. Обработка щелчка По умолчанию раскрывающийся элемент управления Panel выводит кнопку в виде элемента управления ImageButton, который является производным от Image и обла-дает всеми типичными характеристиками кнопки: функциями submit, валидации, возврата данных серверу и обработки события возврата формы. Элемент ImageButton генерирует код сценария, необходимый для перехвата щелчка и инициирования воз-врата формы. При возврате формы вам нужно модифицировать внутреннее состояние элемента управления, чтобы сгенерированная разметка соответствовала его новому виду, то есть тому, будет свернут он или развернут. Поэтому элемент ImageButton должен быть связан с внутренним обработчиком события OnClick: ImageButton img = new ImageButton(); img.Click += new ImageClickEventHandler(OnClick); Вот исходный код этого обработчика: void OnClick(object sender, ImageClickEventArgs e) { //Изменяем состояние свертывания/развертывания _panelDisplayed = !_panelDisplayed; //Отражаем изменения в пользовательском интерфейсе ShowChildControls(_panelDisplayed); ShowImageButton(_panelDisplayed); }
480 Часть III Элементы управления ASP.NET Важно отметить, что это серверное событие никогда не будет обработано ASP.NET, если вы не укажете в объявлении класса интерфейс INamingContainer и если элемент управления ImageButton не будет добавлен в коллекцию Controls. Когда вы не создаете серверный элемент управления, а просто выводите эквивалентную разметку, ASP.NET не может связать возвращенные страницей данные с серверным элементом управле-ния, и событие Click утрачивается. Внутренний обработчик этого события переключает состояние свертывания/раз-вертывания элемента управления, заменяет изображение кнопки и выводит или скры-вает вторую строку таблицы, где расположены дочерние элементы панели. Последнее действие он выполняет с помощью метода ShowChildControls. void ShowChildControls(bool display) { //Убеждаемся в наличии элементов управления if (Controls.Count != 1) return; //Применяем стиль таблицы Table t = (Table)Controls[0]; TableRow r = t.Rows[1]; TableCell body = r.Cells[0]; body.Style["display"] = (display ? "" : "none"); } Заметьте, что все элементы управления генерируют свою разметку и заполняют состояние представления как обычно, чем гарантируется правильная работа с ним. Управление видимостью элементов управления на клиентской странице осуществля-ется с использованием объектной модели браузера. В стандартной DOM у объекта style есть атрибут display, определяющий, должен ли данный элемент выводиться на странице. Если присвоить этому атрибуту значе-ние none, браузер проигнорирует элемент и не станет выводить его для пользователя. Если же это свойство будет содержать пустую строку, элемент отобразится верно. Описанное правило действует в большинстве браузеров, включая Firefox и Netscape версии 6.0 и выше. Примечание В стандартной DOM есть два сходных стилевых атрибута: display и visibility. Оба они могут использоваться для переключения состояния отображения элементов HTML. Разница между ними заключается в том, что когда visibility скрывает элемент, браузер не использует занимаемое им пространство, тогда как при отключении свойства visibility элемент вообще игнорируется. Открытое событие PanelClick Помимо модификации свойств, изменяющих состояние отображения страницы, вы можете передавать на более высокий уровень (например, на уровень хост-страницы) событие Click или же генерировать вместо него новое событие. Давайте рассмотрим последнее решение и добавим в элемент управления Panel пользовательское открытое событие. Событие PanelClick генерируется, когда пользователь щелкает элемент панели, инициирующий возврат формы. Это событие объявляется следующим образом: public event EventHandler<PanelClickEventArgs> PanelClick;
Создание специализированных элементов управления ASP.NET Глава 13 481 Его обработчику передается некоторая информация, упакованная в объект класса PanelClickEventArgs: public class PanelClickEventArgs : EventArgs { public bool BeingClosed; } Класс PanelClickEventArgs является производным от EventArgs - базового класса большинства структур, представляющих информацию о событиях, - и расширяет его, добавляя член булева типа BeingClosed, который указывает, была панель свернута или развернута. Зарегистрированный обработчик события PanelClick вызывается из внутреннего обработчика события Click элемента управления ImageButton: void OnClick(object sender, ImageClickEventArgs e) { PanelClickEventArgs args = new PanelClickEventArgs(); args.BeingClosed = _panelDisplayed; OnPanelClick(args); //Изменяем состояние свертывания/развертывания //(Здесь располагается некоторый код) }protected virtual void OnPanelClick(PanelClickEventArgs args) { if (PanelClick != null) PanelClick(this, args); } В результате выполнения этого кода хост-среда (страница или контейнерный эле-мент управления, в котором находится элемент управления Panel) получает событие PanelClick, как только Panel получает событие Click от своего встроенного элемента ImageButton. Пользовательские события и всплывание событий Можно ли позволить исходному событию Click выйти из элемента управления Panel и достичь родительского элемента? Это возможно, а данный процесс называется всплыванием событий (event bubbling). Когда элемент управления ASP.NET является составным, его поведение опреде-ляется обработкой, которой подвергаются события, генерируемые составляющими его элементами. Всплывание событий - это технология, которая дает дочерним эле-ментам возможность сообщать о своих событиях вверх по иерархии, так что события, генерируемые внутренними элементами, видны на более высоких уровнях. Элемент управления, желающий, чтобы его событие всплывало, должен вызывать из того метода, в котором он это событие генерирует, метод RaiseBubbleEvent: protected virtual void OnPanelClick(PanelClickEventArgs args) { if (PanelClick != null) PanelClick(this, args); base.RaiseBubbleEvent(this, args); }
482 Часть III Элементы управления ASP.NET Метод RaiseBubbleEvent определен в классе Control и наследуется всеми элемен-тами управления ASP.NET. Элементы-контейнеры не видят всплывающее событие в его исходной форме. Если они хотят его обрабатывать, им нужно переопределить метод OnBubbleEvent: protected override bool OnBubbleEvent(object source, EventArgs e) { bool handled = false; if (e is PanelClickEventArgs) { PanelClickEventArgs args = (PanelClickEventArgs) e; if (args.BeingClosed) { //Здесь осуществляется обработка события. //ОБЯЗАТЕЛЬНО укажите, выполнена ли обработка события. //Если вернуть true, всплывание события прекратится handled = true; } } return handled; } Аргумент EventArgs содержит информацию о событии. Вы можете привести его к ожидаемому типу и обработать событие. Значение, которое вы возвращаете из ме-тода OnBubbleEvent, играет важную роль: если вернуть true, событие остановится на данном уровне и более высокие уровни его не увидят. Если же вернуть false (это будет означать, что событие не обработано), событие всплывет выше. Нужно отметить, что технология всплывания события - не для постоянного использования, и в большинстве случаев вы найдете более подходящим решение на основе пользовательского события. Применять эту технологию удобно, когда вы знаете, что определенное событие может быть сгенерировано, но не знаете, какой именно элемент управления это сделает. Когда так бывает? Например, при работе с элементами управления, в которых используются шаблоны, так что неизвестно, какой конкретно шаблон будет содержать элемент. Вот тогда технология всплывания собы-тий и проявит свои достоинства. Об элементах управления, в которых используются шаблоны, я расскажу в следующей главе. Добавление кода сценария Для работы раскрывающегося элемента управления Panel не требуется тесного взаи-модействия между клиентским и серверным окружениями. Событие возврата формы, используемое для сокрытия и отображения панели, не является необходимым. Того же эффекта можно достичь и с использованием клиентского сценария. Вы можете скры-вать и отображать панель на клиентском компьютере, не выполняя возврат формы. Но в этом случае использовать элемент управления ImageButton нельзя, поскольку он выполняет возврат формы автоматически. Так что для вывода кнопки мы теперь воспользуемся элементом Image и добавим сценарий, который выводит указатель мыши, имеющий форму руки, и управляет видимостью панели. Вывод изображения кнопки Когда свойство EnableClientScript содержит значение true, кнопка свертывания/раз-вертывания панели выводится как обычное изображение, но перед этим выполняется особый сценарий: //Создаем элемент управления Image Image img = new Image();
Создание специализированных элементов управления ASP.NET Глава 13 483 img.Attributes["onmouseover"] = "this.style.cursor = \"hand\";"; img.Attributes["onmouseout"] = "this.style.cursor = \"\";"; img.Attributes["onclick"] = "__toggle()"; //cell2 - вторая ячейка верхней строки cell2.Controls.Add(img); Элементу управления Image назначается пара клиентских стилевых атрибутов, onmouseover и onmouseout, благодаря которым при наведении на этот элемент указа-теля мыши последний будет принимать форму руки. Кроме того, мы ассоциируем выполняемый пользователем щелчок изображения с функцией JavaScript, имеющей произвольное имя: __toggle. Метод ShowImageButton, приведенный в предыдущем листинге, вызывается из метода CreateControlHierarchy для установки URL выводимого изображения. Для простоты я не меняю изображения в клиентском сценарии. //В обоих состояниях элемента управления выводится одно и то же изображение string imageName = "ProAspNet20.Advanced.CS.Components.Expand.bmp"; img.ImageUrl = Page.ClientScript.GetWebResourceUrl( this.GetType(), imageName); Вывод кода сценария Функция JavaScript с именем __toggle содержит код для отображения и сокрытия содержимого панели. Этот код должен быть доступен хост-странице, для чего его можно импортировать из сборки элемента управления или из внешнего файла. В ка-честве альтернативы можно сделать так, чтобы элемент управления генерировал код данной функции и выполнял его рендеринг. if (!Page.ClientScript.IsClientScriptBlockRegistered("__toggle")) { string js = BuildScript(body); Page.ClientScript.RegisterClientScriptBlock( this.GetType(), "__toggle", js, true); } Любой клиентский сценарий, подлежащий выводу в составе результирующей стра-ницы, должен быть зарегистрирован для этой страницы, и ему должно быть присвоено имя. С помощью метода IsClientScriptBlockRegistered вы проверяете, не зарегистрирован ли уже определенный блок кода, а с помощью метода RegisterClientScriptBlock выполняе-те его регистрацию. Блок кода на сервере соответствует клиентскому блоку <script>. В ASP.NET 2.0 каждый блок кода сценария должен иметь уникальное имя и быть ассоциированным с некоторым типом. В ASP.NET 1.x все блоки кода ассоциировались с типом хост-страницы, так что явно указывать тип не было необходимости. В новой системе вы, как правило, будете задавать тип элемента управления и использовать имя функции JavaScript в качестве псевдонима блока кода сценария. Исходный код на языке JavaScript задается в виде строки, а необязательный ар-гумент булева типа в вызове метода RegisterClientScriptBlock указывает, нужно ли автоматически генерировать контейнерный тэг <script>. Передав значение false, вы сообщаете, что необходимый тэг уже добавили сами. Генерирование кода сценария Исходный код блока сценария можно генерировать как угодно, лишь бы в результате получалась строка, представляющая функцию на языке JavaScript. Ниже приведен пример кода, в котором для накопления текста формируемой функции используется 
484 Часть III Элементы управления ASP.NET объект StringBuilder. Заметьте, что в .NET Framework предпочтительным средством конкатенации строк является этот объект, а не оператор +. private string BuildScript(TableCell body) { StringBuilder sb = new StringBuilder(); sb.AppendLine("function __toggle() {"); sb.AppendFormat("var body = document.getElementById(\"{0}\");\r\n", body.ClientID); sb.AppendLine("var display = body.style.display;"); sb.AppendLine("if (display == \"\") {"); sb.AppendLine("body.style.display = \"none\";"); sb.AppendLine("} else {"); sb.AppendLine("body.style.display = \"\";"); sb.AppendLine("}"); sb.AppendLine("}"); return sb.ToString(); } Результирующий код на языке JavaScript, включаемый в состав страницы, полу-чается таким: <script type="text/javascript"> <!--function __toggle() { var body = document.getElementById("Panel1_Body"); var display = body.style.display; if (display == "") { body.style.display = "none"; } else { body.style.display = ""; } }//--> </script> Этот код извлекает из таблицы элемент, представляющий содержимое панели, и делает его видимым. Для поиска ссылки на нужный элемент HTML в нем исполь-зуется DOM. Чтобы сгенерировать такой сценарий, вспомогательной функции BuildScript нужно иметь ссылку на серверный объект TableCell. Эта ссылка передается ему в качестве аргумента. Если вы внимательно просмотрите весь исходный код элемента управ-ления Panel, то обнаружите, что серверный идентификатор ячейки таблицы - Body, а клиентский - Panel1_Body. Почему это так? И самое главное, каким образом уста-навливается соответствие между двумя строками? Идентификация элементов Одно из важных правил разработки составных элементов заключается в том, что об-ластью видимости идентификаторов дочерних элементов должен быть родительский элемент. Необходим механизм типа пространства имен, который бы позволял отли-чить ячейку таблицы с именем Body панели Panel1 от одноименной ячейки панели с именем Panel2. Как разработчик страницы вы не контролируете идентификаторы внутренних ячеек таблиц, они для вас невидимы. Вы назначаете двум экземплярам одного элемента управления разные имена, однако этого недостаточно для того, что-
Создание специализированных элементов управления ASP.NET Глава 13 485 бы в DOM страницы ячейки таблицы обоих элементов управления гарантированно имели разные идентификаторы. Реализация маркерного интерфейса INamingContainer, о котором мы уже не раз упоминали, является гарантией того, что элемент управления станет пространством имен своих дочерних элементов. Для примера рассмотрим такой код: cell.ID = "Body"; Если выполнить его в контексте элемента управления Panel с именем Panel1, уни-кальным идентификатором ячейки станет Panel1$Body. Свойство ID будет возвращать Body, но свойство UniqueID вернет Panel1$Body. При генерировании разметки для ячейки таблицы ни одно из двух ID-свойств не используется, а вместо них применя-ется свойство ClientID. Оно совпадает с UniqueID с тем отличием, что символ $ в нем заменен символом подчеркивания (_). Таким образом, при работе в HTML-аналоге серверного сценария нужно ссылать-ся на элемент управления по имени, возвращаемому свойством ClientID серверного элемента управления. Внимание! Значение свойства ClientID обновляется только при добавлении элемента управления в коллекцию Controls его контейнера. Из приведенного выше кода следует, что если вызвать метод BuildScript до того, как объект - ячейка таблицы будет добавлен в коллекцию Controls, свойство ClientID вернет Body вместо Panel1_Body и выполнение клиентского сценария завершится ошибкой, поскольку объекта с таким именем нет. Заключение ASP.NET предоставляет набор серверных элементов управления, из которых можно выбрать подходящий для конкретного применения. Если такого элемента не нашлось, можно создать собственный элемент управления - с нуля, либо расширив один из существующих элементов. Задача написания элемента управления состоит в определе-нии объектной модели и разработке эффективного механизма рендеринга. Кроме того, важно продумать вопросы, связанные с контейнерами, именованием и интеграцией со средствами управления состоянием. В этой главе мы создали три элемента управления и выяснили, как разрабатывается механизм рендеринга, который можно реализовать с использованием одного из двух подходов: выводить HTML-разметку самостоятельно либо строить дерево серверных элементов управления. Преимуществом первого подхода является быстродействие, а преимуществом второго - гибкость решения и удобочитаемость кода. При создании составных элементов управления на первое место выходит принцип агрегирования, а не наследования. Вы собираете вместе несколько разных элементов управления и надстраиваете поверх них объектную модель. Исключительно важно, чтобы составной элемент управления был реализован как контейнер именования. В следующей главе вы познакомитесь с еще более сложным типом специализи-рованных элементов управления - элементами, связанными с данными и использу-ющими шаблоны. Только факты Специализированный серверный элемент управления можно создать как произ-водный от существующего элемента управления, добавив в него новые свойства и методы. Можно также сделать элемент производным от базового класса элементов управ-ления, в котором реализованы такие универсальные функции, как управление 
486 Часть III Элементы управления ASP.NET состоянием представления, поддержка тем, рендеринга и состояния элемента управления. Вы можете создать разметку элемента управления любым из двух способов: на-писать код, который выводит разметку в виде готового HTML-кода или сформи-ровать дерево серверных элементов управления. В последнем случае получится составной элемент управления. Когда необходимо реализовать графические свойства, можно использовать в ка-честве их контейнера стилевой объект. Стилевые свойства следует применять непосредственно перед рендерингом элемента управления, а не во время создания иерархии его элементов. Реализация различных интерфейсов может обогатить поведение элемента управ-ления. С их помощью можно обрабатывать события возврата формы, управлять возвратом данных и осуществлять обратный вызов сценария. 
Глава 14 Элементы управления, связанные с данными и использующие шаблоны Все специализированные элементы управления, которые мы создавали до сих пор, были эффективными и функциональными, но им недоставало нескольких важных возможностей. На практике такие элементы обычно должны поддерживать связыва-ние с данными и шаблоны. О важности этих функций мы говорили в главе 11, когда обсуждали элементы управления Repeater и DataList. Еще более подробно данная тема раскрыта в главе 2 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Для программиста ASP.NET элемент управления, который может быть связан с набором данных, - очень важный инструмент, значительно повышающий личную и командную производительность труда. Исключительно полезна и встроенная под-держка шаблонов, которая делает элемент значительно более гибким и на порядок уменьшает вероятность того, что в дальнейшем его придется модифицировать. По-купая элементы управления сторонних производителей, обладающие богатой функ-циональностью, вы нередко остаетесь неудовлетворенными их пользовательским интерфейсом и конкретным набором возможностей. Многие компании, занимающиеся разработкой программного обеспечения, приобретают компоненты только с полным и хорошо документированным исходным кодом, чтобы можно было решить любые про-блемы, возникающие при попытке интеграции чужого компонента в свое окружение. Возможность адаптации элемента управления в значительной мере обеспечивается поддержкой им шаблонов. Конечно, наличие такой поддержки еще не означает, что вам не потребуется дорабатывать или модифицировать компонент, но тем не менее она решает многие проблемы, делая пользовательский интерфейс и поведение ком-понента настолько гибкими, насколько это возможно. В этой главе мы воспользуемся разработанным в главе 13 элементом управления, который выводит на странице индикатор выполнения задания, и усовершенствуем его, реализовав поддержку связывания с данными. Кроме того, мы спроектируем и реализуем еще пару демонстрационных элементов управления, чтобы получить как можно более полное представление о процессе разработки специализированных элементов управления. В частности, речь пойдет о списочных таблицах результатов запроса и составных элементах управления, связанных с данными. Проектирование элементов управления, связанных с данными Элементы управления, связанные с данными, характеризуются наличием свойства, представляющего источник данных, и набора строковых свойств, определяющих соответствие между полями связанного источника данных и элементами пользова-тельского интерфейса элемента управления. В ASP.NET 1.x свойство, представляю-щее источник данных, могло указывать только на объект, реализующий интерфейс IEnumerable (или производного от него типа) либо IListSource. В ASP.NET 2.0 введена новая модель источников данных. Она представлена группой новых, не имеющих 
488 Часть III Элементы управления ASP.NET пользовательского интерфейса элементов управления, предназначенных для создания связи между визуальными элементами управления, связанными с данными, и кон-тейнерами данных. Команда ASP.NET, проанализировав код, который приходилось писать разработчикам приложений для ASP.NET 1.x, создала новое семейство эле-ментов управления, представляющих источники данных. Эти элементы управления подробно описаны в главе 9 моей книги "Programming Microsoft ASP.NET 2.0: Core Reference" (Microsoft Press, 2005). Использование элементов управления, представляющих источники данных, в стра-ницах ASP.NET дает множество преимуществ. Прежде всего, вы получаете в свое рас-поряжение полностью декларативную модель связывания с данными. Это позволяет сократить количество программного кода, содержащегося в файлах .aspx и файлах отделенного кода. Кроме того, разработчикам приходится придерживаться более стро-гих правил, а значит, код их приложений становится более упорядоченным. Исчезают длинные блоки кода, связанные с событиями, а вместо них появляются компоненты, которые просто подключаются к существующей инфраструктуре. Эти компоненты (такие как элементы управления, представляющие источники данных) наследуют абстрактные классы, реализуют стандартные интерфейсы и в целом демонстрируют высокий уровень повторного использования. В ASP.NET 2.0 любой элемент управления, связанный с данными, должен быть способен поддерживать две формы связывания: с перечислимыми объектами и с элементами управления, представляющими источники данных. В распоряжение разработчиков предоставляется полностью переработанная иерархия классов, на каждом уровне которой, начиная с корневого, реализуются все более специфические возможности связывания с данными. В этой новой иерархии всегда можно выбрать подходящий класс и на его основе создать собственный элемент управления, связан-ный с данными. Типы элементов управления, связанных с данными Любой серверный элемент управления может автоматически извлекать определен-ные данные из внешнего источника. Рассматривая способы взаимодействия между источником данных и элементом управления, можно выделить три разные формы связывания с данными и, соответственно, три разных вида элементов управления: простые, списочные и составные. Простое связывание с данными Простейший способ связывания с данными заключается в привязке объекта к одному или нескольким свойствам элемента управления. Источником данных в таком случае является не список, а отдельные элементы данных. Однако внутренняя структура элемента управления, использующего простое связывание, аналогична структуре элемента, осуществляющего сложное связывание, хотя она, конечно, проще. Элемент управления SimpleGaugeBar, обсуждавшийся в предыдущей главе, может стать хорошим примером простого элемента управления, связанного с данными. Да-лее в этой главе вы увидите, как связать его свойства Value и FormatString с полями объекта, содержащегося в источнике данных, или с элементом управления, представ-ляющим источник данных. Списочные элементы управления Списочные элементы управления выводят список элементов управления с фиксирован-ным пользовательским интерфейсом, который нельзя изменить. Примерами могут слу-жить элементы управления RadioButtonList, CheckBoxList и введенный в ASP.NET 2.0 
Элементы управления, связанные с данными и использующие шаблоны Глава 14 489 BulletedList. Главной особенностью списочных элементов управления является жесткая связь между элементами данных и дочерними элементами управления, такими как переключатели, флажки или маркеры. Как будет показано далее в этой главе, создать списочный элемент управления несложно: нужно только написать код, который будет в цикле выводить один и тот же элемент управления, каждый раз инициализируя его новым значением данных. Большинство списочных элементов управления предоставляют возможность настраи-вать вывод, например указывать количество столбцов и строк выводимых данных. Вы узнаете, как можно реализовать такую возможность в специализированном элементе управления. Сложное связывание с данными Сложные элементы управления, связанные с данными, обычно являются составными. Они выводят список элементов данных, не налагая ограничений на механизм их рен-деринга. Хорошим примером сложного элемента управления, связанного с данными, является элемент управления DataGrid. В этой главе мы разработаем элемент управления BarChart как реалистичный пример элемента со сложным связыванием и поддержкой шаблонов. Для создания пользовательского интерфейса он формирует HTML-таблицу, каждая строка которой представляет горизонтально расположенный столбец гистограммы. Информация для построения гистограммы извлекается из источника данных, с которым связан элемент управления. Внимание! В ASP.NET 1.x связывание с данными работает только в одном направлении, то есть элемент управления обычно не имеет возможности обновлять данные в источни-ке. Каждый элемент управления, связанный с данными, читает эти данные и генерирует определенное событие, когда требуется обновить их в источнике. В ASP.NET 2.0 элементы управления, представляющие источники данных, реализуют механизм двунаправленного связывания с данными. Пока на панели инструментов ASP.NET есть только три двуна-правленных элемента управления: GridView, FormView и DetailsView. Двунаправленное связывание требует написания для элемента управления дополнительного кода, который осуществляет вызов методов элемента управления, представляющего источник данных. Все примеры, приведенные в этой книге, относятся к наиболее распространенному сце-нарию - однонаправленному связыванию с данными. Механизм связывания с данными Иерархия доступных в ASP.NET 2.0 элементов управления, связанных с данными, представлена на рис. 14-1. Как видите, все классы являются производными от кор-невого класса BaseDataBoundControl. Класс BaseDataBoundControl определяет механизм связывания с данными и про-верки связанных данных. В нем реализованы общие для всех элементов управления свойства, необходимые для доступа к данным: DataSource для связи с перечислимым объектом данных и DataSourceID для связи с элементом управления, представляющим источник данных: public virtual object DataSource { get; set; } public virtual string DataSourceID { get; set; } Каждое из этих двух свойств активизирует свой механизм связывания. Они явля-ются взаимоисключающими - если установить их одновременно, будет сгенерировано исключение. Нужно ли вам как разработчику включать в свой код оба элемента? Чтобы правильно ответить на этот вопрос, нужно исследовать внутреннюю структуру элемента управления BaseDataBoundControl и его производных.
490 Часть III Элементы управления ASP.NET Рис. 14-1. Иерархия элементов управления, связанных с данными Связывание с источником данных Свойство DataSource принимает объекты, реализующие интерфейс IEnumerable (на-пример, коллекции) или IListSource (например, DataTable). Присваивание происходит так же, как в ASP.NET 1.x: ctl.DataSource = dataTable; ctl.DataBind(); Помимо установки свойства DataSource вы должны вызвать метод DataBind эле-мента управления (или содержащего его объекта, скажем, страницы). Только при вызове этого метода данные физически загружаются в представление элемента вре-мени выполнения. Свойство DataSourceID содержит строковый идентификатор связанного элемента управления, представляющего источник данных. Как только происходит связывание элемента управления с источником данных, любое взаимодействие между ними (как чтение, так и запись) оказывается вне зоны вашего контроля и является скрытым от вас. У такого решения есть как положительные, так и отрицательные стороны. Хорошо и даже замечательно то, что огромное количество кода удалено из страниц. Инфраструктура ASP.NET гарантирует правильное выполнение кода, написанного в самых лучших традициях. Таким образом, вы пишете страницы быстрее, и в них содержится меньше ошибок. Если же такой способ работы вам не нравится, можете работать по схеме ASP.NET 1.x. Внутренняя архитектура элементов управления, связанных с данными, изменилась в ASP.NET 2.0 довольно существенно. Большая часть изменений воплотилась в классе BaseDataBoundControl. Давайте посмотрим, что происходит, когда вы устанавливаете свойства DataSource и DataSourceID любого элемента управления, связанного с дан-ными. Вот мутатор свойства DataSource: //Псевдокод мутатора свойства DataSource set (object value)
Элементы управления, связанные с данными и использующие шаблоны Глава 14 491 { if (value != null) ValidateDataSource(value); _dataSource = value; OnDataPropertyChanged(); } Полученный объект источника данных сначала проверяется на допустимость типа, а затем кэшируется в закрытом члене. После этого вызывается внутренний метод OnDataPropertyChanged. Теперь посмотрим на мутатор свойства DataSourceID: //Псевдокод мутатора свойства DataSourceID set (string value) { ViewState["DataSourceID"] = value; OnDataPropertyChanged(); } Значение свойства DataSourceID кэшируется в состоянии представления, а за-тем осуществляется вызов метода OnDataPropertyChanged. Что происходит в ме-тоде OnDataPropertyChanged? Он устанавливает защищенную переменную булева типа с именем RequiresDataBinding, определенную в классе BaseDataBoundControl и наследуемую всеми производными от него элементами управления. Свойство RequiresDataBinding содержит значение true, когда элементу управления требуется связывание с данными. Теперь рассмотрим ключевые члены класса BaseDataBoundControl. Класс BaseDataBoundControl Поведение класса BaseDataBoundControl в значительной мере определяется новыми встроенными обработчиками событий, переопределенным методом DataBind (его исходная реализация содержится в элементе управления Control), а также парой виртуальных методов. Класс обрабатывает события Init и PreRender. Если хост-страница выполняет воз-врат формы, в методе OnInit свойству RequiresDataBinding автоматически присва-ивается значение true. Тем самым система гарантирует, что элементы управления, связанные с данными, будут правильно обновляться, даже если они связаны с элемен-тами управления, представляющими источники данных. В методе OnPreRender класс обеспечивает связывание с данными, если таковое необходимо. За выполнение этой задачи отвечает еще один внутренний метод, EnsureDataBound. Он проверяет значение свойства RequiresDataBinding и, если оно равно true, вызывает метод DataBind. Как уже упоминалось, метод DataBind определен в классе Control и переопределен в классе BaseDataBoundControl. Приведем его псевдокод: public override void DataBind() { PerformSelect(); } Интересно, что метод PerformSelect помечен в классе BaseDataBoundControl как абстрактный, так что его реализация оставлена производным классам. Главная задача этого метода - извлечь нужные данные из источника. Еще один абстрактный метод класса BaseDataBoundControl, метод ValidateDataSource, вызывается при установке свойства DataSource.
492 Часть III Элементы управления ASP.NET Класс DataBoundControl Методы ValidateDataSource и PerformSelect класса BaseDataBoundControl переопреде-лены в классе DataBoundControl. Вот псевдокод первого из методов: protected override void ValidateDataSource(object dataSource) { if (dataSource != null) { if (!(dataSource is IListSource) && !(dataSource is IEnumerable) && !(dataSource is IDataSource)) throw new InvalidOperationException(...); } } Как видите, объект DataSource может быть равен null или иметь один из следующих типов: IListSource, IEnumerable либо IDataSource. Интерфейс IDataSource характеризует элементы управления, представляющие источники данных. Вы можете связать эле-мент управления с элементом, представляющим источник данных, двумя способами: декларативно, используя свойство DataSourceID, или программно, установив свойство DataSource экземпляра элемента управления, связанного с данными. Теперь рассмотрим переопределенный метод PerformSelect: protected override void PerformSelect() { //Получаем объект-представление источника данных, //связанный с элементом управления DataSourceView view = GetData(); //Направляем команду SELECT связанному источнику данных; //_arguments - это внутренний член, содержащий ссылку //на структуру данных, заполняемую аргументами команды SELECT _arguments = CreateDataSourceSelectArguments(); view.Select(_arguments, OnDataSourceViewSelectCallback); //Связанные данные обрабатываются внутренней функцией обратного вызова } Этот метод подключается к объекту, представляющему источник данных, и созда-ет объект представления данных. Затем метод подготавливает команду SELECT для выполнения источником данных, таким как SqlDataSource или ObjectDataSource. Хотя разработчики элементов управления предлагают на выбор два разных способа их связывания с данными (через свойство DataSource либо DataSourceID), извлечение данных происходит всегда одинаково, с использованием объектов-представлений. Если элемент управления, который выводит данные, связан с элементом управления, представляющим источник данных, то последний содержит объект-представление источника, получаемый с использованием членов интерфейса IDataSource. Если же элемент управления связан с перечислимым объектом, то объект-представление фор-мируется динамически и возвращается методом GetData. Когда свойство DataSource не пусто, связанный объект заключается в динамически создаваемый объект-пред-ставление, являющийся экземпляром внутреннего недокументированного класса ReadOnlyDataSource. Объект DataSourceView имеет метод Select, используя который, он извлекает дан-ные. Как следует из приведенного выше псевдокода, метод Select принимает некоторые 
Элементы управления, связанные с данными и использующие шаблоны Глава 14 493 входные значения и функцию обратного вызова. Эта функция получает перечислимую коллекцию данных. Итак, объект представления источника данных создается в любом случае, какой бы объект-источник данных вы ни связали с элементом управления. Представление источника данных - это класс, который может выполнять над связанными данными операции SELECT, INSERT, DELETE и UPDATE. Элемент управления DataBoundControl передает оператор SELECT представлению источника данных и получает перечисли-мую коллекцию данных. Эта коллекция содержит данные, которые нужно отобразить в пользовательском интерфейсе элемента управления независимо от того, какой эле-мент управления используется, DataSource или DataSourceID. А как вы, будучи разработчиком элемента управления, можете получить доступ к связываемой коллекции данных? Примечание Внутренняя структура класса HierarchicalDataBoundControl почти идентична структуре класса DataBoundControl, с тем лишь отличием, что в первом классе исполь-зуется иерархический объект-представление. Переопределяемый метод PerformDataBinding Функция обратного вызова, которая получает для обработки результаты выполнения операции SELECT объектом представления источника данных, вызывает защищенный переопределяемый метод PerformDataBinding: protected virtual void PerformDataBinding(IEnumerable data) { //data - это коллекция данных для вывода //в элементе управления, связанном с данными } Метод PerformDataBinding элемента управления DataBoundControl не содержит исполняемого кода. В производных классах его можно переопределить, чтобы он загружал связанные данные во внутреннюю структуру элемента. В ASP.NET 2.0 элементы управления, связанные с данными, обладают очень разно-образными функциональными возможностями, а разрабатывать их при этом просто, как никогда. В большинстве случаев вам потребуется лишь создать новый класс, про-изводный от DataBoundControl, и переопределить в нем метод PerformDataBinding. Итак, вы получили необходимую вводную информацию, и теперь давайте поп-робуем разработать несколько типичных пользовательских элементов управления, связанных с данными. По ходу дела мы детальнее обсудим другие представленные в схеме на рис. 14-1 классы элементов управления, связанных с данными. Примечание У элементов управления, связанных с данными, есть довольно популярное свойство DataMember, которое широко используется в ASP.NET 1.x, как правило, совмес-тно со свой ством DataSource. Оно содержит строку, идентифицирующую член данных в заданном источнике. В ASP.NET 2.0 эти два свойства разделены: DataSource определено в классе BaseDataBoundControl, а DataMember - в классе DataBoundControl. Создание простого элемента управления, связанного с данными В предыдущей главе мы создали составной элемент управления SimpleGaugeBar, который выводит индикатор выполнения определенного задания. Его входными дан-ными являются значения свойств Value и Maximum, соотношение которых индикатор отображает в графической форме. Элемент управления SimpleGaugeBar не связан 
494 Часть III Элементы управления ASP.NET с данными, то есть ни один из элементов его интерфейса нельзя связать с элементом, хранящимся во внешнем источнике данных. Будучи производным от CompositeControl, элемент управления SimpleGaugeBar не реализует никаких описанных выше функций, которые имеют отношение к связыванию с данными. Ключевые компоненты элемента управления Связанная с данными версия элемента управления SimpleGaugeBar реализует техно-логию простого связывания. Пару его существующих свойств можно автоматически заполнять внешними данными согласно классической схеме связывания с данными, применяемой в ASP.NET. Источнику данных, заданному в свойстве DataSource или DataSourceID и обладающему характеристиками, необходимыми для связывания, ставится в соответствие группа открытых свойств объекта, связанного с данными. В случае простого связывания источником данных является отдельный объект, со-держащий только один логический информационный элемент (не список и не набор полей). Ниже перечислены ключевые компоненты каждого элемента управления, связан-ного с данными: дополнительные свойства, представляющие соответствие между свойствами эле-мента управления и полями источника данных; дополнительное свойство, которое представляет и сохраняет объект-источник данных; дополнительная функция управления состоянием представления, необходимая для сохранения объекта-источника данных; модифицированная функция рендеринга, которая учитывает наличие связанных данных. Добавление свойств, связанных с данными Подключая элемент управления к данным, вы вначале задаете источник данных, а за-тем указываете, какие его поля содержат необходимые элементу управления данные. Например, в случае элемента управления DropDownList необходимо задать поля, из которых берутся текстовые элементы и соответствующие им значения. Эти поля задаются в строковых свойствах DataTextField и DataValueField элемента управления DropDownList. Для создаваемого нами элемента управления необходимо определить аналогичные свойства. Обычно все подобные свойства являются строковыми. Хотя их имена про-извольны, как правило, они соответствуют шаблону DataXxxField, где Xxx обозначает роль связываемого свойства. Добавление свойств для связи с элементом данных Элемент управления, представляющий источник данных, должен представлять собой класс, реализующий любые из перечисленных интерфейсов: IEnumerable (коллекции), IListSource (объекты ADO.NET), IDataSource (элементы управления, представляющие источники данных). Предположим, что мы хотим связать элемент управления с од-ной строкой таблицы данных, которая представлена объектом DataTable. Нужно ли сохранять всю строку данных? Если да, то что будет, если строка данных содержит несколько BLOB-полей? Очевидно, что лучше всего извлечь из первоначального объекта-источника данных необходимое подмножество полей и скопировать их в более специализированный объект. Это должен быть экземпляр пользовательского класса, имеющего столько 
Элементы управления, связанные с данными и использующие шаблоны Глава 14 495 открытых свойств, сколько связываемых свойств имеет элемент управления. Напри-мер, у элемента управления DropDownList есть два связываемых свойства, Text и Value. Значит, объект, представляющий элемент данных (ListItem), тоже должен иметь два свойства, Text и Value (их имена произвольны). В новом элементе управления, связанном с данными, определяется класс элемен-та данных, который будет заполняться необходимой информацией, содержащейся в связанном источнике данных. Для правильного обновления страницы при возврате формы необходимо сохранять объект этого класса в состоянии представления. Соот-ветственно, класс должен быть способен сериализовать свои данные, чтобы не при-ходилось использовать с этой целью встроенные средства. Иными словами, в классе элемента данных следует реализовать интерфейс IStateManager, как мы делали это со стилевыми свойствами. Примечание Если связывание осуществляется со списком элементов, класс элемента данных будет коллекцией объектов одиночных элементов данных. Дополнительное управление состоянием представления Пользовательский элемент управления, связанный с данными и поддерживающий элементы данных, должен предоставлять дополнительный код управления состоянием представления, необходимый для того, чтобы данные правильно сохранялись и вос-станавливались. Для этого в элементе управления, связанном с данными, следует пере-определить методы LoadViewState и SaveViewState, чтобы сохранять полезные объек ты, реализующие интерфейс IStateManager, такие как стили и элементы данных. Заметьте, что в элементе управления SimpleGaugeBar, описанном в главе 13, мы не переопределяли методы LoadViewState и SaveViewState пользовательского объекта стиля. Правильность такого решения спорна, и для надежности лучше переопреде-лить указанные свойства, когда пользовательский элемент управления работает с объектами, реализующими интерфейс IStateManager. Если этого не сделать, возникнет риск потери динамически модифицированных значений стилевых атрибутов (или атрибутов объекта IStateManager). Рассмотрим такой код: protected void Page_Load(object sender, EventArgs e) { if (!IsPostBack) SimpleGaugeBar1.TextStyle.BackColor = Color.Yellow; } Значение атрибута BackColor задается лишь при первом отображении страницы. Поэтому, если свойство TextStyle не будет явно сохранено в состоянии представле-ния (см. главу 13), заданная установка цвета при первом же возврате формы будет утеряна. protected void Page_Load(object sender, EventArgs e) { //Стиль динамически изменяется при каждом вызове страницы, //поэтому нет нужды сохранять объект стиля в состоянии представления SimpleGaugeBar1.TextStyle.BackColor = Color.Yellow; } Если ожидается, что пользователи созданного вами элемента управления будут устанавливать стили во время разработки и не станут проверять свойство IsPostBack, то можно сэкономить на управлении состоянием представления, по крайней мере для стилей.
496 Часть III Элементы управления ASP.NET Переопределение метода PerformDataBinding Следующей ключевой задачей разработки специализированного элемента управления, связанного с данными и наследующего класс DataBoundControl, является переопреде-ление метода PerformDataBinding. Этот метод получает контент связанного источника данных в форме перечислимого объекта. При разработке элемента управления необ-ходимо написать код, считывающий нужные данные из их источника и кэширующий их в объекте элемента данных. Напоследок следует переопределить механизм рендеринга элемента управления, чтобы он выводил связанные данные. Примечание Если вам не требуется связанный с данными элемент управления, который ведет себя определенным образом (например, список или составной элемент), то лучше всего делать свой элемент производным от DataBoundControl. Если же вы хотите начать с более низкого уровня, то можете создать элемент, производный от BaseDataBoundControl, и переопределить в нем методы PerformSelect и ValidateDataSource. Нет нужды говорить, что этот путь хорош только для тех случаев, когда нужно изменить способ проверки и/или извлечения данных. Элемент управления GaugeBar Давайте, выполнив описанные выше действия, создадим новую версию элемента управления SimpleGaugeBar и назовем ее GaugeBar. Это будет составной элемент уп-равления, и мы сделаем его производным от DataBoundControl, в котором реализована готовая функциональность связывания с данными. public class GaugeBar : DataBoundControl { } Чтобы быть точным, добавлю, что в ASP.NET 2.0 есть еще класс CompositeData-BoundControl, который поддерживает и связывание с данными, и создание составных элементов. Мы воспользуемся им в следующем примере. Определение соответствия между полями источника данных и свойствами элемента управления В нашем новом элементе управления GaugeBar используется очень тщательно про-анализированный в главе 12 код элемента управления SimpleGaugeBar. Для каждого связываемого свойства, входящего в состав интерфейса программирования элемента управления, нам требуется дополнительное строковое свойство. Элемент управления GaugeBar имеет два связываемых свойства, Value и FormatString. Их выбор сделан произвольно. Нам нужно определить пару строковых свойств с именами DataXxxField, одно для Value и одно для FormatString. Эти свойства, DataValueField и DataTextField, будут содержать имена полей источника данных, которые соответствуют свойствам Value и FormatString. Снова-таки, имена свойств DataValueField и DataTextField выбраны произвольно. public virtual string DataValueField { get { object o = ViewState["DataValueField"]; if (o == null) return String.Empty; return (string) o;
Элементы управления, связанные с данными и использующие шаблоны Глава 14 497 } set { ViewState["DataValueField"] = value; } }public virtual string DataTextField { get { object o = ViewState["DataTextField"]; if (o == null) return String.Empty; return (string) o; } set { ViewState["DataTextField"] = value; } } Как видите, оба свойства хранят свои данные в коллекции ViewState и по умол-чанию содержат пустые строки. Наш класс GaugeBar имеет еще три популярных свойства, унаследованных от родительских классов: DataSource, DataSourceID и DataMember. Объект элемента данных GaugeBar Поскольку мы связали элемент управления GaugeBar с внешними данными, нам при-дется эти данные отслеживать и кэшировать. Для этой цели нам потребуется объект элемента данных. Как уже упоминалось, так называется объект пользовательского класса, содержащего столько открытых свойств, сколько связываемых свойств имеет-ся в интерфейсе элемента управления. Класс элемента данных элемента управления GaugeBar будет иметь имя GaugeBarDataItem (опять же, выбранное произвольно) и следующее определение: public class GaugeBarDataItem : IStateManager { private string _text; private float _value; private bool _marked; public GaugeBarDataItem() { } public GaugeBarDataItem(float value, string text) { _text = text; _value = value; } public string Text { get { return _text; } set { _text = value; } } public float Value { get { return _value; } set { _value = value; }
498 Часть III Элементы управления ASP.NET } public bool IsTrackingViewState { get { return _marked; } } public void LoadViewState(object state) { if (state != null) { Pair p = (Pair)state; _value = (float)p.First; _text = (string)p.Second; } } public object SaveViewState() { return new Pair(_value, _text); } public void TrackViewState() { _marked = true; } } У данного класса два открытых свойства, Text и Value, сохраняемых с использованием локальных членов класса, и он реализует интерфейс IStateManager, используя который, сохраняет свои данные между возвратами формы в состоянии представления. Метод SaveViewState возвращает объект Pair (род упрощенного двухэлементного массива), заполненный текущими значениями свойств Text и Value. Объект Pair, воз-вращаемый методом ViewState, становится входным аргументом метода LoadViewState, который распаковывает объект Pair и инициализирует свойства Text и Value. Элемент управления GaugeBar должен иметь доступное только для чтения открытое свойство типа GaugeBarDataItem с произвольным именем. Я назвал его DataItem: private GaugeBarDataItem _dataItem; private GaugeBarDataItem DataItem { get { if (_dataItem == null) { _dataItem = new GaugeBarDataItem(); if (base.IsTrackingViewState) _dataItem.TrackViewState(); } return _dataItem; } } В отличие от свойств элемента управления, сохраняемых в коллекции ViewState, свойство DataItem содержит свое значение в приватном члене _dataItem. Однако 
Элементы управления, связанные с данными и использующие шаблоны Глава 14 499 данный член не является постоянным и не может сохранять свое значение между возвратами формы. Поэтому в аксессоре свойства DataItem необходимо проверять свойство _dataItem на равенство значению null и при положительном результате создавать новый экземпляр класса GaugeBarDataItem. Код, содержащийся в аксессоре свойства, выполняется при обращении к этому свойству. Как вы сейчас сможете убедиться, приведенный выше код гарантирует, что при обращении к свойству DataItem никогда не будет возвращено значение null и что состояние объекта будет правильно восстанавливаться после каждого возврата формы. Элемент данных и состояние представления Большинство свойств элемента управления, которые мы рассматривали до сих пор, используют для сохранения своих значений состояние представления. Почему же мы не храним в нем значение свойства DataItem и стили? Что не так, например, с при-веденным ниже кодом? //NB: чтобы этот код работал, тип GaugeBarDataItem //должен быть сериализуемым public virtual GaugeBarDataItem DataItem { get { object o = ViewState["DataItem"]; if (o == null) return new GaugeBarDataItem(); return (string) o; } set { ViewState["DataItem"] = value; } } Ошибок здесь никаких нет, но подумайте о том, как использование такого кода отразится на производительности элемента управления. Если сохранять целый объект в состоянии представления, то придется применять двоичный сериализатор. Класс BinaryFormatter, который является стандартным средством сериализации управляемых объектов приложений .NET, не отличается высоким быстродействием и предназначен для сохранения состояния объекта целиком, включая его открытые и закрытые свойс-тва - как простые, так и составные. Поэтому применение данного класса приводит к увеличению времени отклика сервера и генерированию объемного состояния пред-ставления. В то же время, прибегнув к пользовательской сериализации, вы получите быстродействующий код и существенно сократите объем подлежащей сохранению информации. Таким образом, можно сформулировать простое правило: контейнер ViewState подходит для сохранения свойств примитивных типов - строк, булевых значений, цветов, дат, байтов и массивов любого из этих типов. Ссылочные типы (такие как пользовательские классы), подлежат пользовательской сериализации; вам нужно реа-лизовать интерфейс IStateManager и предоставлять доступ к свойствам через аксессор, подобный приведенному выше. Если речь идет о разработке элементов управления, то описанные действия необходимо выполнить для свойств-стилей и свойств, пред-ставляющих элементы данных. Специализированное управление состоянием В элементе управления, который имеет свойства, сохраняемые в состоянии пред-ставления с применением пользовательской процедуры сериализации, необходимо 
500 Часть III Элементы управления ASP.NET переопределить защищенные методы SaveViewState и LoadViewState. Они опреде-лены в классе Control и по умолчанию работают только с контейнерным объектом ViewState: protected override object SaveViewState() { //Получаем стандартный объект состояния - контейнер ViewState object baseState = base.SaveViewState(); //Получаем объект состояния для свойства DataItem object itemState = DataItem.SaveViewState(); //Получаем объект состояния для объекта TextStyle object styleState = TextStyle.SaveViewState(); //Упаковываем все в единый объект return new Triplet(baseState, itemState, styleState); } Метод SaveViewState элемента управления GaugeBar должен сохранять три объекта: стандартное состояние представления, свойство DataItem и свойство TextStyle. Стандарт-ное состояние представления вы сохраняете с помощью вызова метода SaveViewState базового класса, а другие объекты состояния - путем вызова метода SaveViewState из ре-ализации интерфейса IStateManager объектов DataItem и TextStyle. Метод SaveViewState элемента управления должен возвращать один объект, поэтому необходимо объединить все данные - в массив или комбинацию объектов Pair и Triplet. Объект, возвращенный методом SaveViewState, получает метод LoadViewState, который извлекает их него данные и записывает их в исходные свойства. protected override void LoadViewState(object savedState) { if (savedState != null) { Triplet t = (Triplet) savedState; base.LoadViewState(t.First); DataItem.LoadViewState(t.Second); TextStyle.LoadViewState(t.Third); } else { base.LoadViewState(null); } } Реализация метода LoadViewState интерфейса IStateManager для сериализуемых объектов определяет, как каждый объект (скажем, стиль или элемент данных) вос-станавливает свои данные. Заметьте, что при вызове метода DataItem.LoadViewState вызывается аксессор свойства DataItem, который при первом вызове инициализирует внутренний член _dataItem. Получение связанных данных В ASP.NET 2.0 связанный с данными элемент управления получает их с помощью ме тода PerformDataBinding. Этот метод обязательно должен быть переопределен, поскольку его стандартная реализация ничего не делает. Важно помнить, что аргу-
Элементы управления, связанные с данными и использующие шаблоны Глава 14 501 мент IEnumerable, передаваемый методу PerformDataBinding, представляет коллекцию связанных данных, причем независимо от формата исходных данных (это может быть и объект ADO.NET, и коллекция, и элемент управления, представляющий источник данных). Ниже приведена реализация метода PerformDataBinding для класса GaugeBar: protected override void PerformDataBinding(IEnumerable data) { //Аргумент data - это один объект, а не список. Нам же нужно получить итератор //и один раз вызвать метод MoveNext для получения данных if (data == null) return; IEnumerator e = data.GetEnumerator(); e.MoveNext(); //Устанавливаем значения связанных свойств по умолчанию float displayValue = 0; string displayText = String.Empty; //Считываем значение свойства Value if (!String.IsNullOrEmpty(DataValueField)) displayValue = (float) DataBinder.GetPropertyValue( e.Current, DataValueField); //Считываем значение свойства FormatString if (!String.IsNullOrEmpty(DataTextField)) displayText = (string) DataBinder.GetPropertyValue( e.Current, DataTextField); //Заполняем свойство DataItem DataItem.Value = displayValue; DataItem.Text = displayText; } В данном случае объект IEnumerable, переданный методу PerformDataBinding, со-держит единственный элемент. Однако этот интерфейс не делает различия между единственным элементом и списком. Следовательно, для получения объекта данных вам нужно получить итератор и перейти к первому элементу. //data имеет тип IEnumerable IEnumerator e = data.GetEnumerator(); e.MoveNext(); //Используйте e.Current для получения физического объекта данных Выражение e.Current возвращает объект данных, связанный с элементом управле-ния, то есть контейнер, из которого вы можете извлечь поля, соответствующие связы-ваемым свойствам. Если вы знаете, что элемент управления связан, скажем, с объектом DataRow, то можете извлечь значение свойства Value, используя такой код: displayValue = ((DataRow) e.Current)[DataValueField]; Использование класса DataBinder делает код более гибким и не зависящим от типа связанного источника данных. Метод GetPropertyValue класса DataBinder, применяя технологию рефлексии, получает информацию об объекте, чтобы узнать, есть ли у него открытое свойство с заданным именем: displayText = (string) DataBinder.GetPropertyValue( e.Current, DataTextField);
502 Часть III Элементы управления ASP.NET Метод GetPropertyValue возвращает объект данных, который нужно привести к тре-буемому типу. Остальная часть работы заключается в обновлении механизма рендеринга, чтобы при необходимости осуществить связывание данных производилось обращение к объекту DataItem. Приведенный ниже метод BuildLabel выводит возле индикатора нашего элемента управления описательный текст (описание элемента управления было приведено в главе 13). void BuildLabel(TableCell container) { //Вычисляем значение, которое нужно представить float buf = GetValueToRepresent(); //Получаем строку для вывода надписи string msg = GetTextToRepresent(); Label lbl = new Label(); if (container is TableCell) container.Controls.Add(lbl); else Controls.Add(lbl); lbl.Text = String.Format(msg, buf, Maximum); } Метод BuildLabel добавляет в формируемую иерархию элементов управления эле-мент Label. Текст, который выводится в этом элементе, составляется с использованием значений данных и строки форматирования элемента управления. Свойства Value и FormatString можно связывать с данными или присваивать им значения статически. Поэтому необходима функция, которая будет проверять наличие связи с данными и возвращать либо связанное значение, либо присвоенное. Если имеются и связанное, и присвоенное значения, то элемент возвращает связанное. float GetValueToRepresent() { float f = 0; if (DataItem.Value >=0) f = DataItem.Value; else f = Value; return f; }string GetTextToRepresent() { string msg = ""; if (!String.IsNullOrEmpty(DataItem.Text)) msg = DataItem.Text; else msg = FormatString; return msg; } Никакие другие изменения для расширения элемента управления SimpleGaugeBar (см. главу 13) и реализации в нем поддержки связывания с данными не требуются.
Элементы управления, связанные с данными и использующие шаблоны Глава 14 503 Ниже приведен код обработчика события Load демонстрационной страницы, на которой используется элемент управления GaugeBar, связываемый с динамически генерируемым объектом DataTable: protected void Page_Load(object sender, EventArgs e) { //В качестве значения GaugeBar используется случайное число. //Это значение хранится в объекте DataTable Random rnd = new Random(); DataTable dt = new DataTable(); dt.Columns.Add("Numbers", typeof(float)); dt.Columns.Add("Label", typeof(string)); DataRow row = dt.NewRow(); row[0] = rnd.Next(0,100); row[1] = "{0} out of {1}"; dt.Rows.Add(row); dt.AcceptChanges(); //Связываем данные DataTable с GaugeBar GaugeBar1.DataValueField = "Numbers"; GaugeBar1.DataTextField = "Label"; GaugeBar1.DataSource = dt; GaugeBar1.DataBind(); } У элемента управления DataTable два столбца, Numbers типа float и Label типа string. Таблица должна содержать одну строку данных. Если в ней несколько строк, метод PerformDataBinding использует только первую. Связать данные с элементом управления GaugeBar можно также с помощью свой-ства DataItem: GaugeBar1.DataItem.Value = 12; GaugeBar1.DataItem.Text = "{0} %"; Заметьте, что для инициирования процесса и обновления пользовательского эле-мента управления вызов метода DataBind не требуется. Связывание списочного элемента управления с данными Элементы управления, связанные с данными, часто бывают списочными. Такой эле-мент формирует свой пользовательский интерфейс, повторяя для каждого связанного элемента данных определенный шаблон. Например, элемент управления CheckBoxList выводит для каждого элемента данных элемент управления CheckBox, а элемент уп-равления DropDownList создает для каждого элемента данных новый элемент <option> в рамках родительского тэга <select>. В ASP.NET 2.0 все списочные элементы управления наследуют ListControl - единс-твенный среди представленных на рис. 14-1 классов, который был определен еще в ASP.NET 1.x. Элемент управления ListControl добавляет в интерфейс своего роди-тельского класса DataBoundControl целую серию новых членов. Кроме того, списоч-ные элементы часто предоставляют возможность управлять их выводом, например выбирать между горизонтальным и вертикальным рендерингом. Общие характеристики списочных элементов управления Как показано на рис. 14-1, элемент управления ListControl является родоначальни-ком пяти часто используемых элементов управления: DropDownList, CheckBoxList, 
504 Часть III Элементы управления ASP.NET RadioButtonList, ListBox и BulletedList. Элемент управления BulletedList реализован толь-ко в ASP.NET 2.0. Перечисленные элементы имеют единый интерфейс программирова-ния, мало чем отличающийся от интерфейса элемента управления DataBoundControl. Рассмотрим некоторые из их открытых членов. Дополнительные свойства элемента управления ListControl В табл. 14-1 перечислены свойства и методы, специфические для класса ListControl и всех производных от него элементов управления. Табл. 14-1. Свойства, специфические для списочных элементов управления Свойство Описание AppendDataBoundItems Указывает, можно ли заполнять коллекцию Items и программно, и путем связывания с данными AutoPostBack Указывает, должен ли при изменении выделения производиться автоматический возврат формы CausesValidation Указывает, должна ли перед возвратом формы производиться валидация элемента DataTextField Имя поля источника данных, в котором содержится текст связанных элементов DataTextFormatString Строка форматирования выводимого текста DataValueField Имя поля источника данных, в котором содержатся значения связанных элементов Items Коллекция связанных элементов. В зависимости от значения свойства AppendDataBoundItems эта коллекция может заполняться программно. Элементы коллекции имеют тип ListItem SelectedIndex Индекс текущего элемента SelectedItem Объект ListItem, соответствующий текущему элементу SelectedValue Значение текущего элемента Text Устанавливает и возвращает значение свойства SelectedValue ValidationGroup Имя проверочной группы, к которой принадлежит элемент Некоторые свойства, такие как AutoPostBack, CausesValidation и ValidationGroup, не имеют отношения к связыванию элемента управления с данными. Элементы данных у всех списочных элементов управления имеют тип ListItem. Поскольку списочные эле-менты управления не используют описанное выше свойство DataItem, указывающее на единственный объект, а выводят список элементов, необходима коллекция объектов. Такую коллекцию представляет свойство Items, имеющее тип ListItemCollection. Когда вы связываете списочный элемент управления с данными, коллекция Items запол-няется; обычно это происходит в методе PerformDataBinding. Однако если свойство AppendDataBoundItems возвращает значение true (а это его значение по умолчанию), элементы в свойство ListItem можно добавлять программным способом. Простейший списочный элемент управления Списочный элемент управления можно создавать двумя способами. В простейшем случае класс делается производным от элемента управления ListControl. Как будет показано чуть ниже, количество кода, который при этом нужно написать, минимально, но следует иметь в виду несколько ограничений. Предположим, что нужно создать список гиперссылок. Элемент управления, который в этом случае будет многократно выводиться, - это HyperLink, и нам нужно задать URL и текст каждой ссылки с ис-пользованием связываемых свойств.
Элементы управления, связанные с данными и использующие шаблоны Глава 14 505 public class SimpleHyperLinkList : ListControl { private HyperLink _controlToRepeat; private HyperLink ControlToRepeat { get { if (_controlToRepeat == null) _controlToRepeat = new HyperLink(); return _controlToRepeat; } } protected override void Render(HtmlTextWriter writer) { for (int i=0; i<Items.Count; i++) { HyperLink ctl = ControlToRepeat; ctl.ApplyStyle(ControlStyle); ctl.Text = Items[i].Text; ctl.NavigateUrl = Items[i].Value; ctl.RenderControl(writer); writer.Write("<br />"); } } } Главными компонентами элемента управления SimpleHyperLinkList являются за-крытое свойство ControlToRepeat и метод Render. Свойство ControlToRepeat указывает на дерево элементов управления, которое должно повторяться для каждого связанного элемента данных. Вы создаете это дерево при первом обращении к элементу управ-ления, а потом оно используется повторно. В методе Render выполняется цикл, на каждой итерации которого выводится элемент управления HyperLink. Свойствам Text и HyperLink присваиваются значе-ния связанных полей. Метод RenderControl выводит разметку элемента управления HyperLink. Эта разметка накапливается в объекте writer, после чего выводится, как показано на рис. 14-2. Рис. 14-2. Элемент управления SimpleHyperLinkList Вам следует знать о некоторых важных ограничениях, связанных с работой эле-мента управления SimpleHyperLinkList. Если этот элемент является производным от 
506 Часть III Элементы управления ASP.NET ListControl, он должен использовать в качестве элемента данных объект типа ListItem, и вы не можете создать собственный тип. Имена существующих свойств, которые ставятся в соответствие элементам данных, также нельзя изменить, хотя можно до-бавить новые такие свойства. Сейчас мы продолжим исследование списочных элементов управления, связанных с данными, и напишем расширенную версию элемента управления SimpleHyperLinkList, работающую с пользовательской коллекцией данных и пользовательскими свойствами. Элемент управления HyperLinkList Поведение нашего нового элемента управления будет почти полностью определяться его базовым элементом ListControl. Объявление класса HyperLinkList таково: public class HyperLinkList : DataBoundControl, IRepeatInfoUser { } Методы интерфейса IRepeatInfoUser помогают сформировать разметку нового элемента, в которой гиперссылки выводятся в несколько столбцов (число его строк и столбцов задается пользователем). Определение соответствия между полями источника данных и свойствами элемента управления У элемента управления HyperLinkList есть три свойства, соответствующие полям источника данных: DataTextField, DataTooltipField и DataUrlField. public virtual string DataTextField { get { object o = ViewState["DataTextField"]; if (o == null) return String.Empty; return (string) o; } set { ViewState["DataTextField"] = value; } }public virtual string DataTooltipField { get { object o = ViewState["DataTooltipField"]; if (o == null) return String.Empty; return (string) o; } set { ViewState["DataTooltipField"] = value; } }public virtual string DataUrlField { get { object o = ViewState["DataUrlField"];
Элементы управления, связанные с данными и использующие шаблоны Глава 14 507 if (o == null) return String.Empty; return (string) o; } set { ViewState["DataUrlField"] = value; } } Представленные свойства ставят три ключевых атрибута гиперссылки (отобра-жаемый текст, всплывающая подсказка и URL) в соответствие полям источника данных. Элемент данных элемента управления HyperLinkList Объект элемента данных - это класс, который представляет элемент данных, связан-ных с элементом управления. В нашем примере он содержит компоненты гиперссылки: отображаемый текст, всплывающую подсказку и URL. public class HyperLinkItem { private string _text; private string _url; private string _tooltip; public HyperLinkItem() { } public HyperLinkItem(string url, string text, string tooltip) { _text = text; _url = url; _tooltip = tooltip; } public string Text { get { return _text; } set { _text = value; } } public string Tooltip { get { return _tooltip; } set { _tooltip = value; } } public string Url { get { return _url; } set { _url = value; } } } В составе класса определены три открытых члена, Url, Tooltip и Text, значения которых хранятся в локальных переменных, а также пара конструкторов. Класс HyperLinkItem представляет n-й элемент связанных данных. Для представления всего набора связанных данных нам нужна коллекция объектов HyperLinkItem.
508 Часть III Элементы управления ASP.NET Для создания коллекции в ASP.NET 2.0 может использоваться родовой тип, что позволяет существенно уменьшить объем необходимого кода, если не свести его к ну-лю. Однако в нашем случае нужно реализовать интерфейс IStateManager. class HyperLinkItemCollection : Collection<HyperLinkItem>, IStateManager { private bool _marked; public HyperLinkItemCollection() { _marked = false; } public bool IsTrackingViewState { get { return _marked; } } public void TrackViewState() { _marked = true; } public void LoadViewState(object state) { if (state != null) { Triplet t = (Triplet) state; //Необходимо гарантировать, что коллекция, //которую мы собираемся заполнить, пуста Clear(); string[] rgUrl = (string[])t.First; string[] rgText = (string[])t.Second; string[] rgTooltip = (string[])t.Third; for (int i = 0; i < rgUrl.Length; i++) Add(new HyperLinkItem(rgUrl[i], rgText[i], rgTooltip[i])); } } public object SaveViewState() { int numOfItems = Count; object[] rgTooltip = new string[numOfItems]; object[] rgText = new string[numOfItems]; object[] rgUrl = new string[numOfItems]; for (int i = 0; i < numOfItems; i++) { rgTooltip[i] = this[i].Tooltip; rgText[i] = this[i].Text; rgUrl[i] = this[i].Url; } return new Triplet(rgUrl, rgText, rgTooltip); } }
Элементы управления, связанные с данными и использующие шаблоны Глава 14 509 Открытым свойством нашего элемента управления, соответствующим свойству DataItem элемента управления GaugeBar, является коллекция Items (ее имя выби-рается произвольно). private HyperLinkItemCollection _items; public virtual HyperLinkItemCollection Items { get { if (_items == null) { _items = new HyperLinkItemCollection(); if (base.IsTrackingViewState) _items.TrackViewState(); } return _items; } } Интересен код метода SaveViewState. Возвращаемый им объект должен содержать URL, текст и всплывающую подсказку каждого связанного элемента данных. Для их хранения используются три массива, которые объединяются в объект Triplet. Метод LoadViewState распаковывает эту информацию и заполняет коллекцию. Таким образом, класс HyperLinkItemCollection способен сохранять и восстанавли-вать свои данные, используя состояние представления. Однако необходим еще код управления состоянием представления объекта HyperLinkList: protected override object SaveViewState() { object baseState = base.SaveViewState(); object itemState = Items.SaveViewState(); return new Pair(baseState, itemState); }protected override void LoadViewState(object savedState) { if (savedState != null) { Pair p = (Pair) savedState; base.LoadViewState(p.First); Items.LoadViewState(p.Second); } } Методы SaveViewState и LoadViewState элемента управления HyperLinkList вызыва-ются, когда элемент управления собирается сохранить свои данные в состоянии пред-ставления или восстановить их оттуда. Вызов такой же пары методов свойства Items гарантирует, что коллекция будет сохраняться и восстанавливаться правильно. Получение связанных данных Связанный с данными элемент управления получает данные с помощью метода PerformDataBinding. Такой элемент управления содержит коллекцию, представляю-щую источник данных. Задача метода PerformDataBinding - извлечь информацию из источника и обеспечить ее кэширование в промежуточной структуре данных, причем 
510 Часть III Элементы управления ASP.NET как можно более легковесной, поскольку ее необходимо сохранять между возврата-ми формы. protected override void PerformDataBinding(IEnumerable dataSource) { base.PerformDataBinding(dataSource); string urlField = DataUrlField; string textField = DataTextField; string tooltipField = DataTooltipField; if (dataSource != null) { foreach (object o in dataSource) { HyperLinkItem item = new HyperLinkItem(); item.Url = DataBinder.GetPropertyValue(o, urlField, null); item.Text = DataBinder.GetPropertyValue(o, textField, null); item.Tooltip = DataBinder.GetPropertyValue(o, tooltipField, null); Items.Add(item); } } } Как видите, для каждого элемента данных код создает новый объект HyperLinkItem, заполняет его значениями полей и добавляет в коллекцию Items. Интерфейс IRepeatInfoUser Пока наш элемент управления HyperLinkList мало отличается от своего предшес-твенника SimpleHyperLinkList, созданного в предыдущем разделе, разве что у него несколько иной набор членов. Теперь пришло время снабдить его новой функцией - способностью выводить элементы в заданном направлении и с заданным количеством строк и столбцов. Если вам приходилось пользоваться встроенным элементом управ-ления ASP.NET CheckBoxList, то вам известно назначение свойств RepeatDirection, RepeatLayout и RepeatColumns. Будучи установленными, эти свойства определяют направление вывода элементов списка и его раскладку. В табл. 14-2 указана роль каждого из этих свойств; все они доступны для чтения и записи. Табл. 14-2. Свойства интерфейса IRepeatInfoUser Свойство Описание RepeatColumns Определяет количество столбцов RepeatDirection Указывает направление вывода: по вертикали или по горизонтали RepeatLayout Определяет способ вывода: табличный или потоковый Задавая эти свойства в разных сочетаниях, можно изменять внешний вид элемента управления. Давайте посмотрим, как запрограммировать данные свойства. public virtual RepeatDirection RepeatDirection { get { object o = ViewState["RepeatDirection"]; if (o != null) return (RepeatDirection) o;
Элементы управления, связанные с данными и использующие шаблоны Глава 14 511 return RepeatDirection.Vertical; } set { ViewState["RepeatDirection"] = value; } }public virtual int RepeatColumns { get { object o = ViewState["RepeatColumns"]; if (o != null) return (int) o; return 0; } set { ViewState["RepeatColumns"] = value; } }public virtual RepeatLayout RepeatLayout { get { object o = ViewState["RepeatLayout"]; if (o != null) return (RepeatLayout) o; return RepeatLayout.Table; } set { ViewState["RepeatLayout"] = value; } } Элемент управления, который хочет поддерживать определенные возможности рендеринга, должен содержать в методе Render соответствующий код. protected override void Render(HtmlTextWriter writer) { if (Items.Count > 0) { RepeatInfo ri = new RepeatInfo(); Style controlStyle = (base.ControlStyleCreated ? base.ControlStyle : null); ri.RepeatColumns = RepeatColumns; ri.RepeatDirection = RepeatDirection; ri.RepeatLayout = RepeatLayout; ri.RenderRepeater(writer, this, controlStyle, this); } } Структура RepeatInfo существует со времен ASP.NET 1.x и позволяет элементам управления выводить содержимое в соответствии с заданными правилами рендеринга. Второй параметр метода RenderRepeater указывает на объект (в нашем случае - this), реализующий интерфейс IRepeatInfoUser. Наличие данного интерфейса является обязательным. Его члены перечислены в табл. 14-3. Табл. 14-3. Члены интерфейса IRepeatInfoUser Член Описание HasFooter Указывает, имеет ли элемент управления нижний колонтитул HasHeader Указывает, имеет ли элемент управления заголовок (см. след. стр.)
512 Часть III Элементы управления ASP.NET Член Описание HasSeparators Указывает, выводятся ли между элементами разделители RepeatedItemCount Определяет количество выводимых элементов Есть у данного интерфейса и пара методов - GetItemStyle и RenderItem. Первый возвращает объект стиля, применяемого при рендеринге элементов, а второй генери-рует разметку. Следующий код показывает, как можно реализовать указанный интер-фейс для нашего элемента управления: bool IRepeatInfoUser.HasFooter { get { return false; } }bool IRepeatInfoUser.HasHeader { get { return false; } }bool IRepeatInfoUser.HasSeparators { get { return false; } }int IRepeatInfoUser.RepeatedItemCount { get { return this.Items.Count; } }Style IRepeatInfoUser.GetItemStyle(ListItemType itemType, int repeatIndex) { return null; }void IRepeatInfoUser.RenderItem(ListItemType itemType, int repeatIndex, RepeatInfo repeatInfo, HtmlTextWriter writer) { HyperLink ctl = ControlToRepeat; int i = repeatIndex; ctl.ID = i.ToString(); ctl.Text = Items[i].Text; ctl.NavigateUrl = Items[i].Url; ctl.ToolTip = Items[i].Tooltip; ctl.RenderControl(writer); } Метод RenderItem автоматически вызывается для каждого связанного элемента и осуществляет его рендеринг. В цикле может выводиться как экземпляр отдельного элемента управления (например, HyperLink в нашем случае), так и дерево элементов управления. Открытое свойство элемента управления, значение которого выводится Табл. 14-3. (окончание)
Элементы управления, связанные с данными и использующие шаблоны Глава 14 513 в цикле, может быть связано с данными. Сам элемент управления выводится с ис-пользованием метода RenderControl. Результат вы видите на рис. 14-3. Рис. 14-3. Элемент управления HyperLinkList (свойство RepeatColumns установлено равным 3) Построение составного элемента управления, использующего шаблоны Отправной точкой для построения сложных элементов управления с богатым ин-терфейсом, связанных с данными, является класс CompositeDataBoundControl. Такой элемент управления должен выполнять следующие функции: служить контейнером именования; создавать собственный пользовательский интерфейс, используя метод Create-ChildControls; содержать логику, необходимую для восстановления иерархии дочерних элементов после возврата формы. В свое время разработчикам приложений для ASP.NET 1.x приходилось немало потрудиться для реализации последнего требования, но теперь вы можете о нем за-быть: все необходимое сделает за вас класс CompositeDataBoundControl. Общие характеристики составных элементов управления, связанных с данными В ASP.NET 2.0 главным аспектом разработки составного элемента управления, свя-занного с данными, является проектирование его внутренней иерархии. Вам предсто-ит переопределить с этой целью метод CreateChildControls. Кроме того, в подобный элемент обычно добавляют стили и шаблоны. У реального составного элемента управления дерево элементов бывает очень слож-ным. В качестве внешнего контейнера часто используется многострочная HTTP-таб-лица, в ячейках которой размещаются другие элементы управления, нередко в слож-ных сочетаниях. Создание иерархии дочерних элементов управления Вам следует знать, что составные элементы управления строят свой интерфейс, ком-бинируя существующие элементы управления в методе CreateChildControls. Будучи определенным в классе Control, этот метод имеет следующий прототип: protected override void CreateChildControls() 
514 Часть III Элементы управления ASP.NET В классе CompositeDataBoundControl данный метод переопределяется и перегру-жается. Его перегруженная версия выполняет несколько интересных задач. Ее псев-докод таков: protected override void CreateChildControls() { Controls.Clear(); object o = ViewState["_!ItemCount"]; if ((o == null) && RequiresDataBinding) EnsureDataBound(); else { int numOfItems = (int) o; object[] rg = new object[numOfItems]; CreateChildControls(rg, false); base.ClearChildViewState(); } } Сначала метод очищает коллекцию Controls, чтобы в ней не осталось дочерних элементов управления, а затем извлекает значение особого элемента состояния пред-ставления с именем _!ItemCount. Данный элемент кэширует количество элементов, включенных в составной элемент управления. Код, который строит дерево элементов, отвечает за сохранение этого значения в состоянии представления. Количество элементов, образующих иерархию элемента управления, важно знать в том случае, когда желательно оптимизировать процесс связывания данных. В ASP.NET сложные элементы управления, содержащие много элементов данных, реализуются как составные элементы управления, связанные с данными. Давайте выясним, чем они отличаются от списка элементов управления с простым связыванием. Связанные с данными списочные и простые элементы управления, подобные рас-смотренному нами ранее элементу управления GaugeBar, кэшируют свои элементы данных в состоянии представления. Кроме того, они могут получать данные либо в результате связывания, либо программным способом, через коллекцию Items или свойство DataItem. Связанные с данными составные элементы управления, такие как DataGrid, DataList и GridView, получают данные исключительно посредством связывания и поэтому не сохраняют их ни в какой форме. Рассмотрим следующую ситуацию. Имеется страница со сложным элементом управления GridView и несколькими кнопочными элементами управления. Когда пользователь щелкает одну из кнопок, никакой код, имеющий отношение к элементу управления GridView, не выполняется, но при этом производится возврат формы. Без специальных ухищрений в коде эле-мента управления вы не можете гарантировать, что составной элемент управления не окажется после обновления страницы пустым. Дело в том, что если обработчик события возврата формы не свяжет данные с составным элементом управления, этот элемент не узнает, что с ним что-то не так, и не обновит свой интерфейс. Как мы уже сказали, в ASP.NET составные элементы управления по определению получают дан-ные исключительно путем связывания и не кэшируют их. Следовательно, необходима особая обработка события возврата формы. У составных элементов управления, связанных с данными, метод CreateChildControls работает в двух режимах, со связыванием и без такового. При работе без связывания элемент управления вызывает описанную в следующем подразделе перегруженную 
Элементы управления, связанные с данными и использующие шаблоны Глава 14 515 версию метода CreateChildControls. Данный метод определен как абстрактный в классе CompositeDataBoundControl, а в производных классах его нужно переопределять. Перегруженная версия метода CreateChildControls Ниже приведено объявление перегруженной версии метода CreateChildControls, оп-ределенной в классе CompositeDataBoundControl: protected abstract int CreateChildControls( IEnumerable dataSource, bool dataBinding); Первым параметром здесь является коллекция связанных данных. Второй пара-метр определяет текущую ситуацию: происходит связывание с новыми данными или обновление после возврата формы. Метод возвращает количество элементов, добав-ленных в дерево элемента управления. Это значение затем сохраняется в состоянии представления методом PerformDataBinding (определенным в классе CompositeData-BoundControl), псевдокод которого таков: protected internal override void PerformDataBinding(IEnumerable data) { base.PerformDataBinding(data); Controls.Clear(); base.ClearChildViewState(); TrackViewState(); int numOfItems = CreateChildControls(data, true); base.ChildControlsCreated = true; ViewState["_!ItemCount"] = numOfItems; } Заметьте, что метод PerformDataBinding вызывает новую перегруженную версию метода CreateChildControls и передает ей во втором аргументе значение true, указывая, что происходит процесс связывания данных. Какой код должна содержать перегруженная версия метода CreateChildControls? Скорее всего, вы предпочтете написать собственный построитель элемента управления (его типичное имя - CreateControlHierarchy) и вернуть из метода CreateChildControls значение, возвращенное этим построителем. Мы вернемся к затронутой теме, когда будем обсуждать демонстрационный элемент управления BarChart. Перегруженный метод CreateChildControls в режиме связывания вызывается из мето-да PerformDataBinding, а в режиме без связывания - из метода CreateChildControls: //o - значение, прочитанное из ViewState int numOfItems = (int) o; object[] rg = new object[numOfItems]; CreateChildControls(rg, false); В данном случае вместо связанных данных методу передается пустой массив объектов заданного размера. Массив нужен для того, чтобы построитель элемента управления (обычно это метод CreateControlHierarchy) выполнил цикл с указанным количеством итераций и построил внешний контейнер требуемой конфигурации, на-пример таблицу с необходимым количеством столбцов и строк. Как вы увидите позже, при рассмотрении примера с элементом управления BarChart, составной связанный с данными элемент управления отделяет иерархию от данных. Если булев параметр метода CreateChildControls имеет значение false, данные не добавляются в иерархию. При этом механизм возврата формы ASP.NET гарантирует, что дочерние элементы управления будут восстановлены вместе со своими значениями. Иными словами, если составной связанный с данными элемент управления выводит связанные данные, 
516 Часть III Элементы управления ASP.NET используя, скажем, элемент управления Label, тогда после возврата формы составной элемент не будет восстанавливать данные сам, а попросит свои дочерние элементы управления самостоятельно восстановить данные из состояния представления. Таким образом, элемент управления Label восстановит значение своего свойства Text. Как видите, элементы, входящие в состав составного элемента управления, сами сохраняют свои данные в состоянии представления и сами их оттуда восстанавливают, обеспечивая тем самым корректное восстановление составного элемента управления после возврата формы. При этом, конечно, дочерние элементы управления все вместе держат в состоянии представления довольно много данных. Элемент XXXItem Как показало предыдущее обсуждение, команда ASP.NET имела серьезные основания потребовать, чтобы составные элементы управления, связанные с данными, получали данные исключительно посредством связывания. В таком случае отпадает необходи-мость включать в состав элементов управления свойство Items, как у списочных эле-ментов управления. Конечно, ничто не мешает вам добавить в собственные элементы управления поддержку объектов, представляющих элементы данных. Большинство составных элементов управления имеют коллекцию элементов, но не коллекцию элементов данных. Ее элементы - это составляющие пользователь-ского интерфейса самого элемента управления. Например, у элемента управления DataGrid объект DataGridItem представляет строку таблицы. А у нашего элемента управления BarChart, выводящего гистограмму, элементом служит производный от TableRow класс, который содержит информацию, необходимую для вывода одного столбца гистограммы. Количество элементов, из которых состоит элемент управления, хранится в состоянии представления. Давайте посмотрим, как эти концепции применяются к нашему связанному с дан-ными демонстрационному составному элементу управления BarChart. Элемент управления BarChart Элемент управления BarChart является производным от CompositeDataBoundControl и для него мы определим свойства, описанные в табл. 14-4. Каждый столбец гисто-граммы представлен элементом коллекции Items. Табл. 14-4. Свойства элемента управления BarChart Свойство Описание DataTextField Имя поля данных, значение которого выводится в виде надписи для столбца гистограммы DataTextFormatString Строка форматирования текста надписи DataValueField Имя поля данных, значения которого представлены горизонтально расположенными столбцами гистограммы DataValueFormatString Строка форматирования значения, выводимого над каждым столб-цом гистограммы Items Коллекция элементов интерфейса элемента управления BarChart. Каждый элемент представляет столбец гистограммы. Элементы коллекции Items имеют тип BarChartItem Maximum Максимальное значение, которое может быть представлено в гис-тограмме SubTitle Подзаголовок гистограммы Title Заголовок гистограммы
Элементы управления, связанные с данными и использующие шаблоны Глава 14 517 На рис. 14-4 показано, как выглядит гистограмма, создаваемая элементом управ-ления BarChart. Рис. 14-4. Элемент управления BarChart Кроме того, у элемента управления BarChart имеется набор стилевых свойств, описанных в табл. 14-5. Табл. 14-5. Стилевые свойства элемента управления BarChart Свойство Описание BarStyle Стиль всей строки, содержащей элемент гистограммы LabelStyle Стиль надписи столбца SubTitleStyle Стиль подзаголовка гистограммы TitleStyle Стиль заголовка гистограммы ValueStyle Стиль значения, представленного столбцом гистограммы Все перечисленные стили применяются в методе Render, равно как и в других элементах управления, связанных с данными. Элемент BarChartItem Пользовательский интерфейс элемента управления BarChart создается в перегружен-ной версии метода CreateChildControls: protected override int CreateChildControls( IEnumerable dataSource, bool dataBinding) { return CreateControlHierarchy(dataSource, dataBinding); } Оба своих аргумента метод CreateChildControls передает внутреннему методу CreateControlHierarchy, который отвечает за создание гистограммы. int CreateControlHierarchy(IEnumerable dataSource, bool dataBinding) {
518 Часть III Элементы управления ASP.NET //Получение выводимых данных (из источника данных или состояния представления) if (dataSource == null) { RenderEmptyControl(); return 0; } //Начало построения иерархии элементов Table t = new Table(); Controls.Add(t); //Добавление строки заголовка CreateTitle(t); //Добавление строки подзаголовка CreateSubTitle(t); //Добавление столбцов int totalItems = CreateAllItems(t, dataSource, dataBinding); return totalItems; } Элемент управления создает таблицу с двумя строками, для заголовка и подзаго-ловка, и еще серию строк для столбцов гистограммы. Метод CreateAllItems добавляет элементы гистограммы и подсчитывает их количество, которое потом записывается в состояние представления. int CreateAllItems(Table t, IEnumerable data, bool useDataSource) { //Счетчик добавляемых элементов int itemCount = 0; //Очищаем коллекцию (если null, создаем ее) Items.Clear(); //В цикле по элементам данных создаем коллекцию foreach (object o in data) { //Создаем объект -элемент гистограммы BarChartItemType itemType = BarChartItemType.Item; BarChartItem item = CreateBarChartItem(t, itemType, o, useDataSource); //Добавляем новый объект в коллекцию Items _items.Add(item); //Увеличиваем счетчик itemCount++; } //Возвращаем количество элементов //(его нужно знать для правильной обработки возвратов формы) return itemCount; } Для каждого связанного элемента метод создает объект BarChartItem и добавляет его в коллекцию Items. О классе BarChartItem мы поговорим чуть позже.
Элементы управления, связанные с данными и использующие шаблоны Глава 14 519 Заметьте, что для очистки коллекции используется вызов Items.Clear, а для до-бавления в нее нового столбца - вызов _items.Add. Свойство Items реализовано сле-дующим образом: private BarChartItemCollection _items; public virtual BarChartItemCollection Items { get { if (_items == null) _items = new BarChartItemCollection(); return _items; } } Свойство Items хранит свои данные в переменной _items. Первый вызов метода Items.Clear обеспечивает правильную инициализацию коллекции. В следующий раз можно обратиться прямо к переменной _items, чтобы сэкономить на вызове аксессора. Класс BarChartItem представляет столбец гистограммы. Он определяется так: public class BarChartItem : TableRow { private object _dataItem; private BarChartItemType _itemType; public BarChartItem(BarChartItemType itemType) { _itemType = itemType; } public object DataItem { get {return _dataItem;} set {_dataItem = value;} } public BarChartItemType ItemType { get {return _itemType;} } } Данный класс является производным от TableRow, ведь горизонтальный стол-бец нашей гистограммы - это не что иное, как строка таблицы. В указанном классе определены свойства DataItem и ItemType. Свойство DataItem содержит ссылку на элемент данных связанного источника. Например, если элемент управления BarChart связан с объектом DataTable, то DataItem связан с объектом DataRow, соответству-ющим данному столбцу гистограммы. Свойство же ItemType определяет тип строки заголовка: Title, SubTitle или Item. Значения этого свойства определены в следующем перечислимом типе: public enum BarChartItemType { Title, SubTitle,
520 Часть III Элементы управления ASP.NET Item } Свойство Items содержит группу объектов BarChartItem и представляет собой кол-лекцию типа BarChartItemCollection: public class BarChartItemCollection : Collection<BarChartItem> {} Поскольку объекты - элементы гистограммы - не сохраняют свои данные в со-стоянии представления, необходимость в реализации интерфейса IStateManager и дополнительных методов управления состоянием представления, как в предыдущем примере, отпадает. Добавление связанных данных Разрабатывая составной элемент управления, связанный с данными, переопределять метод PerformDataBinding не нужно. Однако следует уделить некоторое внимание коду, который формирует структуру элемента управления, и коду, добавляющему данные. Метод CreateBarChartItem создает новую строку таблицы и связывает ее со свой-ством DataItem. Что содержит эта строка? На рис. 14-4 видно, что каждая строка имеет две ячейки: для надписи и столбца гистограммы. BarChartItem CreateBarChartItem(Table t, BarChartItemType itemType, object dataItem, bool useDataSource) { //Создаем новую строку для внешней таблицы BarChartItem item = new BarChartItem(itemType); //Создаем ячейки для надписи и данных TableCell labelCell = CreateLabelCell(item); TableCell valueCell = CreateValueCell(item); //Добавляем строку в таблицу t.Rows.Add(item); //Выполняем связывание if (useDataSource) { //Получаем объект источника данных item.DataItem = dataItem; //Связываем надписи с данными BindLabelCell(labelCell, dataItem); BindValueCell(valueCell, dataItem); } //Возвращаем полностью сконфигурированный элемент return item; } Методы CreateLabelCell и CreateValueCell добавляют ячейки в строку таблицы. Вот их реализация: private TableCell CreateLabelCell(BarChartItem item) {
Элементы управления, связанные с данными и использующие шаблоны Глава 14 521 //Создаем и добавляем ячейку TableCell cell = new TableCell(); item.Cells.Add(cell); return cell; }private TableCell CreateValueCell(BarChartItem item) { //Создаем и добавляем ячейку TableCell cell = new TableCell(); item.Cells.Add(cell); //Добавляем надписи Label lblGraph = new Label(); Label lblText = new Label(); cell.Controls.Add(lblGraph); cell.Controls.Add(new LiteralControl("<br>")); cell.Controls.Add(lblText); return cell; } Цветной столбец реализуется в виде надписи, ширина которой задается как про-цент от максимального значения, представляемого диаграммой. В методе CreateBarChartItem оператор if отделяет код создания дочернего эле-мента управления от кода связывания с данными. Если метод работает в режиме связывания, для каждого элемента гистограммы устанавливается свойство DataItem и вызываются два метода, добавляющие данные в дочерние элементы управления элемента BarChart: private void BindLabelCell(TableCell cell, object dataItem) { if (!String.IsNullOrEmpty(DataTextField)) { string txt = DataBinder.GetPropertyValue( dataItem, DataTextField, DataTextFormatString); cell.Text = txt; } }private void BindValueCell(TableCell cell, object dataItem) { //Связываем надпись для значения столбца Label lblGraph = (Label) cell.Controls[0]; object o = null; if (!String.IsNullOrEmpty(DataValueField)) o = DataBinder.GetPropertyValue(dataItem, DataValueField); else return; float val = Convert.ToSingle(o); float valueToRepresent = 100 * val /Maximum; lblGraph.Width = Unit.Percentage(valueToRepresent); //Связываем надпись для заголовка столбца Label lblText = (Label) cell.Controls[2];
522 Часть III Элементы управления ASP.NET lblText.Text = DataBinder.GetPropertyValue( dataItem, DataValueField, DataValueFormatString); } Процесс связывания с данными мало отличается от рассмотренного нами для других типов элементов управления. Главная задача последнего метода - вычислить ширину надписи, которая будет изображать горизонтальный столбец. Примечание Как видите, в процессе построения иерархии элементов управления стили им не присваиваются. Как и в случае других элементов управления, связанных с данными, они применяются на последней стадии жизненного цикла элемента управления, в методе Render - непосредственно перед генерированием разметки элемента управления. События элемента управления BarChart У элемента управления BarChart есть и пара событий: BarChartCreated и Bar Chart-DataBound. То, что они напоминают события элемента управления DataGrid, не слу-чайность. Хотя наш элемент BarChart гораздо проще, он построен по тем же прин-ципам, что и DataGrid. public event EventHandler<BarChartItemEventArgs> BarChartItemCreated; public event EventHandler<BarChartItemEventArgs> BarChartItemDataBound; protected virtual void OnBarChartCreated(BarChartItemEventArgs e) { if (BarChartItemCreated != null) BarChartItemCreated(this, e); }protected virtual void OnBarChartItemDataBound(BarChartItemEventArgs e) { if (BarChartItemDataBound != null) BarChartItemDataBound(this, e); } Событие BarChartItemCreated генерируется, когда в таблицу добавляется новая строка, представляющая столбец диаграммы, а событие BarChartItemData Bound - ко-гда эта строка связывается с данными. При этом первое событие генерируется неза-висимо от рабочего режима элемента управления, а второе - только при его создании в режиме связывания с данными. Информация об обоих событиях передается в структуре следующего типа: public class BarChartItemEventArgs : EventArgs { private BarChartItem _item; public BarChartItemEventArgs(BarChartItem item) { _item = item; } public BarChartItem Item { get { return _item; } } }
Элементы управления, связанные с данными и использующие шаблоны Глава 14 523 Оба события генерируются в методе CreateBarChartItem. BarChartItem CreateBarChartItem(Table t, BarChartItemType itemType, object dataItem, bool useDataSource) { //Создаем новую строку внешней таблицы BarChartItem item = new BarChartItem(itemType); //Создаем ячейки для надписи и значения TableCell labelCell = CreateLabelCell(item); TableCell valueCell = CreateValueCell(item); BarChartItemEventArgs argsCreated = new BarChartItemEventArgs(item); OnBarChartItemCreated(argsCreated); if (useDataSource) { BarChartItemEventArgs argsData = new BarChartItemEventArgs(item); OnBarChartItemDataBound(argsData); } }Использование элемента управления BarChart Теперь несколько слов о том, как описанные события обрабатываются в коде хост-страницы. Рассмотрим разметку, которая служит для включения элемента управления BarChart в состав страницы: <expo:BarChart runat="server" id="BarChart1" Maximum="100" SubTitle="Subtitle" Title="Title" OnBarChartDataBound="BarChart1_BarChartDataBound" > </expo:BarChart> Здесь ничто не указывает на источник данных. В обработчике события Page_Load осуществляется связывание элемента управления с данными. Эти данные, получаемые с помощью запроса к SQL Server 2000, состоят из двух столбцов, один из которых содержит фамилии служащих, а другой - суммы сделок, заключенных этими служа-щими в 1997 году. Источником данных является база данных Northwind. protected void Button1_Click(object sender, EventArgs e) { DataTable data = ExecuteQuery(1997); BarChart1.Maximum = 150000; BarChart1.Title = "Northwind Sales"; BarChart1.SubTitle = "(Year 1997)"; BarChart1.DataSource = data; BarChart1.DataTextField = "Employee"; BarChart1.DataValueField = "Sales"; BarChart1.DataBind(); } Гистограмма, представленная на рис. 14-4, получена в результате выполнения этого кода. Демонстрационная страница обрабатывает событие BarChartDataBound следую-щим образом: void BarChart1_BarChartDataBound(object sender, ProAspNet20.Advanced.BarChartItemEventArgs e)
524 Часть III Элементы управления ASP.NET { //Получаем сумму продаж для текущего столбца Decimal sales = (Decimal) DataBinder.GetPropertyValue( e.Item.DataItem, "sales"); //Добавляем подсказку string tip = sales.ToString(); e.Item.Attributes["title"] = tip; //Выделяем столбец, если sales > 50000 if (sales > 50000) e.Item.Cells[1].BackColor = Color.LightGreen; } Для каждой строки определяется всплывающая подсказка, в которой выводится сумма продаж определенного служащего. Столбцы тех служащих, чьи суммы продаж превышают $50 000, выделяются другим цветом (рис. 14-5). Рис. 14-5. Вывод элемента управления BarChart, модифицированный обработчиками событий уровня страницы Примечание Все элементы управления, связанные с данными, генерируют два стандарт-ных события: DataBinding и DataBound. Первое из них поддерживалось и в ASP.NET 1.x, оно генерируется перед началом процесса связывания с данными. Второе событие введено в ASP.NET 2.0, оно сигнализирует о завершении данного процесса. Реализация поддержки шаблонов Элемент управления BarChart принимает две строки, которые он выводит в качестве заголовка и подзаголовка диаграммы. Можно было бы определить и аналогичное свойство для нижнего колонтитула. Заголовок, подзаголовок и нижний колонти-тул - самостоятельные элементы иерархии BarChart. Что можно выводить в таких элементах? Если эти свойства реализованы в виде обычных строк, то с их помощью нельзя вывести ничего, кроме обычного текста.
Элементы управления, связанные с данными и использующие шаблоны Глава 14 525 Однако, применив строки форматирования, и в этом случае можно достичь неко-торой степени гибкости. Строка форматирования задается пользователем элемента управления и содержит предопределенное количество подстановочных параметров, которые этот элемент заменяет своими внутренними данными. Например, строка форматирования элемента управления GaugeBar по умолчанию такова: {0}/{1}. Здесь два подстановочных параметра, а интерпретируется эта строка следующим образом: //В первый параметр подставляется значение свойства Value, //а во второй - значение свойства Maximum String.Format(FormatString, Value, Maximum); Для получения более привлекательного результата в строке форматирования раз-решается использовать тэги HTML, однако лучше этого не делать, поскольку код, который в результате получается, сложен, и его трудно сопровождать. Гораздо более эффективным способом настройки пользовательского интерфейса элементов управ-ления является применение шаблонов. Шаблоны и пользовательские элементы управления В ASP.NET шаблоны можно импортировать двумя способами: используя свойства типа ITemplate и путем динамической загрузки пользовательских элементов управ-ления. Как рассказывалось в главе 12, пользовательский элемент управления - это специализированный компонент, используемый наравне с серверными элементами управления. Динамически включая такие элементы в состав своего элемента управ-ления, его интерфейс можно сделать более гибким и универсальным. На то место со-здаваемого элемента управления, где должен размещаться пользовательский контент, вы помещаете элемент управления PlaceHolder, а затем во время выполнения создаете экземпляр пользовательского элемента управления и добавляете его в коллекцию Controls элемента управления PlaceHolder: placeHolder.Controls.Add(Page.LoadControl("usercontrol.ascx")); Этот код вызывается на ранней стадии жизненного цикла элемента управления, в обработчике события Init. С помощью метода LoadControl код шаблона загружает-ся из отдельного файла. Хорошо это или плохо, зависит от ситуации. Если шаблон, который вы хотите реализовать, сложен, лучше держать его отдельно от основной страницы. Но, с другой стороны, такое усложнение структуры страницы может быть и неоправданным. Когда шаблон непосредственно доступен исходному коду страницы, ее разработка существенно упрощается. Впрочем, между двумя подходами возможен определенный компромисс. Вы можете определить в элементе управления свойство ITemplate и предоставить автору страницы свободу выбора способа установки этого свойства, с тем чтобы он мог статически задать разметку шаблона или использовать содержимое файла .ascx. Определение свойства-шаблона Свойство-шаблон представляет собой совокупность текста и элементов управления, содержащихся в специальном контейнере. В классе этого контейнера определяются свойства, которые авторы страниц могут использовать в выражениях связывания с данными для доступа к свойствам элемента управления. Следующий код показывает, как определить свойство-шаблон с именем TitleTemplate: [PersistenceMode(PersistenceMode.InnerProperty)] [TemplateContainer(typeof(TitleTemplateContainer))] public ITemplate TitleTemplate {
526 Часть III Элементы управления ASP.NET get { return _titleTemplate; } set { _titleTemplate = value; } } Шаблон хранится в закрытом члене _titleTemplate, который определен следующим образом: private ITemplate _titleTemplate = null; Свойство-шаблон характеризуется парой атрибутов: PersistenceMode и Template-Container. Первый из них указывает, как осуществляется сохранение значения дан-ного свойства в хост-странице. Поддерживаемые режимы сохранения перечислены в табл. 14-6. Табл. 14-6. Режимы сохранения свойств элемента управления Режим Описание Attribute Свойство сохраняется в итоговой разметке как HTML-кодированный атрибут EncodedInnerDe fault-Property Свойство сохраняется как внутренний текст элемента управления в формате HTML; такую установку можно задавать только для строк InnerDefaultProperty Свойство сохраняется как внутренний текст элемента управления и является свойством элемента управления, используемым по умолча-нию; такую установку можно задать только для одного из свойств InnerProperty Свойство сохраняется в элементе управления в виде вложенного тэга; такая установка часто задается для сложных объектов с шаблонами и стилями Наиболее типичной установкой является InnerProperty, при использовании кото-рой Microsoft Visual Studio 2005 сохраняет контент шаблона в виде вложенного тэга, имеющего то же имя, что и свойство. <expo:BarChart runat="server" ID="BarChart1" ... > <TitleTemplate> </TitleTemplate> </expo:BarChart> Если выбрать установку InnerDefaultProperty, получится единственный вложенный тэг, тогда как установка InnerProperty позволяет создавать сколько угодно вложенных тэгов. Это удобно для сложных элементов управления с несколькими шаблонами и стилями. Атрибут TemplateContainer задает тип контейнера именования, в котором будет содержаться созданный шаблон. Как уже упоминалось, шаблон хранится в контейнере, который включен в коллекцию Controls элемента управления. Тип, заданный в атри-буте TemplateContainer, должен определить разработчик элемента управления. Определение контейнера шаблона Контейнер шаблона - это простой элемент управления, реализующий интерфейс INamingContainer. Он может иметь любые открытые члены, однако чаще всего в его состав включается свойство для доступа к родительскому элементу управления как целому и несколько свойств для быстрого доступа к его составляющим. Ниже при-веден пример простого контейнерного типа для свойства TitleTemplate: public class TitleTemplateContainer : WebControl, INamingContainer { private BarChart _parent;
Элементы управления, связанные с данными и использующие шаблоны Глава 14 527 public TitleTemplateContainer(BarChart parent) { _parent = parent; } public string Title { get { return _parent.Title; } } public string SubTitle { get { return _parent.SubTitle; } } public BarChart BarChart { get { return _parent; } } } Еще раз отмечу, что ограничений или особых указаний относительно набора членов данного класса не существует, за исключением одного: он должен содержать ссыл-ку на родительский элемент управления, в нашем примере - на BarChart. Обычно контейнерный класс создается для конкретного элемента управления (или группы элементов управления) и нигде больше не используется. Так что вы можете решить по своему усмотрению, предоставлять доступ прямо к свойству, содержащему ссылку на родительский элемент управления, или фильтровать интерфейс программирования элемента управления, открывая доступ к подмножеству его свойств (например, к Title и SubTitle). Можно делать и то и другое, как в приведенном выше примере. Интерфейс программирования контейнера шаблона важен тем, что он определяет, к какой информации будут иметь доступ авторы страниц, создающие шаблоны. Сам контейнер шаблона доступен посредством свойства Container. Установка свойства-шаблона На рис. 14-6 показан элемент управления BarChart, поддерживающий шаблоны. Он размещен на странице, создаваемой в Visual Studio 2005. Средство Microsoft IntelliSense выводит подсказку для свойства TitleTemplate, чем упрощает установку значения этого свойства. Шаблон может содержать любые элементы управления и литералы в любом со-четании. Однако для доступа к внутренней информации родительского элемента управления вам придется пользоваться выражениями связывания с данными. При-ведем простейший пример шаблона: <TitleTemplate> <img src="Title.gif" /> <%# Container.Title %> </TitleTemplate> Это шаблон для заголовка элемента управления BarChart, выводящий текст, за-данный в свойстве Title, а рядом - изображение. Приведем еще один пример: <TitleTemplate> <%# Container.Title %>
528 Часть III Элементы управления ASP.NET <small>(<%# DateTime.Now.ToString() %>)</small> </TitleTemplate> Рис. 14-6. Visual Studio 2005 распознает свойства-шаблоны На рис. 14-7 показан заголовок гистограммы, сформированный с использованием шаблона, в котором рядом с исходным значением свойства Title выводится текущее время - меньшим шрифтом и в скобках. Заметьте, что к шаблону применены стилевые атрибуты, задаваемые в свойстве TitleStyle. Рис. 14-7. Элемент управления BarChart с заголовком, созданным с применением шаблона
Элементы управления, связанные с данными и использующие шаблоны Глава 14 529 Ключевое слово Container используется для ссылки на экземпляр контейнера шаб-лона, через который осуществляется доступ к свойствам элемента управления, откры-ваемым классом контейнера. Доступ к информации, которая не является статической, осуществляется с использованием выражений связывания с данными <%# ...%>, точно так же, как в шаблонах встроенных элементов управления ASP.NET. Рендеринг шаблона До сих пор мы говорили о том, как определить свойство-шаблон серверного элемента управления. Напомню, что для этого вам нужно: определить свойство типа ITemplate, значение которого хранится в закрытой пе-ременной; пометить свойство атрибутом PersistenceMode; определить контейнерный класс шаблона; пометить свойство атрибутом TemplateContainer. Указанными действиями вы определите открытый интерфейс шаблона. Однако для того чтобы интегрировать его в иерархию элемента управления, следует сделать кое-что еще. В частности, вам нужно откорректировать код, создающий ту часть дерева элемента управления, где должен размещаться шаблон. Например, свойство TitleTemplate предназначено для вывода заголовка, значит, вам нужно модифицировать внутренний метод CreateTitle. Его обновленная версия приведена ниже: private void CreateTitle(Table t) { //Создаем строку таблицы BarChartItem item = new BarChartItem(BarChartItemType.Title); t.Rows.Add(item); //Добавляем ячейку для заголовка TableCell cell = new TableCell(); cell.ColumnSpan = BarChart.ColumnsCount; item.Cells.Add(cell); //Осуществляем выбор между обычным текстом и шаблоном if (TitleTemplate != null) { _titleTemplateContainer = new TitleTemplateContainer(this); TitleTemplate.InstantiateIn(_titleTemplateContainer); cell.Controls.Add(_titleTemplateContainer); } else cell.Text = Title; //Вызываем метод DataBind, чтобы обеспечить вычисление #-выражения item.DataBind(); } Необходимо проверить, определен ли шаблон для заголовка элемента управления. Если нет, свойству Text ячейки таблицы просто присваивается значение свойства Title. В противном случае мы создаем экземпляр контейнерного типа и используем его 
530 Часть III Элементы управления ASP.NET в качестве входного аргумента метода InstantiateIn - единственного метода интерфей-са ITemplate. В заключение мы добавляем контейнер шаблона в иерархию элементов управления, в данном случае - в коллекцию Controls ячейки заголовка. Для обеспечения успешной обработки используемых в шаблоне выражений связы-вания с данными необходимо выполнить еще одно важное действие: вызвать для заго-ловочного элемента метод DataBind. Напомню, что выражения связывания с данными вычисляются только после вызова этого метода. Без него шаблон будет работать пра-вильно, но результаты вычисления выражений <%# ... %> в нем не отобразятся. Как элементы управления, связанные с данными, работают с источниками данных Разработчикам элементов управления для приложений ASP.NET 1.x приходилось решать дополнительную проблему: придумывать, как реализовать для источника данных интерфейс IEnumerable. В массивах, коллекциях и объектах DataView этот интерфейс реализован, чего нельзя сказать о таких популярнейших объектах ADO.NET, как DataTable и DataSet. Они реализуют другой интерфейс - IListSource. Проблема еще более усложняется, если элемент управления имеет свойство DataMember. Реализация интерфейса IEnumerable для источника данных необходи-ма любым элементам управления, связанным с данными, в том числе и встроенным элементам управления ASP.NET, у которых имеется соответствующий внутренний метод. К сожалению, этот метод, имеющий имя GetResolvedDataSource, определен во внутреннем классе, который не доступен вне сборки system.web: static IEnumerable GetResolvedDataSource( object dataSource, string dataMember); Класс, которому принадлежит метод, называется DataSourceHelper; он опреде-лен в пространстве имен System.Web.UI. Если вы пишете в ASP.NET 1.x элемент управления, связанный с данными, то вам стоит ознакомиться с кодом данного метода. Увидеть его можно двумя способами: воспользовавшись технологией рефлексии или применив декомпилятор. К счастью, с появлением ASP.NET 2.0 все эти сложности остались позади. Элементы управления, связанные с данными, позволяют переопределить метод PerformDataBinding, который получает готовую коллекцию IEnumerable независи-мо от того, к какому типу принадлежит исходный источник данных. Заключение Большинство реальных элементов управления являются составными и связаны с дан-ными. Они должны быть достаточно гибкими, чтобы разработчики могли настраивать их пользовательский интерфейс. С этой целью в состав элемента управления может быть включен богатый набор визуальных свойств, стилей и тем. Возможность еще более гибкой настройки обеспечивается поддержкой шаблонов. В этой главе мы проанализировали средства ASP.NET, используемые при созда-нии элементов управления, связанных с данными. В ASP.NET 1.x программистам приходилось изучать накопленный опыт создания таких элементов и воплощать его в собственных разработках. Единственным подспорьем для них в этом деле были кни-ги и периодические издания - среда же разработки ничем им не помогала. Например, 
Элементы управления, связанные с данными и использующие шаблоны Глава 14 531 разработчику приходилось заботиться о том, чтобы при осуществлении возврата фор-мы элементы управления не исчезали со страниц или не выводились на них пустыми. Все эти проблемы решались методом проб и ошибок. В ASP.NET 2.0 все изменилось в лучшую сторону. Теперь в вашем распоряжении имеется набор тщательно продуманных промежуточных классов, воплотивших весь накопленный разработчиками опыт. Наличие таких классов позволяет выбрать для каждого нового элемента подходящий уровень системной поддержки, благодаря чему вы, создавая свой элемент, сразу получаете необходимый набор базовых возможнос-тей. Мы обсудили внутреннюю реализацию всех этих классов: BaseDataBoundControl, DataBoundControl, ListControl и CompositeDataBoundControl. И если вам приходилось корпеть над специализированными элементами управления в ASP.NET 1.x, вы оцените описанные нововведения. Мы детально проанализировали три типа элементов управления, связанных с дан-ными (простые, списочные и сложные), обговорили различные вопросы, касающиеся их стилевого оформления, рендеринга, структуры, управления состоянием представ-ления, элементов данных, шаблонов и сохранения значений свойств. Однако все эти замечательные программные возможности не имели бы для нас такой ценности, если бы не поддержка со стороны среды разработки Visual Studio. Конфигурирование эле-мента управления для декларативного программирования является темой следующей, последней, главы этой книги. Только факты Элемент управления, связанный с данными, обладает свойством, представляющим источник данных, и набором строковых свойств, определяющих соответствие меж-ду полями источника данных и составляющими пользовательского интерфейса элемента управления. Связывание элемента управления с данными может осуществляться через свойство DataSource либо DataSourceID. Первое указывает на объект, реализующий интер-фейс IEnumerable, а второе - на элемент управления, представляющий источник данных. Простой элемент управления, связанный с данными, обычно является производ-ным от DataBoundControl, и в нем переопределяется метод PerformDataBinding. Метод PerformDataBinding передает вашему коду готовую перечислимую коллек-цию связанных данных, каким бы ни был источник этих данных. На основе коллекции связанных данных должна быть создана коллекция меньшего размера, содержащая объекты элементов данных и сохраняемая в состоянии пред-ставления, чтобы данные не утрачивались между возвратами формы. Вы создаете класс элемента данных (и коллекцию объектов элементов данных, если элемент управления связан со списком) и делаете его способным к сериализации для со-хранения в состоянии представления. Для сохранения данных в состоянии представления вам необходимо также пере-определить методы класса элемента управления, сохраняющие состояние элемента управления в состоянии представления и восстанавливающие его оттуда. ListControl - это готовый класс, который легко расширить, чтобы он циклически выводил любой элемент управления или дерево элементов. Но если вы хотите создать специализированный список элементов, нужно сделать его производным от DataBoundControl и выполнить действия, описанные в настоящей главе. 
532 Часть III Элементы управления ASP.NET Для расширения возможностей рендеринга списочного элемента управления мож-но реализовать в нем интерфейс IRepeatInfoUser и соответствующим образом модифицировать механизм рендеринга. CompositeDataBoundControl - это базовый класс, используемый при построении сложных элементов управления, составленных из существующих элементов уп-равления, связанных с данными. Свойства с поддержкой шаблонов позволяют создателям страниц модифицировать пользовательский интерфейс элемента управления, используя в нем собственные фрагменты разметки. 
Глава 15 Поддержка специализированных элементов управления во время разработки В состав серверного элемента управления входят два разных набора средств: времени выполнения и времени разработки. Средства времени выполнения используются, когда элемент управления включается в состав выводимой страницы и отображается в браузере, а средства времени разработки обеспечивают его интеграцию в графический дизайнер, такой, как Microsoft Visual Studio 2005, и позволяют программисту кон-фигурировать его внешний вид и поведение декларативным способом по принципу WYSIWYG (what-you-see-is-what-you-get - что видишь, то и получаешь). Подобно стандартным и встроенным элементам управления специализированные элементы управления Microsoft ASP.NET могут интегрироваться в графический дизайнер - для этого они, конечно, должны быть разработаны соответствующим образом. Все элементы управления наследуют определенные возможности времени раз-работки от базового класса Control. Например, можно их перетаскивать с панели инструментов на Web-форму или, выделив в дизайнере, работать с их свойствами в окне Properties. Возможности, которыми элемент управления обладает во время разработки, могут быть расширены путем установки предопределенных атрибутов-метаданных, опре-деления пользовательских редакторов свойств и добавления специализированного дизайнера. Все это я продемонстрирую на конкретных примерах. Однако, должен сразу оговориться, снабжать элемент управления пользователь-скими средствами времени выполнения не обязательно. Класс Control, прямо или косвенно наследуемый всеми элементами управления, уже содержит базовый набор необходимых возможностей. Их достаточно для того, чтобы с элементом управления можно было работать в графическом дизайнере, но недостаточно для полноценного, профессионально сделанного компонента с богатым набором средств, облегчающих работу программиста. Архитектура .NET времени разработки В Microsoft .NET Framework компонент, с которым можно работать в дизайнере, представляет собой класс, реализующий интерфейс IComponent. Этот интерфейс, реализованный в классе Control, имеет всего одно свойство, Site, которое представляет объект, реализующий интерфейс ISite. Этот объект называется сайтом. Он связывает компонент с контейнером и обеспечивает их взаимодействие, а также позволяет кон-тейнеру управлять содержащимися в нем компонентами и выполнять роль репозита-рия необходимой информации, такой как имена и атрибуты компонентов.
534 Часть III Элементы управления ASP.NET Примечание С интерфейсом IComponent тесно связан класс Component, определенный в пространстве имен System.ComponentModel. Данный класс реализует указанный интер-фейс и является основой всех управляемых компонентов. Компонентом можно назвать любой объект многократного применения, используемый по принципу черного ящика и взаимодействующий с другими объектами. Это определение в .NET Framework было несколько расширено, и здесь компонент может также управлять жизненным циклом внешних ресурсов и обеспечивать поддержку для времени разработки. Элементы управления ASP.NET не наследуют класс Component, а реализуют интерфейс IComponent самостоятельно. Сайты, контейнеры и элементы управления Интерфейс IComponent расширяет интерфейс IDisposable и помимо членов последнего содержит также метод Dispose. Этот метод доступен всем компонентам и позволяет явно освобождать внешние ресурсы. Заметьте, что метод Dispose освобождает ресурсы детерминированно, тогда как стандартный сборщик мусора делает это недетермини-рованным способом. Средства времени разработки, предназначенные для классов, реализующих интерфейс IComponent, встроены в .NET Framework и обеспечивают возможность манипулирования представлениями этих классов на рабочей поверх-ности дизайнера. Если элемент управления содержит средства для поддержки работы в дизайнере, это значит, что его можно поместить в контейнер, с которым он будет взаимодей-ствовать с помощью методов интерфейса ISite. Компонент имеет доступ к сервисам, которые контейнер публикует через сайт. Список членов интерфейса ISite приведен в табл. 15-1. Табл. 15-1. Члены интерфейса ISite Свойство Описание Component Возвращает компонент, связанный с классом и реализующий интерфейс ISite Container Возвращает объект, реализующий интерфейс IContainer, связанный с объектом, реализующим интерфейс ISite DesignMode Определяет, находится ли компонент в режиме дизайна Name Возвращает или устанавливает имя компонента, связанного с сайтом Элемент управления - это компонент, поддерживающий работу в дизайнере и обладающий собственным пользовательским интерфейсом. Это определение отно-сится и к элементам управления Microsoft Windows Forms, и к элементам управле-ния ASP.NET. Как уже упоминалось, класс ASP.NET Control реализует интерфейс IComponent и предоставляет инфраструктуру, поверх которой может надстраиваться пользовательский интерфейс. Заметьте, что элемент управления - это всегда компонент; компонент, с другой стороны, не всегда является элементом управления. Контейнером для серверных элементов управления ASP.NET является графичес-кий дизайнер. Во время разработки дизайнер предоставляет элементам управления ряд сервисов, доступ к которым осуществляется через его интерфейс. Примечание Интерфейс ISite является производным от интерфейса IServiceProvider, который представляет метод GetService, открывающий элементам управления доступ к открытым сервисам хоста.
Поддержка специализированных элементов управления во время разработки Глава 15 535 Элементы управления и дизайнеры Принципы, по которым создавалась архитектура среды разработки Visual Studio 2005, очень отличается от принципов создания ранних архитектур такого типа. В .NET Frame work возможности элемента управления времени разработки реализуются не в его составе, а в отдельном классе. Такие классы и элементы управления декларативно связываются друг с другом с помощью атрибутов. Разделение кода времени выполнения и времени разработки имеет два важных преимущества. Во-первых, код, составляющий собственно элемент управления, не содержит ничего лишнего, благодаря чему во время выполнения элемент управления имеет небольшой размер. Во-вторых, за счет вынесения функциональности времени разработки во внешние классы создается более гибкая и расширяемая архитектура. Примечание Объем памяти, занимаемой элементом управления, уменьшается только в том случае, если код времени разработки откомпилирован в отдельную сборку. То, что сборка содержит и код времени выполнения, и код времени разработки, обычно не имеет особого значения. Однако это важно для встроенных элементов управления ASP.NET, которые уста-навливаются в виде отдельных наборов сборок. Кроме того, это может иметь значение для больших библиотек элементов управления, например инструментальных комплексов сто-ронних разработчиков. Для отдельных специализированных элементов управления лучше создавать две разные сборки, поскольку сборка времени разработки на сервере не нужна и включать ее в состав сайта ни к чему. Она требуется только для Visual Studio 2005. Базовые средства времени разработки можно расширить для элемента управления несколькими способами. Простейший из них является почти полностью деклара-тивным и заключается в установке нескольких атрибутов метаданных для свойств элемента управления и объявления класса. Для начала вам нужно импортировать пространство имен System. ComponentModel. Чтобы снабдить элемент управления более сложными средствами времени разра-ботки, потребуются дополнительные усилия: необходимо будет написать конвертеры типов, графические редакторы типов и дизайнеры компонентов. Все эти элементы представлены в табл. 15-2. Табл. 15-2. Средства элемента управления для времени разработки Функция Описание Дизайнер Класс, отвечающий за внешний вид и поведение элемента управления в гра фи-ческом дизайнере .NET. Набор возможностей, которые можно программировать для дизайнера, в ASP.NET 2.0 значительно расширен и усовершенствован Редактор Класс, предоставляющий удобный способ редактирования свойств элемента управления Конвертер типов Класс, выполняющий преобразование, необходимое для представления значений произвольных типов (в том числе сложных) в виде строк. Используется в окне свойств Механизм поддержки серверных элементов управления ASP.NET во время раз-работки, которые мы обсудим в этой главе, являются частью более универсального механизма времени разработки, реализованного для .NET Framework. В ASP.NET компоненты, с которыми можно работать в дизайнере, являются клас-сами, наследующими Control; его хостинг в дизайнере обеспечивает класс-контейнер, производный от ControlDesigner. Контейнер - это класс, реализующий интерфейс IDesigner, а компонент, с которым можно работать в дизайнере, - это любой класс, реализующий интерфейс IComponent.
536 Часть III Элементы управления ASP.NET Атрибуты-метаданные Атрибуты-метаданные - это особые описательные элементы, которые можно ассо-циировать с типами и членами. Единственная задача такого атрибута - предоставлять дополнительную информацию о типе или члене компонентам, которые в ней заин-тересованы. Если некий тип помечен атрибутом, то код, не относящийся к данному типу, может проверять значение его атрибута или просто то, имеется ли он в наличии. Этот внешний код, основываясь на полученной информации, может изменить способ работы с данным типом. Примечание Атрибуты не меняют поведение компонентов, которым они присвоены. Однако компонент, помеченный определенными атрибутами, может выглядеть по-другому для внешних программ и игнорироваться либо обрабатываться определенным образом в зависимости от того, какие атрибуты ему присвоены. Для серверных элементов управления ASP.NET информация, содержащаяся в атри-бутах-метаданных, проверяется и запрашивается инструментами разработки, такими, как Visual Studio 2005. Подобные атрибуты определяют представление и возможности программирования элементов управления, размещенных в графическом дизайнере. По стандартному соглашению имя класса атрибута оканчивается суффиксом Attribute, например: BrowsableAttribute, DefaultValueAttribute. Объявляя атрибут в ис-ходном коде элемента управления, суффикс Attribute обычно опускают. Говоря об атрибутах элементов управления, следует различать атрибуты време-ни выполнения и времени разработки. И те и другие могут назначаться серверным элементам управления, но с разной целью. Атрибуты времени выполнения влияют на функционирование элемента управления в среде ASP.NET и отработку цикла "запрос-ответ". (В таком случае внешним кодом, проверяющим атрибуты, является рабочий процесс ASP.NET). Атрибуты времени разработки не влияют на поведение элемента управления во время выполнения приложения, но упрощают его конфи-гурирование в Visual Studio 2005. (В этом случае внешний код, интересующийся значениями атрибутов, - это Visual Studio.) Атрибуты, действующие во время разработки В табл. 15-3 перечислены наиболее популярные атрибуты элементов управления времени разработки. Большинство из них можно присваивать свойствам и событиям, а некоторые - также классам. Табл. 15-3. Атрибуты времени разработки серверных элементов управления Атрибут Описание Bindable Указывает, может ли элемент управления быть связан с данными Browsable Указывает, должно ли свойство или событие выводиться в окне Properties Category Имя категории, к которой принадлежит свойство или событие. Данный атрибут используется для группировки свойств в окне Properties DefaultEvent Событие элемента управления, обработчик которого создается по умолча-нию, когда пользователь дважды щелкает элемент управления в дизайнере. Данный атрибут может присваиваться только классу DefaultProperty Свойство элемента управления, выделяемое в окне Properties по умолчанию, когда пользователь щелкает элемент в дизайнере. Данный атрибут может присваиваться только классу
Поддержка специализированных элементов управления во время разработки Глава 15 537 Атрибут Описание DefaultValue Значение, присваиваемое свойству элемента управления по умолчанию. Если тип свойства не является простым, необходим конвертер типов Description Описание свойства или события. Этот текст выводится в нижней части окна Properties, когда пользователь выделяет свойство или событие Editor Редактор, используемый для модификации значения свойства в графическом дизайнере Themeable Указывает, может ли свойство быть добавлено в обложку элемента управления в теме. В ASP.NET 1.x данный атрибут не поддерживается ToolboxData Используемая по умолчанию разметка, которую Visual Studio добавляет в страницу .aspx, когда вы перетаскиваете элемент управления с панели инструментов в Web-форму. Данный атрибут может присваиваться только классу TypeConverter Класс конвертера типов, используемый для преобразования значения свой ства в текст. Данный атрибут может присваиваться только классу Большая часть этих атрибутов используется в окне Properties в Visual Studio 2005. Это окно показано на рис. 15-1. Обычно оно пристыковано к правому краю Visual Studio ниже окна Solution. Рис. 15-1. Окно Properties в Visual Studio 2005 Прежде чем я перейду к описанию особенностей применения каждого из атрибутов, хочу предупредить вас об одном нюансе поведения Visual Studio 2005. Когда вы откры-ваете в дизайнере страницу ASP.NET, содержащую тот или иной элемент управления, Visual Studio 2005 загружает сборку этого элемента. Когда будете разрабатывать и тестировать элементы управления, имейте в виду, что эта сборка не выгружается и не заменяется автоматически при перекомпиляции элемента управления. Чтобы внесен-ные вами в элемент управления изменения отразились в дизайнере, нужно закрыть и повторно открыть все страницы, в которых этот элемент используется. Табл. 15-3. (окончание)
538 Часть III Элементы управления ASP.NET Установка атрибутов Атрибут в C# заключается в квадратные скобки, а в Visual Basic - в угловые. Вот пример кода на C#: [Bindable(true)] public int Count { }и аналогичный пример на Visual Basic: <Bindable(True)> _ Public Property Count As Integer End Property Заметьте, что в Visual Basic атрибутом считается набор ключевых слов, располо-женный перед оператором, поэтому вы должны либо размещать атрибут и оператор в одной строке, либо использовать символ подчеркивания (_), указывающий, что оператор продолжается на следующей строке. Можно присваивать одному элементу несколько атрибутов. Делается это так: [Bindable(true)] [Browsable(true)] public int Count { } либо так: [Bindable(true), Browsable(true)] public int Count { }Атрибут Bindable Атрибут Bindable указывает дизайнеру, может ли свойство быть связано с данными во время разработки. Заметьте, что этот атрибут, принимающий значение булева типа, на самом деле не управляет возможностью связывания свойства с данными, а просто по-мечает его как отображаемое в диалоговом окне DataBindings. Таково поведение этого атрибута в Visual Studio 2003. Свойства, для которых атрибут Bindable установлен в false, могут быть ассоциированы с источником данных программно с использованием выражений связывания с данными. В окне Properties в Visual Studio 2005 вы не найдете строки DataBindings. Вместо нее там присутствует запись Expressions, где перечисляются связываемые свойства. Однако значение атрибута Bindable, похоже, никак не влияет на включение свойства в этот список. По умолчанию данный атрибут равен false. Атрибут Browsable Все свойства элемента управления выводятся в окне Properties, если вы явно не ука-жете для них обратное, задав атрибут Browsable, равный false. Однако при отсутствии на то веских причин, этот атрибут лучше не использовать. В некоторых случаях его устанавливают в false для свойств, доступных только для чтения, а также тех, которые 
Поддержка специализированных элементов управления во время разработки Глава 15 539 предназначены исключительно для программного доступа (как свойство DataItem элемента управления GaugeBar, который мы разрабатывали в главе 14). [Browsable(false)] public GaugeBarDataItem DataItem { } Заметьте, что свойства, доступные только для чтения и не объявленные явно не-отображаемыми, выводятся в окне Properties как недоступные. Атрибуты Category и Description Атрибуты Category и Description обычно устанавливаются для каждого свойства и события. Первый из них определяет, к какой категории из представленных в окне Properties логически принадлежит свойство, а второй задает описательный текст для вывода в нижней части этого окна. Информация о категории используется только в том случае, когда пользователь выбирает в окне Properties представление свойств по категориям (см. на рис. 15-1). По умолчанию свойства выводятся в алфавитном порядке. Для переключения представлений используются кнопки в окне Properties. В системе определены следующие стандартные категории свойств: Accessibility, Appearance, Behavior, Data, Layout и Misc. Если указать другое имя, будет создана новая категория. По умолчанию пользовательские свойства относятся к категории Misc. [Category("Appearance")] [Description("Gets and sets whether notches should be displayed")] public bool GridLines { } Текст, присвоенный атрибутам Category и Description, может быть локализован путем создания пользовательских атрибутов, как показано ниже: [LocalizableDescription("Local_GridLines_Desc")] public bool GridLines { } Текст, присвоенный пользовательскому атрибуту Category и/или Description, послу-жит ключом для извлечения локализованного значения атрибута из ресурсов сборки с применением пользовательского кода, который вам нужно будет написать. Атрибут DefaultValue В атрибуте DefaultValue задается значение, присваиваемое свойству по умолчанию. Оно не влияет на значение свойства во время выполнения. Когда элемент управле-ния помещается в Web-форму, Visual Studio 2005 создает его экземпляр и запраши-вает у него текущие значения свойств для заполнения окна Properties. Затем Visual Studio 2005 сравнивает значения свойств со значениями атрибута DefaultValue, и если они различны, выводит в окне Properties реальное значение полужирным шрифтом, чтобы вы видели, что данному свойству присвоено не то значение, которое для него задано по умолчанию. Атрибут Themeable В ASP.NET 2.0 введено такое полезное средство, как темы, позволяющее сразу на-значить элементу управления целый блок визуальных установок. Тема состоит из файлов каскадных таблиц стилей (CSS) и обложек. Можно сказать, что тема - это 
540 Часть III Элементы управления ASP.NET набор объявлений элементов управления, каждому из которых присваиваются за-данные по умолчанию визуальные атрибуты. Когда элемент управления размеща-ется на странице ASP.NET, для которой задана тема, все имеющиеся в составе этой темы установки, определенные для элементов управления такого типа, применяются к данному элементу. Темы могут применяться только к визуальным свойствам. Те же свойства, которые определяют поведение элемента управления, не нуждаются в подобном механизме установки. Однако компилятор не отличает поведенческие свойства от визуальных и генерирует исключение всякий раз, когда для свойства, не объявленного явно как не поддерживающее темы, не нашлось установки темы. [Themeable(false)] public float Maximum { } Свойство Maximum элемента управления GaugeBar является поведенческим и не предназначено для определения внешнего вида элемента управления. Поэтому мы пометили его как не поддерживающее темы. По умолчанию все свойства поддержи-вают темы. Атрибут Editor В атрибуте Editor задается редактор, используемый для изменения значения свойства элемента управления. Когда свойство помечено атрибутом Editor, дизайнер создает новый экземпляр типа редактора и по команде пользователя выводит его во всплыва-ющем диалоговом окне. Здесь разработчик страницы может выбрать значение свойс-тва, используя предоставленный пользовательский интерфейс, и вернуться в окно Properties. Класс редактора должен быть производным от базового класса UITypeEditor. В этой главе мы рассмотрим пример его создания. Атрибут TypeConverter В атрибуте TypeConverter задается класс, который действует как конвертер типов данных. Он производит преобразование введенного пользователем текста в значение свойства или предлагает выбрать значение из раскрывающегося списка. Существуют стандартные конвертеры, используемые по умолчанию для свойств перечислимых типов, для которых Visual Studio 2005 выводит раскрывающиеся списки, и для цве-товых свойств, устанавливаемых при помощи палитры. В этой главе мы рассмотрим пример подобного конвертера. Атрибуты классов Каждое объявление класса элемента управления должно быть снабжено как минимум следующими тремя атрибутами: DefaultEvent, DefaultProperty и ToolboxData. Атрибут DefaultProperty определяет свойство, которое выделяется в окне Properties, когда пользователь щелкает элемент управления в дизайнере, а атрибут DefaultEvent опре-деляет событие, обработчик которого создается в ответ на двойной щелчок элемента управления в дизайнере, как показано на рис. 15-2. [ToolboxData("<{0}:BarChart runat=\"server\"></{0}:BarChart>")] [DefaultProperty("Title")] [DefaultEvent("BarChartCreated")] public class BarChart : CompositeDataBoundControl { }
Поддержка специализированных элементов управления во время разработки Глава 15 541 Рис. 15-2. Когда пользователь дважды щелкает элемент управления в дизайнере, создается обработчик события Атрибут ToolboxData определяет тэг, который генерируется для пользовательского элемента управления при его размещении в форме. Текст, который вы задаете в этом атрибуте, должен содержать допустимую разметку, необходимую для определения элемента управления. Дизайнер заменит все вхождения элемента {0} префиксом тэга, ассоциированным с элементом управления. Перечисления и цветовые типы Среда разработки обеспечивает особую поддержку некоторых типов свойств, в том числе цветовых и свойств-перечислений. Например, для свойства типа Color автома-тически выводится цветовая палитра (рис. 15-3). Рис. 15-3. Свойства типа Color можно редактировать с помощью стандартного окна палитры Аналогичным образом редактируются свойства перечислимых типов: для них выводится раскрывающийся список с полным набором значений перечисления. Вам 
542 Часть III Элементы управления ASP.NET для этого ничего делать не требуется. На рис. 15-4 показано, как происходит редак-тирование значения свойства BorderStyle элемента управления BarChart, созданного нами в главе 14. Рис. 15-4. Значение свойства BorderStyle можно выбрать в раскрывающемся списке Точно так же Visual Studio 2005 поступает с любыми другими свойствами поль-зовательских перечислимых типов. Атрибуты, действующие во время выполнения Разрабатывая серверный элемент управления, вы обычно используете атрибуты как директивы среде разработки Visual Studio 2005. Однако существует несколько атри-бутов, которые влияют на поведение элемента управления во время выполнения. Они указывают анализатору страницы, как обрабатывать исходный код из файла .aspx. Данные атрибуты перечислены в табл. 15-4. Табл. 15-4. Атрибуты, влияющие на поведение времени выполнения Атрибут Описание ControlBuilder Класс построителя элемента управления для данного элемента ParseChildren Указывает исполняющей среде ASP.NET способ интерпретации вложенного содержимого элемента управления: должно оно обрабатываться как свойства или как дочерние элементы управления TemplateContainer Контейнерный класс, служащий оболочкой для заданного шаблона (см. главу 14) О построителях элементов управления необходимо рассказать отдельно. По умол-чанию каждый элемент управления ассоциирован с определенным классом-постро-ителем. Этот класс работает бок о бок с анализатором страницы, помогая ему интер-претировать разметку элемента управления и строить дочерние элементы управления. Класс построителя элемента управления отвечает за обработку дочерних элементов разметки, которую содержит главный тэг этого элемента. Базовый класс построителей, используемый по умолчанию, называется ControlBuilder.
Поддержка специализированных элементов управления во время разработки Глава 15 543 Для каждого вложенного элемента класс ControlBuilder добавляет в коллекцию Controls дочерний элемент управления. Кроме того, он создает литеральные элементы управления для текста, расположенного между вложенными тэгами элемента управ-ления. Специализированные элементы управления обрабатываются построителем, используемым по умолчанию. Но если вас не устраивает принцип работы класса ControlBuilder, вы можете написать собственный такой класс. Как правило, поль-зовательские построители создают в тех случаях, когда элемент управления имеет сложную структуру или содержит дочерние тэги, требующие особой обработки. Рендеринг значений разных типов Любая информация, которую вы вводите в окне Properties, сохраняется на диске в ви-де атрибутов элемента управления. Стандартный механизм сериализации прекрасно работает для примитивных типов данных (даты, числа, цвета), но не вся информа-ция, которая содержится в блоке кода разметки, на самом деле является строковой. Рассмотрим свойство Width элемента управления: <expo:GaugeBar runat="server" ID="GaugeBar1" width="200px" /> Значение атрибута width выглядит как строка (200px), но тип соответствующе-го ему свойства Width элемента управления не является строковым. Это свойство объявлено как Unit. Что же делает строку 200px понятной элементу управления? Анализатор страницы с помощью специальных модулей, известных как конвертеры типов, выполняет преобразование значений из одного типа данных в другой. В нашем случае класс UnitConverter преобразует строки в значения типа Unit и сериализует значения типа Unit в строки. Реализация конвертера типов Чтобы вы лучше поняли, для чего необходимы конверторы типов, давайте расширим элемент управления GaugeBar, созданный в главе 14, дополнив его свойством Filter сложного типа. Это свойство будет содержать несколько атрибутов, относящихся к средствам рендеринга, таким как альфа-фильтры и фильтры свечения. Примечание Альфа-фильтры и фильтры свечения - это особые компоненты, поддержи-ваемые только Microsoft Internet Explore 5.0 и более новыми версиями данного браузера. Для их применения в стандартном тэге Style нужно задать пользовательские атрибуты. В результате дополнительные фильтры рендеринга будут распознаны и обработаны Internet Explorer, а другие браузеры их проигнорируют. В частности, необходимо реализовать для элемента управления GaugeBar возмож-ность применять радиальный альфа-фильтр с устанавливаемым уровнем прозрачности или бордюрный фильтр, который выводит вокруг элемента управления нечто вроде градиентной рамки. Толщину и цвет этой рамки можно задавать программно. Добавление свойства Filter в элемент управления GaugeBar Средства фильтрации элемента управления GaugeBar инкапсулированы в новом свойстве Filter, определенном следующим образом: private FilterSettings _gaugeFilters = null; [Category("Appearance")] [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)] [Description("Defines the filter settings of the gauge")] public FilterSettings Filter { get
544 Часть III Элементы управления ASP.NET { if (_gaugeFilters == null) _gaugeFilters = new FilterSettings(); return _gaugeFilters; } } Поскольку свойство Filter имеет пользовательский тип, оно не сохраняется в со-стоянии представления. Это свойство характеризуется новым атрибутом Designer-SerializationVisibility, который мы рассмотрим немного позже. Тип свойства Filter не примитивен - это сложный класс с несколькими свойствами: public class FilterSettings { private GaugeFilterType _type; private Color _glowColor; private int _glowStrength; private int _alphaOpacity; public FilterSettings() { _type = GaugeFilterType.None; _glowStrength = 5; _alphaOpacity = 25; } [Description("Gets and sets the type of the filter to use")] [NotifyParentProperty(true)] public GaugeFilterType FilterType { get { return _type; } set { _type = value; } } [Description("Gets and sets the color of the border")] [NotifyParentProperty(true)] public Color GlowColor { get { return _glowColor; } set { _glowColor = value; } } [Description("Indicates the width of the border")] [NotifyParentProperty(true)] public int GlowStrength { get { return _glowStrength; } set { _glowStrength = value; } } [Description("Indicates the percentage of opacity desired")] [NotifyParentProperty(true)] public int AlphaOpacity { get { return _alphaOpacity; } set { _alphaOpacity = value; } } }
Поддержка специализированных элементов управления во время разработки Глава 15 545 Эти свойства не сохраняются в состоянии представления. Поскольку данные ат-рибуты созданы для установки во время разработки, мы присвоили им значения по умолчанию, не изменяемые программным способом. Таким образом, не используя состояние представления, которое нам в данном случае не требуется, мы немного оптимизировали элемент управления. Что происходит при редактировании свойства Filter во время разработки? На рис. 15-5 показано, как Visual Studio 2005 выводит содержимое свойства со значени-ями, заданными по умолчанию. Рис. 15-5. Редактирование содержимого пользовательского свойства сложного типа в Visual Studio 2005 Как видите, в окне Properties выводится лишь тип свойства, а точнее, результат применения к нему метода ToString. Изменить отображаемый текст ничего не стоит, но как сделать содержимое свойства редактируемым? Для этого есть две возможности: добавить конвертер типов или определить ре-дактор типа. Рассмотрим сначала первую из них. Что такое конвертер типов Конвертер типов - это объект, который реализует определенную логику по преоб-разованию одного типа в другой. Многие объекты .NET Framework, например целые числа, цвета, шрифты и уже упоминавшийся тип Unit, ассоциированы с конвертерами типов. Конвертеры используются, когда требуется представить значение непримитив-ного типа в строковом формате для сохранения в файле .aspx. Кроме того, конвер-теры считывают строковое представление значения и возвращают его к исходному типу. Они работают за сценой, когда вы задаете, например, шрифтовые свойства посредством текстовых атрибутов во время разработки и извлекаете объект Font для использования во время выполнения. Для того чтобы свойства объекта FilterSettings было удобно редактировать в Visual Studio 2005, нам нужно создать конвертер типов, разделяющий сложный объект на части, которые устанавливаются и сохраняются по отдельности. Для этого мы созда-дим класс, наследующий TypeConverter, и переопределим несколько его членов. Создание конвертера типов Конвертер для конкретного типа должен определять, к каким типам и из каких ти-пов можно преобразовывать его значения. Членами, которые нужно для этого пе-реопределить, являются методы CanConvertTo и CanConvertFrom. Они сверяют тип 
546 Часть III Элементы управления ASP.NET назначения или исходный тип со списком типов, поддерживаемых конвертером. Оба метода возвращают значения булева типа, указывающее, возможно ли выполнить преобразование. В списке поддерживаемых типов должен обязательно присутство-вать тип String, но могут поддерживаться и другие преобразования, в зависимости от назначения и реализации конвертера. (Например, числа типа Integer могут преобра-зовываться в байтовые массивы или десятичные значения, если такое преобразование вам необходимо.) Кроме того, нужно переопределить методы ConvertTo и ConvertFrom. Как подска-зывают их имена, эти методы выполняют преобразование к типу FilterSettings и из него. Обычно процесс сериализации составного значения заключается в создании разделенной запятыми строки, в которой значения каждого свойства представлены в виде составляющих строк. Способ сериализации отдельных свойств определяется программистом. Ниже приведена полная реализация конвертера типов для класса FilterSettings. public class GaugeFilterSettingsConverter : TypeConverter { private const int NumOfMembers = 4; public GaugeFilterSettingsConverter() { } //Преобразование из типа String возможно public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) { if (sourceType == typeof(string)) return true; return base.CanConvertFrom(context, sourceType); } //Преобразование к типу String и создание нового экземпляра возможно public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) { if (destinationType == typeof(string)) return true; if (destinationType == typeof(InstanceDescriptor)) return true; return base.CanConvertTo(context, destinationType); } //Преобразование FilterSettings в строку public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) { //Убеждаемся, что value является объектом типа FilterSettings if (value != null) { if (!(value is FilterSettings)) throw new ArgumentException( "Invalid FilterSettings object", "value"); }
Поддержка специализированных элементов управления во время разработки Глава 15 547 //Если null, возвращаем пустую строку if (destinationType == typeof(string)) { if (value == null) return String.Empty; //Получаем объект для сериализации и необходимые конвертеры FilterSettings filter = (FilterSettings) value; TypeConverter cvInt; cvInt = TypeDescriptor.GetConverter(typeof(int)); TypeConverter cvColor; cvColor = TypeDescriptor.GetConverter(typeof(Color)); //Создаем строку string[] parts = new string[NumOfMembers]; parts[0] = filter.FilterType.ToString(); parts[1] = cvInt.ConvertTo(filter.AlphaOpacity, typeof(int)); parts[2] = cvInt.ConvertTo(filter.GlowStrength, typeof(int)); parts[3] = cvColor.ConvertTo(filter.GlowColor, typeof(string)); return String.Join(culture.TextInfo.ListSeparator, parts); } return base.ConvertTo(context, culture, value, destinationType); } //Преобразование заданного значения к типу FilterSettings public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) { //Создаем экземпляр по умолчанию if (value == null) return new FilterSettings(); //Выполняем десериализацию из строкового представления if (value is string) { //Получаем исходную строку string data = (string) value; if (data.Length == 0) return new FilterSettings(); //Разделяем ее на пары string[] parts = data.Split(culture.TextInfo.ListSeparator[0]); if (parts.Length != NumOfMembers) throw new ArgumentException( "Invalid FilterSettings object", "value"); //Создаем новый объект FilterSettings FilterSettings filter = new FilterSettings(); //Часть 0 - это строка, представляющая свойство FilterType Type t = typeof(GaugeFilterType); filter.FilterType = (GaugeFilterType) Enum.Parse(t, parts[0]); //Часть 1 представляет свойство AlphaOpacity (integer) TypeConverter cvInt; cvInt = TypeDescriptor.GetConverter(typeof(int));
548 Часть III Элементы управления ASP.NET filter.AlphaOpacity = (int) cvInt.ConvertFrom(context, culture, parts[1]); //Часть 2 представляет свойство GlowStrength (integer) filter.GlowStrength = (int) cvInt.ConvertFrom(context, culture, parts[2]); //Часть 3 представляет свойство GlowColor (Color) TypeConverter cvColor; cvColor = TypeDescriptor.GetConverter(typeof(Color)); filter.GlowColor = (Color) cvColor.ConvertFrom(context, culture, parts[3]); return filter; } return base.ConvertFrom(context, culture, value); } } Класс GaugeFilterSettingsConverter позволяет преобразовывать объекты типа Filter-Set tings в строки и наоборот, как показывает реализация методов CanConvertTo и CanConvertFrom. Объект FilterSettings сериализуется в строку путем создания серии разделенных запятыми токенов. Выбирая разделитель, мы не стали учитывать куль-туру, поскольку запятая подходит для большинства культур. Обратите внимание на применение специализированных конвертеров, с помощью которых получается строковое представление типов Color и Integer: TypeConverter cvInt = TypeDescriptor.GetConverter(typeof(int)); TypeConverter cvColor = TypeDescriptor.GetConverter(typeof(Color)); Обращение к этим конвертерам не является обязательным: вы можете исполь-зовать для сериализации членов класса в строки любой другой алгоритм, однако желательно, чтобы представление в дизайнере распространенных типов все же было стандартным: parts[2] = cvInt.ConvertTo(filter.GlowStrength, typeof(int)); parts[3] = cvColor.ConvertTo(filter.GlowColor, typeof(string)); Точно так же, преобразование разделенной запятыми строки в новый экземпляр класса FilterSettings выполняется с использованием специализированных конвертеров, преобразующих отдельные значения: filter.GlowStrength = cvInt.ConvertFrom(context, culture, parts[2]); filter.GlowColor = cvColor.ConvertFromString(context, culture, parts[3]); Конвертер не начинает действовать до тех пор, пока вы не свяжете его с классом FilterSettings: [TypeConverter(typeof(GaugeFilterSettingsConverter))] public class FilterSettings { } Теперь в окне Properties выводится запись для свойства Filter, содержащая разде-ленный запятыми набор строк. Цвета в ней выводятся как целые числа: //0=тип, 25=непрозрачность, 5=интенсивность, -256=цвет 0,25,5,-256 
Поддержка специализированных элементов управления во время разработки Глава 15 549 Для редактирования свойств нужно ввести новое значение прямо в текстовое поле. Очевидно, что это не лучшее решение, и действительно существует другой вариант. Наследование класса ExpandableObjectConverter Если вы работаете в Visual Studio 2005, то знаете, что для установки шрифта здесь можно выбрать свойство Font и отредактировать разные его компоненты, в частности Size и Name. Эти компоненты выводятся в окне свойств в отдельных строках, которые появляются при развертывании элемента представляющего свойство Font. Как бы и нам реализовать подобное поведение? Для этого конвертер типов должен быть производным от класса ExpandableObje ctConverter. Данный класс наследует TypeConverter и имеет два дополнительных пе-реопределяемых метода: GetProperties и GetPropertiesSupported. Достаточно заменить в приведенном выше коде базовый класс, и полученный конвертер будет вести себя точно так же, как конвертер свойства Font (рис. 15-6). Рис. 15-6. Свойство Filter стало развертываемым Каждое свойство класса, ассоциированного с конвертером типов, должно быть помечено атрибутом NotifyParentProperty, для того чтобы родительское свойство уве-домлялось об изменении его значения. В следующем коде показано, какие метаданные требуются составляющему свойству Text: [Description("Gets and sets the type of filter to use")] [NotifyParentProperty(true)] public GaugeFilterType FilterType { get { return _type; } set { _type = value; } } На рис. 15-7 представлена демонстрационная страница, на которой используется элемент управления GaugeBar с примененными к нему фильтрами. А вот фрагмент исходного кода страницы, на которой выводится этот элемент: <expo:GaugeBar runat="server" ID="GaugeBar1" Width="200px" Height="20px" BackColor="LightCyan"
550 Часть III Элементы управления ASP.NET Value="22" BorderStyle="Solid" BorderWidth="1px" BorderColor="MediumAquamarine" ForeColor="MediumAquamarine" GridLines="True" FormatString="<b>{0}</b>%" Filter-AlphaOpacity="4" Filter-FilterType="Glow" Filter-GlowColor="Blue" Filter-GlowStrength="5" > </expo:GaugeBar> Рис. 15-7. Элемент управления GaugeBar с примененными к нему двумя фильтрами в Internet Explorer Как видите, составляющие свойства сериализуются в стандартном формате: свой-ство-подсвойство. Для управления сериализацией значений используются сериали-зационные атрибуты, такие, как DesignerSerializationVisibility, впервые встретившийся нам в объявлении нового свойства Filter. Сериализационные атрибуты Атрибуты, описанные в табл. 15-5, указывают дизайнеру, как можно сериализовать элемент управления и его свойства. Процесс сериализации очень важен, поскольку он является частью процесса формирования HTML-кода элемента управления. Атрибут DesignerSerializationVisibility может принимать значения, перечисленные в табл. 15-6. Табл. 15-5. Атрибуты сериализации серверного элемента управления времени разработки Атрибут Описание DesignerSerializationVisibility Определяет, будет ли (если будет, то каким образом) свойство, выводимое в окне Properties, сохраняться в разметке элемента управления
Поддержка специализированных элементов управления во время разработки Глава 15 551 Атрибут Описание NotifyParentProperty Определяет, должны ли сведения об изменении составляющих свойств передаваться родительскому свойству. Этот атрибут используется, когда преобразуемое свойство является производ-ным от ExpandableObjectConverter PersistChildrenAttribute Указывает, должно вложенное содержимое элемента управле-ния интерпретироваться как свойства или как дочерние элементы управления PersistenceMode Определяет, должно свойство сохраняться в тэге элемента управления как атрибут тэга элемента управления или как вложенное содержимое Табл. 15-6. Значения атрибута DesignerSerializationVisibility Значение Описание Content Контент свойства (например, Filter) сериализуется как целое. Все составляющие свойства сериализуются с использованием специализированного соглашения об именах. Составляющими свойства являются дочерние члены сложного типа. Например, FilterType и GlowColor являются составляющими свойства Filter. Для составляющего свойства FilterType создается атрибут с именем Filter-FilterType Hidden Свойство исключается из сериализации и не сохраняется в разметке элемента управления Visible Значение по умолчанию: свойство верхнего уровня сериализуется. Когда задана эта установка, такое свойство как Filter сериализуется в виде разделенного запя-тыми списка дочерних значений. Все составляющие свойства сохраняются не по отдельности, а в виде единого атрибута Filter Атрибут PersistChildren устанавливается в false для элементов управления, произ-водных от WebControl, и в true - для элементов управления, производных от Control. В первом случае вложенный контент элемента управления обрабатывается как свойс-тва. Каждый тэг ставится в соответствие свойству с таким же именем. Например, дочернему тэгу <ItemTemplate> соответствует свойство ItemTemplate. Если это автома-тическое соответствие отключено, то есть атрибут PersistChildren равен false, дочерний тэг рассматривается как HTML-элемент и для правильной обработки его содержимого требуется пользовательский построитель; при отсутствии такового компилятор гене-рирует ошибку. Атрибут PersistenceMode указывает, как следует сохранять содержимое свойства. Можете решить, хотите ли вы, чтобы оно сериализовалось как атрибут тэга управления элемента или как дочерний тэг. Допустимые значения данного атрибута приведены в табл. 15-7. Табл. 15-7. Значения атрибута PersistenceMode Значение Описание Attribute Свойство сохраняется как атрибут тэга. Это значение по умолчанию EncodedInnerDefault Property Свойство сохраняется как единственное содержимое тэга в формате HTML InnerDefaultProperty Свойство сохраняется как единственное содержимое тэга, но не кодируется InnerProperty Свойство сохраняется как дочерний тэг вместе с любыми другими свойствами элемента управления Табл. 15-5. (окончание)
552 Часть III Элементы управления ASP.NET Если у вашего элемента управления имеются свойства-шаблоны, вы можете из-менить значение атрибута PersistenceMode для каждого элемента, чтобы дизайнер не удалил вложенный контент при сохранении данных, выведенных в окне Properties. Ниже приведен типичный заголовок свойства-шаблона (см. главу 14). [TemplateContainer(typeof(TitleTemplateContainer))] [PersistenceMode(PersistenceMode.InnerProperty)] public ITemplate TitleTemplate { get { return _titleTemplate; } set { _titleTemplate = value; } } Приведенный код указывает, что свойство TitleTemplate должно сохраняться как вложенный тэг вместе со всеми остальными свойствами элемента управления. Создание редактора типов Окно Properties не отличается особой гибкостью в отношении редактирования зна-чений. Да, в нем есть цветовые палитры и раскрывающиеся списки, но свойства, не содержащие значений цвета или перечислимого типа, редактируются непосредственно в текстовых полях. Если такое поведение встроенного редактора Visual Studio вас не устраивает, вы можете создать собственный редактор и связать его с дизайнером. Базовым классом таких компонентов является UITypeEditor. Ваша задача - определить пользователь-ский класс редактора и, используя атрибуты-метаданные, проинформировать дизайнер о том, что определенное свойство должно редактироваться в специализированном диалоговом окне. Редактор типа - это диалоговое окно Windows Forms, для управления которым используется стандартный интерфейс. Указанное диалоговое окно содержит элементы управления, облегчающие редактирование данных, а потом помещает в буфер стро-ковое значение для окна Properties. Давайте создадим такой редактор для свойства Filter. Редактор свойства Filter Ниже показано, как можно заменить развертываемый конвертер типов специализи-рованным редактором свойства с удобным пользовательским интерфейсом. [Editor(typeof(GaugeFilterSettingsEditor), typeof(UITypeEditor))] public FilterSettings Filter { } Атрибут Editor указывает, что данное диалоговое окно будет использоваться для редактирования значения свойства определенного типа, в данном случае - пользова-тельского класса GaugeFilterSettingsEditor. Второй аргумент атрибута задает тип базо-вого класса реактора. В .NET Framework определено несколько классов редакторов, которые могут послужить основой для ваших собственных классов. UITypeEditor является базовым классом редакторов свойств. В производные от него классы могут быть добавлены специализированные средства редактирования определенного свойства. Есть и другие встроенные редакторы - для коллекций, URL, цветов, дат и т. д.
Поддержка специализированных элементов управления во время разработки Глава 15 553 Когда свойство помечено атрибутом Editor, дизайнер выводит в его строке кноп-ку с символом многоточия (рис. 15-8). Щелкнув ее, пользователь видит диалоговое окно, где осуществляется редактирование свойств с использованием более удобного пользовательского интерфейса. Рис. 15-8. Свойство Filter и кнопка с многоточием, открывающая пользовательский редактор Примечание Для использования редакторов на базе UITypeEditor вам потребуется сборка System.Windows.Forms. Она довольно велика, из-за чего элемент управления потребляет много памяти. Если вы собираетесь определять редакторы типа UITypeEditor, поместите функции времени выполнения и времени разработки в разные сборки. Разработка пользовательского редактора типа Создание пользовательского редактора типа начинается с определения нового класса, производного от UITypeEditor или любого другого типа редактора. После этого в проект добавляется класс формы и определяется пользовательский интерфейс диалогового окна. Скорее всего, вам потребуется импортировать одно или несколько пространств имен, связанных с Windows Forms и дизайнерами. Наверняка будут необходимы как минимум такие ссылки: using System.Drawing.Design; using System.Windows.Forms; Ссылки на классы Windows Forms нужны, несмотря на то, что вы работаете с проектом элемента управления для Web, - ведь окно редактора отображается не в браузере. В классе редактора типа должны быть переопределены методы GetEditStyle и Edit-Value. Первый из них определяет тип окна редактора: DropDown или Modal, - а второй обеспечивает отображение этого окна и извлечение значений, передаваемых в окно Properties. Ниже приведен код класса GaugeFilterSettingsEditor. public class GaugeFilterSettingsEditor : UITypeEditor { public override UITypeEditorEditStyle GetEditStyle( ITypeDescriptorContext context) { return UITypeEditorEditStyle.Modal; } public override object EditValue(
554 Часть III Элементы управления ASP.NET ITypeDescriptorContext context, IServiceProvider provider, object value) { //Создайте и выведите здесь диалоговое окно Windows Forms //Используйте возвращаемые диалоговым окном значения //для возврата значения из метода return value; } } Если метод GetEditStyle возвращает значение UITypeEditorEditStyle.DropDown, ди-зайнер готовится вывести заданный элемент управления непосредственно под текс-товым полем свойства. Если же он возвращает UITypeEditorEditStyle.Modal, дизайнер выводит модальное окно. Метод EditValue вызывается для редактирования. В приведенном выше коде созда-ется и выводится новое диалоговое окно. Когда оно закрывается, можно использовать глобальные поля или свойства его класса для извлечения введенной пользователем информации и сохранения ее во внутренней переменной. Значение, возвращенное методом EditValue, присваивается свойству. Если выбран интерфейс DropDown, для вывода пользовательского элемента управ-ления в окне Properties следует использовать методы интерфейса IWindowsFormsEditor-Service. В этом случае вместо формы создается пользовательский элемент управления, а дизайнер вместо кнопки с многоточием вводит кнопку со стрелкой. public override object EditValue( ITypeDescriptorContext context, IServiceProvider provider, object value) { object o = provider.GetService(typeof(IWindowsFormsEditorService)); IWindowsFormsEditorService srv = (IWindowsFormsEditorService) o; if (srv != null) { //Выводим пользовательский элемент управления и извлекаем значения MyControl myCtl = new MyControl(value); srv.DropDownControl(myCtl); } } Можно также реализовать собственный механизм рисования, переопределив ме-тоды GetPaintValueSupported и PaintValue. Первый просто возвращает значение булева типа. Второму передается прямоугольник, представляющий область окна Properties, в которой должен быть нарисован элемент, и объект Graphics. Для формирования вывода метод PaintValue может использовать всю мощь GDI+. Работа с пользовательскими коллекциями Со свойствами элементов управления, реализованными в виде коллекций, большин-ство дизайнеров работают особым образом - для них используется специализирован-ный редактор типов. Вы щелкаете кнопку с многоточием, и появляется диалоговое окно, подобное показанному на рис. 15-9.
Поддержка специализированных элементов управления во время разработки Глава 15 555 Рис. 15-9. Стандартный редактор коллекций, используемый большинством встроенных элементов управления Такое диалоговое окно может наследоваться и большинством пользовательских свойств-коллекций, причем для этого не нужно прикладывать особых усилий. Разработка класса-коллекции Дизайнер Visual Studio 2005 ассоциирует все классы, наследующие интерфейс ICollection, с классом CollectionEditor. Этот класс отвечает за вывод пользовательского интерфейса, представленного на рис. 15-9. Коллекция должна состоять из объектов классов, в составе которых определе-ны свойства, а не поля. Тогда редактор может извлечь члены и заполнить таблицу свойств, выводимую справа. Для заполнения коллекции можно использовать элементы управления из диалогового окна. Новые элементы выводятся в списке слева с описа-нием, возвращенным методом ToString класса, реализующего коллекцию. Редактирование коллекции HyperLinkItemCollection Элемент управления, созданный нами в главе 14, имеет свойство-коллекцию с именем Items, в которой содержится описание гиперссылок, подлежащих выводу на странице. Каждая ссылка представлена объектом типа HyperLinkItem. Класс-коллекция называ-ется HyperLinkItemCollection и объявляется следующим образом: public class HyperLinkItemCollection : Collection<HyperLinkItem> { } У класса HyperLinkItem три открытых свойства: Text, Url и Tooltip. Щелкнув кноп-ку с многоточием возле элемента Items в окне Properties, можно вывести диалоговое окно, показанное на рис. 15-10. В нем вы увидите список гиперссылок, имеющихся в Web-форме, и сможете его отредактировать. Рис. 15-10. Стандартный редактор коллекции работает со свойствами типа HyperLinkItemCollection 
556 Часть III Элементы управления ASP.NET Пользовательские дизайнеры Иногда при тестировании специализированного элемента управления вы сосредота-чиваетесь на его поведении времени выполнения. Создав тестовую страницу, вы снова и снова запускаете ее, и когда наконец чувствуете, что удовлетворены результатами, решаете протестировать поведение элемента управления во время разработки. И тут вдруг выясняется, что он отказывается работать в дизайнере и выбрасывает исклю-чение. В ASP.NET 2.0 класс Control имеет новое булево свойство с именем DesignMode. Как указывает его имя, свойство возвращает true, если экземпляр элемента управления выводится в дизайнере, и false - если он выполняется в приложении. В простейшем случае описанная проблема решается путем включения в метод Render оператора if. if (DesignMode) { }else { } В других случаях требуется более тщательно отделить рендеринг времени вы-полнения от рендеринга времени разработки. В этом вам поможет пользовательский дизайнер. Встроенные дизайнеры Каждый элемент управления ассоциирован с компонентом-дизайнером, который отве чает за генерирование разметки для вывода в Visual Studio 2005. Этот базовый дизайнер обеспечивает извлечение разметки элемента управления в виде строки и передачу ее хост-среде. Заметьте, что при хостинге в Visual Studio 2005 (или в любой другой среде разработ-ки) элемент управления не проходит обычный жизненный цикл и не получает событий. Взаимодействие между ним и хостом ограничено вызовом метода RenderControl. Есть по крайней мере две причины, по которым вам может потребоваться пользо-вательский дизайнер элемента управления. Первая из них заключается в том, что вас не удовлетворяет представление элемента управления в дизайнере во время разработ-ки, - например, потому, что неудачно запрограммирован механизм рендеринга эле-мента управления, или же потому, что этот элемент сильно зависит от данных времени выполнения. Чтобы представление элемента управления было более реалистичным, пользовательский дизайнер может использовать некие искусственные данные. Вторая причина может состоять в том, что вы хотите выводить сообщения или (что особенно вероятно в ASP.NET 2.0) предоставить пользователю более широкие возможности, используя средства хост-среды: добавить списки с автоматическим форматированием, пользовательские действия и задания. Прежде чем мы продолжим изучение темы пользовательских дизайнеров, я хотел бы коротко проанализировать пару встроенных дизайнеров, с которыми вы должны быть уже хорошо знакомы. Класс ControlDesigner Класс ControlDesigner предоставляет базовый набор возможностей времени разработ-ки, характерных для элементов управления ASP.NET. Он получает от хост-дизайнера 
Поддержка специализированных элементов управления во время разработки Глава 15 557 экземпляр элемента управления и перенаправляет его разметку в поток в памяти. В следующем псевдокоде показано, как он работает: //ctl - это экземпляр элемента управления, расположенный в дизайнере StringWriter sw = new StringWriter(); HtmlTextWriter writer = new HtmlTextWriter(sw); ctl.RenderControl(writer); return sw.ToString(); Полученная строка возвращается Visual Studio 2005 и отображается в Web-форме. Главным элементом любого дизайнера элемента управления является метод Get-DesignTimeHtml. Он не имеет аргументов и возвращает HTML-код, необходимый для представления элемента управления во время разработки. Приведенный выше код взят из метода GetDesignTimeHtml, реализованного в классе ControlDesigner. Доволь-но часто пользовательские дизайнеры являются просто классами, наследующими ControlDesigner и переопределяющими метод GetDesignTimeHtml. Дизайнеры для элементов управления, связанных с данными Встроенные дизайнеры существуют для всех категорий элементов управления, свя-занных с данными. Главное назначение таких дизайнеров - обеспечить реалистичное представление элемента управления, как будто он связан с реальными данными. Обычно дизайнер загружает для этой цели демонстрационные данные, главным об-разом фиксированные строки, например: "Элемент, связанный с данными" (далее будет приведен пример). Однако в ASP.NET 2.0 дизайнер выполняет дополнительные задачи, такие как предоставление удобного окружения времени выполнения для конфигурирования элемента управления. При этом дизайнер часто имеет интерфейс типа мастера. На рис. 15-11 показан стандартный список действий, определенных для элементов управления, связанных с данными. При написании дизайнера для элемента управления, связанного с данными, лучше брать за основу класс DataBoundControlDesigner. По сравнению с ControlDesigner он имеет более простую архитектуру, но его основным элементом также является метод GetDesignTimeHtml. Класс DataBoundControlDesigner включает метод DataBind, который вызывает но-вый метод - GetDesignTimeDataSource, отвечающий за предоставление данных для использования во время разработки. Если элемент управления связан с полностью конфигурируемым элементом управления, представляющим источник данных, то это реальный набор данных; в противном случае это тестовые данные, как в ASP.NET 1.x. Рис. 15-11. Список действий дизайнера, связанного с данными, в ASP.NET 2.0
558 Часть III Элементы управления ASP.NET Написание пользовательских дизайнеров Базовым классом дизайнеров элементов управления является ControlDesigner, распо-ложенный в пространстве имен System.Web.UI.Design. Этот класс определяет общее поведение дизайнеров и поддерживает методы, которые окружение времени разра-ботки может вызывать для разных целей. ControlDesigner - первый конкретный класс в иерархии, который можно использовать в собственном коде. Все дизайнеры для элементов управления ASP.NET наследуют абстрактный класс HtmlControlDesigner, который отличает их от дизайнеров элементов управления для Windows. Дизайнеры элементов управления HTML В среде графического дизайнера серверный элемент управления не отличается ин-терактивностью, не генерирует событие возврата формы и формирует ограничен-ный HTML-вывод. Если вы хотите, чтобы элемент управления отвечал принципу WYSIWYG, реализуйте механизм его рендеринга в методе Render. Именно этот метод вызывается из визуального дизайнера для получения HTML-кода элемента управ-ления. Если создать составной элемент управления и переопределить метод Create-ChildControls, элемент управления будет нормально работать во время выполнения, но не во время разработки. В дизайнере последовательность вызовов иная, и элемент, структурированный таким образом, вернет дизайнеру HTML-строку. В ASP.NET 2.0 базовый класс CompositeControl гораздо лучше справляется с такой ситуацией. Од-нако если вы не сделаете свой класс производным от CompositeControl, но при этом определите иерархию элементов управления, вам придется самостоятельно обеспе-чивать создание дочерних элементов управления в методе Render. Далее приводится псевдокод метода Render элемента управления CompositeControl, который вам нужно воспроизвести в коде собственного элемента управления, чтобы он правильно вел себя во время разработки: protected internal override void Render(HtmlTextWriter writer) { if (base.DesignMode) this.EnsureChildControls(); base.Render(writer); } Чтобы получить возможность управлять внешним видом элемента управления в графическом дизайнере, нужно переопределить несколько методов, таких, как GetDesignTimeHtml. Написание пользовательского дизайнера для элемента управ-ления - наиболее эффективный способ решения проблем времени разработки без изменения поведения времени выполнения. Создание дизайнера элемента управления Типичный дизайнер элемента управления является производным от ControlDesigner и наследует несколько методов, описанных в следующем списке. С помощью этих методов он управляет выводом HTML-кода в графическом дизайнере. GetDesignTimeHtml - этот метод возвращает HTML-разметку, которая используется для представления элемента управления во время разработки. По умолчанию метод возвращает вывод, сгенерированный методом Render, однако переопределив его, вы можете изменить эту строку или даже определить фиксированное представление элемента управления. 
Поддержка специализированных элементов управления во время разработки Глава 15 559 GetEmptyDesignTimeHtml - данный защищенный переопределяемый метод полу-чает код разметки HTML, представляющий пустой элемент управления во время разработки. Базовая реализация этого метода возвращает строку, содержащую имя и идентификатор класса элемента управления. GetErrorDesignTimeHtml - этот защищенный переопределяемый метод возвра-щает код HTML-разметки, выводимый в том случае, если во время разработки в элементе управления произойдет ошибка. Возвращаемый методом текст обычно содержит информацию об определенном исключении. В специализированном дизайнере элемента управления вы можете также пере-определить или использовать методы AllowResize и CreatePlaceHolderDesignTimeHtml. Первый из них возвращает значение булева типа, которое информирует дизайнер о возможности изменения размеров элемента управления. Обычно ничто не мешает сделать элемент управления допускающим изменение размеров. Однако в некоторых случаях предпочтителен фиксированный размер, например, когда шаблон элемента управления, поддерживающего шаблоны, является пустым. Метод CreatePlaceHolderDesignTimeHtml принимает строку сообщения и возвраща-ет блок HTML-текста, который выглядит и ведет себя как так же, как аналогичные блоки стандартных элементов управления. Например, вы можете с помощью этого метода выдавать сообщение об ошибке, как показано в следующем фрагменте кода (рис. 15-12): protected override string GetErrorDesignTimeHtml(Exception e) { return CreatePlaceHolderDesignTimeHtml("There was an error"); }Рис. 15-12. Сообщение элемента управления об ошибке времени выполнения Если вам не нравится стандартный пользовательский интерфейс, или же вы хо-тите немного его изменить, можете просто вернуть произвольный HTML-код, как рассказывается в следующем примере. Генерирование HTML-разметки Ниже продемонстрирована простая реализация дизайнера для элемента управле-ния GaugeBar. В данном классе переопределяются три метода: GetDesignTimeHtml, Initialize и OnClick, - а также свойство AutoFormats. Благодаря этому представление элемента управления меняется согласно задаваемым в дизайнере установкам, эле-мент обнаруживает щелчки мыши и поддерживает меню автоформатирования. Метод GetDesignTimeHtml принимает вывод элемента управления и вставляет его в таблицу вместе с коротким примечанием. public class GaugeBarDesigner : ControlDesigner {
560 Часть III Элементы управления ASP.NET private GaugeBar _controlInstance; private bool _addNote; private float _originalValue; public override void Initialize(IComponent component) { //Получаем ссылку на элемент управления разрабатываемой страницы _controlInstance = (GaugeBar) component; base.Initialize(component); } public override string GetDesignTimeHtml() { if (_controlInstance.Value < 0) { //Сохраняем текущее значение, не являющееся допустимым _originalValue = _controlInstance.Value; //Создаем случайное значение. Это присваивание необходимо //будет отменить на выходе, иначе значение будет сохранено //в ASPX-файле _controlInstance.Value = GetRandomNumber(); _addNote = true; } else _addNote = false; //Если допустимое значение не предоставлено, //добавляем сообщение в разметку if (_addNote) { string template = "..."; string message = "The <b>Value</b> property has no valid " + "value set. <br/>The displayed value has " + "been randomly generated to help " + "you form an idea about the control. <hr/>" + "<small>Courtesy of <b>Programming " + "Microsoft ASP.NET 2.0 Applications-" + "Advanced Topics</b></small>"; string markup = String.Format(template, base.Component.GetType().Name, base.Component.Site.Name, base.GetDesignTimeHtml(), message); //Восстанавливаем исходное сообщение _controlInstance.Value = _originalValue; //Возврат return markup; }
Поддержка специализированных элементов управления во время разработки Глава 15 561 //Возвращаем разметку по умолчанию return base.GetDesignTimeHtml(); } protected override void OnClick(DesignerRegionMouseEventArgs e) { base.OnClick(e); //Повторяем рендеринг элемента управления с новым случайным значением UpdateDesignTimeHtml(); } public override DesignerAutoFormatCollection AutoFormats { get { DesignerAutoFormatCollection autoFormats; autoFormats = new DesignerAutoFormatCollection(); autoFormats.Add(new SimpleAutoFormat()); autoFormats.Add(new PercentageAutoFormat()); return autoFormats; } } private int GetRandomNumber() { Random rnd = new Random(); return (int) rnd.Next(0, (int)_controlInstance.Maximum); } } На рис. 15-13 элемент управления GaugeBar показан в дизайнере Visual Studio 2005. Дизайнер адаптирует возвращаемую разметку, основываясь на заданном значении свойства Value. Рис. 15-13. Элемент управления GaugeBar в среде Visual Studio
562 Часть III Элементы управления ASP.NET Адаптация разметки с учетом значения свойства Value Вывод элемента управления GaugeBar в большой мере определяется значением свой-ства Value. Если во время разработки этому свойству присвоено отрицательное значе-ние, то есть реальное его значение становится известным только во время выполнения, пользователь может не увидеть реалистического представления элемента управления. Поэтому давайте сделаем так, чтобы в случае, когда реальное значение свойства Value является отрицательным, элемент управления GaugeBar выводил случайное значение. Кроме того, мы добавим пояснительную надпись, которая информирует пользователя о принятом нами решении. (А заодно посмотрим, как осуществляется интеграция в дизайнер пользовательской логики.) Наш HTML-код времени разработки будет состоять из двух частей: основного вывода элемента управления и дополнительной информации, включающей сооб-щение об авторском праве. Эта дополнительная информация во время выполнения отображаться не будет. Вы можете оформить данную разметку, как пожелаете, и сформировать ее лю-бым способом, в том числе с помощью StringBuilder и String.Format. Чтобы конечный результат оставался как можно более близким к стандартным сообщениям, которые обычно выводятся дизайнерами, я позаимствовал HTML-строку, используемую ме-тодом CreatePlaceHolderDesignTimeHtml, и слегка ее модифицировал. HTML-шаблон вывода элемента управления описывает HTML-таблицу, в строках которой выводятся: имя типа элемента управления, его идентификатор, используемая по умолчанию разметка и сообщение для пользователя. В параметре component методу Initialize передается ссылка на элемент управления GaugeBar, созданная Visual Studio 2005 для целей рендеринга. Мы кэшируем эту ссылку и пользуемся ею при подготовке разметки. Проверяем свойство Value и, если оно содержит отрицательное значение, заменяем его значением, сгенерированным случайным образом. Заметьте, что любые установки, заданные для элемента управ-ления в дизайнере, при сохранении страницы сохраняются в Web-форме ASP.NET. Поэтому важно восстановить исходное значение свойства Value, как только разметка будет сгенерирована. Описанная стратегия используется большинством дизайнеров элементов управ-ления, которые при рендеринге элемента управления выводят не настоящие данные, а их имитацию. На рис. 15-14 показано представление элемента управления GaugeBar во время разработки, когда свойство Value имеет отрицательное значение. Заметьте, что настоя-щее значение этого свойства, -1, установлено в окне Properties. Именно это значение будет выводиться во время выполнения. В ASP.NET 2.0 разработчики элементов управления могут перехватывать щелчки мыши, производимые в прямоугольнике элемента управления. Ниже показано, как можно перехватить щелчок и сгенерировать для вывода в элементе управления другое случайное число. protected override void OnClick(DesignerRegionMouseEventArgs e) { base.OnClick(e); UpdateDesignTimeHtml(); } Метод UpdateDesignTimeHtml обновляет представление элемента управления, чтобы отразить изменения, которые вы могли к этому моменту внести. В структуре 
Поддержка специализированных элементов управления во время разработки Глава 15 563 DesignerRegionMouseEventArgs содержится информация о местоположении курсора, которую вы можете использовать для выполнения различных действий. Рис. 15-14. Элемент управления GaugeBar с недопустимым значением свойства Value Создание списка AutoFormats У некоторых элементов управления внизу окна Properties размещается ссылка Auto-Format (см. рис. 15-14). Эта ссылка появляется автоматически, если класс дизайнера возвращает в свойстве AutoFormats непустую коллекцию. Коллекция AutoFormats представляет собой список классов, которые задают для элемента управления предопределенные обложки, выбираемые во время разработки. Каждая обложка - это класс, наследующий класс DesignerAutoFormat. В приведенном ниже коде определены два формата. DesignerAutoFormatCollection autoFormats; autoFormats = new DesignerAutoFormatCollection(); autoFormats.Add(new SimpleAutoFormat()); autoFormats.Add(new PercentageAutoFormat()); Рассмотрим пример класса автоформатирования: public class SimpleAutoFormat : DesignerAutoFormat { public SimpleAutoFormat() : base("(Default formatting)") { } public override void Apply(System.Web.UI.Control control) { GaugeBar _gaugeBar = control as GaugeBar; if (_gaugeBar != null) { _gaugeBar.FormatString = "{0} out of {1}";
564 Часть III Элементы управления ASP.NET _gaugeBar.Segments = 4; _gaugeBar.TextStyle.BackColor = Color.Transparent; _gaugeBar.TextStyle.Font.Name = "verdana"; _gaugeBar.TextStyle.Font.Size = FontUnit.Point(8); _gaugeBar.TextStyle.DisplayTextAtBottom = true; _gaugeBar.TextStyle.RenderInsideTable = false; } } } Параметр, передаваемый базовому конструктору, содержит текстовое описание форматирования. Метод Apply получает ссылку на элемент управления и устанавлива-ет некоторые его визуальные свойства, присваивая им предопределенные значения. Классы автоформатирования, перечисленные в свойстве AutoFormats, используются для заполнения диалогового окна Visual Studio 2005, показанного на рис. 15-15. Рис. 15-15. Диалоговое окно Auto Format с форматами для элемента управления GaugeBar Назначение дизайнера классу элемента управления Вы связываете пользовательский дизайнер с элементом управления, используя атри-бут Designer, как показано в следующем фрагменте кода: [Designer(typeof(GaugeBarDesigner))] public class GaugeBar : DataBoundControl { } Класс дизайнера будет загружен, когда пользователь поместит элемент управления в Web-форму, после чего графический дизайнер выполнит обратный вызов методов данного класса. В ASP.NET 1.x вы обычно делаете дизайнер производным от класса ControlDesigner и расширяете его, переопределив несколько методов. В ASP.NET 2.0 важно, чтобы выбранный базовый класс дизайнера (например, CompositeControlDesigner или DataBoundDesigner) как можно больше подходил по своим характеристикам для элемента управления. Заметьте, что огромное количество элементов управления ASP.NET 2.0 имеют специализированные дизайнеры. Так что планируя разработку пользователь-ского элемента управления, обязательно выделите дополнительное время для проек-тирования средств времени разработки.
Поддержка специализированных элементов управления во время разработки Глава 15 565 Заключение Приложения, написанные для .NET Framework, большей частью имеют компонентную структуру, и приложения ASP.NET - не исключение. Создавая страницы в Visual Studio 2005, разработчик составляет их в графическом дизайнере. Элементы управ-ления выбираются в палитре и перетаскиваются на рабочую поверхность. При этом создаются их экземпляры, которые можно декларативно конфигурировать в окне Properties. Элементы управления ASP.NET знают, как интегрироваться в данное окру-жение, но их поведение в нем можно значительно усовершенствовать. В этой главе мы обсудили три способа улучшения возможностей элементов управ-ления ASP.NET времени разработки. Было рассказано о ряде атрибутов-метаданных, которые назначаются классам и свойствам элементов управления с тем, чтобы эти свойства отображались с заданным вами описанием и правильно разделялись на ка-тегории. Установка атрибутов является эффективным решением для свойств простых типов, таких как строки, целые числа и перечисления. Свойства пользовательский типов требуют выполнения большего объема работы, и нередко для них приходится создавать конвертеры типов. Обычно такой конвертер возвращает разделенную запятыми строку, в которой каждый токен является значе-нием одного открытого свойства. Свойство, связанное с конвертером, может быть представлено в окне Properties в виде развертываемого узла с дочерними строками, представляющими составляющие его свойства. Для этого данное свойство нужно сде-лать производным от более специализированного класса ExpandableObjectConverter. Однако во всех этих случаях пользователь вынужден редактировать значения свойств, используя обычные текстовые поля ввода. Если такое положение дел вас не устраивает, можно создать пользовательский редактор типа или даже редактор компонента. Редакторами в Windows Forms называются классы, связанные с окном Properties и открывающие вызываемое из него диалоговое окно с удобным графиче-ским интерфейсом для редактирования свойства. Класс редактора типа предназначен для редактирования отдельного свойства, а класс редактора компонента генерирует нечто вроде страницы свойств с единым пользовательским интерфейсом для редак-тирования всех свойств элемента управления. Наконец, для управления поведением компонента в графическом дизайнере можно создать специализированный дизайнерский класс. Такой класс состоит из нескольких переопределенных методов, управляющих выводом HTML-текста, сгенерированного для элемента управления в среде разработки. По умолчанию во время разработки элемент управления выглядит и ведет себя практически так же, как во время выпол-нения. Однако иногда бывает желательно, чтобы его вывод был другим и не являлся функцией текущих значений свойств. В таких случаях и применяют пользовательские дизайнеры элементов управления. Только факты У серверного элемента управления есть два разных набора функций: времени разработки и времени выполнения. Поведение элемента управления во время разработки можно усовершенствовать тремя способами: задав предопределенные атрибуты-метаданные, разработав спе-циализированные редакторы свойств и создав пользовательский дизайнер. С помощью атрибутов можно указать, как свойство должно выводиться в окне Properties. 
566 Часть III Элементы управления ASP.NET Значения свойств, задаваемые в окне Properties, сохраняются в сериализованном виде в составе разрабатываемой страницы ASP.NET; атрибут PersistenceMode опре-деляет, как и где они будут сохраняться. Конвертеры типов - это классы, производные от TypeConverter и используемые для сериализации значений непримитивных типов в строки, которые могут быть сохранены в файле .aspx. Если вас не устраивают стандартные средства редактирования свойств элемента управления, вы можете создать собственный редактор и связать его с дизайнером. Базовым классом редакторов типов является UITypeEditor. Дизайнер элемента управления - это класс, генерирующий разметку, выводимую элементом управления в Visual Studio 2005. Каждый такой элемент имеет встро-енный дизайнер, который можно сменить посредством специального атрибута. Класс ControlDesigner определяет базовое поведение дизайнеров элементов управ-ления. Каждый пользовательский дизайнер прямо или косвенно является произ-водным от этого класса. 
Алфавитный указатель AActive Directory, провайдер, 144 Ajax.NET, библиотека, 252, 257 API CodeDOM, 42 Data Protection (DPAPI), 106 XMLDOM, 41 предкомпиляции, 25 расширения IIS (ISAPI), 3, 51 управления конфигурациями, 122 AppDomain, 2 ASP.NET временные файлы, 10 зарезервированные папки, 29 исполняющая среда, 3 как расширение ISAPI, 52 конвейер, 6, 8 компоненты, 6 конфигурация, 84 модель процесса, 3 IIS 5.0, 4 IIS 6.0, 4 оснастка MMC, 129 Atlas, система, 259 AzMan, менеджер ролей, 148 CCatalog Part, компонент, 264, 265 Catalog Zone, 297 CodeDOM, модель, 42 cookie использование провайдером, 166 DDOM (Document Object Model), 124, 227, 249 EEditor Part, 297 Editor Zone, создание, 295 GGDI+, 350 IIIS (Internet Information Server), 3, 51 IIS 7.0, 54 ISAPI (Internet Server Application Programming Interface), 3 модель, 51 модуль, 3 расширение, 53 структура компонента, 53 управляемые расширения и фильтры, 54 фильтр, 53 JJavaScript, 224 MMicrosoft SharePoint и Web Parts, 263 Rreader, объект, 348 SScript Callbacks, технология, 239 WWeb -зона изменение раскладки, 293 свойства, 284 стили, 284 -сад, 4 -сервер, 51 -сервис, вызов, 189 Web Part, компонент, 262 автоматическое обновление, 278 атрибуты свойств, 275 команды, 286 перемещение, 294 пользовательская команда, 287 пользовательский элемент управления, 281 редактирование, 290 рендеринг, 276
568 Алфавитный указатель Web Part, компонент (продолжение) серверный элемент управления, 282 создание, 269 сохранение данных, 288 элементы окна, 268 Web Parts, технология, 261 динамическое соединение, 302 модель соединения, 302 соединение компонентов, 301 статическое соединение, 302 Web Parts Framework, 263 Web Zone, компонент, 264 ААгент пользователя строка, 225 псевдоним, 100 адаптер мобильного устройства, 315 модель, 138 элемента управления, 30 атрибут Bindable, 537 Browsable, 537 Category, 538 ControlBuilder, 541 DefaultEvent, 539 DefaultProperty, 539 DefaultValue, 538 Description, 538 DesignerSerializationVisibility, 543, 549 Editor, 539, 551 NotifyParentProperty, 548 ParseChildren, 541 PersistChildren, 550 PersistenceMode, 526, 550, 564 TemplateContainer, 526, 541 Themeable, 539 ToolboxData, 539 TypeConverter, 539 времени разработки, 535, 537 метаданных, 535 сериализационный для дизайнера, 549 Ббаза данных aspnetdb.mdf, 143, 159 мониторинг, 99 библиотека aspnet_isapi, 3 asp.dll, 52 ISAPI, 51 блок кода, 203-205 выводимый по требованию, 230 стартовый, 233 браузер выбор целевого, 227 информация о возможностях, 225, 226 определение типа, 225 Ввалидатор, 323 возврат формы, 224, 258 всплывание событий, 481 вызов обратный сценария, 240, 247 параллельный, 243, 252 выражение, 203 динамическое, 208 AppSettings, 209 ConnectionStrings, 209 Resources, 33, 209 литеральное, 19 пользовательское, 203 связывания с данными, 21, 207-209 Дделегат, 70, 433 AsyncCallback, 70 BeginEventHandler, 179 EndEventHandler, 179 EventHandler, 433 TimeoutHandler, 198 WaitCallback, 185 дерево карты сайта, 367 конфигурационных файлов, 85 элементов управления страницы, 19 диаграмма гистограмма, 363 круговая, 361 создание, 358 дизайнер элемента управления, 534 встроенный, 555 разработка, 555 директива @Control, 422, 443 @Implements, 247 @OutputCache, 99, 423 @Page, 8, 18, 178, 227, 422 @Reference, 443, 444 @Register, 268, 426 @WebHandler, 62 Ззаголовок HTTP cache-control, private, 99 Content-Type, 338
Алфавитный указатель 569 заголовок HTTP (продолжение) UserAgent, 225 пользовательский, 75 зона Web Parts, 264 Иидентификация анонимная, 95 изображение в Oracle, 349 в SQL Server, 349 в базе данных, 342-347 в поле BLOB, 342 динамическое, 337 загрузка из ресурса, 339 тип, 338 интерфейс IAsyncResult, 177, 194 ICallbackEventHandler, 246, 453 ICollection, 554 IComponent, 532, 533 IDataSource, 492 IDesigner, 534 IDisposable, 533 IEnumerable, 487, 490, 530 IHttpAsyncHandler, 55, 70, 176, 185 IHttpHandler, 6, 8, 55, 175 IHttpHandlerFactory, 8 IHttpModule, 72 IListSource, 487, 490, 530 INamingContainer, 394, 419, 452, 480, 485, 526 IPostBackDataHandler, 452 IPostBackEventHandler, 452 IRepeatInfoUser, 510, 531 IServiceProvider, 533 ISite, 532, 533 IStateManager, 495, 498, 499 ITemplate, 399 IWebActionable, 272 IWebEditable, 272 IWebPart, 272 Ккарта сайта, 152, 366 в виде меню, 369 защита, 370, 371 конфигурирование, 387 локализация, 370, 388 отображение, 380 персонализация, 374 программная модификация, 369 составная, 369 класс Assembly, 341 BarChartItem, 519 BaseDataBoundControl, 447, 489, 491, 492 BaseDataList, 447 BaseValidator, 323 BinaryFormatter, 499 Bitmap, 351 BrowserCapabilities, 225 BuildProvider, 36 CatalogPart, 265 CatalogZone, 266 ClientScriptManager, 229 CollectionEditor, 554 CompareValidator, 323 CompositeControl, 447 CompositeControlDesigner, 563 CompositeDataBoundControl, 447, 513, 531 ConfigurationSection, 128 ConnectionsZone, 266 Control, 418, 447, 448, 451, 532, 533 ControlBuilder, 542 ControlDesigner, 534, 555-557, 564 CustomValidator, 323 DataBinder, 501 DataBoundControl, 447, 492, 496, 531 DataBoundControlDesigner, 556 DataBoundDesigner, 563 DataSourceHelper, 530 DataSourceView, 492 DeclarativeCatalogPart, 299 EditorPart, 265 EditorZone, 266 EventArgs, 434 ExpandableObjectConverter, 548, 564 ExpressionBuilder, 208, 211 FastObjectFactory, 17 GenericWebPart, 270 Graphics, 351 HierarchicalDataBoundControl, 447 HtmlTextWriter, 453 HttpApplication, 6, 8, 50, 72 HttpApplicationFactory, 6 HttpCapabilitiesBase, 225, 226 HttpResponse, 338 HttpRuntime, 8, 13 ImportCatalogPart, 300 ListControl, 447, 531 ListItemCollection, 504 MobileCapabilities, 225 MobilePage, 310, 312, 334 Page, 8, 260 PageHandlerFactory, 6, 8, 50 PageParser, 215 PageParserFilter, 215
570 Алфавитный указатель класс (продолжение) Panel, 265 ProviderBase, 139, 174 RangeValidator, 323 RegularExpressionValidator, 324 RepeaterItem, 395 RequiredFieldValidator, 324 SessionStateModule, 50 SiteMap, 372, 373, 379 SiteMapProvider, 368 StaticSiteMapProvider, 368 StringBuilder, 484 TemplateControl, 419, 443 TextControl, 320 TextWriter, 45 TypeConverter, 548, 564 UITypeEditor, 551, 564 UserControl, 418-420 VirtualFile, 47 VirtualPathProvider, 46 WebConfigurationManager, 122 WebControl, 418, 447, 452 WebPart, 268, 269, 270 WebPartConnection, 266 WebPartManager, 265, 267 WebPartZone, 266 window, 236 XmlHttpRequest, 240 XmlSiteMapProvider, 367 базовый провайдера, 141 обработчика страницы, 9 повторное использование, 20 структура, 17 частичный, 10 клиент, 227 код клиентский, 224 коллекция Modules, 76 Zones, 266 создание класса, 38 компиляция приложения пакетная, 27 параметры, 26 конвертер типов, 542, 544 контейнер именования, 419 шаблона, 526 контекст устройства GDI, 351 конфигурация, редактирование, 135 кэширование адаптера мобильного устройства, 314 вывода, 3, 98, 423 страницы, 3, 423 фрагментов, 98 кэширование (продолжение) данных, 347 запроса браузером, 78 изображений, 358 параметры, 98 Мменеджер Web Parts, 262, 270 режим отображения, 290 компиляции, 36 состояния сеанса, 151 метод AddOnPreRenderCompleteAsync, 179, 180 AllowResize, 558 BeginProcessRequest, 177 CanConvertFrom, 544 CanConvertTo, 544 ClearChildViewState, 454 ConvertFrom, 545 ConvertTo, 545 CreateChildControls, 454, 513-517, 557 CreateControlHierarchy, 454, 474, 517 CreatePlaceHolderDesignTimeHtml, 558 DataBind, 491 Dispose, 533 DrawRectangle, 352 DrawString, 353 EditValue, 552 EndProcessRequest, 177 EnsureDataBound, 491 ExecuteScalar, 348 FillRectangle, 352 GetCallbackEventReference, 245 GetCodeExpression, 211 GetDesignTimeHtml, 556-558 GetEditStyle, 552 GetEmptyDesignTimeHtml, 558 GetErrorDesignTimeHtml, 558 GetManifestResourceNames, 341 GetManifestResourceStream, 341 GetProperties, 548 GetPropertiesSupported, 548 GetPropertyValue, 501 GetResolvedDataSource, 530 InstantiateIn, 529 IsClientScriptBlockRegistered, 232, 483 LoadControl, 419, 443 LoadTemplate, 419 LoadViewState, 495, 509 OnBubbleEvent, 482 OnPreRender, 491 ParseControl, 420 PerformDataBinding, 493, 496, 509, 515, 530
Алфавитный указатель 571 метод (продолжение) PerformSelect, 491, 492 ProcessRequest, 6, 55, 175 RaiseBubbleEvent, 482 RegisterAsyncTask, 178, 198, 202 RegisterClientScriptBlock, 230, 483 RegisterStartupScript, 233 Render, 453 RenderItem, 512 SaveViewState, 495, 509 ValidateDataSource, 491, 492 многопоточность, 165 модель "адаптер", 139 "поведение", 139 провайдеров, 136, 174 конфигурационный слой, 140 слой хранения, 140 схема, 137 модуль HTTP, 50 написание, 72, 73 подписка на события, 74 регистрация, 76 Ннавигация по сайту, 108, 116, 366 по файлам конфигурации, 122 Ообработчик HTTP, 50, 63 асинхронный, 69 написание, 55, 56 регистрация, 60 создание, 64, 68 события, 20 обратный вызов сценария, 240, 247 объект Cache, 438 записи HTTP-текста, 453 окно Properties, 551 всплывающее, 236 Ппапка App_Browsers, 30 App_Code, 30 App_Data, 32 App_GlobalResources, 32 App_LocalResources, 33 папка (продолжение) App_Themes, 34 App_WebReferences, 34 Bin, 29 перевод строки, 19 персонализация, 289 карты сайта, 369 построитель выражений, 208 $AppSettings, 209 $ConnectionStrings, 209 $Profile, 213 $Resources, 209 пользовательский, 210 сборки, 36 предкомпиляция приложения, 8, 21 для развертывания, 21, 23 программная, 25 с возможностью последующего обновления, 25 на месте, 21 приложение мобильное, 355 навигация, 328 приватное состояние представления, 334 состояние представления, 333 состояние сеанса, 334 формы, 328 провайдер ActiveDirectoryMembershipProvider, 144 AuthorizationStoreRoleProvider, 146, 147 BufferedWebEventProvider, 154 DpapiProtectedConfigurationProvider, 162 EventLogWebEventProvider, 155 InProcSessionStateStore, 151 MailWebEventProvider, 155 OutOfProcSessionStateStore, 151 ProfileProvider, 149 RoleProvider, 146 RsaProtectedConfigurationProvider, 160 SessionStateStoreProviderBase, 150 SqlMembershipProvider, 142 SqlPersonalizationProvider, 157, 159 SqlRoleProvider, 146 SqlSessionStateStore, 151 TemplatedMailWebEventProvider, 156 TraceWebEventProvider, 157 WebEventProvider, 154 WindowsTokenRoleProvider, 146, 147 XmlSiteMapProvider, 153 виртуального пути, 46 встроенный, 141 защиты конфигурации (шифрования), 159 карты сайта, 152, 367
572 Алфавитный указатель провайдер (продолжение) компиляции, 26, 34, 35 ForceCopyBuildProvider, 37 IgnoreFileBuildProvider, 37 пользовательский, 37, 40 персонализации, 289 Web Parts, 158, 159 пользовательский, 164 инициализация, 164 профилей, пользовательский, 170, 172 ролей, 146 событий Web, 154 состояния сеанса, 150 членства, 142 шифрования, 126 процесс dllhost.exe, 51 inetinfo.exe, 51 рабочий, w3wp.exe, 5 пул приложений, 5 путь по карте сайта, 375 Рразбивка на страницы DataList, 414 мобильной формы, 313 табличных элементов управления, 393 раздел <anonymousIdentification>, 95 <appSettings>, 88, 120 <assemblies>, 27 <authentication>, 95 <authorization>, 97 <browserCaps>, 97 <buildProviders>, 44 <caching>, 98 <Choice>, 332 <clientTarget>, 100 <codeSubDirectories>, 31 <compilation>, 26, 28 <configProtectedData>, 88, 121 <configSections>, 88 <configuration>, 84 структура, 87 <connectionStrings>, 88, 121 <customErrors>, 100 <deployment>, 101 <deviceFilters>, 332 <DeviceSpecific>, 332 <EncryptedData>, 126 <filedeps>, 12 <globalization>, 101 <healthMonitoring>, 102, 156 <hostingEnvironment>, 103 <httpCookies>, 103 раздел (продолжение) <httpHandlers>, 57, 63 <httpModules>, 76 <httpRuntime>, 104, 176 <identity>, 105 <location>, 89, 92 <machineKey>, 106 <mailSettings>, 156 <mappings>, 44 <membership>, 106 <pages>, 107 <processModel>, 109 <profile>, 111 <protectedData>, 125 <roleManager>, 112 <section>, 88 <sectionGroup>, 88 <securityPolicy>, 113 <sessionPageState>, 113 <sessionState>, 114 <siteMap>, 116, 367 <siteMapNode>, 367-369 атрибуты, 368 <system.diagnostics>, 88 <system.runtime.remoting>, 88 <system.web>, 88, 92, 134 <trace>, 116 <trust>, 117 <urlMappings>, 118 <webControls>, 118 <webServices>, 119 <xhtmlConformance>, 120 <ZoneTemplate>, 295, 297 пользовательский, 127 редактор типа, 551 рендеринг адаптивный, 332 Ссайт, 532 сборка связывание с приложением, 27 страницы, 12 генерирование, 10 свойство AppendDataBoundItems, 504 AuthorizationFilter, 273 ClientID, 485 ClientTarget, 227 DataItem, 498, 499 DataMember, 493 DataSource, 437, 489-492, 531 DataSourceID, 489, 490, 531 Filter, 542 ID, 485 Items, 504, 516, 519
Алфавитный указатель 573 свойство (продолжение) Paginate, 313 RequiresDataBinding, 491 Site, 532 UniqueID, 485 -шаблон определение, 527 установка, 525 событие, 433 AuthorizeWebPart, 269, 273 BeginRequest, 74 DataBinding, 208 EndRequest, 74 ItemCommand, 317 PreRender, 260 PreRenderComplete, 81, 178, 180 ViewStateExpire, 334 страница асинхронная, 175 жизненный цикл, 186 параллельные задачи, 193 применение, 188 создание, 180, 184 добавление литеральной строки, 220 мобильная, 311 жизненный цикл, 314 некомпилируемая, 28 построитель выражений, 213 обновление, 77 отслеживание изменений, 12 скрытый код, 13 сценарий submit-элемента, 233 загрузка из ресурса, 235 серверный внешний, 234 Ттрассировка приложения, 116 тэг<body>, 19, 421 <form>, 19, 20, 230, 421 <head>, 19, 20 <html>, 421 <img>, 336, 365 <script>, 228 <SelectedItemTemplate>, 412 <ZoneTemplate>, 270 Уудаленный вызов процедур, 258 установка глобальная, 90 немодифицируемая, 92 утилита aspnet_compiler, 22, 24 aspnet_regiis.exe, 127 resgen.exe, 32 WSAT (Web Site Administration Tool), 130 xsd.exe, 32 Ффабрика, 139 обработчиков HTTP, 6, 50, 68 обработчиков страниц, 6 файл .ashx, 8 .asmx, 2, 8, 35 global.asax, 13 machine.config, 85, 134 web.config, 85 web.sitemap, 367, 369 веб сервиса, 2 конфигурационный, 84 обработчика HTTP, 2 страницы, 2 файлы, создаваемые при обработке запроса, 15 фильтр ISAPI, 53 альфа, 543 анализатора страниц, 215 доступа (авторизации), 97 Web Parts, 269, 273 карты сайта, 368 свечения, 543 устройства, 332 Шшаблон элемента управления 393, 397 Repeater, 397 загрузка, 399 программное создание, 400 рендеринг, 529 элемента управления DataList, 412 поддержка в элементе управления, 524 шифрование RSA, 126 алгоритма RSA, 162 конфигурационного раздела, 125 Ээлемент управления, 533 BulletedList, 489, 504 CheckBoxList, 488, 503 Command, 321
574 Алфавитный указатель элемент управления (продолжение) DataGrid, 318, 489 DataList, 405-415 DataTable, 490 DetailsView, 489 DropDownList, 503 FileUpload, 346 Form, мобильный, 316 FormView, 394, 489 GridView, 489 HtmlInputFile, 346 List, 317 ListBox, 504 ListControl, 503, 504 Menu, 384- 387 ObjectList, 318 Panel, 316 PhoneCall, 322, 333 RadioButtonList, 488, 504 Repeater, 394-404, 437-439 интерфейс программирования, 394 SelectionList, 319 SiteMapDataSource, 377-379, 383, 384 SiteMapPath, 375 TextBox, 321 TreeView, 380-384 ValidationSummary, 324 дизайнер, 534 итеративный, 392 конвертер типов, 534 мобильный, 307 архитектура, 307 классы, 309 элемент управления (продолжение) отображающий отдельную запись, 394 поддержка шаблонов, 524 пользовательский 418, 419, 424 динамическая загрузка, 443 обработка событий, 433 объектная модель, 428 производный, 424 размещение на странице, 426 разработка, 424 регистрация, 427, 428 связанный с данными, 436 создание из страницы, 421 представление, 393 представляющий источник данных, 378, 488 редактор, 534 связанный с данными, 392, 488 двунаправленный, 489 работа с источником данных, 530 сложный, 489 составной, 513 списочный, 488 составной, 447 специализированный, 418, 424, 446 расширение существующего, 447 рендеринг, 459, 473 с богатыми возможностями, 468 создание с нуля, 451 списочный, 392 табличный, 393 эмулятор мобильного устройства, 327
