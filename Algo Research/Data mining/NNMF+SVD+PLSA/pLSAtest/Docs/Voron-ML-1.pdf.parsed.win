
Математические методы обучения по прецедентам (теория обучения машин) К. В. Воронцов http://www.ccas.ru/voron voron@ccas.ru Материал находится в стадии разработки, может содержать ошибки и неточности. Автор будет благодарен за любые замечания и предложения, направленные по адресу vokov@forecsys.ru, либо высказанные в обсуждении страницы ?Машинное обучение (курс лекций, К.В.Воронцов)? вики-ресурса www.MachineLearning.ru. Перепечатка фрагментов данного материала без согласия автора является плагиатом. Содержание 1 Введение: задачи обучения по прецедентам 4 :1.1 Основные понятия и определения . . . . . . . . . . . . . . . . . . . . . . 4 1.1.1 Объекты и признаки . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.1.2 Ответы и типы задач . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.1.3 Модель алгоритмов и метод обучения . . . . . . . . . . . . . . . . 5 1.1.4 Функционал качества . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.1.5 Вероятностная постановка задачи обучения . . . . . . . . . . . . 7 1.1.6 Проблема переобучения и понятие обобщающей способности . . 8 :1.2 Примеры прикладных задач . . . . . . . . . . . . . . . . . . . . . . . . . 9 1.2.1 Задачи классификации . . . . . . . . . . . . . . . . . . . . . . . . 9 1.2.2 Задачи восстановления регрессии . . . . . . . . . . . . . . . . . . 11 1.2.3 Задачи ранжирования . . . . . . . . . . . . . . . . . . . . . . . . . 12 1.2.4 Задачи кластеризации . . . . . . . . . . . . . . . . . . . . . . . . . 13 1.2.5 Задачи поиска ассоциаций . . . . . . . . . . . . . . . . . . . . . . 14 1.2.6 Методология тестирования обучаемых алгоритмов . . . . . . . . 14 1.2.7 Приёмы генерации модельных данных . . . . . . . . . . . . . . . 16 2 Байесовские методы классификации 18 :2.1 Вероятностная постановка задачи классификации . . . . . . . . . . . . 18 2.1.1 Функционал среднего риска . . . . . . . . . . . . . . . . . . . . . 18 2.1.2 Оптимальное байесовское решающее правило . . . . . . . . . . . 19 2.1.3 Задача восстановления плотности распределения . . . . . . . . . 21 :2.2 Непараметрическая классификация . . . . . . . . . . . . . . . . . . . . . 22 2.2.1 Непараметрические оценки плотности . . . . . . . . . . . . . . . 22 2.2.2 Метод парзеновского окна . . . . . . . . . . . . . . . . . . . . . . 23 :2.3 Нормальный дискриминантный анализ . . . . . . . . . . . . . . . . . . . 25 2.3.1 Многомерное нормальное распределение . . . . . . . . . . . . . . 25 2.3.2 Квадратичный дискриминант . . . . . . . . . . . . . . . . . . . . 26 2.3.3 Линейный дискриминант Фишера . . . . . . . . . . . . . . . . . . 29 :2.4 Разделение смеси распределений . . . . . . . . . . . . . . . . . . . . . . . 32 2.4.1 EM-алгоритм . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 2.4.2 Смеси многомерных нормальных распределений . . . . . . . . . 37
2 К.В.Воронцов. Вычислительные методы обучения по прецедентам 2.4.3 Сеть радиальных базисных функций . . . . . . . . . . . . . . . . 39 3 Метрические методы классификации 42 :3.1 Метод ближайшего соседа и его обобщения . . . . . . . . . . . . . . . . 42 3.1.1 Обобщённый метрический классификатор . . . . . . . . . . . . . 42 3.1.2 Метод ближайших соседей . . . . . . . . . . . . . . . . . . . . . . 43 3.1.3 Метод парзеновского окна . . . . . . . . . . . . . . . . . . . . . . 45 3.1.4 Метод потенциальных функций . . . . . . . . . . . . . . . . . . . 45 :3.2 Отбор эталонных объектов . . . . . . . . . . . . . . . . . . . . . . . . . . 47 3.2.1 Понятие отступа объекта . . . . . . . . . . . . . . . . . . . . . . . 47 3.2.2 Алгоритм STOLP для отбора эталонных объектов . . . . . . . . 48 4 Линейные методы классификации 51 :4.1 Аппроксимация и регуляризация эмпирического риска . . . . . . . . . . 51 :4.2 Линейная модель классификации . . . . . . . . . . . . . . . . . . . . . . 54 :4.3 Метод стохастического градиента . . . . . . . . . . . . . . . . . . . . . . 57 4.3.1 Классические частные случаи . . . . . . . . . . . . . . . . . . . . 59 4.3.2 Эвристики для улучшения градиентных методов обучения . . . 60 :4.4 Логистическая регрессия . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 4.4.1 Обоснование логистической регрессии . . . . . . . . . . . . . . . 62 4.4.2 Метод стохастического градиента для логистической регрессии . 64 4.4.3 Скоринг и оценивание апостериорных вероятностей . . . . . . . 66 :4.5 Метод опорных векторов . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 4.5.1 Линейно разделимая выборка . . . . . . . . . . . . . . . . . . . . 68 4.5.2 Линейно неразделимая выборка . . . . . . . . . . . . . . . . . . . 69 4.5.3 Ядра и спрямляющие пространства . . . . . . . . . . . . . . . . . 73 :4.6 ROC-кривая и оптимизация порога решающего правила . . . . . . . . . 78 5 Методы восстановления регрессии 80 :5.1 Метод наименьших квадратов . . . . . . . . . . . . . . . . . . . . . . . . 80 :5.2 Непараметрическая регрессия: ядерное сглаживание . . . . . . . . . . . 80 5.2.1 Формула Надарая-Ватсона . . . . . . . . . . . . . . . . . . . . . . 80 5.2.2 Выбор ядра и ширины окна . . . . . . . . . . . . . . . . . . . . . 81 5.2.3 Проблема выбросов: робастная непараметрическая регрессия . . 82 5.2.4 Проблема краевых эффектов . . . . . . . . . . . . . . . . . . . . . 83 :5.3 Линейная регрессия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 5.3.1 Сингулярное разложение . . . . . . . . . . . . . . . . . . . . . . . 85 5.3.2 Проблема мультиколлинеарности . . . . . . . . . . . . . . . . . . 86 5.3.3 Гребневая регрессия . . . . . . . . . . . . . . . . . . . . . . . . . . 86 5.3.4 Лассо Тибширани . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 5.3.5 Линейная монотонная регрессия . . . . . . . . . . . . . . . . . . . 89 :5.4 Метод главных компонент . . . . . . . . . . . . . . . . . . . . . . . . . . 89 :5.5 Нелинейные методы восстановления регрессии . . . . . . . . . . . . . . 93 5.5.1 Нелинейная модель регрессии . . . . . . . . . . . . . . . . . . . . 93 5.5.2 Нелинейные одномерные преобразования признаков . . . . . . . 94 5.5.3 Обобщённые линейные модели . . . . . . . . . . . . . . . . . . . . 96 5.5.4 Неквадратичные функции потерь . . . . . . . . . . . . . . . . . . 96
3 5.5.5 Логистическая регрессия и итерационный взвешенный МНК . . 98 :5.6 Метод опорных векторов в задачах регрессии . . . . . . . . . . . . . . . 99 6 Искусственные нейронные сети 102 :6.1 Проблема полноты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 6.1.1 Задача ?исключающего ИЛИ? . . . . . . . . . . . . . . . . . . . . 102 6.1.2 Вычислительные возможности нейронных сетей. . . . . . . . . . 104 :6.2 Многослойные нейронные сети . . . . . . . . . . . . . . . . . . . . . . . . 105 6.2.1 Метод обратного распространения ошибок . . . . . . . . . . . . . 105 6.2.2 Эвристики для улучшения сходимости . . . . . . . . . . . . . . . 108 6.2.3 Оптимизация структуры сети . . . . . . . . . . . . . . . . . . . . 110 7 Кластеризация и визуализация 113 :7.1 Алгоритмы кластеризации . . . . . . . . . . . . . . . . . . . . . . . . . . 113 7.1.1 Эвристические графовые алгоритмы . . . . . . . . . . . . . . . . 115 7.1.2 Функционалы качества кластеризации . . . . . . . . . . . . . . . 117 7.1.3 Статистические алгоритмы . . . . . . . . . . . . . . . . . . . . . . 119 7.1.4 Иерархическая кластеризация . . . . . . . . . . . . . . . . . . . . 122 :7.2 Сети Кохонена . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126 7.2.1 Модели конкурентного обучения . . . . . . . . . . . . . . . . . . . 126 7.2.2 Самоорганизующиеся карты Кохонена . . . . . . . . . . . . . . . 128 7.2.3 Гибридные сети встречного распространения . . . . . . . . . . . 131 :7.3 Многомерное шкалирование . . . . . . . . . . . . . . . . . . . . . . . . . 133
4 К.В.Воронцов. Вычислительные методы обучения по прецедентам 1 Введение: задачи обучения по прецедентам В этой вводной лекции даются базовые понятия и обозначения, которые будут использоваться на протяжении всего курса. Приводятся общие постановки задач обу- чения по прецедентам и некоторые примеры прикладных задач. :1.1 Основные понятия и определения Задано множество объектов X, множество допустимых ответов Y , и суще- ствует целевая функция (target function) y? : X > Y , значения которой yi = y?(xi) из- вестны только на конечном подмножестве объектов {x1, . . . , x?} ? X. Пары ?объект- ответ? (xi, yi) называются прецедентами. Совокупность пар X? = (xi, yi)?i=1 называ- ется обучающей выборкой (training sample). Задача обучения по прецедентам заключается в том, чтобы по выборке X? восстановить зависимость y?, то есть построить решающую функцию (decision function) a: X > Y , которая приближала бы целевую функцию y?(x), причём не только на объектах обучающей выборки, но и на всём множестве X. Решающая функция a должна допускать эффективную компьютерную реали- зацию; по этой причине будем называть её алгоритмом. 1.1.1 Объекты и признаки Признак (feature) f объекта xэто результат измерения некоторой характери- стики объекта. Формально признаком называется отображение f : X > Df , где Df множество допустимых значений признака. В частности, любой алгоритм a: X > Y также можно рассматривать как признак. В зависимости от природы множества Df признаки делятся на несколько типов. Если Df = {0, 1}, то f бинарный признак; Если Df конечное множество, то f номинальный признак; Если Df конечное упорядоченное множество, то f порядковый признак; Если Df = R, то f количественный признак. Если все признаки имеют одинаковый тип, Df1 = - - - = Dfn, то исходные данные называются однородными, в противном случае разнородными. Пусть имеется набор признаков f1, . . . , fn. Вектор ??f1(x), . . . , fn(x)называют признаковым описанием объекта x ? X. В дальнейшем мы не будем различать объ- екты из X и их признаковые описания, полагая X = Df1 ? . . . ? Dfn. Совокупность признаковых описаний всех объектов выборки X?, записанную в виде таблицы раз- мера ? ? n, называют матрицей объектов-признаков: F = kfj(xi)k??n = ??f1(x1) . . . fn(x1) . . . . . . . . . f1(x?) . . . fn(x?)??. (1.1) Матрица объектов-признаков является стандартным и наиболее распростра- нённым способом представления исходных данных в прикладных задачах.
5 1.1.2 Ответы и типы задач В зависимости от природы множества допустимых ответов Y задачи обучения по прецедентам делятся на следующие типы. Если Y = {1, . . . ,M}, то это задача классификации (classification) на M непере- секающихся классов. В этом случае всё множество объектов X разбивается на классы Ky = {x ? X: y?(x) = y}, и алгоритм a(x) должен давать ответ на вопрос ?како- му классу принадлежит x??. В некоторых приложениях классы называют образами и говорят о задаче распознавания образов (pattern recognition). Если Y = {0, 1}M, то это задача классификации на M пересекающихся клас- сов. В простейшем случае эта задача сводится к решению M независимых задач классификации с двумя непересекающимися классами. Если Y = R, то это задача восстановления регрессии (regression estimation). Задачи прогнозирования (forecasting) являются частными случаями классифи- кации или восстановления регрессии, когда x ? X описание прошлого поведения объекта x, y ? Y описание некоторых характеристик его будущего поведения. 1.1.3 Модель алгоритмов и метод обучения Опр. 1.1. Моделью алгоритмов называется параметрическое семейство отображе- ний A = {g(x, ?) | ? ? }, где g : X ? > Y некоторая фиксированная функция, множество допустимых значений параметра ?, называемое пространством па- раметров или пространством поиска (search space). Пример 1.1. В задачах с n числовыми признаками fj : X > R, j = 1, . . . , n широко используются линейные модели с вектором параметров ? = (?1, . . . , ?n) ? = Rn: g(x, ?) =Xn j=1 ?jfj(x) для задач восстановления регрессии, Y = R; g(x, ?) = sign Xn j=1 ?jfj(x) для задач классификации, Y = {?1,+1}. Признаками могут быть не только исходные измерения, но и функции от них. В частности, многомерные линейные модели могут использоваться даже в задачах с единственным числовым признаком. Пример 1.2. Один из классических подходов к аппроксимации функций одной пе- ременной по заданным точкам (xi, yi) ? R2, i = 1, . . . , ? заключается в построении полиномиальной модели. Если ввести n признаков fj(x) = xj?1, то функция g(x, ?) из примера 1.1 будет определять полином степени n ? 1 над исходным признаком x. Процесс подбора оптимального параметра модели ? по обучающей выборке X? называют настройкой (fitting) или обучением (training, learning)1 алгоритма a ? A. 1Согласно английской терминологии алгоритм является обучаемым, учеником (learning machine), а выборка данных обучающей, учителем (training sample).
6 К.В.Воронцов. Вычислительные методы обучения по прецедентам Опр. 1.2. Метод обучения (learning algorithm)это отображение ?: (X ? Y )? > A, которое произвольной конечной выборке X? = (xi, yi)?i=1 ставит в соответствие неко- торый алгоритм a ? A. Говорят также, что метод ? строит алгоритм a по выбор- ке X?. Метод обучения должен допускать эффективную программную реализацию. Итак, в задачах обучения по прецедентам чётко различаются два этапа. На этапе обучения метод ? по выборке X? строит алгоритм a = ?(X?). На этапе применения алгоритм a для новых объектов x выдаёт ответы y = a(x). Этап обучения наиболее сложен. Как правило, он сводится к поиску параметров модели, доставляющих оптимальное значение заданному функционалу качества. 1.1.4 Функционал качества Опр. 1.3. Функция потерь (loss function) это неотрицательная функция L(a, x), характеризующая величину ошибки алгоритма a на объекте x. Если L(a, x) = 0, то ответ a(x) называется корректным. Опр. 1.4. Функционал качества алгоритма a на выборке X?: Q(a,X?) = 1?X? i=1 L(a, xi). (1.2) Функционал Q называют также функционалом средних потерь или эмпириче- ским риском [4], так как он вычисляется по эмпирическим данным (xi, yi)?i=1. Функция потерь, принимающая только значения 0 и 1, называется бинарной. В этом случае L(a, x) = 1 означает, что алгоритм a допускает ошибку на объекте x, а функционал Q называется частотой ошибок алгоритма a на выборке X?. Наиболее часто используются следующие функции потерь, при Y ? R: L(a, x) = [a(x) 6= y?(x)] индикатор ошибки, обычно применяется в задачах классификации2; L(a, x) = |a(x) ? y?(x)| отклонение от правильного ответа; функционал Q называется средней ошибкой алгоритма a на выборке X?; L(a, x) = (a(x) ? y?(x))2 квадратичная функция потерь; функционал Q на- зывается средней квадратичной ошибкой алгоритма a на выборке X?; обычно при- меняется в задачах регрессии. Классический метод обучения, называемый минимизацией эмпирического рис- ка (empirical risk minimization, ERM), заключается в том, чтобы найти в заданной мо- дели A алгоритм a, доставляющий минимальное значение функционалу качества Q на заданной обучающей выборке X?: ?(X?) = argmin a?A Q(a,X?). (1.3) Пример 1.3. В задаче восстановления регрессии (Y = R) с n числовыми призна- ками fj : X > R, j = 1, . . . , n, и квадратичной функцией потерь метод минимизации эмпирического риска есть ничто иное, как метод наименьших квадратов: ?(X?) = argmin ? X? i=1 ??g(xi, ?) ? yi2. 2Квадратные скобки переводят логическое значение в число по правилу [ложь] = 0, [истина] = 1.
7 1.1.5 Вероятностная постановка задачи обучения В задачах обучения по прецедентам элементы множества X это не реаль- ные объекты, а лишь доступные данные о них. Данные могут быть неточными, поскольку измерения значений признаков fj(x) и целевой зависимости y?(x) обычно выполняются с погрешностями. Данные могут быть неполными, поскольку изме- ряются не все мыслимые признаки, а лишь физически доступные для измерения. В результате одному и тому же описанию x могут соответствовать различные объек- ты и различные ответы. В таком случае y?(x), строго говоря, не является функцией. Устранить эту некорректность позволяет вероятностная постановка задачи. Вместо существования неизвестной целевой зависимости y?(x) предположим существование неизвестного вероятностного распределения на множестве X ? Y с плотностью p(x, y), из которого случайно и независимо выбираются ? наблюдений X? = (xi, yi)?i=1. Такие выборки называются простыми или случайными одинаково распределёнными (independent identically distributed, i.i.d.). Вероятностная постановка задачи считается более общей, так как функцио- нальную зависимость y?(x) можно представить в виде вероятностного распределения p(x, y) = p(x)p(y|x), положив p(y|x) = ?(y ? y?(x)), где ?(z) дельта-функция. Принцип максимума правдоподобия. При вероятностной постановке задачи вме- сто модели алгоритмов g(x, ?), аппроксимирующей неизвестную зависимость y?(x), задаётся модель совместной плотности распределения объектов и ответов ?(x, y, ?), аппроксимирующая неизвестную плотность p(x, y). Затем определяется значение па- раметра ?, при котором выборка данных X? максимально правдоподобна, то есть наилучшим образом согласуется с моделью плотности. Если наблюдения в выборке X? независимы, то совместная плотность распре- деления всех наблюдений равна произведению плотностей p(x, y) в каждом наблюде- нии: p(X?) = p??(x1, y1), . . . , (x?, y?)= p(x1, y1) - - - p(x?, y?). Подставляя вместо p(x, y) модель плотности ?(x, y, ?), получаем функцию правдоподобия (likelihood): L(?,X?) =Y? i=1 ?(xi, yi, ?). Чем выше значение правдоподобия, тем лучше выборка согласуется с моде- лью. Значит, нужно искать значение параметра ?, при котором значение L(?,X?) максимально. В математической статистике это называется принципом максимума правдоподобия. Его формальные обоснования можно найти, например, в [13]. После того, как значение параметра ? найдено, искомый алгоритм a?(x) стро- ится по плотности ?(x, y, ?) несложно. Связь максимизации правдоподобия с минимизацией эмпирического риска. Вместо максимизации L удобнее минимизировать функционал ?ln L, поскольку он аддитивен (имеет вид суммы) по объектам выборки: ?ln L(?,X?) = ? X? i=1 ln ?(xi, yi, ?) > min ? . (1.4)
8 К.В.Воронцов. Вычислительные методы обучения по прецедентам Этот функционал совпадает с функционалом эмпирического риска (1.2), если определить вероятностную функцию потерь L(a?, x) = ?? ln ?(x, y, ?). Такое опре- деление потери вполне естественночем хуже пара (xi, yi) согласуется с моделью ?, тем меньше значение плотности ?(xi, yi, ?) и выше величина потери L(a?, x). Верно и обратное для многих функций потерь возможно подобрать модель плотности ?(x, y, ?) таким образом, чтобы минимизация эмпирического риска была эквивалентна максимизации правдоподобия. Пример 1.4. Пусть задана модель g(x, ?). Примем дополнительное вероятностное предположение, что ошибки ?(x, ?) = g(x, ?) ? y?(x) имеют нормальное распределе- ние N(?; 0, ?2) = 1 ?v2? exp??? ?2 2?2 с нулевым средним и дисперсией ?2. Тогда модель плотности имеет вид ?(x, y, ?) = p(x)?(y | x, ?) = p(x)N??g(x, ?) ? y?(x); 0, ?2. Отсюда следует, что вероятностная функция потерь совпадает с квадратичной с точ- ностью до констант C0 и C1, не зависящих от параметра ?: ?ln ?(x, y, ?) = ?ln p(x)N??g(x, ?) ? y?(x); 0, ?2= C0 + C1??g(x, ?) ? y?(x)2. Таким образом, существуют два родственных подхода к формализации задачи обучения: первый основан на введении функции потерь, второй на введении веро- ятностной модели порождения данных. Оба в итоге приводят к схожим (иногда даже в точности одинаковым) оптимизационным задачам. Обучение это оптимизация. 1.1.6 Проблема переобучения и понятие обобщающей способности Минимизацию эмпирического риска следует применять с известной долей осто- рожности. Если минимум функционала Q(a,X?) достигается на алгоритме a, то это ещё не гарантирует, что a будет хорошо приближать целевую зависимость на произ- вольной контрольной выборке Xk = (x'i, y'i)ki=1. Когда качество работы алгоритма на новых объектах, не вошедших в состав обучения, оказывается существенно хуже, чем на обучающей выборке, говорят об эф- фекте переобучения (overtraining) или переподгонки (overfitting). При решении прак- тических задач с этим явлением приходится сталкиваться очень часто. Легко представить себе метод, который минимизирует эмпирический риск до нуля, но при этом абсолютно не способен обучаться. Получив обучающую вы- борку X?, он запоминает её и строит алгоритм, который сравнивает предъявляемый объект x с обучающими объектами xi из X?. В случае совпадения x = xi алгоритм выдаёт правильный ответ yi. Иначе выдаётся произвольный ответ. Эмпирический риск принимает наименьшее возможное значение, равное нулю. Однако этот алго- ритм не способен восстановить зависимость вне материала обучения. Отсюда вывод: для успешного обучения необходимо не только запоминать, но и обобщать. Обобщающая способность (generalization ability) метода ? характеризуется ве- личиной Q(?(X?),Xk) при условии, что выборки X? и Xk являются представительны- ми. Для формализации понятия ?представительная выборка? обычно принимается стандартное предположение, что выборки X? и Xk простые, полученные из одного и того же неизвестного вероятностного распределения на множестве X.
9 Опр. 1.5. Метод обучения ? называется состоятельным, если при заданных до- статочно малых значениях ? и ? справедливо неравенство PX?,XkQ(?(X?),Xk) > ?< ?. (1.5) Параметр ? называется точностью, параметр (1 ? ?) надёжностью. Допустима также эквивалентная формулировка: для любых простых выборок X? и Xk оценка Q(?(X?),Xk) 6 ? справедлива с вероятностью не менее 1 ? ?. Получение оценок вида (1.5) является фундаментальной проблемой стати- стической теории обучения. Первые оценки были получены в конце 60-х годов В.Н.Вапником и А.Я.Червоненкисом [5, 6, 7]. В настоящее время статистическая теория развивается очень активно [34], однако для многих практически интересных случаев оценки обобщающей способности либо неизвестны, либо сильно завышены. Эмпирические оценки обобщающей способности применяются в тех случаях, когда не удаётся воспользоваться теоретическими. Пусть дана выборка XL = (xi, yi)Li=1. Разобьём её N различными способами на две непересекающиеся подвыборки обучающую X?nдлины ? и контрольную Xkn длины k = L??. Для каждого разбиения n = 1, . . . ,N построим алгоритм an = ?(X?n) и вычислим значение Qn = Q(an,Xkn). Среднее арифметическое значений Qn по всем разбиениям называется оценкой скользящего контроля (cross-validation, CV): CV(?,XL) = 1 N XN n=1 Q(?(X?n),Xkn). (1.6) Возможны различные варианты скользящего контроля, отличающиеся способа- ми разбиения выборки XL [48]. В простейшем варианте разбиения генерируются слу- чайным образом, число N берётся в диапазоне от 20 до 100. Стандартом ?де факто? считается методика t?q-кратного скользящего контроля (t?q-fold cross-validation), когда выборка случайным образом разбивается на q блоков равной (или почти рав- ной) длины, каждый блок по очереди становится контрольной выборкой, а объедине- ние всех остальных блоковобучающей. Выборка XL по-разному t раз разбивается на q блоков. Итого получается N = tq разбиений. Данная методика даёт более точные оценки за счёт того, что все объекты ровно по t раз встречаются в контроле. Недостатками скользящего контроля являются: вычислительная неэффектив- ность, высокая дисперсия, неполное использование имеющихся данных для обучения из-за сокращения длины обучающей выборки с L до ?. :1.2 Примеры прикладных задач Прикладные задачи классификации, регрессии и прогнозирования встречаются в самых разных областях человеческой деятельности, и их число постоянно растёт. 1.2.1 Задачи классификации Пример 1.5. В задачах медицинской диагностики в роли объектов выступают па- циенты. Признаки характеризуют результаты обследований, симптомы заболевания
10 К.В.Воронцов. Вычислительные методы обучения по прецедентам и применявшиеся методы лечения. Примеры бинарных признаков пол, наличие го- ловной боли, слабости, тошноты, и т. д. Порядковый признак тяжесть состояния (удовлетворительное, средней тяжести, тяжёлое, крайне тяжёлое). Количественные признаки возраст, пульс, артериальное давление, содержание гемоглобина в кро- ви, доза препарата, и т. д. Признаковое описание пациента является, по сути дела, формализованной историей болезни. Накопив достаточное количество прецедентов, можно решать различные задачи: классифицировать вид заболевания (дифференци- альная диагностика); определять наиболее целесообразный способ лечения; пред- сказывать длительность и исход заболевания; оценивать риск осложнений; находить синдромы наиболее характерные для данного заболевания совокупности симпто- мов. Ценность такого рода систем в том, что они способны мгновенно анализировать и обобщать огромное количество прецедентов возможность, недоступная человеку. Пример 1.6. Задача оценивания заёмщиков решается банками при выдаче креди- тов. Потребность в автоматизации процедуры выдачи кредитов впервые возникла в период бума кредитных карт 60-70-х годов в США и других развитых странах. Объектами в данном случае являются заёмщики физические или юридические лица, претендующие на получение кредита. В случае физических лиц признаковое описание состоит из анкеты, которую заполняет сам заёмщик, и, возможно, допол- нительной информации, которую банк собирает о нём из собственных источников. Примеры бинарных признаков: пол, наличие телефона. Номинальные признаки место проживания, профессия, работодатель. Порядковые признаки образование, занимаемая должность. Количественные признаки возраст, стаж работы, доход се- мьи, размер задолженностей в других банках, сумма кредита. Обучающая выборка составляется из заёмщиков с известной кредитной историей. В простейшем случае принятие решений сводится к классификации заёмщиков на два класса: ?хороших? и ?плохих?. Кредиты выдаются только заёмщикам первого класса. В более сложном случае оценивается суммарное число баллов (score) заёмщика, набранных по сово- купности информативных признаков. Чем выше оценка, тем более надёжным счита- ется заёмщик. Отсюда и название кредитный скоринг (credit scoring). На стадии обучения производится синтез и отбор информативных признаков и определяется, сколько баллов назначать за каждый признак, чтобы риск принимаемых решений был минимален. Следующая задача решить, на каких условиях выдавать кредит: определить процентную ставку, срок погашения, и прочие параметры кредитного договора. Эта задача также сводится к обучению по прецедентам. Пример 1.7. Задача предсказания ухода клиентов (churn prediction) возникает у крупных и средних компаний, работающих с большим количеством клиентов, как правило, с физическими лицами. Особенно актуальна эта задача для современных телекоммуникационных компаний. Когда рынок приходит в состояние, близкое к на- сыщению, основные усилия компаний направляются не на привлечение новых клиен- тов, а на удержание старых. Для этого необходимо как можно точнее выделить сег- мент клиентов, склонных к уходу в ближайшее время. Классификация производится на основе информации, хранящейся у компании: клиентских анкет, данных о часто- те пользования услугами компании, составе услуг, тарифных планах, регулярности платежей, и т. д. Наиболее информативны данные о том, что именно изменилось в поведении клиента за последнее время. Поэтому объектами, строго говоря, явля-
11 ются не сами клиенты, а пары ?клиент xi в момент времени ti?. Требуется предска- зать, уйдёт ли клиент к моменту времени ti +t. Обучающая выборка формируется из клиентов, о которых доподлинно известно, в какой момент они ушли. 1.2.2 Задачи восстановления регрессии Пример 1.8. Термин ?регрессия? был введён в 1886 году антропологом Фрэнсисом Гальтоном при изучении статистических закономерностей наследственности роста. Повседневный опыт подсказывает, что в среднем рост взрослых детей тем больше, чем выше их родители. Однако Гальтон обнаружил, что сыновья очень высоких отцов часто имеют не столь высокий рост. Он собрал выборку данных по 928 па- рам отец-сын. Количественно зависимость неплохо описывалась линейной функцией y = 23x, где x отклонение роста отца от среднего, y отклонение роста сына от среднего. Гальтон назвал это явление ?регрессией к посредственности?, то есть к среднему значению в популяции. Термин регрессия движение назаднамекал также на нестандартный для того времени ход исследования: сначала были собраны данные, затем по ним угадана модель зависимости, тогда как традиционно посту- пали наоборот: данные использовались лишь для проверки теоретических моделей. Это был один из первых случаев моделирования, основанного исключительно на дан- ных. Позже термин, возникший в частной прикладной задаче, закрепился за широ- ким классом методов восстановления зависимостей. Огромное количество регрессионных задач возникает в физических экспери- ментах, в промышленном производстве, в экономике. Пример 1.9. Задача прогнозирования потребительского спроса решается совре- менными супермаркетами и торговыми розничными сетями. Для эффективного управления торговой сетью необходимо прогнозировать объёмы продаж для каждо- го товара на заданное число дней вперёд. На основе этих прогнозов осуществляется планирование закупок, управление ассортиментом, формирование ценовой полити- ки, планирование промоакций (рекламных кампаний). Специфика задачи в том, что количество товаров может исчисляться десятками или даже сотнями тысяч. Прогно- зирование и принятие решений по каждому товару ?вручную? просто немыслимо. Исходными данными для прогнозирования являются временн?ые ряды цен и объёмов продаж по товарам и по отдельным магазинам. Современные технологии позволяют получать эти данные от кассовых аппаратов и накапливать в едином хранилище дан- ных. Для увеличения точности прогнозов необходимо учитывать различные внеш- ние факторы, влияющие на спрос: рекламные кампании, социально-демографические условия, активность конкурентов, праздники, и даже погодные условия. В зависимо- сти от целей анализа в роли объектов выступают либо товары, либо магазины, либо пары ?магазин-товар?. Ещё одна особенность задачи несимметричность функции потерь. Если прогноз делается с целью планирования закупок, то потери от зани- женного прогноза, как правило, существенно выше, чем от завышенного. Пример 1.10. Задача предсказания рейтингов решается интернет-магазинами, особенно книжными, видео и аудио. Приобретая товар, клиент имеет возможность выставить ему рейтинг, например, целое число от 1 до 5. Система использует ин- формацию о всех выставленных рейтингах для персонализации предложений. Когда
12 К.В.Воронцов. Вычислительные методы обучения по прецедентам клиент видит на сайте страницу с описанием товара, ему показывается также ранжи- рованный список схожих товаров, пользующихся популярностью у схожих клиентов. Основная задача прогнозировать рейтинги товаров, которые данный клиент ещё не приобрёл. Роль матрицы объектов-признаков играет матрица клиентов-товаров, заполненная значениями рейтингов. Как правило, она сильно разрежена и может иметь более 99% пустых ячеек. Фиксированного целевого признака в этой задаче нет. Алгоритм должен предсказывать рейтинги для любых незаполненных ячеек матрицы. Данный тип задач выделяют особо и называют задачами коллаборативной фильтрации (collaborative filtering). О трудности и актуальности этой задачи говорит следующий факт. В октябре 2006 года крупнейшая американская компания Netflix, занимающаяся видеопрокатом через Internet, объявила международный конкурс с призом в 1 миллион долларов то- му, кто сможет на 10% улучшить точность прогнозирования рейтингов, по сравнению с системой Netflix Cinematch (см. http://www.netflixprize.com). Примечательно, что прогнозы самой Cinematch были лишь на те же 10% точнее элементарных прогно- зов по средним рейтингам фильмов. Компания крайне заинтересована в увеличении точности прогнозов, поскольку около 70% заказов поступают через рекомендующую систему. Конкурс успешно завершился только через два с половиной года. 1.2.3 Задачи ранжирования Задачи ранжирования (ranking) возникают в области информационного поиска. Результатом поиска по запросу может оказаться настолько длинный список ответов, что пользователь физически не сможет его просмотреть. Поэтому ответы упорядо- чивают по убыванию релевантности степени их соответствия запросу. Критерий упорядочения в явном виде неизвестен, хотя человек легко отличает более релевант- ные ответы от менее релевантных или совсем нерелевантных. Обычно для размет- ки выборки пар ?запрос, ответ? привлекают команду экспертов (асессоров), чтобы учесть мнения различных людей, которые зачастую противоречат друг другу. Затем решают задачу обучения ранжированию (learning to rank). Пример 1.11. Задача ранжирования текстовых документов, найденных в Ин- тернете по запросу пользователя, решается всеми современными поисковыми маши- нами. Объектами являются пары ?запрос, документ?, ответами оценки релевант- ности, сделанные асессорами. В зависимости от методологии формирования обуча- ющей выборки оценки асессоров могут быть бинарными (релевантен, не релевантен) или порядковыми (релевантность в баллах). Признаками являются числовые харак- теристики, вычисляемые по паре ?запрос, документ?. Текстовые признаки основаны на подсчёте числа вхождений слов запроса в документы. Возможны многочисленные варианты: с учётом синонимов или без, с учётом числа вхождений или без, во всём до- кументе или только в заголовках, и т. д. Ссылочные признаки основаны на подсчёте числа документов, ссылающихся на данный. Кликовые признаки основаны на под- счёте числа обращений к данному документу. Пример 1.12. Задачу предсказания рейтингов из примера 1.10 на практике луч- ше ставить как задачу ранжирования. Пользователю выдаётся список рекомендаций, поэтому важно обеспечить высокую релевантность относительно небольшого числа
13 товаров, попадающих в вершину списка. Среднеквадратичная ошибка предсказа- ния рейтингов, которую предлагалось минимизировать в условии конкурса Netflix, в данном случае не является адекватной мерой качества. Заметим, что в этой задаче в роли асессоров выступают все пользователи рекомендательного сервиса. Покупая товар или выставляя оценку, пользователь пополняет обучающую выборку и тем самым способствует улучшению качества сервиса. 1.2.4 Задачи кластеризации Задачи кластеризации (clustering) отличаются от классификации (classification) тем, что в них не задаются ответы yi = y?(xi). Известны только сами объекты xi, и требуется разбить выборку на подмножества (кластеры) так, чтобы каждый кла- стер состоял из схожих объектов, а объекты разных кластеров существенно отлича- лись. Для этого необходимо задавать функцию расстояния на множестве объектов. Число кластеров также может задаваться, но чаще требуется определить и его. Пример 1.13. Основным инструментом социологических и маркетинговых иссле- дований является проведение опросов. Чтобы результаты опроса были объективны, необходимо обеспечить представительность выборки респондентов. С другой сторо- ны, требуется минимизировать стоимость проведения опроса. Поэтому при плани- ровании опросов возникает вспомогательная задача: отобрать как можно меньше респондентов, чтобы они образовывали репрезентативную выборку, то есть пред- ставляли весь спектр общественного мнения. Один из способов это сделать состоит в следующем. Сначала составляются признаковые описания достаточно большого числа точек опроса (это могут быть города, районы, магазины, и т. д.). Для этого используются недорогие способы сбора информации пробные опросы или фикса- ция некоторых характеристик самих точек. Затем решается задача кластеризации, и из каждого кластера отбирается по одной представительной точке. Только в ото- бранном множестве точек производится основной, наиболее ресурсоёмкий, опрос. Задачи кластеризации, в которых часть объектов (как правило, незначитель- ная) размечена по классам, называются задачами с частичным обучением (semi- supervised learning). Считается, что они не сводятся непосредственно к классифика- ции или кластеризации, и для их решения нужны особые методы. Пример 1.14. Задача рубрикации текстов возникает при работе с большими кол- лекциями текстовых документов. Допустим, имеется некоторый иерархический руб- рикатор, разработанный экспертами для данной предметной области (например, для спортивных новостей), или для всех областей (например, универсальный десятичный классификатор УДК). Имеется множество документов, классифицированных по руб- рикам вручную. Требуется классифицировать по тем же рубрикам второе множество документов, которое может быть существенно больше первого. Для решения данной задачи используется функция расстояния, сравнивающая тексты по составу терми- нов. Терминами, как правило, являются специальные понятия предметной области, собственные имена, географические названия, и т. д. Документы считаются схожими, если множества их терминов существенно пересекаются.
14 К.В.Воронцов. Вычислительные методы обучения по прецедентам 1.2.5 Задачи поиска ассоциаций Задача поиска ассоциативных правил (association rule induction) вынесена в от- дельный класс и относится к задачам обучения без учителя, хотя имеет много общего с задачей классификации. Пример 1.15. Задача анализа рыночных корзин (market basket analysis) состоит в том, чтобы по данным о покупках товаров в супермаркете (буквально, по чекам) определить, какие товары часто совместно покупаются. Эта информация может быть полезной для оптимизации размещения товаров на полках, планирования рекламных кампаний (промо-акций), управления ассортиментом и ценами. В данной задаче объ- екты соответствуют чекам, признаки являются бинарными и соответствуют товарам. Единичное значение признака fj(xi) = 1 означает, что в i-м чеке зафиксирована по- купка j-го товара. Задача состоит в том, чтобы выявить все наборы товаров, которые часто покупают вместе. Например, ?если куплен хлеб, то c вероятностью 60% будет куплено и молоко?. Во многие учебники по бизнес-аналитике вошёл пример, когда система поиска ассоциативных правил обнаружила неочевидную закономерность: ве- чером перед выходными днями возрастают совместные продажи памперсов и пива. Разместив дорогие сорта пива рядом с памперсами, менеджеры смогли увеличить продажи в масштабах всей розничной сети, что окупило внедрение системы анализа данных. Позже маркетологи и социологи предложили разумное объяснение данному явлению, однако обнаружено оно было именно путём анализа данных. Пример 1.16. Задача выделения терминов (term extraction) из текстов, решаемая перед задачей рубрикации (см. пример 1.14), может быть сведена к поиску ассоциа- ций. Терминами считаются отдельные слова или устойчивые словосочетания, кото- рые часто встречаются в небольшом подмножестве документов, и редко во всех остальных. Множество часто совместно встречающихся терминов образует тему, ско- рее всего, соответствующую некоторой рубрике. 1.2.6 Методология тестирования обучаемых алгоритмов Пока ещё не создан универсальный метод обучения по прецедентам, способный решать любые практические задачи одинаково хорошо. Каждый метод имеет свои преимущества, недостатки и границы применимости. На практике приходится прово- дить численные эксперименты, чтобы понять, какой метод из имеющегося арсенала лучше подходит для конкретной задачи. Обычно для этого методы сравниваются по скользящему контролю (1.6). Существует два типа экспериментальных исследований, отличающихся целями и методикой проведения. Эксперименты на модельных данных. Их цельвыявление границ применимо- сти метода обучения; построение примеров удачной и неудачной его работы; пони- мание, на что влияют параметры метода обучения. Модельные эксперименты часто используются на стадии отладки метода. Модельные выборки сначала генерируются в двумерном пространстве, чтобы работу метода можно было наглядно представить на плоских графиках. Затем исследуется работа метода на многомерных данных, при различном числе признаков. Генерация данных выполняется либо с помощью
15 датчика случайных чисел по заданным вероятностным распределениям, либо де- терминированным образом. Часто генерируется не одна модельная задача, а целая серия, параметризованная таким образом, чтобы среди задач оказались как заведо- мо ?лёгкие?, так и заведомо ?трудные?; при такой организации эксперимента точнее выявляются границы применимости метода. Эксперименты на реальных данных. Их цельлибо решение конкретной при- кладной задачи, либо выявление ?слабых мест? и границ применимости конкрет- ного метода. В первом случае фиксируется задача, и к ней применяются многие методы, или, возможно, один и тот же метод при различных значениях парамет- ров. Во втором случае фиксируется метод, и с его помощью решается большое чис- ло задач (обычно несколько десятков). Специально для проведения таких экспери- ментов создаются общедоступные репозитории реальных данных. Наиболее извест- ныйрепозиторий UCI (университета Ирвина, Калифорния), доступный по адресу http://archive.ics.uci.edu/ml. Он содержит около двух сотен задач, в основном классификации, из самых разных предметных областей [30]. Полигон алгоритмов классификации. В научных статьях по машинному обу- чению принято приводить результаты тестирования предложенного нового метода обучения в сравнении с другими методами на представительном наборе задач. Срав- нение должно производиться в равных условиях по одинаковой методике; если это скользящий контроль, то при одном и том же множестве разбиений. Несмотря на зна- чительную стандартизацию таких экспериментов, результаты тестирования одних и тех же методов на одних и тех же задачах, полученные разными авторами, всё же могут существенно различаться. Проблема в том, что используются различные ре- ализации методов обучения и методик тестирования, а проведённый кем-то ранее эксперимент практически невозможно воспроизвести во всех деталях. Для решения этой проблемы разработан Полигон алгоритмов классификации, доступный по ад- ресу http://poligon.MachineLearning.ru. В этой системе реализована унифициро- ванная расширенная методика тестирования и централизованное хранилище задач. Реализация алгоритмов классификации, наоборот, децентрализована. Любой поль- зователь Интернет может объявить свой компьютер вычислительным сервером По- лигона, реализующим один или несколько методов классификации. Все результаты тестирования сохраняются как готовые отчёты в базе данных системы и могут быть в любой момент выданы по запросу без проведения трудоёмких вычислений заново. Конкурсы по решению задач анализа данных. В последние годы компании, за- интересованные в решении прикладных задач анализа данных, всё чаще стали об- ращаться к такой форме привлечения научного сообщества, как открытые конкур- сы с денежными премиями для победителя. В каждом таком конкурсе публикуется обучающая выборка с известными ответами, тестовая выборка, ответы на которой известны только организатору конкурса, и критерий, по которому алгоритмы претен- дентов сравниваются на данных тестовой выборки. Информацию о текущих конкур- сах можно найти на сайтах http://www.kaggle.com, http://tunedit.org. Существу- ют также сайты, на которых можно тестировать различные алгоритмы на различных наборах данных: http://poligon.MachineLearning.ru, http://mlcomp.org.
16 К.В.Воронцов. Вычислительные методы обучения по прецедентам 1.2.7 Приёмы генерации модельных данных Данный раздел носит справочный характер. В нём перечислены некоторые све- дения, полезные при генерации модельных выборок данных. Моделирование случайных данных. Следующие утверждения позволяют гене- рировать случайные выборки с заданными распределениями [10]. Будем предпола- гать, что имеется стандартный способ получать равномерно распределённые на от- резке [0, 1] случайные величины. Утв. 1. Если случайная величина r равномерно распределена на [0, 1], то случай- ная величина ? = [r < p] принимает значение 1 с вероятностью p и значение 0 с вероятностью 1 ? p. Утв. 2. Если случайная величина r равномерно распределена на [0, 1], и задана воз- растающая последовательность F0 = 0, F1, . . . , Fk?1, Fk = 1, то дискретная случайная величина ?, определяемая условием F??1 6 r < F?, принимает значения j = 1, . . . , k с вероятностями pj = Fj ? Fj?1. Утв. 3. Если случайная величина r равномерно распределена на [0, 1], и задана возрастающая на R функция F(x), 0 6 F(x) 6 1, то случайная величина ? = F?1(r) имеет непрерывную функцию распределения F(x). Утв. 4. Если r1, r2 две независимые случайные величины, равномерно распреде- лённые на [0, 1], то преобразование Бокса-Мюллера ?1 = p?2 ln r1 sin 2?r2; ?2 = p?2 ln r1 cos 2?r2; даёт две независимые нормальные случайные величины с нулевым матожиданием и единичной дисперсией: ?1, ?2 ? N(0, 1). Утв. 5. Если ? нормальная случайная величина из N(0, 1), то случайная ве- личина ? = ? + ?? имеет нормальное распределение N(?, ?2) с матожиданием ? и дисперсией ?2. Утв. 6. Пусть n-мерный вектор x = (?1, . . . , ?n) составлен из независимых нормаль- ных случайных величин ?i ? N(0, 1). Пусть V невырожденная n ? n-матрица, ? ? Rn. Тогда вектор x' = ? + V тx имеет многомерное нормальное распределе- ние N(?,) c вектором матожидания ? и ковариационной матрицей = V тV . Утв. 7. Пусть на вероятностном пространстве X заданы k плотностей распреде- ления p1(x), . . . , pk(x). Пусть дискретная случайная величина ? принимает значения 1, . . . , k с вероятностями w1, . . . ,wk. Тогда случайный элемент x ? X, полученный со- гласно распределению p?(x), подчиняется смеси распределений p(x) = Pkj=1 wjpj(x). На практике часто используют смеси многомерных нормальных распределений.
17 Рис. 1. Модельная выборка ?спирали?. Рис. 2. Серия модельных выборок ?пила?. Утв. 8. Предыдущий случай обобщается на континуальные смеси распределений. Пусть на вероятностном пространстве X задано параметрическое семейство плотно- стей распределения p(x, t), где t ? R параметр. Пусть значение ? ? R взято из рас- пределения с плотностью w(t). Тогда случайный элемент x ? X, полученный соглас- но распределению p(x, ? ), подчиняется распределению p(x) = R +? ?? w(t)p(x, t) dt. Этот метод, называемый методом суперпозиций, позволяет моделировать широкий класс вероятностных распределений, представимых интегралом указанного вида. Утв. 9. Пусть в Rn задана прямоугольная область = [a1, b1]?. . . ?[an, bn] и про- извольное подмножество G ? . Пусть r = (r1, . . . , rn) вектор из n независимых случайных величин ri, равномерно распределённых на [ai, bi]. Метод исключения со- стоит в том, чтобы генерировать случайный вектор r до тех пор, пока не выполнится условие r ? G. Тогда результирующий вектор r равномерно распределён на G. Этот метод вычислительно неэффективен, если объём G много меньше объёма . Неслучайные модельные данные позволяют наглядно продемонстрировать, в ка- ких случаях одни методы работают лучше других. Один из классических примеров две спирали на Рис. 1. Эта выборка хорошо классифицируется методом ближайших соседей, но непреодолимо трудна для линей- ных разделяющих правил. Если витки спиралей расположить ближе друг к другу, за- дача станет трудна и для метода ближайших соседей. Некоторые кусочно-линейные разделители справляются с задачей и в этом случае. Обычно при создании модельных данных, как случайных, так и неслучайных, вводится параметр, плавно изменяющий задачу от предельно простой до предельно трудной. Это позволяет исследовать границы применимости метода. На Рис. 2 пока- зана серия модельных задач классификации с двумя классами, обладающая таким свойством относительно метода ближайших соседей и некоторых других алгоритмов.
18 К.В.Воронцов. Вычислительные методы обучения по прецедентам 2 Байесовские методы классификации Байесовский подход является классическим в теории распознавания образов и лежит в основе многих методов. Он опирается на теорему о том, что если плот- ности распределения классов известны, то алгоритм классификации, имеющий ми- нимальную вероятность ошибок, можно выписать в явном виде. Для оценивания плотностей классов по выборке применяются различные подходы. В этом курсе лек- ций рассматривается три: параметрический, непараметрический и оценивание смесей распределений. :2.1 Вероятностная постановка задачи классификации Пусть X множество объектов, Y конечное множество имён классов, мно- жество X ? Y является вероятностным пространством с плотностью распреде- ления p(x, y) = P(y)p(x|y). Вероятности появления объектов каждого из классов Py = P(y) называются априорными вероятностями классов. Плотности распределе- ния py(x) = p(x|y) называются функциями правдоподобия классов3. Вероятностная постановка задачи классификации разделяется на две независимые подзадачи. Задача 2.1. Имеется простая выборка X? = (xi, yi)?i=1 из неизвестного распределе- ния p(x, y) = Pypy(x). Требуется построить эмпирические оценки4 априорных веро- ятностей ? Py и функций правдоподобия ?py(x) для каждого из классов y ? Y . Задача 2.2. По известным плотностям распределения py(x) и априорным вероятно- стям Py всех классов y ? Y построить алгоритм a(x), минимизирующий вероятность ошибочной классификации. Вторая задача решается относительно легко, и мы сразу это сделаем. Первая задача имеет множество решений, поскольку многие распределения p(x, y) могли бы породить одну и ту же выборку X?. Приходится привлекать различные предположе- ния о плотностях, что и приводит к большому разнообразию байесовских методов. 2.1.1 Функционал среднего риска Знание функций правдоподобия позволяет находить вероятности событий вида ?x ? при условии, что x принадлежит классу y?: P(|y) = Zpy(x) dx, ? X. Рассмотрим произвольный алгоритм a: X > Y . Он разбивает множество X на непересекающиеся области Ay = {x ? X | a(x) = y}, y ? Y . Вероятность того, что появится объект класса y и алгоритм a отнесёт его к классу s, равна Py P(As|y). Каждой паре (y, s) ? Y ? Y поставим в соответствие величину потери ?ys при отне- сении объекта класса y к классу s. Обычно полагают ?yy = 0, и ?ys > 0 при y 6= s. Соотношения потерь на разных классах, как правило, известны заранее. 3 Большой буквой P будем обозначать вероятности, а строчной pплотности распределения. 4 Символами с ?крышечкой? принято обозначать выборочные (эмпирические) оценки вероятно- стей, функций распределения или случайных величин, вычисляемые по выборке.
19 Опр. 2.1. Функционалом среднего риска называется ожидаемая величина потери при классификации объектов алгоритмом a: R(a) =Xy?YXs?Y ?ysPy P(As|y). Если величина потерь одинакова для ошибок любого рода, ?ys = [y 6= s], то сред- ний риск R(a) совпадает с вероятностью ошибки алгоритма a. 2.1.2 Оптимальное байесовское решающее правило Теорема 2.1. Если известны априорные вероятности Py и функции правдоподобия py(x), то минимум среднего риска R(a) достигается алгоритмом a(x) = argmin s?Y Xy?Y ?ysPypy(x). Доказательство. Для произвольного t ? Y запишем функционал среднего риска: R(a) =Xy?YXs?Y ?ysPy P(As|y) = =Xy?Y ?ytPy P(At|y) + X s?Y \{t}Xy?Y ?ysPy P(As|y). Применив формулу полной вероятности, P(At|y) = 1 ? P s?Y \{t}P(As|y), получим: R(a) =Xy?Y ?ytPy + X s?Y \{t}Xy?Y (?ys ? ?yt)Py P(As|y) = = const(a) + X s?Y \{t} ZAsXy?Y (?ys ? ?yt)Pypy(x) dx. (2.1) Введём для сокращения записи обозначение gs(x) = Py?Y ?ysPypy(x), тогда R(a) = const(a) + X s?Y \{t} ZAs??gs(x) ? gt(x)dx. В выражении (2.1) неизвестны только области As. Функционал R(a) есть сум- ма |Y |?1 слагаемых I(As) = RAs??gs(x)?gt(x)dx, каждое из которых зависит только от одной области As. Минимум I(As) достигается, когда As совпадает с областью неположительности подынтегрального выражения. В силу произвольности t As = x ? X gs(x) 6 gt(x), ?t ? Y, t 6= s. С другой стороны, As = x ? X a(x) = s. Значит, a(x) = s тогда и толь- ко тогда, когда s = argmin t?Y gt(x). Если минимум gt(x) достигается при нескольких значениях t, то можно взять любое из них, что не повлияет на риск R(a), так как подынтегральное выражение в этом случае равно нулю. Теорема доказана. Часто можно полагать, что величина потери зависит только от истинной клас- сификации объекта, но не от того, к какому классу он был ошибочно отнесён. В этом случае формула оптимального алгоритма упрощается.
20 К.В.Воронцов. Вычислительные методы обучения по прецедентам Теорема 2.2. Если Py и py(x) известны, ?yy = 0 и ?ys ? ?y для всех y, s ? Y , то минимум среднего риска достигается алгоритмом a(x) = argmax y?Y ?yPypy(x). (2.2) Доказательство. Рассмотрим выражение (2.1) из доказательства Теоремы 2.1. По- скольку ?ys не зависит от второго индекса, то для любых s, t ? Y ?ys ? ?yt = ?t[y=t] ? ?s[y=s]. Следовательно, Xy?Y (?ys ? ?yt)Py py(x) = ?tPtpt(x) ? ?sPsps(x) = ?gt(x) ? ?gs(x), где ?gy(x) = ?yPypy(x) для всех y ? Y . Аналогично доказательству Теоремы 2.1 отсюда вытекает, что a(x) = s при тех x, для которых ?gs(x) максимально по s ? Y . Разделяющая поверхность между классами s и tэто геометрическое место то- чек x ? X таких, что максимум в (2.2) достигается одновременно при y = s и y = t: ?tPtpt(x) = ?sPsps(x). Объекты x, удовлетворяющие этому уравнению, можно отно- сить к любому из двух классов s, t, что не повлияет на средний риск R(a). Апостериорная вероятность класса y для объекта xэто условная вероятность P(y|x). Она может быть вычислена по формуле Байеса, если известны py(x) и Py: P(y|x) = p(x, y) p(x) = Ppy(x)Py s?Y ps(x)Ps . Во многих приложениях важно не только классифицировать объект x, но и ска- зать, с какой вероятностью P(y|x) он принадлежит каждому из классов. Через апо- стериорные вероятности выражается величина ожидаемых потерь на объекте x: R(x) =Xy?Y ?y P(y|x). Принцип максимума апостериорной вероятности. Оптимальный алгоритм клас- сификации (2.2) можно переписать через апостериорные вероятности: a(x) = argmax y?Y ?y P(y|x). Поэтому выражение (2.2) называют байесовским решающим правилом. Минимальное значение среднего риска R(a), достигаемое байесовским решаю- щим правилом, называется байесовским риском или байесовским уровнем ошибки. Если классы равнозначны (?y ? 1), то байесовское правило называется также принципом максимума апостериорной вероятности. Если классы ещё и равноверо- ятны (Py ? 1 |Y | ), то объект x просто относится к классу y с наибольшим значением плотности распределения py(x) в точке x.
21 2.1.3 Задача восстановления плотности распределения Перейдём к Задаче 2.1. Требуется оценить, какой могла бы быть плотность вероятностного распределения p(x, y) = Pypy(x), сгенерировавшего выборку X?. Обозначим подвыборку прецедентов класса y через X?y = (xi, yi)?i=1 yi = y. Проще всего оценить априорные вероятности классов Py. Согласно закону боль- ших чисел, частота появления объектов каждого из классов ? Py = ?y ? , ?y = |X?y|, y ? Y, (2.3) сходится по вероятности к Py при ?y > ?. Чем больше длина выборки, тем точнее выборочная оценка ? Py. Оценка (2.3) является несмещённой лишь в том случае, ес- ли все без исключения наблюдавшиеся объекты заносились в обучающую выборку. На практике применяются и другие принципы формирования данных. Например, в задачах с несбалансированными классами (unbalanced classes) один из классов мо- жет встречаться в тысячи раз реже остальных; это может затруднять построение ал- горитмов, поэтому выборку формируют неслучайным образом, чтобы объекты всех классов были представлены поровну. Возможна также ситуация, когда обучающая выборка формируется в ходе планируемого эксперимента, а применять построенный алгоритм классификации предполагается в реальной среде с другими априорными вероятностями классов. Во всех подобных ситуациях оценка ? Py должна делаться не по доле обучающих объектов (2.3), а из других содержательных соображений. Задача восстановления плотности имеет самостоятельное значение, поэтому мы сформулируем её в более общем виде, обозначая выборку через Xm вместо X?y, что позволит несколько упростить обозначения. Задача 2.3. Задано множество объектов Xm = {x1, . . . , xm}, выбранных случай- но и независимо согласно неизвестному распределению p(x). Требуется построить эмпирическую оценку плотности функцию ?p(x), приближающую p(x) на всём X. ?Наивный? байесовский классификатор. Допустим, что объекты x ? X опи- сываются n числовыми признаками fj : X > R, j = 1, . . . , n. Обозначим через x = = (?1, . . . , ?n) произвольный элемент пространства объектов X = Rn, где ?j = fj(x). Гипотеза 2.1. Признаки f1(x), . . . , fn(x) являются независимыми случайными ве- личинами. Следовательно, функции правдоподобия классов представимы в виде py(x) = py1(?1) - - - pyn(?n), y ? Y, (2.4) где pyj(?j) плотность распределения значений j-го признака для класса y. Предположение о независимости существенно упрощает задачу, так как оце- нить n одномерных плотностей гораздо проще, чем одну n-мерную плотность. Одна- ко оно крайне редко выполняется на практике, поэтому алгоритмы классификации, использующие (2.4), называются наивными байесовскими (na??ve Bayes). Подставим эмпирические оценки одномерных плотностей ?pyj(?) в (2.4) и затем в (2.2). Получим алгоритм a(x) = argmax y?Y ln ?y ? Py +Xn j=1 ln ?pyj(?j). (2.5)
22 К.В.Воронцов. Вычислительные методы обучения по прецедентам Основные его преимуществапростота реализации и низкие вычислительные затраты при обучении и классификации. В тех редких случаях, когда признаки (по- чти) независимы, наивный байесовский классификатор (почти) оптимален. Основной его недостатокнизкое качество классификации. Он используется либо как эталон при экспериментальном сравнении алгоритмов, либо как элементар- ный ?строительный блок? в алгоритмических композициях, ??. :2.2 Непараметрическая классификация Непараметрические методы классификации основаны на локальном оценива- нии плотностей распределения классов py(x) в окрестности классифицируемого объ- екта x ? X. Для классификации объекта x применяется основная формула (2.2). 2.2.1 Непараметрические оценки плотности Локальное оценивание опирается на само определение плотности. Начнём с про- стейших одномерных оценок. Они уже могут оказаться полезными на практике, в частности, при построении ?наивных? байесовских классификаторов (2.5). Кро- ме того, они подскажут нам идеи обобщения на многомерный случай. Дискретный случай. Пусть X конечное множество, причём |X| ? m. Оценкой плотности служит гистограмма значений xi, встретившихся в выборке Xm = (xi)mi=1: ?p(x) = 1mXm i=1 [xi = x]. (2.6) Эта оценка не применима, если |X| ? m, и, тем более, в непрерывном случае, так как её значение почти всегда будет равно нулю. Одномерный непрерывный случай. Пусть X = R. Согласно определению плот- ности, p(x) = lim h>0 1 2hP[x ? h, x + h], где P[a, b] вероятностная мера отрезка [a, b]. Соответственно, эмпирическая оценка плотности определяется как доля точек вы- борки, лежащих внутри отрезка [x ? h, x + h], где h неотрицательный параметр, называемый шириной окна: ?ph(x) = 1 2mh Xm i=1 |x ? xi| < h. (2.7) Функция ?ph(x) является кусочно-постоянной, что приводит к появлению ши- роких зон неуверенности, в которых максимум (2.2) достигается одновременно для нескольких классов y ? Y . Проблема решается с помощью локальной непараметри- ческой оценки Парзена-Розенблатта [57, 56]: ?ph(x) = 1 mh Xm i=1 Kx ? xi h , (2.8) где K(z) функция, называемая ядром, чётная и нормированная R K(z) dz = 1.
23 Функция ?ph(x) обладает той же степенью гладкости, что и ядро K(z), и, благо- даря нормировке, действительно может интерпретироваться как плотность вероят- ности: R ?ph(x) dx = 1 при любом h. На практике часто используются ядра, показанные на рис. 3, стр. 25. Прямоугольное ядро K(z) = 12|z| < 1соответствует простейшей оценке (2.7). Точечное ядро K(z) = [z=0] при h=1 соответствует дискретному случаю (2.6). Обоснованием оценки (2.7) служит следующая теорема, утверждается, что ?ph(x) поточечно сходится к истинной плотности p(x) для широкого класса ядер при увеличении длины выборки m и одновременном уменьшении ширины окна h. Теорема 2.3 ([56, 57, 25]). Пусть выполнены следующие условия: 1) выборка Xm простая, получена из плотности распределения p(x); 2) ядро K(z) непрерывно, его квадрат ограничен: RX K2(z) dz < ?; 3) последовательность hm такова, что lim m>?hm = 0 и lim m>?mhm = ?. Тогда ?phm(x) сходится к p(x) при m > ?для почти всех x ? X, причём скорость сходимости имеет порядок O(m?2/5). Многомерный непрерывный случай. Пусть объекты описываются n числовыми признаками fj : X > R, j = 1, . . . , n. Тогда непараметрическая оценка плотности в точке x ? X записывается в следующем виде [9, 17]: ?ph(x) = 1mXm i=1 Yn j=1 1 hjKfj(x) ? fj(xi) hj . (2.9) Таким образом, в каждой точке xi многомерная плотность представляется в ви- де произведения одномерных плотностей. Заметим, что это никак не связано с ?на- ивным? байесовским предположением о независимости признаков. При ?наивном? подходе плотность представлялась бы как произведение одномерных парзеновских оценок (2.8), то есть как произведение сумм, а не как сумма произведений. Произвольное метрическое пространство. Пусть на X задана функция рассто- яния ?(x, x'), вообще говоря, не обязательно метрика. Одномерная оценка Парзена- Розенблатта (2.8) легко обобщается и на этот случай: ?ph(x) = 1 mV (h) Xm i=1 K?(x, xi) h , (2.10) где V (h) нормирующий множитель, гарантирующий, что ?ph(x) действительно яв- ляется плотностью. Сходимость оценки (2.10) доказана при некоторых дополнитель- ных ограничениях на ядро K и метрику ?, причём скорость сходимости лишь немного хуже, чем в одномерном случае [22]. 2.2.2 Метод парзеновского окна Запишем парзеновскую оценку плотности (2.10) для каждого класса y ? Y : ?py,h(x) = 1 ?yV (h) X? i=1 [yi = y]K?(x, xi) h , (2.11)
24 К.В.Воронцов. Вычислительные методы обучения по прецедентам где K ядро, h ширина окна. Если нормирующий множитель V (h) не зависит от y, то в байесовском классификаторе (2.2) его можно убрать из-под знака argmax и вообще не вычислять. Подставим оценку плотности (2.11) и оценку априорной вероятности классов ? Py = ?y/? в формулу (2.2): a(x;X?, h) = argmax y?Y ?yX? i=1 [yi = y]K?(x, xi) h . (2.12) Выборка X? сохраняется ?как есть? и играет роль параметра алгоритма. Если метрика ? фиксирована, то обучение парзеновского классификатора (2.12) сводится к подбору ширины окна h и вида ядра K. Ширина окна h существенно влияет на качество восстановления плотности. При h > 0 плотность концентрируется вблизи обучающих объектов, и функция ?ph(x) пре- терпевает резкие скачки. При h > ? плотность чрезмерно сглаживается и вырож- дается в константу. Следовательно, должно существовать компромиссное значение ширины окна h?. На практике его находят по скользящему контролю: LOO(h,X?) = X? i=1 a??xi;X?\xi, h6= yi> min h , где a(x;X? \xi, h) алгоритм классификации, построенный по обучающей выбор- ке X? без объекта xi. Обычно зависимость LOO(h) имеет характерный минимум, соответствующий оптимальной ширине окна h?. Переменная ширина окна h(x). Если распределение объектов в пространстве X сильно неравномерно, то возникает проблема локальных сгущений. Одно и то же значение ширины окна h приводит к чрезмерному сглаживанию плотности в одних областях пространства X, и недостаточному сглаживанию в других. Проблему ре- шает переменная ширина окна, определяемая в каждой точке x ? X как расстояние до (k + 1)-го соседа h(x) = ???x, x(k+1), если считать, что обучающие объекты ран- жированы по возрастанию расстояний до x. Нормирующий множитель V (h) не должен зависеть от y, поэтому в числе со- седей должны учитываться объекты всех классов, хотя плотности ?py,h(x)(x) оцени- ваются по подвыборкам X?y для каждого класса y ? Y в отдельности. Оптимальное значение k? определяется по критерию скользящего контроля, аналогично h?. Функция ядра K практически не влияет на качество восстановления плотности и на качество классификации. В то же время, она определяет степень гладкости функции ?ph(x). Вид ядра может также влиять на эффективность вычислений. Гаус- совское ядро G требует просмотра всей выборки для вычисления значения ?ph(x) в произвольной точке x. Ядра E, Q, T, являются финитными (имеют ограничен- ный носитель, рис. 3), и для них достаточно взять только те точки выборки, которые попадают в окрестность точки x радиуса h.
25 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 -0.0 0.2 0.4 0.6 0.8 1.0 E Q T П G Рис. 3. Часто используемые ядра: E Епанечникова; Q квартическое; T треугольное; G гауссовское; прямоугольное. Проблема ?проклятия размерности?. Если используемая метрика ?(x, x') осно- вана на суммировании различий по всем признакам, а число признаков очень велико, то все точки выборки могут оказаться практически одинаково далеки друг от друга. Тогда парзеновские оценки плотности становятся неадекватны. Это явление назы- вают проклятием размерности (curse of dimensionality). Выход заключается в по- нижении размерности с помощью преобразования пространства признаков (см. раз- дел ??), либо путём отбора информативных признаков (см. раздел ??). Можно стро- ить несколько альтернативных метрик в подпространствах меньшей размерности, и полученные по ним алгоритмы классификации объединять в композицию. На этой идее основаны алгоритмы вычисления оценок, подробно описанные в ??. :2.3 Нормальный дискриминантный анализ В параметрическом подходе предполагается, что плотность распределения вы- борки Xm = {x1, . . . , xm} известна с точностью до параметра, p(x) = ?(x; ?), где ? фиксированная функция. Вектор параметров ? оценивается по выборке Xm с помо- щью принципа максимума правдоподобия (maximum likelihood). Нормальный дискриминантный анализ это специальный случай байесовской классификации, когда предполагается, что плотности всех классов py(x), y ? Y являются многомерными нормальными. Этот случай интересен и удобен тем, что задача оценивания параметров распределения по выборке решается аналитически. 2.3.1 Многомерное нормальное распределение Пусть X = Rn, то есть объекты описываются n числовыми признаками. Опр. 2.2. Вероятностное распределение с плотностью N(x; ?,) = (2?)?n2 ||?12 exp???12 (x ? ?)т?1(x ? ?), x ? Rn, называется n-мерным нормальным (гауссовским) распределением с математическим ожиданием (центром) ? ? Rn и ковариационной матрицей ? Rn?n. Предполагается, что матрица симметричная, невырожденная, положительно определённая.
26 К.В.Воронцов. Вычислительные методы обучения по прецедентам Интегрируя по Rn, можно убедиться в том, что это действительно распределе- ние, а параметры ? и оправдывают своё название: Z N(x; ?,) dx = 1; Ex = Z xN(x; ?,) dx = ?; E(x ? ?)(x ? ?)т = Z (x ? ?)(x ? ?)тN(x; ?,) dx = . Геометрическая интерпретация нормальной плотности. Если признаки некор- релированы, = diag(?21, . . . , ?2n), то линии уровня плотности распределения имеют форму эллипсоидов с центром ? и осями, параллельными линиям координат. Если признаки имеют одинаковые дисперсии, = ?2In, то эллипсоиды являются сферами. Если признаки коррелированы, то матрица не диагональна и линии уровня имеют форму эллипсоидов, оси которых повёрнуты относительно исходной системы координат. Действительно, как всякая симметричная матрица, имеет спектральное разложение = V SV т, где V = (v1, . . . , vn) ортогональные собственные векторы матрицы , соответствующие собственным значениям ?1, . . . , ?n, матрица S диаго- нальна, S = diag(?1, . . . , ?n). Тогда ?1 = V S?1V т, следовательно, (x ? ?)т?1(x ? ?) = (x ? ?)тV S?1V т(x ? ?) = (x' ? ?')тS?1(x' ? ?'). Это означает, что в результате ортогонального преобразования координат x' = V тx оси эллипсоидов становятся параллельны линиям координат. В новых координатах ковариационная матрица S является диагональной. Поэтому линейное преобразо- вание V называется декоррелирующим. В исходных координатах оси эллипсоидов направлены вдоль собственных векторов матрицы . 2.3.2 Квадратичный дискриминант Рассмотрим задачу классификации с произвольным числом классов. Теорема 2.4. Если классы имеют n-мерные нормальные плотности распределения py(x) = N(x; ?y,y), y ? Y. то байесовский классификатор задаёт квадратичную разделяющую поверхность. Она вырождается в линейную, если ковариационные матрицы классов равны. Доказательство. Поверхность, разделяющая классы s и t, описывается уравнением ?sPsps(x) = ?tPtpt(x), которое после логарифмирования принимает вид ln ps(x) ? ln pt(x) = Cst, где Cst = ln(?tPt/?sPs) константа, не зависящая от x. Разделяющая поверхность в общем случае квадратична, поскольку ln py(x) является квадратичной формой по x: ln py(x) = ?n2 ln 2? ? 12 ln |y| ? 12 (x ? ?y)т?1 y (x ? ?y).
27 Если s = t ? , то квадратичные члены сокращаются и уравнение поверхности вырождается в линейную форму: xт?1(?s ? ?t) ? 12?тs?1?s + 12?тt?1?t = Cst; (x ? ?st)т?1(?s ? ?t) = Cst; где ?st = 12 (?s + ?t) точка посередине между центрами классов. Геометрия разделяющих поверхностей. Рассмотрим простейший случай, когда классы s, t равновероятны и равнозначны (?sPs = ?tPt), ковариационные матрицы равны, признаки некоррелированы и имеют одинаковые дисперсии (s = t = ?In). Это означает, что классы имеют одинаковую сферическую форму. В этом случае разделяющая гиперплоскость проходит посередине между классами, ортогонально линии, соединяющей центры классов. Нормаль гиперплоскости обладает свойством оптимальности это та прямая, в одномерной проекции на которую классы разделя- ются наилучшим образом, то есть с наименьшим значением байесовского риска R(a). Если признаки коррелированы (s = t 6= ?In), то ортогональность исчеза- ет, однако разделяющая гиперплоскость по-прежнему проходит посередине между классами, касательно к линиям уровня обоих распределений. Если классы не равновероятны или не равнозначны (?sPs 6= ?tPt), то разделя- ющая гиперплоскость отодвигается дальше от более значимого класса. Если ковариационные матрицы не диагональны и не равны, то разделяющая поверхность становится квадратичной и ?прогибается? так, чтобы менее плотный класс ?охватывал? более плотный. В некоторых случаях более плотный класс ?разрезает? менее плотный на две несвязные области. Это может приводить к парадоксальным ситуациям. Например, может возникнуть область, в которой объекты будут относиться к менее плотному классу, хотя объекты более плотного класса находятся ближе. Если число классов превышает 2, то разделяющая поверхность является кусоч- но-квадратичной, а при равных ковариационных матрицахкусочно-линейной. Расстояние Махаланобиса. Если классы равновероятны и равнозначны, ковариа- ционные матрицы равны, то уравнение разделяющей поверхности принимает вид (x ? ?s)т?1(x ? ?s) = (x ? ?t)т?1(x ? ?t); kx ? ?sk= kx ? ?tk; где ku ? vk? p(u ? v)т?1(u ? v) метрика в Rn, называемая расстоянием Ма- халанобиса. Разделяющая поверхность является геометрическим местом точек, рав- ноудалённых от центров классов в смысле расстояния Махаланобиса. Если признаки независимы и имеют одинаковые дисперсии, то расстояние Ма- халанобиса совпадает с евклидовой метрикой. В этом случае оптимальным (байесов- ским) решающим правилом является классификатор ближайшего среднего (nearest mean classifier), относящий объект к классу с ближайшим центром.
28 К.В.Воронцов. Вычислительные методы обучения по прецедентам Принцип максимума правдоподобия составляет основу параметрического под- хода. Пусть задано множество объектов Xm = {x1, . . . , xm}, выбранных независимо друг от друга из вероятностного распределения с плотностью ?(x; ?). Функцией прав- доподобия называется совместная плотность распределения всех объектов выборки: p(Xm; ?) = p(x1, . . . , xm; ?) =Ym i=1 ?(xi; ?). Значение параметра ?, при котором выборка максимально правдоподобна, то есть функция p(Xm; ?) принимает максимальное значение, называется оценкой максимума правдоподобия. Как известно из математической статистики, эта оценка обладает рядом оптимальных свойств [13, 16]. Вместо максимизации правдоподобия удобнее максимизировать его логарифм: L(Xm; ?) = Xm i=1 ln ?(xi; ?) > max ? . (2.13) Для решения этой задачи можно использовать стандартные методы оптимиза- ции. В некоторых случаях решение выписывается в явном виде, исходя из необходи- мого условия оптимума (если функция ?(x; ?) достаточно гладкая по параметру ?): ? ??L(Xm; ?) = Xm i=1 ? ?? ln ?(xi; ?) = 0. (2.14) Выборочные оценки параметров нормального распределения. В случае гаус- совской плотности с параметрами ? ? (?,) задача максимизации правдоподобия имеет аналитическое решение, которое получается из уравнений (2.14). Теорема 2.5. Пусть задана независимая выборка объектов Xm = (x1, . . . , xm). То- гда оценки параметров гауссовской плотности ?(x; ?) ? N(x; ?,), доставляющие максимум функционалу правдоподобия (2.13), имеют вид ?? = 1m Xm i=1 xi; ?= 1m Xm i=1 (xi ? ??)(xi ? ??)т. Поправка на смещение. Естественным требованием к оценке параметра распреде- ления является её несмещённость. Опр. 2.3. Пусть Xm есть выборка случайных независимых наблюдений, получен- ная согласно распределению ?(x; ?) при фиксированном ? = ?0. Оценка ??(Xm) пара- метра ?, вычисленная по выборке Xm, называется несмещённой, если EXm ??(Xm) = ?0. Оценка ?? является несмещённой, E?? = ?. Однако оценка ?уже смещена: E?= = m m?1. Это связано с тем, что при вычислении ?вместо неизвестного точного значения матожидания ? приходится подставлять его выборочную оценку ??. Для учёта этого небольшого смещения вводится поправка на смещение: ?= 1 m ? 1 Xm x=1(xi ? ??)(xi ? ??)т. (2.15)
29 Подстановочный алгоритм. Оценим параметры функций правдоподобия ??y и ?y по частям обучающей выборки X?y = {xi ? X? | yi = y} для каждого класса y ? Y . Затем эти выборочные оценки подставим в формулу (2.2). Получим байесовский нор- мальный классификатор, который называется также подстановочным (plug-in). В асимптотике ?y > ? оценки ??y и ?y обладают рядом оптимальных свойств: они не смещены, состоятельны и эффективны. Однако оценки, сделанные по корот- ким выборкам, могут быть не достаточно точными. Недостатки подстановочного алгоритма вытекают из нескольких чрезмерно сильных базовых предположений, которые на практике часто не выполняются. : Функции правдоподобия классов могут существенно отличаться от гауссовских. В частности, когда имеются признаки, принимающие дискретные значения, или когда классы распадаются на изолированные сгустки. : Если длина выборки меньше размерности пространства, ?y < n, или среди признаков есть линейно зависимые, то матрица ?y становится вырожденной. В этом случае обратная матрица не существует и метод вообще неприменим. : На практике встречаются задачи, в которых признаки ?почти линейно зависи- мы?. Тогда матрица ?y является плохо обусловленной, то есть близкой к неко- торой вырожденной матрице. Это так называемая проблема мультиколлинеар- ности, которая влечёт неустойчивость как самой обратной матрицы ? ?1 y , так и вектора ? ?1 y (x ? ?st). Они могут непредсказуемо и сильно изменяться при незначительных вариациях исходных данных, например, связанных с погреш- ностями измерений. Неустойчивость снижает качество классификации. : Выборочные оценки чувствительны к нарушениям нормальности распределе- ний, в частности, к редким большим выбросам. Наивный нормальный байесовский классификатор. Предположим, что все при- знаки fj(x) независимы и нормально распределены с матожиданием ?yj и дисперси- ей ?yj , вообще говоря, отличающимися для разных классов: pyj(?) = 1 v2??yj exp?(? ? ?yj)2 2?2yj , y ? Y, j = 1, . . . , n. Тогда, как нетрудно убедиться, ковариационные матрицы y и их выборочные оценки ?y будут диагональны. В этом случае проблемы вырожденности и мульти- коллинеарности не возникают. Метод обучения до крайности прост и сводится к вы- числению параметров ??yj и ??yj для всех y ? Y и всех признаков j = 1, . . . , n. 2.3.3 Линейный дискриминант Фишера В 1936 г. Р.Фишер предложил простую эвристику, позволяющую увели- чить число объектов, по которым оценивается ковариационная матрица, повысить
30 К.В.Воронцов. Вычислительные методы обучения по прецедентам её устойчивость и заодно упростить алгоритм обучения [41]. Предположим, что кова- риационные матрицы классов одинаковы и равны . Оценим ?по всем ? обучающим объектам. С учётом поправки на смещённость, ?= 1 ? ? |Y |X? i=1 (xi ? ??yi)(xi ? ??yi)т Согласно теореме 2.4, разделяющая поверхность линейна, если классов два, и кусочно-линейна, если классов больше. Запишем подстановочный алгоритм: a(x) = argmax y?Y ???yPypy(x)= = argmax y?Y ??ln(?yPy) ? 12 ??тy ? ?1??y | {z } ?y +xт ?| ?{1z??}y ?y = = argmax y?Y ??xт?y + ?y. (2.16) Этот алгоритм называется линейным дискриминантом Фишера (ЛДФ). Он неплохо работает, когда формы классов действительно близки к нормальным и не слишком сильно различаются. В этом случае линейное решающее правило близ- ко к оптимальному байесовскому, но существенно более устойчиво, чем квадратич- ное, и часто обладает лучшей обобщающей способностью. Вероятность ошибки линейного дискриминанта Фишера выражается через расстояние Махаланобиса между классами, в случае, когда классов два [28]: R(a) = ???12k?1 ? ?2k, где (r) = N(x; 0, 1) функция стандартного нормального распределения. Регуляризация ковариационной матрицы. Эвристика Фишера не является ради- кальным решением проблемы мультиколлинеарности: общая ковариационная матри- ца классов ?также может оказаться плохо обусловленной (близкой к вырожденной). Признаком плохой обусловленности является наличие у матрицы собственных значе- ний, близких к нулю. Поэтому один из способов решения проблемымодифициро- вать матрицу ?так, чтобы все её собственные значения ? увеличились на заданное число ? , а все собственные векторы v сохранились. Для этого достаточно прибавить к матрице единичную, умноженную на ? : (?+ ? In)v = ?v + ?v = (? + ? )v. Известны и другие способы решения проблемы плохой обусловленности. Мож- но пропорционально уменьшать недиагональные элементы вместо ?брать мат- рицу (1 ? ? )?+ ? diag ?[28]. Можно занулять недиагональные элементы матрицы, соответствующие тем парам признаков, ковариации которых незначимо отличаются от нуля [2]; при этом матрица становится разреженной, и для её обращения могут применяться специальные, более эффективные, алгоритмы. Можно разбивать мно- жество признаков на группы и полагать, что признаки из разных групп не коррели- рованы. Тогда матрица ?приобретает блочно-диагональный вид. Для таких матриц также существуют специальные эффективные алгоритмы обращения.
31 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -0.050 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 i ?i m ? p t m ? q max t (?t ? ?t+1) Рис. 4. Эксперт предположил, что в выборке длины m = 25 находится от q = 3 до p = 10 выбросов. Более точное число выбросов, равное 6, удалось определить по критерию ?крутого склона?. Отбор и преобразование признаков. Другой способ устранения мультиколлинеар- ности заключается в том, чтобы отбросить наименее значимые признаки. Различные методы отбора признаков (features selection) рассматриваются в разделе ??. Обратим внимание на кажущийся парадокс: информация отбрасывается, но качество класси- фикации повышается. Существует простой ?жадный? метод отбора признаков, в котором исходная n-мерная задача сводится к серии двумерных задач. Это метод редукции размер- ности А.М.Шурыгина [28]. Сначала находятся два признака, в подпространстве которых линейный дискриминант Фишера наилучшим образом разделяет классы (т. е. байесовский риск R(a) принимает наименьшее значение). Обозначим его пара- метры через ?(2) y , ?(2) y : y ? Y , где в векторе ?(2) y ? Rn лишь два коэффициента не равны нулю. Функция проекции на нормаль разделяющей гиперплоскости прини- мается за новый признак: ?(x) = xт?(2) y . Из оставшихся n ? 2 признаков выбирается тот, который в паре с ?(x) наилучшим образом разделяет классы. Снова строится двумерный линейный дискриминант и определяются параметры ?(3) y , ?(3) y : y ? Y , где в векторе ?(3) y ? Rn уже три коэффициента не равны нулю. Так продолжается до тех пор, пока присоединение новых признаков улучшает качество классификации (понижает байесовский риск). Достоинства метода редукции возможность отбро- сить неинформативные признаки и обойтись без обращения ковариационных матриц размера более 2?2. В некоторых прикладных задачах он превосходит другие мето- ды классификации [28]. Недостатком является отсутствие строгого теоретического обоснования. Как и всякая ?жадная? стратегия, он находит неоптимальный набор признаков. По всей видимости, этот метод подходит для тех задач, в которых имеется небольшое число признаков, существенно более информативных, чем остальные. Ещё один способ сокращения размерности заключается в том, чтобы из име- ющегося набора признаков построить новый набор, состоящий из наименьшего чис- ла максимально информативных признаков. Оптимальное линейное преобразование пространства признаков строится с помощью метода главных компонент (principal component analysis), который будет рассмотрен в разделе :5.4. Робастные методы оценивания. Оценки, устойчивые относительно редких боль- ших выбросов или других несоответствий реальных данных модельному распреде- лению ?(x; ?), называются робастными (robust здравый).
32 К.В.Воронцов. Вычислительные методы обучения по прецедентам Простейший метод фильтрации выбросов состоит в двукратном решении зада- чи. Сначала вычисляется оценка максимума правдоподобия для параметра ?? по всей выборке Xm. Для каждого объекта xi ? Xm вычисляется значение правдоподобия ?i = ?(xi; ??), и объекты сортируются по убыванию правдоподобий: ?1 > . . . > ?m. Объекты, оказавшиеся в конце этого ряда, считаются нетипичными (выбросами) и удаляются из выборки. Для этого может применяться критерий ?крутого скло- на?: задаются два параметра p и q, и находится значение t ? {m? p, . . . ,m? q ? 1}, для которого скачок правдоподобия ?t ? ?t+1 максимален. Затем последние (m ? t) объектов удаляются из выборки, см. рис. 4. После этого оценка ?? вычисляется вто- рично по отфильтрованной выборке. Если выбросов много, то, возможно, придётся провести несколько таких фильтраций подряд. Заметим, что удаление объекта может не требовать полного пересчёта оценки ??. В частности, оценки нормального распределения ??, ?аддитивны по объектам, и для них достаточно вычесть слагаемое, соответствующее удаляемому объекту. :2.4 Разделение смеси распределений В тех случаях, когда ?форму? класса не удаётся описать каким-либо одним распределением, можно попробовать описать её смесью распределений. Гипотеза 2.2. Плотность распределения на X имеет вид смеси k распределений: p(x) =Xk j=1 wjpj(x), Xk j=1 wj = 1, wj > 0, где pj(x) функция правдоподобия j-й компоненты смеси, wj её априорная веро- ятность. Функции правдоподобия принадлежат параметрическому семейству рас- пределений ?(x; ?) и отличаются только значениями параметра, pj(x) = ?(x; ?j). Иными словами, ?выбрать объект x из смеси p(x)? означает сначала выбрать j-ю компоненту смеси из дискретного распределения {w1, . . . ,wk}, затем выбрать объект x согласно плотности pj(x). Задача разделения смеси заключается в том, чтобы, имея выборку Xm случай- ных и независимых наблюдений из смеси p(x), зная число k и функцию ?, оценить вектор параметров = (w1, . . . ,wk, ?1, . . . , ?k). 2.4.1 EM-алгоритм К сожалению, попытка разделить смесь, используя принцип максимума правдо- подобия ?в лоб?, приводит к слишком громоздкой оптимизационной задаче. Обойти эту трудность позволяет алгоритм EM (expectation-maximization). Идея алгоритма заключается в следующем. Искусственно вводится вспомогательный вектор скрытых (hidden) переменных G, обладающий двумя замечательными свойствами. С одной стороны, он может быть вычислен, если известны значения вектора параметров . С другой стороны, поиск максимума правдоподобия сильно упрощается, если извест- ны значения скрытых переменных.
33 EM-алгоритм состоит из итерационного повторения двух шагов. На E-шаге вы- числяется ожидаемое значение (expectation) вектора скрытых переменных G по те- кущему приближению вектора параметров . На М-шаге решается задача максими- зации правдоподобия (maximization) и находится следующее приближение вектора по текущим значениям векторов G и . Алгоритм 2.1. Общая идея EM-алгоритма 1: Вычислить начальное приближение вектора параметров ; 2: повторять 3: G := EStep(); 4: := MStep(,G); 5: пока и G не стабилизируются. Этот алгоритм был предложен и исследован М.И.Шлезингером как инстру- мент для самопроизвольной классификации образов [27]. Двенадцать лет спустя он был открыт заново в [39] под названием ЕМ-алгоритма. Область его примене- ния чрезвычайно широкадискриминантный анализ, кластеризация, восстановле- ние пропусков в данных, обработка сигналов и изображений [26]. Здесь мы рассмат- риваем его как инструмент разделения смеси распределений. E-шаг (expectation). Обозначим через p(x, ?j) плотность вероятности того, что объ- ект x получен из j-й компоненты смеси. По формуле условной вероятности p(x, ?j) = p(x) P(?j | x) = wjpj(x). Введём обозначение gij ? P(?j | xi). Это неизвестная апостериорная вероятность того, что обучающий объект xi получен из j-й компоненты смеси. Возьмём эти ве- личины в качестве скрытых переменных. Обозначим G = (gij)m?k = (g1, . . . , gj), где gj j-й столбец матрицы G. Каждый объект обязательно принадлежит какой-то компоненте, поэтому справедлива формула полной вероятности: Xk j=1 gij = 1 для всех i = 1, . . . , ?. Зная параметры компонент wj , ?j , легко вычислить gij по формуле Байеса: gij = wjpj(xi) Pks=1 wsps(xi) для всех i, j. (2.17) В этом и заключается E-шаг алгоритма EM. M-шаг (maximization). Покажем, что знание значений скрытых переменных gij и принцип максимума правдоподобия приводят к оптимизационной задаче, допуска- ющей эффективное численное (или даже аналитическое) решение. Будем максими- зировать логарифм правдоподобия Q() = ln Ym i=1 p(xi) = Xm i=1 ln Xk j=1 wjpj(xi) > max .
34 К.В.Воронцов. Вычислительные методы обучения по прецедентам при ограничении Pkj=1 wj = 1. Запишем лагранжиан этой оптимизационной задачи: L(;Xm) =Xm i=1 lnXk j=1 wjpj(xi)? ?Xk j=1 wj ? 1. Приравняем нулю производную лагранжиана по wj : ?L ?wj = Xm i=1 pj(xi) Pks=1 wsps(xi) ? ? = 0, j = 1, . . . , k. (2.18) Умножим левую и правую части на wj , просуммируем все k этих равенств, и поменяем местами знаки суммирования по j и по i: Xm i=1 Xk j=1 wjpj(xi) Pks=1 wsps(xi) | {z } =1 = ? Xk j=1 wj | {z } =1 , откуда следует ? = m. Теперь снова умножим левую и правую части (2.18) на wj , подставим ? = m, и, замечая сходство с формулой (2.17), получим выражение весов компонент через скрытые переменные: wj = 1m Xm i=1 wjpj(xi) Pks=1 wsps(xi) = 1m Xm i=1 gij , j = 1, . . . , k. (2.19) Легко проверить, что ограничения-неравенства wj > 0 будут выполнены на каждой итерации, если они выполнены для начального приближения. Приравняем нулю производную лагранжиана по ?j , помня, что pj(x) ? ?(x; ?j): ?L ??j = Xm i=1 wj Pks=1 wsps(xi) ? ??j pj(xi) = Xm i=1 wjpj(xi) Pks=1 wsps(xi) ? ??j ln pj(xi) = = Xm i=1 gij ? ??j ln pj(xi) = ? ??j Xm i=1 gij ln pj(xi) = 0, j = 1, . . . , k. Полученное условие совпадает с необходимым условием максимума в задаче максимизации взвешенного правдоподобия ?j := argmax ? Xm i=1 gij ln ?(xi; ?), j = 1, . . . , k. (2.20) Таким образом, M-шаг сводится к вычислению весов компонент wj как сред- них арифметических (2.19) и оцениванию параметров компонент ?j путём решения k независимых оптимизационных задач (2.20). Отметим, что разделение переменных оказалось возможным благодаря удачному введению скрытых переменных. Условия сходимости алгоритма EM рассматриваются в работах [39, 67, 47].
35 Алгоритм 2.2. ЕМ-алгоритм с фиксированным числом компонент Вход: выборка Xm = {x1, . . . , xm}; k число компонент смеси; = (wj , ?j)kj=1 начальное приближение параметров смеси; ? параметр критерия останова; Выход: = (wj , ?j)kj=1 оптимизированный вектор параметров смеси; 1: ПРОЦЕДУРА EM (Xm, k,, ?); 2: повторять 3: E-шаг (expectation): для всех i = 1, . . . ,m, j = 1, . . . , k g0ij := gij ; gij := wj?(xi; ?j) Pks=1 ws?(xi; ?s) ; 4: M-шаг (maximization): для всех j = 1, . . . , k ?j := argmax ? mPi=1 gij ln ?(xi; ?); wj := 1m mPi=1 gij ; 5: пока max i,j |gij ? g0ij | > ?; 6: вернуть (wj , ?j)kj=1; Критерий останова. Итерации останавливаются, когда значения функционала Q() или скрытых переменных G перестают существенно изменяться. Удобнее кон- тролировать скрытые переменные, так как они имеют смысл вероятностей и прини- мают значения из отрезка [0, 1]. Реализация итерационного процесса показана в Алгоритме 2.2. На E-шаге вы- числяется матрица скрытых переменных G по формуле (2.17). На M-шаге решается серия из k задач максимизации взвешенного правдоподобия (2.20), каждая из нихпо полной выборке Xm с вектором весов gj . Обобщённый EM-алгоритм. Не обязательно добиваться высокой точности реше- ния оптимизационной задачи (2.20) на каждом M-шаге алгоритма. Достаточно лишь сместиться в направлении максимума, сделав одну или несколько итераций, и затем выполнить E-шаг. Этот алгоритм также обладает неплохой сходимостью и называ- ется обобщённым ЕМ-алгоритмом (generalized EM-algorithm, GEM) [39]. Проблема выбора начального приближения. Алгоритм EM сходится при до- статочно общих предположениях к локальному оптимуму. Качество этого решения и скорость сходимости существенно зависят от начального приближения. Сходимость ухудшается в тех случаях, когда делается попытка поместить несколько компонент в один фактический сгусток распределения, либо разместить компоненту посередине между сгустками. Стандартная (но далеко не самая лучшая) эвристика заключается в том, чтобы выбрать параметры начальных компонент случайным образом. Дру- гая идея взять в качестве центров компонент k объектов, максимально удалённых
36 К.В.Воронцов. Вычислительные методы обучения по прецедентам Алгоритм 2.3. EM-алгоритм с последовательным добавлением компонент Вход: выборка Xm = {x1, . . . , xm}; R максимальный допустимый разброс правдоподобия объектов; m0 минимальная длина выборки, по которой можно восстановить плотность; ? параметр критерия останова; Выход: k число компонент смеси; = (wj , ?j)kj=1 веса и параметры компонент; 1: начальное приближение одна компонента: ?1 := argmax ? mPi=1 ln ?(xi; ?); w1 := 1; k := 1; 2: для всех k := 2, 3, . . . 3: выделить объекты с низким правдоподобием: U := {xi ? Xm: p(xi) < max j p(xj)/R}; 4: если |U| < m0 то 5: выход из цикла по k; 6: начальное приближение для k-й компоненты: ?k := argmax ? P xi?U ln ?(xi; ?); wk := 1m|U|; wj := wj(1 ? wk), j = 1, . . . , k ? 1; 7: EM (Xm, k,, ?); друг от друга. Можно стартовать итерационный процесс много раз из различных начальных приближений и затем выбрать наилучшее решение. EM-алгоритм с последовательным добавлением компонент позволяет решить две проблемы сразувыбора начального приближения и выбора числа компонент. Идея заключается в следующем. Имея некоторый набор компонент, можно выделить объекты xi, которые хуже всего описываются смесьюэто объекты с наименьшими значениями правдоподобия p(xi). По этим объектам строится ещё одна компонента. Затем она добавляется в смесь и запускаются EM-итерации, чтобы новая компонента и старые ?притёрлись друг к другу?. Так продолжается до тех пор, пока все объекты не окажутся покрыты компонентами. Реализация этой идеи представлена в Алгоритме 2.3. На шаге 1 строится первая компонента и полагается k = 1. Затем в цикле последовательно добавляется по од- ной компоненте. Если значение правдоподобия p(xi) в R раз меньше максимального значения правдоподобия, значит объект xi плохо описывается смесью. Заметим, что это лишь эвристика; совсем не обязательно сравнивать p(xi) именно с максимальным правдоподобием; можно брать среднее правдоподобие или фиксированное пороговое значение P0. На шаге 3 формируется подвыборка U из объектов, которые не под- ходят ни к одной из компонент. Если длина этой подвыборки меньше порога m0, то процесс добавления компонент на этом заканчивается, и оставшиеся объекты счи- таются выбросами. На шаге 6 снова применяется метод максимума правдоподобия для формирования новой компоненты, но теперь уже не по всей выборке, а только
37 по подвыборке U. Веса компонент пересчитываются таким образом, чтобы их сум- ма по-прежнему оставалась равной единице. На шаге 7 все предыдущие компоненты вместе с новой компонентой проходят через цикл итераций EM-алгоритма. Стохастический EM-алгоритм. Максимизируемый функционал Q() в общем случае может иметь большое количество локальных экстремумов. Поэтому EM- алгоритму присущи обычные недостатки любого детерминированного процесса мно- гоэкстремальной оптимизации: застревание в локальных максимумах, зависимость решения от начального приближения, медленная сходимость при неудачном выборе начального приближения. Обычно такого рода недостатки преодолеваются методами адаптивной стохастической оптимизации. Описание одного из вариантов стохастического EM-алгоритма (stochastic EM- algorithm, SEM) можно найти в [1, стр. 207]. Основное отличие от Алгоритма 2.2 в том, что на M-шаге (шаг 4) вместо максимизации взвешенного правдоподобия ?j := argmax ? Xm i=1 gij ln ?(xi; ?) решается задача максимизации обычного, невзвешенного, правдоподобия ?j := argmax ? Xxi?Xj ln ?(xi; ?), где выборки Xj генерируются из Xm путём стохастического моделирования. Для каждого объекта xi ? Xm разыгрывается случайное значение j(i) из дискрет- ного распределения вероятностей {gij : j = 1, . . . , k}, и объект xi ? Xm включается только в выборку Xj(i). В [1] описана другая стратегия там число компонент k последовательно уменьшается, начиная с некоторого заведомо избыточного числа kmax. Если ком- понента оказывается слишком малочисленной, |Xj | 6 m0, то она вовсе удаляется. Возможно также совмещение обеих стратегий. Преимущества SEM обусловлены тем, что рандомизация ?выбивает? оптимиза- ционный процесс из локальных максимумов. SEM работает быстрее обычного детер- минированного EM, и его результаты меньше зависят от начального приближения. Как правило, SEM находит экстремум Q(), более близкий к глобальному. 2.4.2 Смеси многомерных нормальных распределений Рассмотрим решение задачи M-шага в частном случае, когда компоненты име- ют нормальные (гауссовские) плотности. В этом случае функционал (2.20) является квадратичным и положительно определенным, поэтому решение выписывается в яв- ном аналитическом виде. Гауссовские смеси общего вида. Теорема 2.6. Пусть компоненты смеси имеют n-мерные нормальные распределе- ния ?(x; ?j) = N(x; ?j ,j) с параметрами ?j = (?j ,j), где ?j ? Rn вектор мато- жидания, j ? Rn?n ковариационная матрица, j = 1, . . . , k. Тогда стационарная
38 К.В.Воронцов. Вычислительные методы обучения по прецедентам точка оптимизационной задачи (2.20) имеет вид ??j = 1 mwjXm i=1 gijxi, j = 1, . . . , k; ?j = 1 mwj Xm i=1 gij(xi ? ??j)(xi ? ??j)т, j = 1, . . . , k. Таким образом, M-шаг сводится к вычислению выборочного среднего и выбо- рочной ковариационной матрицы для каждой компоненты смеси со своим распре- делением весов объектов. Вес i-го объекта для j-й компоненты равен gij оценке принадлежности данного объекта данной компоненте, вычисленной на E-шаге. Смеси многомерных нормальных распределений позволяют приближать любые непрерывные плотности вероятности. Они являются универсальными аппроксимато- рами плотностей, подобно тому, как полиномы являются универсальными аппрокси- маторами непрерывных функций. В практических задачах это позволяет восстанав- ливать функции правдоподобия классов даже в тех случаях, когда на первый взгляд для выполнения условий Теоремы 2.6 нет содержательных оснований. Недостатком гауссовских смесей является необходимость обращать ковариа- ционные матрицы. Это трудоёмкая операция. Кроме того, ковариационные матри- цы нередко оказываются вырожденными или плохо обусловленными, что приводит к неустойчивости выборочных оценок плотности и самого классификатора. Стан- дартные приёмы (регуляризация, метод главных компонент) позволяют справиться с этой проблемой. Но есть и другой выход использовать для описания компонент более простые распределения, например, сферические. Гауссовские смеси c диагональными матрицами ковариации. Трудоёмкого об- ращения матриц можно избежать, если принять гипотезу, что в каждой компоненте смеси признаки некоррелированы. В этом случае гауссианы упрощаются, оставаясь, тем не менее, универсальными аппроксиматорами плотности. Теорема 2.7. Пусть компоненты смеси имеют n-мерные нормальные распределе- ния с параметрами (?j ,j), где ?j = (?j1, . . . , ?jn), j = diag(?2j1, . . . , ?2jn) диаго- нальная матрица, j = 1, . . . , k: ?(x; ?j) = N(x; ?j ,j) = Yn d=1 1 ?jdv2? exp?12?d ? ?jd ?jd 2, x = (?1, . . . , ?n). Тогда стационарная точка оптимизационной задачи (2.20) имеет вид ??jd = 1 mwj Xm i=1 gijxid, d = 1, . . . , n; ??2jd = 1 mwj Xm i=1 gij(xid ? ??jd)2, d = 1, . . . , n; где xi = (xi1, . . . , xin) объекты выборки Xm.
39 Доказательство. Продифференцируем логарифм нормальной плотности N(x; ?j ,j) по параметрам ?jd, ?jd в точке xi = (xi1, . . . , xin): ? ??jd lnN(xi; ?j ,j) = ??2 jd (xid ? ?jd); ? ??jd lnN(xi; ?j ,j) = ???1 jd + ??3 jd (xid ? ?jd)2. Приравняем нулю производные взвешенного функционала правдоподобия по параметрам ?jd, ?jd: ???2 jd Xm i=1 gij(xid ? ?jd) = 0; ??3 jd Xm i=1 gij ???2jd ? (xid ? ?jd)2= 0. Отсюда, вынося параметры ?jd, ?jd за знак суммирования по i, и применяя соотношение (2.19), получаем требуемое. Можно было бы пойти дальше и предположить, что компоненты имеют сфери- ческие плотности, j = ?2j In. Однако такое предположение имеет очевидный недоста- ток: если признаки существенно различаются по порядку величины, то компоненты будут иметь сильно вытянутые формы, которые придётся аппроксимировать боль- шим количеством сферических гауссианов. Предположение о неравных дисперсиях признаков приводит к алгоритму классификации, не чувствительному к различиям в масштабах измерения признаков. Радиальные функции. Гауссиан pj(x) = N(x; ?j ,j) с диагональной матрицей j можно записать в виде pj(x) = Nj exp ???12?2j(x, ?j), где Nj = (2?)?n2 (?j1 - - - ?jn)?1 нормировочный множитель, ?j(x, x')взвешенная евклидова метрика в n-мерном пространстве X: ?2j(x, x') = Xn d=1 ??2 jd |?d ? ?'d |2, x = (?1, . . . , ?n), x' = (?'1, . . . , ?'n). Чем меньше расстояние ?j(x, ?j), тем выше значение плотности в точке x. По- этому плотность pj(x) есть функция близости вектора x к центру ?j . Функции f(x), зависящие только от расстояния между x и фиксированной точ- кой пространства X, принято называть радиальными. 2.4.3 Сеть радиальных базисных функций Выше мы рассматривали задачу разделения смеси распределений, забыв на вре- мя об исходной задаче классификации. Пусть теперь Y = {1, . . . ,M}, каждый класс y ? Y имеет свою плотность распределения py(x) и представлен частью выборки X?y = {(xi, yi) ? X? | yi = y}.
40 К.В.Воронцов. Вычислительные методы обучения по прецедентам 8?9>x:=;< - - - p11(x) - - - p1k1(x) pM1(x) - - - pMkM(x) P- - - P arg max a(x) 55 22 ,, )) w11 YYYY ,,YYYY w1k1 gggg 33 ggg wM1 WWWW ++WWW wMkM eee 22ee ?1P1 JJ JJ $$JJ ?MPM tt tt ::tt // Рис. 5. Сеть радиальных базисных функций представляет собой трёхуровневую суперпозицию. Пусть функции правдоподобия классов py(x), y ? Y , представимы в виде смесей ky компонент. Каждая компонента имеет n-мерную гауссовскую плотность с пара- метрами ?yj = (?yj1, . . . , ?yjn), yj = diag(?2yj1, . . . , ?2yjn), j = 1, . . . , ky: py(x) = Xky j=1 wyjpyj(x), pyj(x) = N(x; ?yj ,yj), Xky j=1 wyj = 1, wyj > 0. Алгоритм классификации. Запишем байесовское решающее правило (2.2), выра- зив плотность каждой компоненты pyj(x) через взвешенное евклидово расстояние от объекта x до центра компоненты ?yj : a(x) = argmax y?Y ?yPy Xky j=1 wyj Nyj exp ???12?2yj(x, ?yj)| {z } pyj (x) , (2.21) где Nyj = (2?)?n2 (?yj1 - - - ?yjn)?1 нормировочные множители. Алгоритм имеет вид суперпозиции, состоящей из трёх уровней или слоёв, Рис 5. Первый слой образован k1 + - - - + kM гауссианами pyj(x), y ? Y , j = 1, . . . , ky. На входе они принимают описание объекта x, на выходе выдают оценки близости объекта x к центрам ?yj , равные значениям плотностей компонент в точке x. Второй слой состоит из M сумматоров, вычисляющих взвешенные средние этих оценок с весами wyj . На выходе второго слоя появляются оценки принадлежности объекта x каждому из классов, равные значениям плотностей классов pyj(x). Третий слой образуется единственным блоком argmax, принимающим оконча- тельное решение об отнесении объекта x к одному из классов. Таким образом, при классификации объекта x оценивается его близость к каж- дому из центров ?yj по метрике ?yj(x, ?yj), j = 1, . . . , ky. Объект относится к тому классу, к чьим центрам он располагается ближе. Описанный трёхуровневый алгоритм классификации называется сетью c ради- альными базисными функциями или RBF-сетью (radial basis function network). Это одна из разновидностей нейронных сетей. Обучение RBF-сети сводится к восстановлению плотностей классов py(x) с помо- щью EM-алгоритма. Результатом обучения являются центры ?yj и дисперсии yj
41 компонент j = 1, . . . , ky. Оценивая дисперсии, мы фактически подбираем веса при- знаков в метриках ?yj(x, ?yj) для каждого центра ?yj . При использовании Алгорит- ма 2.3 для каждого класса определяется оптимальное число компонент смеси. Преимущества EM-алгоритма. По сравнению с широко известными градиентны- ми методами настройки нейронных сетей (см. главу 6), EM-алгоритм более устойчив к шуму и быстрее сходится. Кроме того, он описывает каждый класс как совокуп- ность компонент или кластеров, что позволяет лучше понимать внутреннюю струк- туру данных. В частности, центры сферических гауссовских компонент ?yj можно интерпретировать как виртуальные эталонные объекты, с которыми сравниваются классифицируемые объекты. Во многих прикладных задачах виртуальным этало- нам удаётся подыскать содержательную интерпретацию. Например, в медицинской дифференциальной диагностике это может быть определённая (j-я) форма данно- го (y-го) заболевания. Информация о том, что классифицируемый объект близок именно к этому эталону, может быть полезной при принятии решений. EM-алгоритм может также использоваться для решения задач кластеризации, о чём пойдёт речь в главе 7.
42 К.В.Воронцов. Вычислительные методы обучения по прецедентам 3 Метрические методы классификации Во многих прикладных задачах измерять степень сходства объектов существен- но проще, чем формировать признаковые описания. Например, такие сложные объек- ты, как фотографии лиц, подписи, временные ряды или первичные структуры белков естественнее сравнивать непосредственно с друг с другом путём некоторого ?наложе- ния с выравниванием?, чем изобретать какие-то признаки и сравнивать признаковые описания. Если мера сходства объектов введена достаточно удачно, то, как правило, оказывается, что схожим объектам очень часто соответствуют схожие ответы. В зада- чах классификации это означает, что классы образуют компактно локализованные подмножества. Это предположение принято называть гипотезой компактности5. Для формализации понятия ?сходства? вводится функция расстояния в простран- стве объектов X. Методы обучения, основанные на анализе сходства объектов, будем называть метрическими, даже если функция расстояния не удовлетворяет всем ак- сиомам метрики (в частности, аксиоме треугольника). В англоязычной литературе употребляются термины similarity-based learning или distance-based learning. :3.1 Метод ближайшего соседа и его обобщения Пусть на множестве объектов X задана функция расстояния ?: X?X > [0,?). Существует целевая зависимость y? : X > Y , значения которой известны только на объектах обучающей выборки X? = (xi, yi)?i=1, yi = y?(xi). Множество классов Y конечно. Требуется построить алгоритм классификации a: X > Y , аппроксимирую- щий целевую зависимость y?(x) на всём множестве X. 3.1.1 Обобщённый метрический классификатор Для произвольного объекта u ? X расположим элементы обучающей выборки x1, . . . , x? в порядке возрастания расстояний до u: ?(u, x(1) u ) 6 ?(u, x(2) u ) 6 - - - 6 ?(u, x(?) u ), где через x(i) u обозначается i-й сосед объекта u. Соответственно, ответ на i-м соседе объекта u есть y(i) u = y?(x(i) u ). Таким образом, любой объект u ? X порождает свою перенумерацию выборки. Опр. 3.1. Метрический алгоритм классификации с обучающей выборкой X? от- носит объект u к тому классу y ? Y , для которого суммарный вес ближайших обу- чающих объектов ??y(u,X?) максимален: a(u;X?) = argmax y?Y ??y(u,X?); ??y(u,X?) =X? i=1 [y(i) u = y]w(i, u); (3.1) где весовая функция w(i, u) оценивает степень важности i-го соседа для классифика- ции объекта u. Функция ??y(u,X?) называется оценкой близости объекта u к классу y. 5 В математике компактными принято называть ограниченные замкнутые множества. Гипотеза компактности не имеет ничего общего с этим понятием, и должна пониматься скорее в ?бытовом? смысле этого слова.
43 Метрический классификатор определён с точностью до весовой функции w(i, u). Обычно она выбирается неотрицательной, не возрастающей по i. Это соответству- ет гипотезе компактности, согласно которой чем ближе объекты u и x(i) u , тем выше шансы, что они принадлежат одному классу. Обучающая выборка X? играет роль параметра алгоритма a. Настройка сво- дится к запоминанию выборки, и, возможно, оптимизации каких-то параметров ве- совой функции, однако сами объекты не подвергаются обработке и сохраняются ?как есть?. Алгоритм a(u;X?) строит локальную аппроксимацию выборки X?, причём вы- числения откладываются до момента, пока не станет известен объект u. По этой при- чине метрические алгоритмы относятся к методам ленивого обучения (lazy learning), в отличие от усердного обучения (eager learning), когда на этапе обучения строится функция, аппроксимирующая выборку. Метрические алгоритмы классификации относятся также к методам рассужде- ния по прецедентам (case-based reasoning, CBR). Здесь действительно можно гово- рить о ?рассуждении?, так как на вопрос ?почему объект u был отнесён к классу y?? алгоритм может дать понятное экспертам объяснение: ?потому, что имеются схожие с ним прецеденты класса y?, и предъявить список этих прецедентов. Выбирая весовую функцию w(i, u), можно получать различные метрические классификаторы, которые подробно рассматриваются ниже. 3.1.2 Метод ближайших соседей Алгоритм ближайшего соседа (nearest neighbor, NN) относит классифицируемый объект u ? X? к тому классу, которому принадлежит ближайший обучающий объект: w(i, u) = [i = 1]; a(u;X?) = y(1) u . Этот алгоритм является, по всей видимости, самым простым классификатором. Обучение NN сводится к запоминанию выборки X?. Единственное достоинство этого алгоритма простота реализации. Недостатков гораздо больше: : Неустойчивость к погрешностям. Если среди обучающих объектов есть вы- брос объект, находящийся в окружении объектов чужого класса, то не только он сам будет классифицирован неверно, но и те окружающие его объекты, для которых он окажется ближайшим. : Отсутствие параметров, которые можно было бы настраивать по выборке. Алгоритм полностью зависит от того, насколько удачно выбрана метрика ?. : В результате низкое качество классификации. Алгоритм k ближайших соседей (k nearest neighbors, kNN). Чтобы сгладить вли- яние выбросов, будем относить объект u к тому классу, элементов которого окажется больше среди k ближайших соседей x(i) u , i = 1, . . . , k: w(i, u) = [i 6 k]; a(u;X?, k) = argmax y?Y Xk i=1 [y(i) u = y]. При k = 1 этот алгоритм совпадает с предыдущим, следовательно, неустойчив к шуму. При k = ?, наоборот, он чрезмерно устойчив и вырождается в константу.
44 К.В.Воронцов. Вычислительные методы обучения по прецедентам Таким образом, крайние значения k нежелательны. На практике оптимальное зна- чение параметра k определяют по критерию скользящего контроля с исключением объектов по одному (leave-one-out, LOO). Для каждого объекта xi ? X? проверяется, правильно ли он классифицируется по своим k ближайшим соседям. LOO(k,X?) =X? i=1 ha??xi;X?\{xi}, k6= yii > min k . Заметим, что если классифицируемый объект xi не исключать из обучающей выборки, то ближайшим соседом xi всегда будет сам xi, и минимальное (нулевое) значение функционала LOO(k) будет достигаться при k = 1. Существует и альтернативный вариант метода kNN: в каждом классе выбира- ется k ближайших к u объектов, и объект u относится к тому классу, для которого среднее расстояние до k ближайших соседей минимально. Алгоритм k взвешенных ближайших соседей. Недостаток kNN в том, что мак- симум может достигаться сразу на нескольких классах. В задачах с двумя классами этого можно избежать, если взять нечётное k. Более общая тактика, которая годит- ся и для случая многих классов ввести строго убывающую последовательность вещественных весов wi, задающих вклад i-го соседа в классификацию: w(i, u) = [i 6 k]wi; a(u;X?, k) = argmax y?Y Xk i=1 [y(i) u = y]wi. Выбор последовательности wi является эвристикой. Если взять линейно убыва- ющие веса wi = k+1?i k , то неоднозначности также могут возникать, хотя и реже (при- мер: классов два; первый и четвёртый сосед голосуют за класс 1, второй и третий за класс 2; суммы голосов совпадают). Неоднозначность устраняется окончатель- но, если взять нелинейно убывающую последовательность, скажем, геометрическую прогрессию: wi = qi, где знаменатель прогрессии q ? (0, 1) является параметром алгоритма. Его можно подбирать по критерию LOO, аналогично числу соседей k. Недостатки простейших метрических алгоритмов типа kNN. : Приходится хранить обучающую выборку целиком. Это приводит к неэф- фективному расходу памяти и чрезмерному усложнению решающего правила. При наличии погрешностей (как в исходных данных, так и в модели сходства ?) это может приводить к понижению точности классификации вблизи границы классов. Имеет смысл отбирать минимальное подмножество эталонных объек- тов, действительно необходимых для классификации. : Поиск ближайшего соседа предполагает сравнение классифицируемого объекта со всеми объектами выборки за O(?) операций. Для задач с большими выбор- ками или высокой частотой запросов это может оказаться накладно. Пробле- ма решается с помощью эффективных алгоритмов поиска ближайших соседей, требующих в среднем O(ln ?) операций. : В простейших случаях метрические алгоритмы имеют крайне бедный набор параметров, что исключает возможность настройки алгоритма по данным.
45 3.1.3 Метод парзеновского окна Ещё один способ задать веса соседям определить wi как функцию от рассто- яния ?(u, x(i) u ), а не от ранга соседа i. Введём функцию ядра K(z), невозрастающую на [0,?). Положив w(i, u) = K?? 1h?(u, x(i) u )в общей формуле (3.1), получим алгоритм a(u;X?, h) = argmax y?Y X? i=1 [y(i) u = y]K?(u, x(i) u ) h . (3.2) Параметр h называется шириной окна и играет примерно ту же роль, что и чис- ло соседей k. ?Окно? это сферическая окрестность объекта u радиуса h, при попа- дании в которую обучающий объект xi ?голосует? за отнесение объекта u к классу yi. Мы пришли к этому алгоритму чисто эвристическим путём, однако он имеет более строгое обоснование в байесовской теории классификации, и, фактически, совпадает с методом парзеновского окна. Параметр h можно задавать априори или определять по скользящему кон- тролю. Зависимость LOO(h), как правило, имеет характерный минимум, поскольку слишком узкие окна приводят к неустойчивой классификации; а слишком широкие к вырождению алгоритма в константу. Фиксация ширины окна h не подходит для тех задач, в которых обучающие объекты существенно неравномерно распределены по пространству X. В окрестно- сти одних объектов может оказываться очень много соседей, а в окрестности дру- гих ни одного. В этих случаях применяется окно переменной ширины. Возьмём финитное ядро невозрастающую функцию K(z), положительную на отрезке [0, 1], и равную нулю вне его. Определим h как наибольшее число, при котором ровно k ближайших соседей объекта u получают ненулевые веса: h(u) = ?(u, x(k+1) u ). Тогда алгоритм принимает вид a(u;X?, k) = argmax y?Y Xk i=1 [y(i) u = y]K  ?(u, x(i) u ) ?(u, x(k+1) u )!. (3.3) Заметим, что при финитном ядре классификация объекта сводится к поиску его соседей, тогда как при не финитном ядре (например, гауссовском) требуется перебор всей обучающей выборки. Выбор ядра обсуждается также в разделе 2.2.2. 3.1.4 Метод потенциальных функций В методе парзеновского окна центр радиального ядра Kh(u, x) = K?? 1h?(u, x)помещается в классифицируемый объект u. В силу симметричности функции рас- стояния ?(u, x) возможен и другой, двойственный, взгляд на метрическую класси- фикацию. Допустим, что ядро помещается в каждый обучающий объект xi и ?при- тягивает? объект u к классу yi, если он попадает в его окрестность радиуса hi: a(u;X?) = argmax y?Y X? i=1 [yi = y] ?i K?(u, xi) hi , ?i > 0, hi > 0. (3.4) По сути, эта формула отличается от (3.3) только тем, что здесь ширина окна hi зависит от обучающего объекта xi, а не от классифицируемого объекта u.
46 К.В.Воронцов. Вычислительные методы обучения по прецедентам Алгоритм 3.1. Метод потенциальных функций Вход: X? обучающая выборка; Выход: Коэффициенты ?i, i = 1, . . . , ? в (3.4); 1: Инициализация: ?i = 0; i = 1, . . . , ?; 2: повторять 3: выбрать объект xi ? X?; 4: если a(xi) 6= yi то 5: ?i := ?i + 1; 6: пока число ошибок на выборке не окажется достаточно мало Данная идея лежит в основе метода потенциальных функций [3] и имеет пря- мую физическую аналогию с электрическим потенциалом. При Y = {?1,+1} обуча- ющие объекты можно понимать как положительные и отрицательные электрические заряды; коэффициенты ?i как абсолютную величину этих зарядов; ядро K(z) как зависимость потенциала от расстояния до заряда; а саму задачу классифика- ции как ответ на вопрос: какой знак имеет электростатический потенциал в задан- ной точке пространства u. Заметим, что в электростатике K(z) = 1z либо 1 z+a , однако для наших целей совершенно не обязательно брать именно такое ядро. Алгоритм (3.4) имеет достаточно богатый набор из 2? параметров ?i, hi. Про- стейший и исторически самый первый метод их настройки представлен в Алгорит- ме 3.1. Он настраивает только веса ?i, предполагая, что радиусы потенциалов hi и ядро K выбраны заранее. Идея очень проста: если обучающий объект xi класси- фицируется неверно, то потенциал класса yi недостаточен в точке xi, и вес ?i уве- личивается на единицу. Выбор объектов на шаге 3 лучше осуществлять не подряд, а в случайном порядке. Этот метод не так уж плох, как можно было бы подумать. Условия его сходимости и многочисленные вариации исследованы в [3]. Достоинство Алгоритма 3.1 в том, что он очень эффективен, когда обучающие объекты поступают потоком, и хранить их в памяти нет возможности или необхо- димости. В те годы, когда метод потенциальных функций был придуман, хранение выборки действительно было большой проблемой. В настоящее время такой пробле- мы нет, и Алгоритм 3.1 представляет скорее исторический интерес. Недостатков у Алгоритма 3.1 довольно много: он медленно сходится; результат обучения зависит от порядка предъявления объектов; слишком грубо (с шагом 1) настраиваются веса ?i; центры потенциалов почему-то помещаются только в обу- чающие объекты; задача минимизации числа потенциалов (ненулевых ?i) вообще не ставится; вообще не настраиваются параметры hi. В результате данный алгоритм не может похвастаться высоким качеством классификации. Более современный метод настройки линейных комбинаций потенциальных функций, основанный на EM-алгоритме, рассматривается в :2.4. Он позволяет оп- тимизировать и ширину каждого потенциала, и положения центров, и даже количе- ство потенциалов. Изменилось и название метода: теперь потенциальные функции
47 предпочитают называть радиальными базисными функциями. Формально этот метод не подчиняется общей формуле (3.1), так как классифицируемый объект u сравни- вается не с обучающими объектами, а с центрами потенциалов, которые в общем случае не совпадают ни с одним из обучающих объектов. :3.2 Отбор эталонных объектов Обычно объекты обучения не являются равноценными. Среди них могут нахо- диться типичные представители классовэталоны. Если классифицируемый объ- ект близок к эталону, то, скорее всего, он принадлежит тому же классу. Ещё одна категория объектовнеинформативные или периферийные. Они плотно окружены другими объектами того же класса. Если их удалить из выборки, это практически не отразится на качестве классификации. Наконец, в выборку может попасть некото- рое количество шумовых выбросов объектов, находящихся ?в толще? чужого клас- са. Как правило, их удаление только улучшает качество классификации. Эти соображения приводят к идее исключить из выборки шумовые и неинфор- мативные объекты, оставив только минимальное достаточное количество эталонов. Этим достигается несколько целей одновременноповышается качество и устойчи- вость классификации, сокращается объём хранимых данных и уменьшается время классификации, затрачиваемое на поиск ближайших эталонов. Кроме того, выделе- ние небольшого числа эталонов в каждом классе позволяет понять структуру класса. В первую очередь введём функцию отступа, которая позволит оценивать сте- пень типичности объекта. 3.2.1 Понятие отступа объекта Общая формула (3.1) позволяет ввести характеристику объектов, показываю- щую, насколько глубоко объект погружён в свой класс. Опр. 3.2. Отступом (margin) объекта xi ? X? относительно алгоритма классифи- кации, имеющего вид a(u) = argmax y?Y ??y(u), называется величина M(xi) = ??yi(xi) ? max y?Y \yi ??y(xi). Отступ показывает степень типичности объекта. Отступ отрицателен тогда и только тогда, когда алгоритм допускает ошибку на данном объекте. В зависимости от значений отступа обучающие объекты условно делятся на пять типов, в порядке убывания отступа: эталонные, неинформативные, погранич- ные, ошибочные, шумовые, Рис. 6. : Эталонные объекты имеют большой положительный отступ, плотно окружены объектами своего класса и являются наиболее типичными его представителями. : Неинформативные объекты также имеют положительный отступ. Изъятие этих объектов из выборки (при условии, что эталонные объекты остаются), не влияет на качество классификации. Фактически, они не добавляют к этало- нам никакой новой информации. Наличие неинформативных объектов харак- терно для выборок избыточно большого объёма.
48 К.В.Воронцов. Вычислительные методы обучения по прецедентам 0 20 40 60 80 100 120 140 160 180 200 -0.6 -0.4 -0.20 0.2 0.4 0.6 0.8 i Marginшумы ошибки пограничные объекты надёжно классифицируемые объекты эталонные объекты Рис. 6. Упорядоченные по возрастанию отступов Mi объекты выборки, i = 1, . . . , 200. Условное деление объектов на пять типов. : Пограничные объекты имеют отступ, близкий к нулю. Классификация таких объектов неустойчива в том смысле, что малые изменения метрики или состава обучающей выборки могут изменять их классификацию. : Ошибочные объекты имеют отрицательные отступы и классифицируются неверно. Возможной причиной может быть неадекватность алгоритмической модели (3.1), в частности, неудачная конструкция метрики ?. : Шумовые объекты или выбросы это небольшое число объектов с большими отрицательными отступами. Они плотно окружены объектами чужих классов и классифицируются неверно. Они могут возникать из-за грубых ошибок или пропусков в исходных данных, а также по причине отсутствия важной инфор- мации, которая позволила бы отнести эти объекты к правильному классу. Приведённая типизация условна. Не существует чёткого различия между ?со- седними? типами объектов. В частности, легко строятся примеры выборок, содер- жащих такие пары близких объектов, что любой из них может быть объявлен эта- лонным, а второйнеинформативным. Шумовые и неинформативные целесообразно удалять из выборки. Соответству- ющий эвристический алгоритм будет описан ниже. Распределение значений отступов в выборке даёт полезную дополнительную информацию не только об отдельных объектах, но и о выборке в целом. Если основ- ная масса объектов имеет положительные отступы, то разделение выборки можно считать успешным. Если в выборке слишком много отрицательных отступов, то ги- потеза компактности не выполняется, и в данной задаче при выбранной метрике применять алгоритмы типа kNN нецелесообразно. Если значения отступов концен- трируются вблизи нуля, то ждать надёжной классификации не приходится, так как слишком много объектов оказываются в пограничной ?зоне неуверенности?. 3.2.2 Алгоритм STOLP для отбора эталонных объектов Идея отбора эталонов реализована в алгоритме STOLP [11]. Мы рассмотрим его обобщённый вариант с произвольной весовой функцией w(i, u). Будем строить метрический алгоритм a(u;) вида (3.1), где ? X? множество эталонов.
49 Алгоритм 3.2. Отбор эталонных объектов STOLP Вход: X? обучающая выборка; ? порог фильтрации выбросов; ?0 допустимая доля ошибок; Выход: Множество опорных объектов ? X?; 1: для всех xi ? X? проверить, является ли xi выбросом: 2: если M(xi,X?) < ? то 3: X??1 := X? \ {xi}; ? := ? ? 1; 4: Инициализация: взять по одному эталону от каждого класса: := arg max xi?X?y M(xi,X?)y ? Y ; 5: пока 6= X?; 6: Выделить множество объектов, на которых алгоритм a(u;) ошибается: E := {xi ? X? \ : M(xi,) < 0}; 7: если |E| < ?0 то 8: выход; 9: Присоединить к объект с наименьшим отступом: xi := argmin x?E M(x,); := ? {xi}; Обозначим через M(xi,) отступ объекта xi относительно алгоритма a(xi;). Большой отрицательный отступ свидетельствует о том, что объект xi окружён объ- ектами чужих классов, следовательно, является выбросом. Большой положительный отступ означает, что объект окружён объектами своего класса, то есть является либо эталонным, либо периферийным. Алгоритм 3.2 начинает с отсева выбросов (шаги 1-3). Из выборки X? исключа- ются все объекты xi с отступом M(xi,X?), меньшим заданного порога ?. Если взять ? = 0, то оставшиеся объекты будут классифицированы верно. Вместо ? можно за- давать долю исключаемых объектов с наименьшими значениями отступа. Затем формируется начальное приближение в заносится по одному наибо- лее типичному представителю от каждого класса (шаг 4). После этого начинается процесс последовательного ?жадного? наращивания множества . На каждом шаге к присоединяется объект xi, имеющий минимальное значение отступа. Так продолжается до тех пор, пока число ошибок не окажется меньше заданного порога ?0. Если положить ?0 = 0, то будет построен алгоритм a(u;), не допускающий ошибок на обучающих объектах, за исключением заранее исключённых выбросов. В результате каждый класс будет представлен в одним ?центральным? эта- лонным объектом и массой ?приграничных? эталонных объектов, на которых отступ принимал наименьшие значения в процессе итераций. Параметр ? позволяет регули- ровать ширину зазора между эталонами разных классов. Чем больше ?, тем дальше от границы классов будут располагаться ?приграничные? эталоны, и тем более про- стой, менее ?изрезанной? будет граница между классами.
50 К.В.Воронцов. Вычислительные методы обучения по прецедентам В описанном варианте алгоритм STOLP имеет относительно низкую эффек- тивность. Для присоединения очередного эталона необходимо перебрать множество объектов X? \ , и для каждого вычислить отступ относительно множества этало- нов . Общее число операций составляет O(||2?). Для ускорения алгоритма можно добавлять сразу по несколько эталонов, не пересчитывая отступов. Если при этом выбирать добавляемые эталоны достаточно далеко друг от друга, то добавление од- ного из них практически не будет влиять на отступы остальных. Аналогично, на эта- пе отсева выбросов можно вычислить отступы только один раз, и потом отбросить все объекты с отступами ниже ?. Реализация этих идей не показана в Алгоритме 3.2, чтобы не загромождать его техническими подробностями. Результатом работы алгоритма STOLP является разбиение обучающих объек- тов на три категории: шумовые, эталонные и неинформативные. Если гипотеза ком- пактности верна и выборка достаточно велика, то основная масса обучающих объ- ектов окажется неинформативной и будет отброшена. Фактически, этот алгоритм выполняет сжатие исходных данных.
51 4 Линейные методы классификации Линейные модели широко используются в машинном обучении благодаря их от- носительной простоте, в некоторых случаях хорошей интерпретируемости и наличию глубоко проработанных численных методов. Простейшим обоснованием линейного классификатора служит его аналогия с нервной клеткойнейроном. Персептрон- ные принципы обучения, первоначально заимствованные из нейрофизиологии, затем нашли математические обоснования и с точки зрения градиентных методов миними- зации эмпирического риска, и с точки зрения байесовской теории классификации, и с точки зрения статистических оценок обобщающей способности. :4.1 Аппроксимация и регуляризация эмпирического риска Рассмотрим задачу классификации с двумя классами, Y = {?1,+1}. Пусть модель алгоритмов представляет собой параметрическое семейство отоб- ражений a(x,w) = sign f(x,w), где w вектор параметров. Функция f(x,w) называ- ется дискриминантной функцией. Пока мы не будем предполагать, что она линейна по параметрам. Если f(x,w) > 0, то алгоритм a относит объект x к классу +1, иначе к классу ?1. Уравнение f(x,w) = 0 описывает разделяющую поверхность. Как обычно, задача обучения классификатора a(x,w) заключается в том, чтобы настроить вектор параметров w, имея обучающую выборку пар X? = (xi, yi)?i=1. Опр. 4.1. Величина Mi(w) = yif(xi,w) называется отступом (margin) объекта xi относительно алгоритма классификации a(x,w) = sign f(x,w). Если Mi(w) < 0, то алгоритм a(x,w) допускает ошибку на объекте xi. Чем боль- ше отступ Mi(w), тем правильнее и надёжнее классификация объекта xi. Минимизация аппроксимированного эмпирического риска. Определим функ- цию потерь вида L??Mi(w), где L(M)монотонно невозрастающая функция от- ступа, мажорирующая пороговую функцию потерь: [M < 0] 6 L(M). Тогда мини- мизацию суммарных потерь можно рассматривать как приближённый метод мини- мизации эмпирического рискачисла ошибок на обучающей выборке: Q(w,X?) =X? i=1 [Mi(w) < 0] 6 eQ(w,X?) = X? i=1 L??Mi(w)> min w . (4.1) Некоторые применяемые на практике функции потерь показаны на рис. 7. Квадратичная функция потерь не является монотонной, тем не менее, она соответ- ствует линейному дискриминанту Фишера. Кусочно-линейная функция потерь соот- ветствует методу опорных векторов (SVM), сигмоидная используется в нейронных сетях, логистическая в логистической регрессии, экспоненциальная в алгоритме бустинга AdaBoost, см. ??. Каждый из перечисленных методов имеет свою разумную мотивацию, однако все они приводят к разным функциям потерь. Все эти методы будут рассмотрены далее. Исходя из эвристического принципа максимизации отступов, невозможно от- ветить на ряд вопросов: какие ещё функции L(M) допустимы, какие из них более предпочтительны и в каких ситуациях.
52 К.В.Воронцов. Вычислительные методы обучения по прецедентам -5 -4 -3 -2 -1 0 1 2 3 4 5 012345 S L V E Q M Рис. 7. Непрерывные аппроксимации пороговой функции потерь [M < 0]. Q(M) = (1 ?M)2 квадратичная; V (M) = (1 ?M)+ кусочно-линейная; S(M) = 2(1 + eM)?1 сигмоидная; L(M) = log2(1 + e?M) логистическая; E(M) = e?M экспоненциальная. Вероятностная модель данных позволяет по-другому взглянуть на задачу. Допу- стим, множество X ? Y является вероятностным пространством, и вместо модели разделяющей поверхности f(x,w) задана параметрическая модель совместной плот- ности распределения объектов и классов p(x, y|w). Для настройки вектора параметров w по обучающей выборке X? применим принцип максимума правдоподобия. Найдём такое значение вектора параметров w, при котором наблюдаемая выборка X? максимально правдоподобна (совместная плотность распределения объектов выборки максимальна). Если выборка X? про- стая (состоит из независимых наблюдений, взятых из одного и того же распределения p(x, y|w)), то правдоподобие представляется в виде произведения: p(X?|w) =Y? i=1 p(xi, yi|w) > max w . Удобнее рассматривать логарифм правдоподобия: L(w,X?) = ln p(X?|w) = X? i=1 ln p(xi, yi|w) > max w . (4.2) Сопоставляя (4.2) с правой частью (4.1), легко заключить, что эти две задачи эквивалентны, если положить ?ln p(xi, yi|w) = L??yif(xi,w). Зная модель плотности p(x, y|w), можно выписать вид разделяющей поверх- ности f и функцию L. С другой стороны, задавая вид разделяющей поверхности и функцию потерь L, казалось бы, из чисто эвристических соображений, мы тем самым неявно принимаем некоторую вероятностную модель данных. Принцип максимума совместного правдоподобия данных и модели. Допустим, что наряду с параметрической моделью плотности распределения p(x, y|w) имеет- ся ещё априорное распределение в пространстве параметров модели p(w). Никакая модель не может быть идеальной, поэтому вряд ли параметрическое семейство плот- ностей p(x, y|w) содержит ту самую неизвестную плотность, которая породила вы- борку. Будем считать, что выборка может быть порождена каждой из плотностей p(x, y|w) с вероятностью p(w).
53 Чтобы ослабить априорные ограничения, вместо фиксированной функции p(w) вводится параметрическое семейство априорных распределений p(w; ?), где ? неиз- вестная и не случайная величина, называемая гиперпараметром. Исследователю разрешается варьировать значение гиперпараметра. При этом свойства модели могут изменяться радикальным образом, и появляется возможность найти такое значение гиперпараметра, при котором модель наиболее адекватна. Принцип максимума правдоподобия теперь будет записываться по-другому, по- скольку не только появление выборки X?, но и появление модели w также является случайным. Их совместное появление описывается, согласно формуле условной ве- роятности, плотностью распределения p(X?,w; ?) = p(X?|w)p(w; ?). Таким образом, приходим к принципу максимума совместного правдоподобия данных и модели: L?(w,X?) = ln p(X?,w; ?) =X? i=1 ln p(xi, yi|w) + ln p(w; ?) > max w . (4.3) Функционал L? распадается на два слагаемых: логарифм правдоподобия (4.2) и регуляризатор, не зависящий от данных. Второе слагаемое ограничивает вектор параметров модели, не позволяя ему быть каким угодно. Нормальный регуляризатор. Пусть вектор w ? Rn имеет нормальное распределе- ние, все его компоненты независимы и имеют равные дисперсии ?. Будем считать ? гиперпараметром. Логарифмируя, получаем квадратичный регуляризатор: ln p(w; ?) = ln1 (2??)n/2 exp?kwk2 2? = ? 1 2?kwk2 + const(w), где const(w) слагаемое, не зависящее от w, которым можно пренебречь, поскольку оно не влияет на решение оптимизационной задачи (4.3). Минимизация регуляризо- ванного эмпирического риска приводит в данном случае к выбору такого решения w, которое не слишком сильно отклоняется от нуля. В линейных классификаторах это позволяет избежать проблем мультиколлинеарности и переобучения. Лапласовский регуляризатор. Пусть вектор w ? Rn имеет априорное распределе- ние Лапласа, все его компоненты независимы и имеют равные дисперсии. Тогда ln p(w;C) = ln1 (2C)n exp?kwk1 C = ? 1Ckwk1 + const(w), kwk1 = Xn j=1 |wj |. Распределение Лапласа имеет более острый пик и более тяжёлые ?хвосты?, по сравнению с нормальным распределением. Его дисперсия равна 2C2. Самое интересное и полезное для практики свойство этого регуляризатора за- ключается в том, что он приводит к отбору признаков. Это происходит из-за того, что априорная плотность не является гладкой в точке w = 0. Запишем оптимизационную задачу настройки вектора параметров w: Q(w) = X? i=1 Li(w) + 1C Xn j=1 |wj | > min w ,
54 К.В.Воронцов. Вычислительные методы обучения по прецедентам где Li(w) = L(yif(xi,w))некоторая ограниченная гладкая функция потерь. Сде- лаем замену переменных, чтобы функционал стал гладким. Каждой переменной wj поставим в соответствие две новые неотрицательные переменные uj = 12??|wj |+wjи vj = 12??|wj |?wj. Тогда wj = uj?vj и |wj | = uj+vj . В новых переменных функционал становится гладким, но добавляются ограничения-неравенства: Q(u, v) =X? i=1 Li(u ? v) + 1C Xn j=1 (uj + vj) > min u,v ; uj > 0, vj > 0, j = 1, . . . , n. Для любого j хотя бы одно из ограничений uj > 0 и vj > 0 является активным, то есть обращается в равенство, иначе второе слагаемое в Q(u, v) можно было бы уменьшить, не изменив первое. Если гиперпараметр C устремить к нулю, то актив- ными в какой-то момент станут все 2n ограничений. Постепенное уменьшение гипер- параметра C приводит к увеличению числа таких j, для которых оба ограничения активны, uj = vj = 0, откуда следует, что wj = 0. В линейных моделях это означает, что значения j-го признака игнорируются, и его можно исключить из модели. Таким образом, для тех моделей, в которых обнуление коэффициента wj означа- ет исключение j-го признака, регуляризация Лапласа автоматически приводит к от- бору признаков (features selection). Параметр C позволяет регулировать селектив- ность метода. Чем меньше C, тем большее коэффициентов wj окажутся нулевыми. Независимые параметры с неравными дисперсиями. Возьмём гауссовскую мо- дель априорного распределения p(w), w ? Rn с независимыми параметрами wj , но теперь не будем предполагать, что дисперсии Cj параметров wj одинаковы: p(w) = 1 (2?)n/2vC1 - - -Cn exp? Xn j=1 w2j 2Cj. (4.4) Будем считать дисперсии Cj неизвестными и определять их наравне с самими пара- метрами wj исходя из принципа максимума совместного правдоподобия: Q(w) = X? i=1 Li(w) + 12 Xn j=1lnCj + w2j Cj > min w,C . Результатом такой модификации также является отбор признаков. Если Cj > 0, то параметр wj стремится к нулю, и на практике часто достигает машинного нуля. Если Cj > ?, то на параметр wj фактически не накладывается никаких ограниче- ний, и он может принимать любые значения. :4.2 Линейная модель классификации Пусть X пространство объектов; Y = {?1, 1} множество допустимых отве- тов; объекты описываются n числовыми признаками fj : X > R, j = 1, . . . , n. Вектор x = (x1, . . . , xn) ? Rn, где xj = fj(x), называется признаковым описанием объекта x.
55 Рис. 8. Нервная клетка (рисунок из Википедиисвободной энциклопедии). Если дискриминантная функция определяется как скалярное произведение век- тора x и вектора параметров w ? Rn, то получается линейный классификатор: a(x,w) = sign??hw, xi ? w0= signXn j=1 wjfj(x) ? w0. (4.5) Уравнение hw, xi = 0 задаёт гиперплоскость, разделяющую классы в простран- стве Rn. Если вектор x находится по одну сторону гиперплоскости с её направляю- щим вектором w, то объект x относится к классу +1, иначе к классу ?1. Параметр w0 иногда опускают. Иногда полагают, что среди признаков есть кон- станта, fj(x) ? ?1, и тогда роль свободного коэффициента w0 играет параметр wj . Устройство нервной клетки и модель МакКаллока-Питтса. Линейный клас- сификатор или персептрон является простейшей математической моделью нервной клеткинейрона, Рис 8. Нейрон имеет множество разветвлённых отростков денд- ритов, и одно длинное тонкое волокно аксон, на конце которого находятся синап- сы, примыкающие к дендритам других нервных клеток. Нервная клетка может на- ходиться в двух состояниях: обычном и возбуждённом. Клетка возбуждается, когда в ней накапливается достаточное количество положительных зарядов. В возбуждён- ном состоянии клетка генерирует электрический импульс величиной около 100 мВ и длительностью около 1 мс, который проходит по аксону до синапсов. Синапс при приходе импульса выделяет вещество, способствующее проникновению положитель- ных зарядов внутрь соседней клетки, примыкающей к данному синапсу. Синапсы имеют разную способность концентрировать это вещество, причём некоторые даже препятствуют его выделению они называются тормозящими. После возбуждения клетки наступает период релаксации некоторое время она не способна генериро- вать новые импульсы. Нервную клетку можно рассматривать как устройство, которое на каждом так- те своей работы принимает заряды величиной xj = fj(x) от n входов синапсов, примыкающих к её дендритам. Поступающие заряды складываются с весами wj . Если вес wj положительный, то j-й синапс возбуждающий, если отрицательный,
56 К.В.Воронцов. Вычислительные методы обучения по прецедентам -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 S TL G Z (z) = [z > 0] пороговая функция Хевисайда; (z) = (1 + e?z)?1 сигмоидная функция (S); th(z) = 2(2z) ? 1 гиперболический тангенс (T); ln(z + vz2 + 1) логарифмическая функция (L); exp(?z2/2) гауссовская функция (G); z линейная функция (Z); Рис. 9. Стандартные функции активации '(z). то тормозящий. Если суммарный заряд превышает порог активации w0, то нейрон возбуждается и выдаёт на выходе +1, иначе выдаётся ?1. Функцию ?(z) = sign(z), преобразующую значение суммарного импульса в вы- ходное значение нейрона, называют функцией активации. В общем случае это не обязательно пороговая функция. Используют также ?сглаженную? пороговую функ- цию гиперболический тангенс ?(z) = th(z) и другие, см. Рис. 9. Таким образом, линейный классификатор (4.5) является математической моде- лью нейрона. Эту модель предложили в 1943 году МакКаллок и Питтс [52]. Коннективизм и нейронные сети. Нервная система состоит из огромного чис- ла связанных друг с другом нейронов, распространяющих направленные волны им- пульсов. Скорость распространения импульсов составляет приблизительно 100 м/с. Человек способен решать сложные задачи распознавания и принятия решений за де- сятые доли секунды, откуда следует, что необходимые для этого нейровычисления выполняются не более чем за 102 последовательных тактов. Кора головного мозга человека содержит порядка 1011 нейронов, и каждый нейрон имеет синаптические связи с 103-104 других нейронов. Нейровычисления выполняются с большой сте- пенью параллелизма, и для принятия одного решения может быть задействовано огромное число нейронов. Есть гипотеза, что, соединив большое число элементарных классификаторов (скажем, линейных, но обязательно через нелинейные функции активации), возмож- но создать универсальную машину, способную обучаться решению любых задач, по- добно тому, как это делает человеческий мозг. На основе этой идеи, высказанной ещё в 50-е годы и названной принципом коннективизма, строятся искусственные нейронные сети. На самом деле механизмы функционирования нервных клеток гораздо сложнее описанных выше. В нейрофизиологии известны десятки различных типов нейронов, и многие из них функционируют иначе. Однако в теории искусственных нейронных сетей не ставится задача максимально точного воспроизведения функций биологиче- ских нейронов. Цель в том, чтобы подсмотреть некоторые принципы в живой природе и использовать их для построения обучаемых устройств. Мы начнём с линейных классификаторов, а к задачам обучения искусственных нейронных сетей вернёмся позже, через несколько лекций.
57 :4.3 Метод стохастического градиента Пусть задана обучающая выборка X? = (xi, yi)?i=1, xi ? Rn, yi ? {?1, 1}. Требуется найти вектор весов w ? Rn, при котором достигается минимум аппрокси- мированного эмпирического риска: Q(w,X?) =X? i=1 L??hw, xii yi> min w . (4.6) Применим для минимизации Q(w) метод градиентного спуска. В этом методе выбирается некоторое начальное приближение для вектора весов w, затем запускает- ся итерационный процесс, на каждом шаге которого вектор w изменяется в направле- нии наиболее быстрого убывания функционала Q. Это направление противоположно вектору градиента Q'(w) = ???Q(w) ?wj nj=1: w := w ? ?Q'(w), где ? > 0 величина шага в направлении антиградиента, называемая также темпом обучения (learning rate). Предполагая, что функция потерь L дифференцируема, распишем градиент: w := w ? ? X? i=1 L'??hw, xii yixiyi. (4.7) Каждый прецедент (xi, yi) вносит аддитивный вклад в изменение вектора w, но вектор w изменяется только после перебора всех ? объектов. Сходимость итера- ционного процесса можно улучшить, если выбирать прецеденты (xi, yi) по одному, для каждого делать градиентный шаг и сразу обновлять вектор весов: w := w ? ?L' a??hw, xii yixiyi. (4.8) В методе стохастического градиента (stochastic gradient, SG) прецеденты пе- ребираются в случайном порядке, см.Алгоритм 4.1. Если же объекты предъявлять в некотором фиксированном порядке, процесс может зациклиться или разойтись. Инициализация весов может производиться различными способами. Стандартная рекомендация взять небольшие случайные значения, wj := random??? 1 2n, 1 2n. Ино- гда веса инициализируют нулём. Иногда берут оценки wj := hy, fji hfj , fji, j = 1, . . . , n, (4.9) где fj = ??fj(xi)?i=1 вектор значений j-го признака, y = (yi)?i=1 вектор ответов. Эти оценки являются точными в одном нереалистичном частном случае когда функция потерь квадратична и признаки статистически независимы. Критерий останова в Алгоритме 4.1 основан на приблизительной оценке функцио- нала Q методом экспоненциальной скользящей средней. Вычисление точного значе- ния по всем ? объектам слишком вычислительно трудоёмко. Когда градиентный ме- тод подходит к окрестности минимума, оценка скользящего среднего стабилизирует- ся и приближается к точному значению функционала. Параметр ? можно положить равным 1/?. В случае избыточно длинной выборки его рекомендуется увеличивать.
58 К.В.Воронцов. Вычислительные методы обучения по прецедентам Алгоритм 4.1. Метод стохастического градиента. Вход: X? обучающая выборка; ? темп обучения; ? параметр сглаживания. Выход: Синаптические веса w1, . . . ,wn; 1: инициализировать веса wj , j = 1, . . . , n; 2: инициализировать текущую оценку функционала: Q := P?i=1L??hw, xii yi; 3: повторять 4: выбрать объект xi из X? (например, случайным образом); 5: вычислить выходное значение алгоритма a(xi,w) и ошибку: ?i := L??hw, xii yi; 6: сделать шаг градиентного спуска: w := w ? ?L'??hw, xii yixiyi; 7: оценить значение функционала: Q := (1 ? ?)Q + ??i; 8: пока значение Q не стабилизируется и/или веса w не перестанут изменяться; Преимущества метода SG. : Метод легко реализуется и легко обобщается на нелинейные классификаторы и на нейронные сети суперпозиции линейных классификаторов. : Метод подходит для динамического обучения, когда обучающие объекты по- ступают потоком, и вектор весов обновляется при появлении каждого объекта. : Метод позволяет настраивать веса на избыточно больших выборках, за счёт того, что случайной подвыборки может оказаться достаточно для обучения. Недостатки метода SG. : Функционал Q, как правило, многоэкстремальный, и процесс может сходиться к локальному минимуму, сходиться очень медленно или не сходиться вовсе. : При большой размерности пространства n или малой длине выборки ? возмож- но переобучение. При этом резко возрастает норма вектора весов, появляются большие по абсолютной величине положительные и отрицательные веса, клас- сификация становится неустойчивой малые изменения обучающей выборки, начального приближения, порядка предъявления объектов или параметров ал- горитма ?, ? могут сильно изменить результирующий вектор весов, увеличива- ется вероятность ошибочной классификации новых объектов. : Если функция потерь имеет горизонтальные асимптоты, то процесс может по- пасть в состояние ?паралича?. Чем больше значение скалярного произведения hw, xii, тем ближе значение производной L' к нулю, тем меньше приращение весов в (4.8). Если веса wj попали в область больших значений, то у них прак- тически не остаётся шансов выбраться из этой ?мёртвой зоны?.
59 4.3.1 Классические частные случаи Адаптивный линейный элемент. Рассмотрим случай, когда функция потерь квад- ратична, L(M) = (M ? 1)2. Тогда правило обновления весов на каждой итерации метода стохастического градиента примет вид w := w ? ???hw, xii ? yixi. (4.10) Это правило предложено Видроу и Хоффом в 1960 году и называется дельта- правилом (delta-rule), а сам линейный нейронадаптивным линейным элементом или ADALINE [66]. Это правило подходит также и для решения задач линейной регрессии, когда Y = R, a(x) = hw, xi и функция потерь имеет вид ??hw, xii ? yi2. Персептрон Розенблатта. В 1957 году Розенблатт предложил эвристический алго- ритм обучения нейрона, основанный на принципах нейрофизиологии. Эксперимен- тально было установлено, что при синхронном возбуждении двух связанных нервных клеток синаптическая связь между ними усиливается. Чем чаще синапс угадывает правильный ответ, тем сильнее становится связь. Своеобразная тренировка связи приводит к постепенному запоминанию информации. Если же синапс начинает ча- сто ошибаться или вообще перестаёт использоваться, связь ослабевает, информация начинается забываться. Таким образом, память реализуется в синапсах. В матема- тической модели нейрона роль памяти играет вектор синаптических весов w. Данное правило обучения нетрудно формализовать. Признаки будем пока по- лагать бинарными, fj(x) ? {0, 1}. Ответы также принимают только два значения, yi ? {?1, 1}. Допустим, что сразу после получения классификации объекта a(xi) становится известен правильный ответ yi. Возможны три случая. 1. Если ответ a(xi) совпадает с yi, то вектор весов изменять не нужно. 2. Если a(xi) = ?1 и yi = 1, то вектор весов w увеличивается. Увеличивать имеет смысл только те веса wj , для которых fj(xi) 6= 0; изменение других компонент не повлияет на результат. Положим w := w + ?xi, где ? > 0темп обучения. 3. Если a(xi) = 1 и yi = ?1, то вектор весов уменьшается: w := w ? ?xi. Эти три случая объединяются в так называемое правило Хэбба [45]: если hw, xii yi < 0 то w := w + ?xiyi. (4.11) Легко проверить, что оно в точности соответствует градиентному шагу (4.8), ес- ли взять кусочно-линейную функцию потерь L(M) = (?M)+. Однако формула (4.8) верна для произвольных признаков, не обязательно бинарных. Для правила Хэбба доказана теорема сходимости, которая также справедлива для произвольных действительных признаков. Теорема 4.1 (Новиков, 1962 [55]). Пусть X = Rn, Y = {?1, 1}, и выборка X? линейно разделима существует вектор ? w и положительное число ? такие, что h ? w, xii yi > ? для всех i = 1, . . . , ?. Тогда Алгоритм 4.1 с правилом Хэбба (4.11) за конечное число исправлений находит вектор весов, разделяющий обучающую вы- борку без ошибок, причём из любого начального приближения w0, при любом ? > 0, независимо от порядка предъявления объектов. Если w0 = 0, то достаточное число исправлений вектора весов не превосходит tmax = D? 2 , где D = max x?X? kxk.
60 К.В.Воронцов. Вычислительные методы обучения по прецедентам Доказательство. Запишем выражение для косинуса угла между вектором ? w и век- тором весов после t-го исправления wt, полагая без ограничения общности k ? wk = 1: cos([?w,wt) = h ? w,wti kwtk . При t-м исправлении нейрону с вектором весов wt?1 предъявляется обучающий объект x, правильный ответ y, и при этом нейрон совершает ошибку: hx,wt?1i y < 0. Согласно правилу Хэбба (4.11) в этом случае происходит модификация весов. В силу условия линейной разделимости, справедлива оценка снизу: ? w,wt= ? w,wt?1+ ? h ? w, xi y > ? w,wt?1+ ?? > ? w,w0+ t??. В силу ограниченности выборки, kxk < D, справедлива оценка сверху: kwtk2 = kwt?1k2 + ?2kxk2 + 2? x,wt?1y < kwt?1k2 + ?2D2 < kw0k2 + t?2D2. Подставим полученные соотношения в выражение для косинуса: cos([?w,wt) > h ? w,w0i + t?? pkw0k2 + t?2D2 > ? при t > ?. Косинус не может превышать единицы. Следовательно, при некотором доста- точно большом t не найдётся ни одного x ? X? такого, что hx,wti y < 0, то есть выборка окажется поделенной безошибочно. Если w0 = 0, то нетрудно оценить сверху достаточное число исправлений. Из условия cos 6 1 следует vt?/D 6 1, откуда tmax = (D/?)2. На практике линейная разделимость выборки является скорее исключением, чем правилом. Если условия теоремы Новикова не выполнены, то процесс обучения может оказаться расходящимся. 4.3.2 Эвристики для улучшения градиентных методов обучения В этом разделе рассматриваются эвристические приёмы и рекомендации, ком- пенсирующие недостатки градиентных методов обучения. Все они в полной мере относятся к обучению нейронных сетей, включая широко известный метод обратно- го распространения ошибок, который будет рассмотрен в :6.2. Различных тонкостей настолько много, что применение градиентного обучения по праву считается искус- ством, см. также обзор [50]. Нормализация данных. Градиентный метод чувствителен к масштабу измерения признаков. Если норма вектора объекта kxik принимает большие значения, а функ- ция потерь имеет горизонтальные асимптоты, то итерационный процесс может ока- заться ?парализованным?. Поэтому общей практикой является предварительная нор- мализация признаков: xj := xj ? xjmin xjmax ? xjmin , либо xj := xj ? xjср xjско , j = 1, . . . , n, где xjmin, xjmax, xjср, xjско соответственно минимальное, максимальное, среднее зна- чения и среднеквадратичное отклонение j-го признака.
61 Порядок предъявления объектов. Кроме стандартной рекомендации брать объ- екты в случайном порядке, имеются ещё следующие соображения. 1. Наибольшее смещение весов ожидается для того объекта, который наименее похож на объекты, предъявленные до него. В общем случае довольно трудно найти объект, максимально информативный на данном шаге обучения. Простая эвристи- ка заключается в том, чтобы попеременно предъявлять объекты из разных классов, поскольку объекты одного класса с большей вероятностью содержат схожую инфор- мацию. Эта техника называется перетасовкой объектов (shuffling). 2. Ещё одна эвристика состоит в том, чтобы чаще предъявлять те объекты, на которых была допущена ошибка. Для этого вероятность появления каждого объ- екта устанавливается пропорционально величине ошибки на данном объекте. Эту эвристику рекомендуется применять только в тех случаях, когда исходные данные не содержат выбросов, иначе процесс обучения может сосредоточиться на шумовых объектах, которые вообще следовало бы исключить из обучающей выборки. 3. Простая для реализации эвристика заключается в том, чтобы сравнить вели- чину ошибки на предъявленном объекте с некоторым порогом. Если ошибка окажет- ся меньше порога, вектор весов не модифицируется. Логика та же, что у персептрона Розенблатта: если объект неплохо классифицируется, то менять веса не нужно. При этом увеличивается и скорость настройки. Квадратичная регуляризация в теории нейронных сетей называется также сокра- щением весов (weights decay). Чтобы ограничить рост абсолютных значений весов, к минимизируемому функционалу Q(w) добавляется штрафное слагаемое: Q? (w) = Q(w) + ?2kwk2. Это приводит к появлению аддитивной поправки в градиенте: Q'? (w) = Q'(w) + ?w. В результате правило обновления весов принимает вид w := w(1 ? ?? ) ? ?Q'(w). Таким образом, вся модификация сводится к появлению неотрицательного множите- ля (1 ? ?? ), приводящего к постоянному уменьшению весов. Регуляризация предот- вращает паралич, повышает устойчивость весов в случае мультиколлинеарности, способствует повышению обобщающей способности алгоритма и снижению риска пе- реобучения. Управляющий параметр ? позволяет найти компромисс между точно- стью настройки на конкретную выборку и устойчивостью весов. Недостаток метода в том, что параметр ? приходится подбирать в режиме скользящего контроля, что связано с большими вычислительными затратами. Выбор величины шага. 1. Известно, что градиентные методы сходятся к локальному минимуму, если величину шага ? уменьшать с числом итераций t. Точнее, сходимость гарантируется при ?t > 0, P?t=1 ?t = ?, P?t=1 ?2t < ?, в частности можно положить ?t = 1/t. 2. В методе скорейшего градиентного спуска выбирается адаптивный шаг ?, который является решением одномерной задачи Q??w ? ?Q'(w)> min ? . Во многих случаях эту задачу удаётся решить аналитически [8]. В частности, для алгоритма ADALINE с квадратичной функцией потерь ? = kxik?2.
62 К.В.Воронцов. Вычислительные методы обучения по прецедентам Выбивание из локальных минимумов необходимо для предотвращения сходимо- сти к недостаточно хорошим локальным решениям. Один из простейших способов заключается в том, чтобы при каждой стабилизации функционала производить слу- чайные модификации вектора весов в довольно большой окрестности текущего значе- ния и запускать процесс градиентного спуска из новых точек. Этот приём называют встряхиванием коэффициентов (jog of weights). По сути дела, он является симбиозом градиентного метода и случайного локального поиска (stochastic local search). Ранний останов. Чрезмерная оптимизация может вести к переобучению. Узкий глобальный минимум функционала Q(w,X?) хуже более широкого, но устойчивого локального минимума. Для предотвращения попадания в такие ?расщелины? приме- няется ранний останова (early stopping): в ходе итераций вычисляется какой-нибудь внешний критерий (стр. ??), например, средняя потеря на независимой контрольной выборке, и если он начинает возрастать, процесс настройки прекращается. :4.4 Логистическая регрессия Метод логистической регрессии основан на довольно сильных вероятност- ных предположениях, которые имеют сразу несколько интересных последствий. Во- первых, линейный алгоритм классификации оказывается оптимальным байесовским классификатором. Во-вторых, однозначно определяется функция потерь. В-третьих, возникает интересная дополнительная возможность наряду с классификацией объек- та получать численные оценки вероятности его принадлежности каждому из классов. 4.4.1 Обоснование логистической регрессии В нормальном дискриминантном анализе доказывается, что если плотности классов нормальны и имеют равные матрицы ковариации, то оптимальный байе- совский классификатор линеен. Возникает вопрос: а только ли в этом случае? Ока- зывается, нетон остаётся линейным при менее жёстких предположениях. Базовые предположения. Пусть классов два, Y = {?1,+1}, объекты описыва- ются n числовыми признаками fj : X > R, j = 1, . . . , n. Будем полагать X = Rn, отождествляя объекты с их признаковыми описаниями: x ? (f1(x), . . . , fn(x)). Гипотеза 4.1. Множество прецедентов X ? Y является вероятностным простран- ством. Выборка прецедентов X? = (xi, yi)?i=1 получена случайно и независимо соглас- но вероятностному распределению с плотностью p(x, y) = Pypy(x) = P(y|x)p(x), где Py априорные вероятности, py(x) функции правдоподобия, P(y|x) апостери- орные вероятности классов y ? Y . Опр. 4.2. Плотность распределения p(x), x ? Rn называется экспонентной, если p(x) = exp??c(?) h?, xi + b(?, ?) + d(x, ?), где параметр ? ? Rn называется сдвигом, параметр ? называется разбросом, b, c, d произвольные числовые функции. Класс экспонентных распределений очень широк. К нему относятся многие непрерывные и дискретные распределения: равномерное, нормальное, гипергеомет- рическое, пуассоновское, биномиальное, ??-распределение, и другие.
63 Пример 4.1. Многомерное нормальное распределение с вектором матожидания ? ? Rn и ковариационной матрицей ? Rn?n является экспонентным с парамет- ром сдвига ? = ?1? и параметром разброса ? = : N(x; ?,) = (2?)?n2 ||?12 exp???12 (x ? ?)т?1(x ? ?)= = exp???т?1x | {z } h?,xi ? 12?т?1?1? | {z } b(?,?) ? 12xт?1x ? n2 ln(2?) ? 1 | {z 2 ln |}| d(x,?) . Гипотеза 4.2. Функции правдоподобия классов py(x) принадлежат экспонентному семейству плотностей, имеют равные значения параметров d и ?, но отличаются значениями параметра сдвига ?y. Основная теорема. Напомним, что оптимальный байесовский классификатор име- ет вид a(x) = argmax y?Y ?y P(y|x), где ?y штраф за ошибку на объектах класса y. В случае двух классов a(x) = sign???+ P(+1|x) ? ?? P(?1|x)= signP(+1|x) P(?1|x) ? ?? ?+. Теорема 4.2. Если справедливы гипотезы 4.1, 4.2, и среди признаков f1(x), . . . , fn(x) есть константа, то: 1) байесовский классификатор является линейным: a(x) = sign??hw, xi ? w0, где w0 = ln(??/?+), а вектор w не зависит от штрафов ??, ?+; 2) апостериорная вероятность принадлежности произвольного объекта x ? X классу y ? {?1,+1} может быть вычислена по значению дискриминантной функции: P(y|x) = ???hw, xi y, где ?(z) = 1 1+e?z сигмоидная функция. Доказательство. Рассмотрим отношение апостериорных вероятностей классов и воспользуемся тем, что py(x) экспонентные плотности с параметрами ?y и ?: P(+1|x) P(?1|x) = P+p+(x) P?p?(x) = exp??h(c+(?)?+ ? c?(?)??) | {z } w=const(x) , xi+b+(?, ?+) ? b?(?, ??) + ln P+ P? | {z } const(x) . Здесь вектор w не зависит от x и является вектором свободных коэффициентов при признаках. Все слагаемые под экспонентой, не зависящие от x, можно считать аддитивной добавкой к коэффициенту при константном признаке. Поскольку сво- бодные коэффициенты настраиваются по обучающей выборке, вычислять эту адди- тивную добавку нет никакого смысла, и её можно включить в hw, xi. Следовательно P(+1|x) P(?1|x) = ehw,xi. Используя формулу полной вероятности P(?1|x) + P(+1|x) = 1, нетрудно вы- разить апостериорные вероятности P(?1|x) и P(+1|x) через hw, xi: P(+1|x) = ???+hw, xi; P(?1|x) = ????hw, xi. Объединяя эти два равенства в одно, получаем требуемое: P(y|x) = ???hw, xi y. Разделяющая поверхность в байесовском решающем правиле определяется уравнением ?? P(?1|x) = ?+ P(+1|x), которое равносильно hw, xi ? ln ?? ?+ = 0, сле- довательно, разделяющая поверхность линейна. 
64 К.В.Воронцов. Вычислительные методы обучения по прецедентам -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0 0.5 1.0 1.5 2.0 2.5 3.0 0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 Mi Рис. 10. Логарифмическая функция потерь log2??1 + e?Miи её наклонная асимптота. -5 -4 -3 -2 -1 0 1 2 3 4 5 0 0.2 0.4 0.6 0.8 1.0 Mi Рис. 11. Правило Хэбба: пороговое [Mi < 0] и сглаженное (?Mi). 4.4.2 Метод стохастического градиента для логистической регрессии Принцип максимума правдоподобия. Для настройки вектора весов w по обуча- ющей выборке X? будем максимизировать логарифм правдоподобия выборки: L(w,X?) = log2Y? i=1 p(xi, yi) > max w . Согласно определению условной вероятности, p(x, y) = P(y|x)p(x), где плотно- сти распределения объектов p(x) не зависят от вектора параметров w. Апостериор- ные вероятности выражаются согласно Теореме 4.2 через линейную дискриминант- ную функцию: P(y|x) = ???hw, xi y. Таким образом, L(w,X?) = X? i=1 log2 ???hw, xii yi+ const(w) > max w . Максимизация правдоподобия L(w,X?) эквивалентна минимизации функцио- нала eQ(w,X?), гладко аппроксимирующего эмпирический риск (4.1): eQ(w,X?) = X? i=1 log2??1 + exp(?hw, xii yi)> min w . (4.12) Таким образом, логистическая функция потерь L(M) = log2??1+e?Mявляется следствием экспонентности классов и принципа максимума правдоподобия. Градиентный шаг. Запишем градиент функционала eQ(w), воспользовавшись вы- ражением для производной сигмоидной функции ?'(z) = ?(z)??1??(z)= ?(z)?(?z), и получим логистическое правило обновления весов для градиентного шага в методе стохастического градиента: w := w + ? yixi ????hw, xii yi, (4.13) где (xi, yi)предъявляемый прецедент, ? темп обучения.
65 Аналогия с правилом Хэбба. Логистическая функция потерь является сглажен- ным вариантом кусочно-линейной функции потерь, соответствующей правилу Хэбба, Рис. 10. Поэтому и логистическое правило (4.13) оказывается, в свою очередь, сгла- женным вариантом правила Хэбба (4.11), Рис. 11: w := w + ? yixi hw, xii yi < 0. В правиле Хэбба смещение весов происходит только когда на объекте xi допуска- ется ошибка. В логистическом правиле смещение тем больше, чем меньше отступ Mi(w) = hw, xii yi, то есть чем серьёзнее ошибка. Даже если ошибки нет, но объект близок к границе классов, веса модифицируются так, чтобы граница прошла как можно дальше от объекта. Тем самым градиентная минимизация реализует стра- тегию увеличения зазора (margin) между обучающими объектами и разделяющей поверхностью, что способствует улучшению обобщающей способности [31, 60]. О методах второго порядка. Для оптимизации весов w чаще используется метод Ньютона-Рафсона, описанный в главе о регрессионном анализе, см. 5.5.5. Он имеет более высокую скорость сходимости в окрестности локального оптимума, но требует решения линейной регрессионной задачи (следовательно, обращения ковариационной матрицы размера n?n) на каждой итерации. Отсюда и название методалогисти- ческая регрессия. Это регрессия ещё и потому, что для классифицируемого объекта x оценивается вещественная величина апостериорная вероятность P(+1|x). Сравнение с линейным дискриминантом Фишера. Линейный дискриминант Фи- шера (ЛДФ) и логистическая регрессия исходят из байесовского решающего правила и принципа максимума правдоподобия, однако результат получается разный. В ЛДФ приходится оценивать n|Y | + n(n + 1)/2 параметров (векторы средних для каждого класса и общую ковариационную матрицу), в логистической регрессиитолько n (вектор весов w). Почему? Дело в том, что ЛДФ решает вспомогательную задачу восстановления плотностей распределения классов, предполагая, что плотности нор- мальны. Логистическая регрессия опирается на более слабые предположения о виде плотностей. С точки зрения философского принципа Оккама ?не плодить сущно- сти без необходимости? логистическая регрессия явно предпочтительнее, поскольку ЛДФ вводит избыточную сущность и сводит задачу классификации к более сложной задаче восстановления плотностей. Достоинства логистической регрессии. : Как правило, логистическая регрессия даёт лучшие результаты по сравнению с линейным дискриминантом Фишера (поскольку она основана на менее жёст- ких гипотезах), а также по сравнению с дельта-правилом и правилом Хэбба (поскольку она использует ?более правильную? функцию потерь). : Возможность оценивать апостериорные вероятности и риски. Недостатки логистической регрессии. : Оценки вероятностей и рисков могут оказаться неадекватными, если не выпол- няются предположения Теоремы 4.2.
66 К.В.Воронцов. Вычислительные методы обучения по прецедентам : Градиентный метод обучения логистической регрессии наследует все недостат- ки метода стохастического градиента. Практичная реализация должна преду- сматривать стандартизацию данных, отсев выбросов, регуляризацию (сокраще- ние весов), отбор признаков, и другие эвристики для улучшения сходимости. Возможно применение метода второго порядка, но он требует обращения n?n- матриц на каждом шаге и также не застрахован от плохой сходимости. 4.4.3 Скоринг и оценивание апостериорных вероятностей Скоринг. В случае бинарных признаков, X = {0, 1}n, можно полагать, что функ- ции правдоподобия классов py(x) описываются биномиальными распределениями, следовательно, являются экспонентными. Это соображение служит дополнительным обоснованием бинаризации признаков, когда каждый небинарный исходный признак заменяется одним или несколькими бинарными. В бинарном случае вычисление линейной дискриминантной функции удобно рассматривать как подсчёт баллов (score): если fj(x) = 1, то есть признак fj наблю- дается у объекта x, то к сумме баллов добавляется вес wj . Классификация произво- дится путём сравнения набранной суммы баллов с пороговым значением w0. Благодаря свой простоте подсчёт баллов или Рис. 12. Фрагмент скоринговой карты для задачи принятия кре- дитных решений. скоринг (scoring) пользуется большой популярностью в таких областях, как медицина, геология, банков- ское дело, социология, маркетинг, и др. Абсолютное значение веса wj можно интерпретировать как сте- пень важности признака fj , а знак sign(wj) показывает, в пользу какого класса свидетельствует наличие дан- ного признака. Это важная дополнительная информа- ция о признаках, помогающая экспертам лучше пони- мать и задачу, и классификатор. После бинаризации признаков классификатор представляется в виде так называемой скоринговой карты (scorecard), в которой перечисляются все ис- ходные признаки, для каждого исходного все по- строенные по нему бинарные признаки, для каждого бинарного его вес. Имея такую карту, классифика- цию можно проводить с помощью стандартной элек- тронной таблицы или даже вручную. Рис. 12. Вероятностный выход и оценивание рисков Логистическая функция ? переводит значение линейной дискриминантной функции hw, xi в оценку апостериорной веро- ятности того, что объект x принадлежит классу +1: P(+1|x) = ? hw, xi. Это свойство используется в тех приложениях, где наряду с классификацией объекта x требуется оценить связанный с ним риск как математическое ожидание потерь: R(x) =Xy?Y ?y P(y|x) =Xy?Y ?y???hw, xi y, где ?y величина потери при ошибочной классификации объекта класса y.
67 В практических ситуациях к оценкам апостериорной вероятности следует от- носиться с осторожностью. Теорема 4.2 гарантирует, что P(y|x) = ???hw, xi yтолько для экспонентных классов с равными параметрами разброса. В остальных случаях оценка вероятности носит эвристический характер. На практике экспонентность ред- ко когда проверяется, а гарантировать равенство разброса вообще не представляется возможным. Вероятностная калибровка позволяет пересчитать значение дискриминантной функции в оценку апостериорной вероятности, когда условия теоремы 4.2 не вы- полняются, и даже когда классификатор a(x) = sign f(x,w) не является линейным. Предполагается, что апостериорная вероятность P(+1|x) монотонно зависит от зна- чения дискриминантной функции f(x,w). Существует много способов ввести модель этой зависимости, но мы рассмотрим только один калибровку Платта, основан- ную на линейно-сигмоидальной модели: P(+1|x) = ????f(x,w) + ?. Для настройки неизвестных параметров (?, ?) ? R2 решается задача максимизации правдоподобия X? i=1 log P(yi|xi) = X? i=1 log ????yif(xi,w) + ?yi> max ?,? любым стандартными численными методами оптимизации. :4.5 Метод опорных векторов В 60-70-е годы коллективом советских математиков под руководством В.Н.Вап- ника был разработан метод обобщённого портрета, основанный на построении опти- мальной разделяющей гиперплоскости [7]. Требование оптимальности заключалось в том, что обучающие объекты должны быть удалены от разделяющей поверхности настолько далеко, насколько это возможно. На первый взгляд принцип оптималь- ности существенно отличается от методов минимизации эмпирического риска или максимизации правдоподобия, применяемых в других линейных классификаторах персептроне, дискриминанте Фишера, логистической регрессии. Однако, как станет видно в 4.5.2, различия на самом деле не столь велики. В 90-е годы метод получил широкую мировую известность и после некото- рой переработки и серии обобщений стал называться машиной опорных векторов (support vector machine, SVM) [38]. В настоящее время он считается одним из луч- ших методов классификации. Его современное изложение можно найти в [35, 61]. Метод SVM обладает несколькими замечательными свойствами. Во-первых, обучение SVM сводится к задаче квадратичного программирования, имеющей един- ственное решение, которое вычисляется достаточно эффективно даже на выборках в сотни тысяч объектов. Во-вторых, решение обладает свойством разреженности: положение оптимальной разделяющей гиперплоскости зависит лишь от небольшой доли обучающих объектов. Они и называются опорными векторами; остальные объ- екты фактически не задействуются. Наконец, с помощью изящного математического
68 К.В.Воронцов. Вычислительные методы обучения по прецедентам приёмавведения функции ядра метод обобщается на случай нелинейных разде- ляющих поверхностей. Вопрос о выборе ядра, оптимального для данной прикладной задачи, до сих пор остаётся открытой теоретической проблемой. 4.5.1 Линейно разделимая выборка Рассмотрим задачу классификации на два непересекающихся класса, в которой объекты описываются n-мерными вещественными векторами: X = Rn, Y = {?1,+1}. Будем строить линейный пороговый классификатор: a(x) = signXn j=1 wjxj ? w0= sign??hw, xi ? w0, (4.14) где x = (x1, . . . , xn) признаковое описание объекта x; вектор w = (w1, . . . ,wn) ? Rn и скалярный порог w0 ? R являются параметрами алгоритма. Уравнение hw, xi = w0 описывает гиперплоскость, разделяющую классы в пространстве Rn. Предположим, что выборка X? = (xi, yi)?i=1 линейно разделима и существуют значения параметров w, w0, при которых функционал числа ошибок Q(w,w0) = X? i=1 yi(hw, xii ? w0) 6 0принимает нулевое значение. Но тогда разделяющая гиперплоскость не единствен- на. Можно выбрать другие её положения, реализующие такое же разбиение выборки на два класса. Идея метода заключается в том, чтобы разумным образом распоря- диться этой свободой выбора. Оптимальная разделяющая гиперплоскость. Потребуем, чтобы разделяющая гиперплоскость максимально далеко отстояла от ближайших к ней точек обоих клас- сов. Первоначально данный принцип классификации возник из эвристических сооб- ражений: вполне естественно полагать, что максимизация зазора (margin) между классами должна способствовать более надёжной классификации. Позже этот прин- цип получил и теоретическое обоснование [32, 59, 65]. Нормировка. Заметим, что параметры линейного порогового классификатора опре- делены с точностью до нормировки: алгоритм a(x) не изменится, если w и w0 одно- временно умножить на одну и ту же положительную константу. Удобно выбрать эту константу таким образом, чтобы выполнялось условие min i=1,...,? yi??hw, xii ? w0= 1. (4.15) Множество точек x: ? 1 6 hw, xi ? w0 6 1описывает полосу, разделяющую классы, см. Рис. 13. Ни один из объектов обучающей выборки не попадает внутрь этой полосы. Границами полосы служат две параллельные гиперплоскости с векто- ром нормали w. Разделяющая гиперплоскость проходит ровно по середине между ними. Объекты, ближайшие к разделяющей гиперплоскости, лежат на границах по- лосы, и именно на них достигается минимум (4.15). В каждом из классов имеется хотя бы один такой объект, в противном случае разделяющую полосу можно было бы ещё немного расширить и нарушался бы принцип максимального зазора.
69 x? x+ w Рис. 13. Линейно разделимая выборка. Обучающие объекты x? и x+ находятся на границе разделяю- щей полосы. Вектор нормали w к разделяющей ги- перплоскости определяет ширину полосы. Ширина разделяющей полосы. Чтобы разделяющая гиперплоскость как можно дальше отстояла от точек выборки, ширина полосы должна быть максимальной. Пусть x? и x+ два обучающих объекта классов ?1 и +1 соответственно, лежащие на границе полосы. Тогда ширина полосы есть (x+ ? x?), w kwk= hw, x+i ? hw, x?i kwk = (w0 + 1) ? (w0 ? 1) kwk = 2 kwk. Ширина полосы максимальна, когда норма вектора w минимальна. Итак, в случае линейно разделимой выборки получаем задачу квадратично- го программирования: требуется найти значения параметров w и w0, при которых выполняются ? ограничений-неравенств и норма вектора w минимальна: (hw,wi > min; yi??hw, xii ? w0> 1, i = 1, . . . , ?. (4.16) На практике линейно разделимые классы встречаются довольно редко. Поэто- му постановку задачи (4.16) необходимо модифицировать так, чтобы система огра- ничений была совместна в любой ситуации. 4.5.2 Линейно неразделимая выборка Чтобы обобщить постановку задачи на случай линейно неразделимой выбор- ки, позволим алгоритму допускать ошибки на обучающих объектах, но при этом постараемся, чтобы ошибок было поменьше. Введём дополнительные переменные ?i > 0, характеризующие величину ошибки на объектах xi, i = 1, . . . , ?. Ослабим в (4.16) ограничения-неравенства и одновременно введём в минимизируемый функ- ционал штраф за суммарную ошибку: ?????? ????? 12 hw,wi + CX? i=1 ?i > min w,w0,?; yi??hw, xii ? w0> 1 ? ?i, i = 1, . . . , ?; ?i > 0, i = 1, . . . , ?. (4.17) Положительная константа C является управляющим параметром метода и поз- воляет находить компромисс между максимизацией ширины разделяющей полосы и минимизацией суммарной ошибки.
70 К.В.Воронцов. Вычислительные методы обучения по прецедентам -3 -2 -1 0 1 2 3 0123 Mi Рис. 14. Кусочно-линейная аппроксимация по- роговой функции потерь: [Mi < 0] 6 (1?Mi)+. Регуляризация эмпирического риска. В задачах с двумя классами Y = {?1,+1} отступом (margin) объекта xi от границы классов называется величина Mi(w,w0) = yi??hw, xii ? w0. Алгоритм (4.14) допускает ошибку на объекте xi тогда и только тогда, когда от- ступ Mi отрицателен. Если Mi ? (?1,+1), то объект xi попадает внутрь разделяю- щей полосы. Если Mi > 1, то объект xi классифицируется правильно, и находится на некотором удалении от разделяющей полосы. Согласно (4.17) ошибка ?i выражается через отступ Mi. Действительно, из огра- ничений-неравенств следует, что ?i > 0 и ?i > 1?Mi. В силу требования минимизации суммы Pi ?i одно из этих неравенств обязательно должно обратиться в равенство. Следовательно, ?i = (1 ? Mi)+. Таким образом, задача (4.17) оказывается эквива- лентной безусловной минимизации функционала Q, не зависящего от переменных ?i: Q(w,w0) =X? i=1 ??1 ?Mi(w,w0)+ + 1 2Ckwk2 > min w,w0 . (4.18) В силу неравенства [Mi < 0] 6 (1 ? Mi)+, рис. 14, функционал (4.18) можно рассматривать как верхнюю оценку эмпирического риска (числа ошибочных класси- фикаций объектов обучающей выборки), к которому добавлен регуляризатор kwk2, умноженный на параметр регуляризации 1 2C . Замена пороговой функции потерь [M < 0] кусочно-линейной верхней оценкой L(M) = (1 ? M)+ делает функцию потерь чувствительной к величине ошибки. Функция потерь L(M) штрафует объекты за приближение к границе классов. Введение регуляризатора повышает устойчивость решения w. В случаях, ко- гда минимум эмпирического риска достигается на множестве векторов w, регуля- ризация выбирает из них вектор с минимальной нормой. Тем самым устраняется проблема мультиколлинеарности, повышается устойчивость алгоритма, улучшает- ся его обобщающая способность. Таким образом, принцип оптимальной разделяющей гиперплоскости или максимизации ширины разделяющей полосы тесно связан с ре- гуляризацией некорректно поставленных задач по А.Н.Тихонову [23]. Задача (4.18) соответствует принципу максимума совместного правдоподо- бия (4.3), если принять модель плотности p(xi, yi|w) = z1 exp???(1 ?Mi(w,w0))+, гауссовскую модель априорного распределения вектора параметров w p(w;C) = z2 exp?kwk2 2C ,
71 и не накладывать никаких ограничений на параметр w0. Здесь z1, z2 нормировоч- ные константы, C гиперпараметр. Понимание роли функции потерь и регуляризатора необходимо для того, чтобы более вольно обращаться с постановкой задачи, при необходимости модифицировать её, получая методы, похожие на SVM, но обладающие требуемыми свойствами. Двойственная задача. Запишем функцию Лагранжа задачи (4.17): L(w,w0, ?; ?, ?) = 12kwk2 + CX? i=1 ?i ? X? i=1 ?i??Mi(w,w0) ? 1 + ?i? X? i=1 ?i?i = = 12kwk2 ? X? i=1 ?i??Mi(w,w0) ? 1? X? i=1 ?i???i + ?i ? C, где ? = (?1, . . . , ??)вектор переменных, двойственных к w; ? = (?1, . . . , ??)вектор переменных, двойственных к ? = (?1, . . . , ??). Согласно теореме Куна-Таккера задача (4.17) эквивалентна двойственной за- даче поиска седловой точки функции Лагранжа: ?????? ????? L(w,w0, ?; ?, ?) > min w,w0,? max ?,? ; ?i > 0, ?i > 0, ?i > 0, i = 1, . . . , ?; ?i = 0 либо Mi(w,w0) = 1 ? ?i, i = 1, . . . , ?; ?i = 0 либо ?i = 0, i = 1, . . . , ?; В последних двух строках записаны условия дополняющей нежёсткости. Необходимым условием седловой точки функции Лагранжа является равенство нулю её производных. Отсюда получаются три полезных соотношения: ?L ?w = w ? X? i=1 ?iyixi = 0 =? w = X? i=1 ?iyixi; (4.19) ?L ?w0 = ? X? i=1 ?iyi = 0 =? X? i=1 ?iyi = 0; (4.20) ?L ??i = ??i ? ?i + C = 0 =? ?i + ?i = C, i = 1, . . . , ?. (4.21) Из (4.19) следует, что искомый вектор весов w является линейной комбинацией векторов обучающей выборки xi, причём только тех, для которых ?i > 0. Опр. 4.3. Если ?i > 0, то объект обучающей выборки xi называется опорным век- тором (support vector). Из третьего соотношения (4.21) и неравенства ?i > 0 следует 0 6 ?i 6 C. Отсюда, и из условий дополняющей нежёсткости вытекает, что возможны только три допустимых сочетания значений переменных ?i, ?i, ?i и отступов Mi. Соответственно, все объекты xi, i = 1, . . . , ? делятся на следующие три типа: 1. ?i = 0; ?i = C; ?i = 0; Mi > 1.
72 К.В.Воронцов. Вычислительные методы обучения по прецедентам Объект xi классифицируется правильно и не влияет на решение w. Такие объ- екты будем называть периферийными или неинформативными. 2. 0 < ?i < C; 0 < ?i < C; ?i = 0; Mi = 1. Объект xi классифицируется правильно и лежит в точности на границе разде- ляющей полосы. Такие объекты будем называть опорными граничными. 3. ?i = C; ?i = 0; ?i > 0; Mi < 1. Объект xi либо лежит внутри разделяющей полосы, но классифицируется пра- вильно (0 < ?i < 1, 0 < Mi < 1), либо попадает на границу классов (?i = 1, Mi = 0), либо вообще относится к чужому классу (?i > 1, Mi < 0). Во всех этих случаях объект xi будем называть опорным нарушителем. В силу соотношения (4.21) в лагранжиане обнуляются все члены, содержащие переменные ?i и ?i, и он выражается только через двойственные переменные ?i. ????????? ???????? ?L(?) = ?X? i=1 ?i + 12 X? i=1 X? j=1 ?i?jyiyj hxi, xji > min ? ; 0 6 ?i 6 C, i = 1, . . . , ?; X? i=1 ?iyi = 0. (4.22) Здесь минимизируется квадратичный функционал, имеющий неотрицательно определённую квадратичную форму, следовательно, выпуклый. Область, определя- емая ограничениями неравенствами и одним равенством, также выпуклая. Следова- тельно, данная двойственная задача имеет единственное решение. Допустим, мы решили эту задачу. Тогда вектор w вычисляется по форму- ле (4.19). Для определения порога w0 достаточно взять произвольный опорный гра- ничный вектор xi и выразить w0 из равенства w0 = hw, xii ? yi. На практике для повышения численной устойчивости рекомендуется брать медиану множества значе- ний w0, вычисленных по всем граничным опорным векторам: w0 = medhw, xii ? yi : ?i > 0, Mi = 1, i = 1, . . . , ?. (4.23) В итоге алгоритм классификации представляется в следующем виде: a(x) = signX? i=1 ?iyi hxi, xi ? w0. (4.24) Обратим внимание, что суммирование идёт не по всей выборке, а только по опорным векторам, для которых ?i 6= 0. Классификатор a(x) не изменится, если все остальные объекты исключить из выборки. Это свойство называют разреженно- стью (sparsity); именно оно и отличает SVM от других линейных классификаторов дискриминанта Фишера, логистической регрессии и однослойного персептрона. Ненулевыми ?i обладают не только граничные опорные объекты, но и объекты- нарушители. Это говорит о недостаточной робастности (устойчивости к шуму) SVM. Нарушителями могут быть объекты, появившиеся в результате ошибочных наблю- дений; их надо было бы исключить из выборки, а не строить по ним решение.
73 О подборе параметра регуляризации. Константу C обычно выбирают по крите- рию скользящего контроля. Это трудоёмкий способ, так как задачу приходится ре- шать заново при каждом значении C. Хорошо то, что решение, как правило, не очень чувствительно к выбору C, и слишком точная его оптимизация не требуется. Если есть основания полагать, что выборка почти линейно разделима, и лишь объекты-выбросы классифицируются неверно, то можно применить фильтрацию вы- бросов. Сначала задача решается при некотором C, и из выборки удаляется неболь- шая доля объектов, имеющих наибольшую величину ошибки ?i. После этого задача решается заново по усечённой выборке. Возможно, придётся проделать несколько таких итераций, пока оставшиеся объекты не окажутся линейно разделимыми. 4.5.3 Ядра и спрямляющие пространства Существует ещё один подход к решению проблемы линейной неразделимости. Это переход от исходного пространства признаковых описаний объектов X к ново- му пространству H с помощью некоторого преобразования ?: X > H. Если про- странство H имеет достаточно высокую размерность, то можно надеяться, что в нём выборка окажется линейно разделимой (легко показать, что если выборка X? не про- тиворечива, то всегда найдётся пространство размерности не более ?, в котором она будет линейно разделима). Пространство H называют спрямляющим. Если предположить, что признаковыми описаниями объектов являются векто- ры ?(xi), а не векторы xi, то построение SVM проводится точно так же, как и ранее. Единственное отличие состоит в том, что скалярное произведение hx, x'i в простран- стве X всюду заменяется скалярным произведением h?(x), ?(x')i в пространстве H. Отсюда вытекает естественное требование: пространство H должно быть наделено скалярным произведением, в частности, подойдёт любое евклидово, а в общем случае и гильбертово, пространство. Опр. 4.4. Функция K: X ? X > R называется ядром (kernel function), если она представима в виде K(x, x') = h?(x), ?(x')i при некотором отображении ?: X > H, где H пространство со скалярным произведением. Постановка двойственной задачи (4.22), и сам алгоритм классификации (4.24) зависят только от скалярных произведений объектов, но не от самих признаковых описаний. Это означает, что скалярное произведение hx, x'i можно формально заме- нить ядром K(x, x'). Поскольку ядро в общем случае нелинейно, такая замена при- водит к существенному расширению множества реализуемых алгоритмов a: X > Y . Более того, можно вообще не строить спрямляющее пространство H в явном виде, и вместо подбора отображения ? заниматься непосредственно подбором ядра. Можно пойти ещё дальше, и вовсе отказаться от признаковых описаний объек- тов. Во многих практических задачах объекты изначально задаются информацией об их попарном взаимоотношении, например, отношении сходства. Если эта инфор- мация допускает представление в виде двуместной функции K(x, x'), удовлетворяю- щей аксиомам скалярного произведения, то задача может решаться методом SVM. Для такого подхода недавно был придуман термин беспризнаковое распознавание (featureless recognition), хотя многие давно известные метрические алгоритмы клас- сификации (kNN, RBF и др.) также не требуют задания признаковых описаний.
74 К.В.Воронцов. Вычислительные методы обучения по прецедентам Теорема Мерсера. Любая ли функция двух аргументов K(x, x') может исполнять роль ядра? Следующая теорема даёт исчерпывающий ответ на этот вопрос и пока- зывает, что класс допустимых ядер достаточно широк. Теорема 4.3 (Мерсер, 1909 [53]). Функция K(x, x') является ядром тогда и толь- ко тогда, когда она симметрична, K(x, x') = K(x', x), и неотрицательно R определена: X RX K(x, x')g(x)g(x')dxdx' > 0 для любой функции g : X > R. Существует эквивалентное определение неотрицательной определённости. Опр. 4.5. Функция K(x, x') неотрицательно определена, если для любой конечной выборки Xp = (x1, . . . , xp) из X матрица K = kK(xi, xj)k размера p ? p неотрица- тельно определена: zтKz > 0 для любого z ? Rp. Проверка неотрицательной определённости функции в практических ситуациях может оказаться делом нетривиальным. Часто ограничиваются перебором конечного числа функций, про которые известно, что они являются ядрами. Среди них выби- рается лучшая, как правило, по критерию скользящего контроля. Очевидно, что это не оптимальное решение. На сегодняшний день проблема выбора ядра, оптимального для данной конкретной задачи, остаётся открытой. Конструктивные способы построения ядер. Следующие правила порождения позволяют строить ядра в практических задачах [19, 20]. 1. Произвольное скалярное произведение K(x, x') = hx, x'i является ядром. 2. Константа K(x, x') = 1 является ядром. 3. Произведение ядер K(x, x') = K1(x, x')K2(x, x') является ядром. 4. Для любой функции ?: X > R произведение K(x, x') = ?(x)?(x') ядро. 5. Линейная комбинация ядер с неотрицательными коэффициентами K(x, x') = = ?1K1(x, x') + ?2K2(x, x') является ядром. 6. Композиция произвольной функции ?: X > X и произвольного ядра K0 явля- ется ядром: K(x, x') = K0(?(x), ?(x')). 7. Если s: X?X > R произвольная симметричная интегрируемая функция, то K(x, x') = RX s(x, z)s(x', z) dz является ядром. 8. Функция вида K(x, x') = k(x ? x') является ядром тогда и только тогда, когда Фурье-образ F[k](?) = (2?) n2 RX e?ih?,xik(x) dx неотрицателен. 9. Предел локально-равномерно сходящейся последовательности ядер ядро. 10. Композиция произвольного ядра K0 и произвольной функции f : R > R, пред- ставимой в виде сходящегося степенного ряда с неотрицательными коэффици- ентами K(x, x') = f??K0(x, x'), является ядром. В частности, функции f(z) = ez и f(z) = 1 1?z от ядра являются ядрами.
75 Примеры ядер. Существует несколько ?стандартных? ядер, которые при ближай- шем рассмотрении приводят к уже известным алгоритмам: полиномиальным разде- ляющим поверхностям, двухслойным нейронным сетям, потенциальным функциям (RBF-сетям), и другим. Таким образом, ядра претендуют на роль универсального языка для описания широкого класса алгоритмов обучения по прецедентам. Наблюдается парадоксальная ситуация. С одной стороны, ядра одно из са- мых красивых изобретений в машинном обучении. С другой стороны, до сих пор не найдено эффективного общего подхода к их подбору в конкретных задачах. Пример 4.2. Возьмём X = R2 и рассмотрим ядро K(u, v) = hu, vi2, где u = (u1, u2), v = (v1, v2). Попробуем понять, какое спрямляющее пространство и преобразование ? ему соответствуют. Разложим квадрат скалярного произведения: K(u, v) = hu, vi2 = h(u1, u2), (v1, v2)i2 = = (u1v1 + u2v2)2 = u21v21 + u22v22 + 2u1v1u2v2 = = D??u21, u22,v2u1u2, ??v21, v22,v2v1v2E . Ядро K представляется в виде скалярного произведения в пространстве H = R3. Преобразование ?: R2 > R3 имеет вид ?: (u1, u2) 7> (u21, u22,v2u1u2). Линейной по- верхности в пространстве H соответствует квадратичная поверхность в исходном пространстве X. Данное ядро позволяет разделить внутреннюю и наружную часть произвольного эллипса, что невозможно в исходном двумерном пространстве. Пример 4.3. Усложним ситуацию. Пусть теперь X = Rn, K(u, v) = hu, vid . Тогда компонентами вектора ?(u) являются различные произведения (u1)d1 - - - (un)dn при всевозможных целых неотрицательных d1, . . . , dn, удовлетворяющих условию d1 + - - - + dn = d. Число таких мономов, а следовательно и размерность простран- ства H, равно Cdn+d?1. Пространство H изоморфно пространству всех полиномов, состоящих из мономов степени d от переменных u1, . . . , un. Пример 4.4. Если X = Rn, K(u, v) = ??hu, vi + 1d, то H пространство всех мономов степени не выше d от переменных u1, . . . , un. В этом случае пространство H изоморфно пространству всех полиномов степени d. Линейная разделимость множеств в этом пространстве эквивалентна полиномиаль- ной разделимости множеств в исходном пространстве X. SVM как двухслойная нейронная сеть. Рассмотрим структуру алгоритма a(x) после замены в (4.24) скалярного произведения hxi, xi ядром K(xi, x). Перенумеруем объекты так, чтобы первые h объектов оказались опорными. Поскольку ?i = 0 для всех неопорных объектов, i = h + 1, . . . , ?, алгоритм a(x) примет вид a(x) = signXh i=1 ?iyiK(xi, x) ? w0.
76 К.В.Воронцов. Вычислительные методы обучения по прецедентам @GAFxBE1 CD - - - @GAFxBEn CD K(x, x1) - - - K(x, xh) @G?AFBE1CD X sign a(u) x11 // x1h ?? ? ??? ?? ?? ?? ? xn1   ??      xnh // ?1y1 SSS S ))SSS ?hyh kkk k 55kkk w0 HH // Рис. 15. Машина опорных векторов (SVM) как двухслойная нейросеть. Если X = Rn, то алгоритм a(x) можно рассматривать как суперпозицию, называемую двухслойной нейронной сетью. Первый слой образуют ядра, второй слой собственно линейный классификатор. Такая суперпозиция, построенная ме- тодом SVM, имеет несколько замечательных особенностей. Во-первых, число нейронов первого слоя определяется автоматически, тогда как в нейронных сетях определение числа нейронов является отдельной проблемой. Во-вторых, проясняется смысл двойственных переменных: ?i это степень важности ядра K(x, xi), фактически, важности или ?опорности? объекта xi. Пример 4.5. Классическая нейронная сеть с сигмоидными функциями активации получится, если в качестве ядра взять функцию K(u, v) = th??k0 + k1 hu, vi. Данная функция удовлетворяет условиям Мерсера не при всех значениях парамет- ров k0 и k1. В частности, она им не удовлетворяет при k0 < 0 или k1 < 0 [36]. Однако это не препятствует её успешному практическому применению. Вместо гиперболиче- ского тангенса th z часто используют также логистическую функцию ?(z) = 1 1+e?z . Что плохого произойдёт, если функция K(u, v) не будет удовлетворять услови- ям Мерсера? Постановка задачи квадратичного программирования (4.22) останет- ся той же и в этом случае. Однако квадратичная форма утратит свойство неотри- цательной определённости, минимизируемый функционал уже не будет выпуклым, и решение может оказаться не единственным. Самое неприятное то, что на границах гиперпараллелепипеда 0 6 ?i 6 C возникнет огромное количество локальных ми- нимумов, и поиск решения среди них в общем случае потребует полного перебора. В этой ситуации многие методы квадратичного программирования будут выдавать какой-то локальный минимум, совсем не обязательно хороший. Пример 4.6. Нейронная сеть с радиальными базисными функциями (radial basis functions, RBF) получится, если взять гауссовское ядро K(u, v) = exp????ku ? vk2, где ? параметр. Ядро K(xi, x) вычисляет оценку близости объекта x к опорно- му объекту xi. Чем ближе объекты, тем больше значение ядра. Выходной нейрон
77 складывает все эти оценки, умножая их на коэффициенты ?iyi. При этом близости к опорным объектам класса +1 суммируются с положительными весами, а к объ- ектам класса ?1 с отрицательными. Выходной нейрон производит голосование, сравнивая суммарные близости распознаваемого объекта x к обоим классам. В разделе 2.4.3 рассматривался альтернативный метод обучения RBF-сетей, ос- нованный на EM-алгоритме. Тогда гауссовские ядра играли роль компонент смеси вероятностных распределений. Центры ядер размещались не в опорных объектах, а в местах локальных сгущений плотности объектов. В этом и заключается основ- ное отличие SVM-RBF от EM-RBF. Метод SVM сдвигает центры гауссианов ближе к границе классов, в результате форма разделяющей поверхности описывается более чётко. Таким образом, SVM-RBF лучше подходит для описания классов с границами сложной формы. С другой стороны, EM-RBF более устойчив к выбросам и предпо- чтителен в задачах с ?размытыми? границами классов. Преимущества SVM. : Задача квадратичного программирования имеет единственное решение, для на- хождения которого разработаны достаточно эффективные методы. : Автоматически определяется сложность суперпозиции число нейронов пер- вого слоя, равное числу опорных векторов. : Максимизация зазора между классами улучшает обобщающую способность. Недостатки SVM. : Неустойчивость к шуму в исходных данных. Объекты-выбросы являются опор- ными и существенно влияют на результат обучения. : До сих пор не разработаны общие методы подбора ядер под конкретную за- дачу. На практике ?вполне разумные? ядра, построенные с учётом специфики задачи, могут и не обладать свойством положительной определённости. : Подбор параметра C требует многократного решения задачи. Метод релевантных векторов (RVM). Ещё одна нетривиальная идея регуляри- зации заключается в том, что может быть указан вид функциональной зависимости вектора параметров модели w от обучающей выборки и каких-то новых парамет- ров ?. Тогда априорное распределение можно задавать не для w, а для ?. Поясним эту конструкцию на примере метода релевантных векторов (relevance vector machine, RVM). Приведём только основную идею метода; за подробностями надо обращаться к работам Типпинга и Бишопа [64, 33]. Напомним, что в методе опорных векторов (SVM) вектор параметров w явля- ется линейной комбинацией опорных векторов xi: w =X? i=1 ?iyixi, (4.25)
78 К.В.Воронцов. Вычислительные методы обучения по прецедентам где ?i неотрицательные двойственные переменные, не равные нулю только для опорных векторов xi. Один из недостатков SVM состоит в том, что опорными векто- рами становятся не только пограничные объекты, но и объекты-нарушители, в том числе шумовые выбросы. Метод RVM был предложен как альтернатива, призванная устранить данный дефект. За основу в RVM берётся формула (4.25), и ставится задача определить, какие из коэффициентов ?i можно положить равными нулю. Иными словами, делается по- пытка оптимизировать множество опорных объектов, сохранив свойство разрежен- ности SVM. Для этого предполагается, что ?i независимые нормально распреде- лённые случайные величины с неравными дисперсиями ?i: p(?) = 1 (2?)?/2v?1 - - - ?? exp ?X? i=1 ?2i 2?i! То есть идея та же, что и в регуляризаторе (4.4), только теперь параметры априорного распределения связываются с объектами, а не с признаками. В результате вместо отбора признаков получаем отбор объектов, однако не такой, как в SVM, поэтому здесь опорные объекты называют релевантными. Эксперименты показали, что решение получается ещё более разреженным, чем в SVM, то есть релевантных объектов, как правило, существенно меньше, чем опорных. К сожалению, далеко не во всех задачах это действительно приводит к улучшению качества классификации. :4.6 ROC-кривая и оптимизация порога решающего правила Рассмотрим задачу классификации на два класса, Y = {?1,+1}, и модель алгоритмов a(x,w) = sign??f(x,w)?w0, где w0 ? Rаддитивный параметр дискри- минантной функции. В теории нейронных сетей его называют порогом активации. Согласно Теореме 4.2 в случае линейной дискриминантной функции пара- метр w0 определяется отношением потерь: w0 = ln ?? ?+ , где ?+ и ?? величина потери при ошибке на объекте класса ?+1? и ??1? соответственно. На практике отношение потерь может многократно пересматриваться. Поэтому вводится специальная характеристика ROC-кривая, которая показывает, что про- исходит с числом ошибок обоих типов, если изменяется отношение потерь. Термин операционная характеристика приёмника (receiver operating characte- ristic, ROC curve) пришёл из теории обработки сигналов. Эту характеристику впер- вые ввели во время II мировой войны, после поражения американского военного флота в Пёрл Харборе в 1941 году, когда была осознана проблема повышения точ- ности распознавания самолётов противника по радиолокационному сигналу. Позже нашлись и другие применения: медицинская диагностика, приёмочный контроль ка- чества, кредитный скоринг, предсказание лояльности клиентов, и т. д. Каждая точка на ROC-кривой соответствует некоторому алгоритму. В общем случае это даже не обязательно криваядискретное множество алгоритмов может быть отображено в тех же координатах в виде точечного графика. По оси X откладывается доля ошибочных положительных классификаций (false positive rate, FPR): FPR(a,X?) = P?i=1[yi = ?1][a(xi) = +1] P?i=1[yi = ?1] .
79 Алгоритм 4.2. Эффективный алгоритм построения ROC-кривой Вход: обучающая выборка X?; f(x) = hw, xiдискриминантная функция; Выход: (FPRi,TPRi)?i=0 последовательность точек ROC-кривой; AUCплощадь под ROC-кривой. 1: ?? := P?i=1[yi = ?1]число объектов класса ?1; ?+ := P?i=1[yi = +1] число объектов класса +1; 2: упорядочить выборку X? по убыванию значений f(xi); 3: поставить первую точку в начало координат: (FPR0,TPR0) := (0, 0); AUC := 0; 4: для i := 1, . . . , ? 5: если yi = ?1 то 6: сместиться на один шаг вправо: FPRi := FPRi?1 + 1 ?? ; TPRi := TPRi?1; AUC := AUC + 1 ??TPRi; 7: иначе 8: сместиться на один шаг вверх: FPRi := FPRi?1; TPRi := TPRi?1 + 1 ?+ ; Величина 1 ? FPR(a) равна доле правильных отрицательных классификаций (true negative rate, TNR) и называется специфичностью алгоритма a. Поэтому на го- ризонтальной оси иногда пишут ?1 ? специфичность?. По оси Y откладывается доля правильных положительных классификаций (true positive rate, TPR), называемая также чувствительностью алгоритма a: TPR(a,X?) = P?i=1[yi = +1][a(xi) = +1] P?i=1[yi = +1] . Каждая точка ROC-кривой соответствует определённому значению парамет- ра w0. ROC-кривая монотонно не убывает и проходит из точки (0, 0) в точку (1, 1). Для построения ROC-кривой нет необходимости вычислять FPR и TPR сум- мированием по всей выборке при каждом w0. Более эффективный Алгоритм 4.2 ос- нован на простой идее, что в качестве значений порога w0 достаточно перебрать только ? значений дискриминантной функции f(xi) = hw, xii, которые она принима- ет на объектах выборки. Чем выше проходит ROC-кривая, тем выше качество классификации. Идеаль- ная ROC-кривая проходит через левый верхний уголточку (0, 1). Наихудший алго- ритм соответствует диагональной прямой, соединяющей точки (0, 0) и (1, 1); её также изображают на графике как ориентир. В роли общей характеристики качества классификации, не зависящей от конъ- юнктурного параметра w0, выступает площадь под ROC-кривой (area under curve, AUC). Её вычисление также показано в Алгоритме 4.2.
80 К.В.Воронцов. Вычислительные методы обучения по прецедентам 5 Методы восстановления регрессии Задачу обучения по прецедентам при Y = R принято называть задачей восста- новления регрессии. Основные обозначения остаются прежними. Задано простран- ство объектов X и множество возможных ответов Y . Существует неизвестная целе- вая зависимость y? : X > Y , значения которой известны только на объектах обуча- ющей выборки X? = (xi, yi)?i=1, yi = y?(xi). Требуется построить алгоритм, который в данной задаче принято называть ?функцией регрессии? a: X > Y , аппроксимиру- ющий целевую зависимость y?. :5.1 Метод наименьших квадратов Пусть задана модель регрессии параметрическое семейство функций g(x, ?), где ? ? Rp вектор параметров модели. Определим функционал качества аппрок- симации целевой зависимости на выборке X? как сумму квадратов ошибок: Q(?,X?) =X? i=1 ??g(xi, ?) ? yi2. (5.1) Обучение по методу наименьших квадратов (МНК) состоит в том, чтобы най- ти вектор параметров ??, при котором достигается минимум среднего квадрата ошиб- ки на заданной обучающей выборке X?: ?? = arg min ??Rp Q(?,X?). (5.2) Стандартный способ решения этой оптимизационной задачивоспользовать- ся необходимым условием минимума. Если функция g(x, ?) достаточное число раз дифференцируема по ?, то в точке минимума выполняется система p уравнений от- носительно p неизвестных: ?Q ?? (?,X?) = 2 X? i=1 ??g(xi, ?) ? yi?g ??(xi, ?) = 0. (5.3) :5.2 Непараметрическая регрессия: ядерное сглаживание Непараметрическое восстановление регрессии основано на той же идее, что и непараметрическое восстановление плотности распределения, рассмотренное в 2.2.2. Значение a(x) вычисляется для каждого объекта x по нескольким ближай- шим к нему объектам обучающей выборки. Чтобы можно было говорить о ?близо- сти? объектов, на множестве X должна быть задана функция расстояния ?(x, x'). 5.2.1 Формула Надарая-Ватсона Возьмём самую простую модель регрессии, какая только возможна констан- ту g(x, ?) = ?, ? ? R. Но при этом, чтобы не получить тривиального решения, введём веса объектов wi(x), зависящие от того объекта x, в котором мы собираемся вычислять значение a(x) = g(x, ?). Можно сказать и так, что обучение регрессионной модели будет производиться отдельно в каждой точке x пространства объектов X.
81 Чтобы вычислить значение a(x) = ? для произвольного x ? X, воспользуемся методом наименьших квадратов: Q(?;X?) =X? i=1 wi(x)??? ? yi2 > min ??R . Зададим веса wi обучающих объектов так, чтобы они убывали по мере увеличе- ния расстояния ?(x, xi). Для этого введём невозрастающую, гладкую, ограниченную функцию K: [0,?) > [0,?), называемую ядром: wi(x) = K ?(x, xi) h . Параметр h называется шириной ядра или шириной окна сглаживания. Чем меньше h, тем быстрее будут убывать веса wi(x) по мере удаления xi от x. Приравняв нулю производную ?Q ?? = 0, получим формулу ядерного сглаживания Надарая-Ватсона: ah(x;X?) = P? i=1 yiwi(x) P? i=1wi(x) = P? i=1 yiK???(x,xi) h P? i=1K???(x,xi) h . (5.4) Эта формула интуитивно очевидна: значение a(x) есть среднее yi по объек- там xi, ближайшим к x. В одномерном случае X = R1 метрика задаётся как ?(x, xi) = |x ? xi|. При этом строгим обоснованием формулы (5.4) служит следующая теорема, аналогичная Теореме 2.3 о непараметрическом восстановлении плотности. Теорема 5.1 ([25]). Пусть выполнены следующие условия: 1) выборка X? = (xi, yi)?i=1 простая, получена из распределения p(x, y); 2) ядро K(r) удовлетворяет ограничениям R ? 0 K(r) dr < ? и lim r>?rK(r) = 0; 3) восстанавливаемая зависимость, определяемая плотностью p(y|x), удовле- творяет при любом x ? X ограничению E(y2|x) = RY y2p(y|x) dy < ?; 4) последовательность h? такова, что lim ?>?h? = 0 и lim ?>??h? = ?. Тогда имеет место сходимость по вероятности: ah?(x;X?) P>E(y|x) в любой точке x ? X, в которой E(y|x), p(x) и D(y|x) непрерывны и p(x) > 0. Таким образом, для широкого класса ядер оценка Надарая-Ватсона сходится к ожидаемому значению восстанавливаемой зависимости при неограниченном уве- личении длины выборки ? и одновременном уменьшении ширины окна h. 5.2.2 Выбор ядра и ширины окна Ядерное сглаживаниеэто довольно простой метод с точки зрения реализации. Обучение алгоритма ah(x;X?) сводится к запоминанию выборки, подбору ядра K и ширины окна h.
82 К.В.Воронцов. Вычислительные методы обучения по прецедентам Выбор ядра K мало влияет на точность аппроксимации, но определяющим образом влияет на степень гладкости функции ah(x). В одномерном случае функция ah(x) столько же раз дифференцируема, сколько и ядро K(r). Часто используемые ядра показаны на Рис. 3. Для ядерного сглаживания чаще всего берут гауссовское ядро KG(r) = exp???12r2или квартическое KQ(r) = (1 ? r2)2|r| < 1. Если ядро K(r) финитно, то есть K(r) = 0 при r > 1, то ненулевые веса по- лучат только те объекты xi, для которых ?(x, xi) < h. Тогда в формуле (5.4) доста- точно суммировать только по ближайшим соседям объекта x. В одномерном случае X = R1 для эффективной реализации этой идеи выборка должна быть упорядочена по возрастанию xi. В общем случае необходима специальная структура данных, поз- воляющая быстро находить множество ближайших соседей для любого объекта x. Выбор ширины окна h решающим образом влияет на качество восстановления за- висимости. При слишком узком окне (h > 0) функция ah(x) стремится пройти через все точки выборки, реагируя на шум и претерпевая резкие скачки. При слишком широком окне функция чрезмерно сглаживается и в пределе h > ? вырождается в константу. Таким образом, должно существовать оптимальное значение ширины окна h? компромисс между точностью описания выборки и гладкостью аппрокси- мирующей функции. Проблема локальных сгущений возникает, когда объекты выборки распределе- ны неравномерно в пространстве X. В областях локальных сгущений оптимальна меньшая ширина окна, чем в областях разреженности. В таких случаях использу- ется окно переменной ширины h(x), зависящей от объекта x. Соответственно, веса вычисляются по формуле wi(x) = K???(x,xi) h(x) . Самый простой способвзять в качестве ширины окна h(x) расстояние от объ- екта x до его k + 1-го соседа: hk(x) = ?(x, x(k+1) x ). Недостаток этого способа в том, что функция hk(x) является непрерывной, но не гладкой, поэтому у функций wi(x) и ahk(x) будут разрывные первые производные, даже если ядро гладкое. Для устра- нения этого недостатка можно сгладить саму функцию hk(x) по узлам равномерной сетки, при постоянной ширине окна и каком-либо гладком ядре, скажем, KQ. Оптимизация ширины окна. Чтобы оценить при данном h или k точность локаль- ной аппроксимации в точке xi, саму эту точку необходимо исключить из обучающей выборки. Если этого не делать, минимум ошибки будет достигаться при h > 0. Такой способ оценивания называется скользящим контролем с исключением объек- тов по одному (leave-one-out, LOO): LOO(h,X?) =X? i=1 ??ah??xi;X?\{xi}? yi2 > min h , где минимизация осуществляется по ширине окна h или по числу соседей k. 5.2.3 Проблема выбросов: робастная непараметрическая регрессия Оценка Надарайя-Ватсона крайне чувствительна к большим одиночным вы- бросам. Идея обнаружения выбросов заключается в том, что чем больше величина
83 Алгоритм 5.1. LOWESSлокально взвешенное сглаживание. Вход: X? обучающая выборка; Выход: коэффициенты ?i, i = 1, . . . , ?; 1: инициализация: ?i := 1, i = 1, . . . , ?; 2: повторять 3: вычислить оценки скользящего контроля на каждом объекте: ai := ah??xi;X?\{xi}= P? j=1, j6=i yj?jK???(xi,xj ) h(xi) P? j=1, j6=i ?jK???(xi,xj ) h(xi) , i = 1, . . . , ? 4: вычислить коэффициенты ?i: ?i := ?K??|ai ? yi|; i = 1, . . . , ?; 5: пока коэффициенты ?i не стабилизируются; ошибки ?i = ah??xi;X?\{xi}? yi, тем в большей степени прецедент (xi, yi) является выбросом, и тем меньше должен быть его вес. Эти соображения приводят к идее домножить веса wi(x) на коэффициенты ?i = ?K(?i), где ?Kещё одно ядро, вообще говоря, отличное от K(r). Коэффициенты ?i, как и ошибки ?i, зависят от функции ah, которая, в свою очередь, зависит от ?i. Разумеется, это не ?порочный круг?, а хороший повод для ор- ганизации итерационного процесса, см. Алгоритм 5.1. На каждой итерации строится функция ah, затем уточняются весовые множители ?i. Как правило, этот процесс схо- дится довольно быстро. Он называется локально взвешенным сглаживанием (locally weighted scatter plot smoothing, LOWESS) [37]. Методы восстановления регрессии, устойчивые к шуму в исходных данных, на- зывают робастными, что означает ?разумный, здравый? (robust). Возможны различные варианты задания ядра ?K(?). Жёсткая фильтрация: строится вариационный ряд ошибок ?(1) 6 - - - 6 ?(?), и отбрасывается некоторое количество t объектов с наибольшей ошибкой. Это соот- ветствует ядру ?K(?) = ? 6 ?(??t). Мягкая фильтрация [37]: используется квартическое ядро ?K(?) = KQ?? ? 6med{?i}, где med{?i}медиана вариационного ряда ошибок. 5.2.4 Проблема краевых эффектов В одномерном случае X = R1 часто наблюдается значительное смещение ап- проксимирующей функции ah(x) от истинной зависимости y?(x) вблизи минималь- ных и максимальных значений xi, см. Рис ??. Смещение возникает, когда объекты выборки xi располагаются только по одну сторону (а не вокруг) объекта x. Чем больше размерность пространства объектов, тем чаще возникает такая ситуация. Для решения этой проблемы зависимость аппроксимируется в окрестности точ- ки x ? X не константой a(u) = ?, а линейной функцией a(u) = ?(u ? x) + ?.
84 К.В.Воронцов. Вычислительные методы обучения по прецедентам Введём для краткости сокращённые обозначения wi = wi(x), di = xi ? x и за- пишем задачу наименьших квадратов: Q(?, ?;X?) =X? i=1 wi???di + ? ? yi2 > min ?,??R . Приравнивая нулю производные ?Q ?? = 0 и ?Q ?? = 0, получим систему линейных урав- нений 2 ? 2, решение которой даёт аналог формулы Надарая-Ватсона: ah(x;X?) = P? i=1wid2i P? i=1wiyi ? P? i=1widi P? i=1widiyi P? i=1wi P? i=1wid2i ? P? i=1widi2 . В многомерном случае X = Rn для вычисления коэффициентов в линейной форме a(u) = ?т(u?x)+? приходится решать задачу многомерной линейной регрес- сии (см. ниже). Причём она должна решаться заново для каждой точки x ? X, что сопряжено с большим объёмом вычислений. :5.3 Линейная регрессия Пусть каждому объекту соответствует его признаковое описание ??f1(x), . . . , fn(x), где fj : X > R числовые признаки, j = 1, . . . , n. Линейной моделью регрессии на- зывается линейная комбинация признаков с коэффициентами ? ? Rn: g(x, ?) = Xn j=1 ?jfj(x). Введём матричные обозначения: F = ??fj(xi)??n матрица объекты-признаки; y = ??yi??1 целевой вектор; ? = ???jn?1 вектор параметров. В матричных обозначениях функционал Q принимает вид Q(?) = kF? ? yk2. Запишем необходимое условие минимума (5.3) в матричном виде: ?Q ?? (?) = 2Fт(F? ? y) = 0, откуда следует FтF? = Fтy. Эта система линейных уравнений относительно ? назы- вается нормальной системой для задачи наименьших квадратов. Если матрица FтF размера n ? n невырождена, то решением нормальной системы является вектор ?? = (FтF)?1Fтy = F+y. Матрица F+ = (FтF)?1Fт называется псевдообратной для прямоугольной матри- цы F. Подставляя найденное решение в исходный функционал, получаем Q(??) = kPF y ? yk2,
85 где PF = FF+ = F(FтF)?1Fт проекционная матрица. Решение имеет простую геометрическую интерпретацию. Произведение PF y есть проекция целевого вектора y на линейную оболочку столбцов матрицы F. Раз- ность (PF y?y) есть проекция целевого вектора y на ортогональное дополнение этой линейной оболочки. Значение функционала Q(??) = kPF y ? yk2 есть квадрат дли- ны перпендикуляра, опущенного из y на линейную оболочку. Таким образом, МНК находит кратчайшее расстояние от y до линейной оболочки столбцов F. Известно большое количество численных методов решения нормальной систе- мы. Наибольшей популярностью пользуются методы, основанные на ортогональных разложениях матрицы F. Эти методы эффективны, обладают хорошей численной устойчивостью и позволяют строить различные модификации и обобщения. 5.3.1 Сингулярное разложение Произвольную ? ? n-матрицу ранга n можно представить в виде сингулярного разложения (singular value decomposition, SVD) F = V DUт, обладающего рядом замечательных свойств (позже мы докажем Теорему 5.2, из ко- торой эти свойства будут вытекать как следствия): 1) n ? n-матрица D диагональна, D = diag??v?1, . . . ,v?n, где ?1, . . . , ?n об- щие ненулевые собственные значения матриц FтF и FFт. 2) ??n-матрица V = (v1, . . . , vn) ортогональна, V тV = In, столбцы vj являются собственными векторами матрицы FFт, соответствующими ?1, . . . , ?n; 3) n?n-матрица U = (u1, . . . , un) ортогональна, UтU = In, столбцы uj являются собственными векторами матрицы FтF, соответствующими ?1, . . . , ?n; Имея сингулярное разложение, легко записать псевдообратную матрицу: F+ = (UDV тV DUт)?1UDV т = UD?1V т =Xn j=1 1 p?j ujvтj ; вектор МНК-решения: ?? = F+y = UD?1V тy = Xn j=1 1 p?j uj(vтjy); (5.5) вектор F?? МНК-аппроксимацию целевого вектора y: F?? = PF y = (V DUт)UD?1V тy = V V тy = Xn j=1 vj(vтjy); (5.6) и норму вектора коэффициентов: k??k2 = yтV D?1UтUD?1V тy = yтV D?2V тy = Xn j=1 1 ?j (vтjy)2. (5.7) Итак, если есть сингулярное разложение, то обращать матрицы уже не нужно. Однако вычисление сингулярного разложения практически столь же трудоёмко, как и обращение. Эффективные численные алгоритмы, вычисляющие SVD, реализованы во многих стандартных математических пакетах.
86 К.В.Воронцов. Вычислительные методы обучения по прецедентам 5.3.2 Проблема мультиколлинеарности Если ковариационная матрица = FтF имеет неполный ранг, то её обраще- ние невозможно. Тогда приходится отбрасывать линейно зависимые признаки или применять описанные ниже методырегуляризацию или метод главных компонент. На практике чаще встречается проблема мультиколлинеарности когда матрица имеет полный ранг, но близка к некоторой матрице неполного ранга. Тогда говорят, что матрица неполного псевдоранга или что она плохо обусловлена. Геометри- чески это означает, что объекты выборки сосредоточены вблизи линейного подпро- странства меньшей размерности m < n. Признаком мультиколлинеарности является наличие у матрицы собственных значений, близких к нулю. Число обусловленности матрицы есть ?() = kkk?1k = max u: kuk=1 kuk min u: kuk=1 kuk = ?max ?min , где ?max и ?min максимальное и минимальное собственные значения матрицы , все нормы евклидовы. Матрица считается плохо обусловленной, если ?() & 102 . . . 104. Обращение такой матрицы численно неустойчиво. При умножении обратной матри- цы на вектор, z = ?1u, относительная погрешность усиливается в ?() раз: k?zk kzk 6 ?()k?uk kuk . Именно это и происходит с МНК-решением в случае плохой обусловленности. В фор- муле (5.7) близкие к нулю собственные значения оказываются в знаменателе, в ре- зультате увеличивается разброс коэффициентов ??, появляются большие по абсо- лютной величине положительные и отрицательные коэффициенты. МНК-решение становится неустойчивым малые погрешности измерения признаков или ответов у обучающих объектов могут существенно повлиять на вектор решения ??, а погреш- ности измерения признаков у тестового объекта xна значения функции регрессии g(x, ??). Мультиколлинеарность влечёт не только неустойчивость и переобучение, но и неинтерпретируемость коэффициентов, так как по абсолютной величине коэффи- циента ?j становится невозможно судить о степени важности признака fj . 5.3.3 Гребневая регрессия Для решения проблемы мультиколлинеарности добавим к функционалу Q ре- гуляризатор, штрафующий большие значения нормы вектора весов k?k: Q? (?) = kF? ? yk2 + ?k?k2, где ? неотрицательный параметр. В случае мультиколлинеарности имеется бес- конечно много векторов ?, доставляющих функционалу Q значения, близкие к ми- нимальному. Штрафное слагаемое выполняет роль регуляризатора, благодаря ко- торому среди них выбирается решение с минимальной нормой. Приравнивая нулю производную Q? (?) по параметру ?, находим: ??? = (FтF + ? In)?1Fтy.
87 Таким образом, перед обращением матрицы к ней добавляется ?гребень? диа- гональная матрица ? In. Отсюда и название метода гребневая регрессия (ridge regression). При этом все её собственные значения увеличиваются на ? , а собственные векторы не изменяются. В результате матрица становится хорошо обусловленной, оставаясь в то же время ?похожей? на исходную. Аналогичный приём мы уже упо- минали в разделе 2.3.3 в связи с обращением ковариационной матрицы в линейном дискриминанте Фишера. Выразим регуляризованное МНК-решение через сингулярное разложение: ??? = (UD2Uт + ? In)?1UDV тy = U(D2 + ? In)?1DV тy =Xn j=1 v?j ?j + ? uj(vтjy). Теперь найдём регуляризованную МНК-аппроксимацию целевого вектора y: F??? = V DUт??? = V diag?j ?j + ? V тy = Xn j=1 ?j ?j + ? vj(vтjy). (5.8) Как и прежде в (5.6), МНК-аппроксимация представляется в виде разложения целевого вектора y по базису собственных векторов матрицы FFт. Только теперь проекции на собственные векторы сокращаются, умножаясь на ?j ?j+? ? (0, 1). В срав- нении с (5.7) уменьшается и норма вектора коэффициентов: k???k2 = kD2(D2 + ? In)?1D?1V тyk2 = Xn j=1 1 ?j + ? (vтjy)2 < Xn j=1 1 ?j (vтjy)2 = k??k2. Отсюда ещё одно название методасжатие (shrinkage) или сокращение весов (weight decay) [44]. Понятие эффективной размерности. Из формул видно, что по мере увеличения параметра ? вектор коэффициентов ??? становится всё более устойчивым и жёстко определённым. Фактически, происходит понижение эффективной размерности ре- шенияэто второй смысл термина ?сжатие?. Можно показать, что роль размерности играет след проекционной матрицы. Действительно, в нерегуляризованном случае имеем tr F(FтF)?1Fт = tr(FтF)?1FтF = tr In = n. При использовании регуляризации эффективная размерность принимает зна- чение от 0 до n, не обязательно целое, и убывает при возрастании ? : nэфф = tr F(FтF + ? In)?1Fт = tr diag?j ?j + ? = Xn j=1 ?j ?j + ? < n. Проблема выбора константы регуляризации. При ? > 0 регуляризованное ре- шение стремится к МНК-решению: ??? > ??. При ? > ? чрезмерная регуляризации приводит к вырожденному решению: ??? > 0. Оба крайних случая нежелательны,
88 К.В.Воронцов. Вычислительные методы обучения по прецедентам поэтому оптимальным является некоторое промежуточное значение ? ?. Для его на- хождения можно применять скользящий контроль, см. раздел 1.1.6 или, более по- дробно, ??. Зависимость оценки скользящего контроля от параметра ? , как правило, имеет характерный минимум. Скользящий контроль вычислительно трудоёмкая процедура. Известна прак- тическая рекомендация брать ? в отрезке [0.1, 0.4], если столбцы матрицы F заранее стандартизованы (центрированы и нормированы). Ещё одна эвристикавыбрать ? так, чтобы число обусловленности приняло заданное не слишком большое значение: M0 = ?(FтF + ? In) = ?max+? ?min+? , откуда следует рекомендация ? ? ? ?max/M0. 5.3.4 Лассо Тибширани Ещё один метод регуляризации внешне похож на гребневую регрессию, но при- водит к качественно иному поведению вектора коэффициентов. Вместо добавления штрафного слагаемого к функционалу качества вводится ограничение-неравенство, запрещающее слишком большие абсолютные значения коэффициентов: ??? ?? Q(?) = kF? ? yk2 > min ? ; Xn j=1 |?j | 6 ?; (5.9) где ? параметр регуляризации. При больших значениях ? ограничение (5.9) стано- вится строгим неравенством, и решение совпадает с МНК-решением. Чем меньше ?, тем больше коэффициентов ?j обнуляются. Происходит отбор (селекция) признаков, поэтому параметр ? называют ещё селективностью. Образно говоря, параметр ? зажимает вектор коэффициентов, лишая его избыточных степеней свободы. Отсюда и название методалассо (LASSO, least absolute shrinkage and selection operator) [63]. Чтобы понять, почему лассо осуществляет отбор признаков, приведём задачу квадратичного программирования (5.9) к каноническому виду. Заменим каждую пе- ременную ?j разностью двух новых неотрицательных переменных: ?j = ?+j ? ??j . Функционал Q останется квадратичным по новым переменным, ограничение (5.9) примет линейный вид, и добавится 2n ограничений-неравенств: Xn j=1 ?+j + ??j 6 ?; ?+j > 0; ??j > 0. Чем меньше ?, тем больше ограничений обращаются в равенства ?+j = ??j = 0, что соответствует обнулению коэффициента ?j и исключению j-го признака. Сравнение лассо и гребневой регрессии. Оба метода успешно решают пробле- му мультиколлинеарности. Гребневая регрессия использует все признаки, стараясь ?выжать максимум? из имеющейся информации. Лассо производит отбор признаков, что предпочтительнее, если среди признаков есть шумовые или измерения признаков связаны с ощутимыми затратами. На Рис. 16, взятом из [44], левый ряд графиков соответствует гребневой регрессии, правый рядлассо. Ослабление регуляризации ведёт к уменьшению ошибки на обучении и увеличе- нию нормы вектора коэффициентов. При этом ошибка на контроле в какой-то момент проходит через минимум, и далее только возрастаетэто и есть переобучение.
89 (а) зависимость {j} от = 1/(б) зависимость {j} от ? Рис. 16. Зависимость коэффициентов линейной модели от параметра = 1/для гребневой регрес- сии и от параметра ? для лассо Тибширани, по реальным данным задачи UCI.cancer [44]. 5.3.5 Линейная монотонная регрессия В некоторых приложениях возникает линейная модель регрессии с неотрица- тельными коэффициентами. Например, заранее может быть известно, что чем боль- ше значение признака fj , тем больше должен быть отклик y. При построении линей- ной композиции алгоритмов регрессии или прогнозирования роль признаков играют базовые алгоритмы (см. главу ??). Естественно полагать, что если базовые алгорит- мы настраиваются на один и тот же целевой вектор y, то они должны учитываться в композиции с положительными весами. Возникает задача минимизации квадратичного функционала Q(?,X?) с n огра- ничениями типа неравенств: (Q(?) = kF? ? yk2 > min ? ; ?j > 0; j = 1, . . . , n. Это опять-таки, задача квадратичного программирования с линейными огра- ничениями. Когда ограничение ?j > 0 становится активным, то есть обращается в равенство, признак fj , фактически, исключается из модели регрессии. В линейной композиции это соответствует исключению j-го базового алгоритма из композиции. :5.4 Метод главных компонент Ещё одно решение проблемы мультиколлинеарности заключается в том, что- бы подвергнуть исходные признаки некоторому функциональному преобразованию, гарантировав линейную независимость новых признаков, и, возможно, сократив их количество, то есть уменьшив размерность задачи. В методе главных компонент (principal component analysis, PCA) строится минимальное число новых признаков, по которым исходные признаки восстанав- ливаются линейным преобразованием с минимальными погрешностями. PCA отно- сится к методам обучения без учителя (unsupervised learning), поскольку матрица ?объекты-признаки? F преобразуется без учёта целевого вектора y.
90 К.В.Воронцов. Вычислительные методы обучения по прецедентам Важно отметить, что PCA подходит и для регрессии, и для классификации, и для многих других типов задач анализа данных, как вспомогательное преобразо- вание, позволяющее определить эффективную размерность исходных данных. Постановка задачи. Пусть имеется n числовых признаков fj(x), j = 1, . . . , n. Как обычно, будем отождествлять объекты обучающей выборки и их признаковые опи- сания: xi ? ??f1(xi), . . . , fn(xi), i = 1, . . . , ?. Рассмотрим матрицу F, строки которой соответствуют признаковым описаниям обучающих объектов: F??n = ??f1(x1) . . . fn(x1) . . . . . . . . . f1(x?) . . . fn(x?)?? = ??x1 . . . x???. Обозначим через zi = ??g1(xi), . . . , gm(xi)признаковые описания тех же объек- тов в новом пространстве Z = Rm меньшей размерности, m < n: G??m = ??g1(x1) . . . gm(x1) . . . . . . . . . g1(x?) . . . gm(x?)?? = ??z1 . . . z? ??. Потребуем, чтобы исходные признаковые описания можно было восстановить по новым описаниям с помощью некоторого линейного преобразования, определяе- мого матрицей U = (ujs)n?m: ? fj(x) =Xm s=1 gs(x)ujs, j = 1, . . . , n, x ? X, или в векторной записи: ?x = zUт. Восстановленное описание ?x не обязано в точности совпадать с исходным описанием x, но их отличие на объектах обучающей выборки должно быть как можно меньше при выбранной размерности m. Будем искать одно- временно и матрицу новых признаковых описаний G, и матрицу линейного преобра- зования U, при которых суммарная невязка восстановленных описаний минимальна: 2(G, U) = X? i=1 k?xi ? xik2 = X? i=1 kziUт ? xik2 = kGUт ? Fk2 > min G,U , (5.10) где все нормы евклидовы. Напомним, что kAk2 = trAAт = trAтA, где tr операция следа матрицы. Будем предполагать, что матрицы G и U невырождены: rkG = rk U = m. Иначе существовало бы представление ?G?Uт = GUт с числом столбцов в матрице ?G, меньшим m. Поэтому интересны лишь случаи, когда m 6 rk F. Исчерпывающее решение задачи (5.10) даёт следующая теорема. Теорема 5.2. Если m 6 rk F, то минимум 2(G, U) достигается, когда столбцы матрицы U есть собственные векторы FтF, соответствующие m максимальным соб- ственным значениям. При этом G = FU, матрицы U и G ортогональны.
91 Доказательство. Запишем необходимые условия минимума: (?2/?G = (GUт ? F)U = 0; ?2/?U = Gт(GUт ? F) = 0. Поскольку искомые матрицы G и U невырождены, отсюда следует (G = FU(UтU)?1; U = FтG(GтG)?1. (5.11) Функционал 2(G, U) зависит только от произведения матриц GUт, поэтому ре- шение задачи (5.10) определено с точностью до произвольного невырожденного пре- образования R: GUт = (GR)(R?1Uт). Распорядимся свободой выбора R так, чтобы матрицы UтU и GтG оказались диагональными. Покажем, что это всегда возможно. Пусть ?G ?Uт произвольное решение задачи (5.10). Матрица ?Uт?Uсимметричная, невырожденная, положительно определенная, по- этому существует невырожденная матрица Sm?m такая, что S?1?Uт?US?1т = Im. Матрица Sт ?Gт ?GS симметричная и невырожденная, поэтому существует орто- гональная матрица Tm?m такая, что Tт(Sт ?Gт ?GS)T = diag(?1, . . . , ?m) ? диаго- нальная матрица. По определению ортогональности TтT = Im. Преобразование R = ST невырождено. Положим G = ?GR, Uт = R?1?Uт. Тогда GтG = Tт(Sт ?Gт ?GS)T = ; UтU = T?1(S?1?Uт?US?1т)T?1т = (TтT)?1 = Im. В силу GUт = ?G ?Uт матрицы G и U являются решением задачи (5.10) и удо- влетворяют необходимому условию минимума. Подставим матрицы G и U в (5.11). Благодаря диагональности GтG и UтU соотношения существенно упростятся: ( G = FU; U= FтG. Подставим первое соотношение во второе, получим U= FтFU. Это означает, что столбцы матрицы U обязаны быть собственными векторами матрицы FтF, а диа- гональные элементы ?1, . . . , ?m соответствующими им собственными значениями. Аналогично, подставив второе соотношение в первое, получим G= FFтG, то есть столбцы матрицы G являются собственными векторами FFт, соответствую- щими тем же самым собственным значениям. Подставляя G и U в функционал 2(G, U), находим: 2(G, U) = kF ? GUтk2 = tr(Fт ? UGт)(F ? GUт) = tr Fт(F ? GUт) = = tr FтF ? tr FтGUт = kFk2 ? tr UUт = = kFk2 ? tr=Xn j=1 ?j ? Xm j=1 ?j = Xn j=m+1 ?j , где ?1, . . . , ?n все собственные значения матрицы FтF. Минимум 2 достигается, когда ?1, . . . , ?m наибольшие m из n собственных значений. Собственные векторы u1, . . . , um, отвечающие максимальным собственным зна- чениям, называют главными компонентами. Из Теоремы 5.2 вытекают следующие свойства метода главных компонент.
92 К.В.Воронцов. Вычислительные методы обучения по прецедентам Связь с сингулярным разложением. Если m = n, то 2(G, U) = 0. В этом случае представление F = GUт является точным и совпадает с сингулярным разложением: F = GUт = V DUт, если положить G = V D и = D2. При этом матрица V орто- гональна: V тV = Im. Остальные свойства сингулярного разложения, перечисленные на стр. 85, непосредственно вытекают из Теоремы 5.2. Если m < n, то представление F ? GUт является приближённым. Сингулярное разложение матрицы GUт получается из сингулярного разложения матрицы F путём отбрасывания (обнуления) n ? m минимальных собственных значений. Преобразование Карунена-Лоэва. Диагональность матрицы GтG = означает, что новые признаки g1, . . . , gm не коррелируют на обучающих объектах. Ортогональ- ное преобразование U называют декоррелирующим или преобразованием Карунена- Лоэва. Если m = n, то прямое и обратное преобразование вычисляются с помощью одной и той же матрицы U: F = GUт и G = FU. Задача наименьших квадратов в новом признаковом пространстве имеет вид kG? ? yk2 > min ? . Поскольку U ортогональна, G? = GUтU? = GUт? ? F?, где ? = U?. Это озна- чает, что задача наименьших квадратов в новом пространстве соответствует замене матрицы F на её приближение GUт в исходной задаче наименьших квадратов. Интересно отметить, что новый вектор коэффициентов ? связан со старым ? тем же линейным преобразованием U: ? = UтU? = Uт?. В новом пространстве МНК-решение не требует явного обращения матрицы, поскольку GтG диагональна: ?? = ?1Gтy = D?1V тy; G?? = V D?? = V V тy. Для вектора ?? = U?? МНК-решение выглядит так же, как и раньше, с той лишь разницей, что в суммах (5.5)-(5.7) надо взять первые m 6 n слагаемых, а остав- шиеся n ? m просто отбросить. Интересно сравнить метод главных компонент и гребневую регрессию. Оба сво- дятся к модификации сумм (5.5)-(5.7). Гребневая регрессия сокращает коэффици- енты при всех слагаемых, а метод главных компонент обнуляет коэффициенты при последних слагаемых. Возможно, имеют смысл и комбинации этих двух методов. Эффективная размерность. Главные компоненты содержат основную информа- цию о матрице F. Число главных компонент m называют также эффективной раз- мерностью задачи. На практике её определяют следующим образом. Все собствен- ные значения матрицы FтF упорядочиваются по убыванию: ?1 > . . . > ?n > 0. Задаётся пороговое значение ? ? [0, 1], достаточно близкое к нулю, и определяется наименьшее целое m, при котором относительная погрешность приближения матри- цы F не превышает ?: E(m) = kGUт ? Fk2 kFk2 = ?m+1 + - - - + ?n ?1 + - - - + ?n 6 ?.
93 Величина E(m) показывает, какая доля информации теряется при замене ис- ходных признаковых описаний длины n на более короткие описания длины m. Метод главных компонент особенно эффективен в тех случаях, когда E(m) оказывается ма- лым уже при малых значениях m. Если задать число ? из априорных соображений не представляется возможным, прибегают к критерию ?крутого обрыва?. На графике E(m) отмечается то значе- ние m, при котором происходит резкий скачок: E(m ? 1) ? E(m), при условии, что E(m) уже достаточно мал?о. Визуализация многомерных данных. Метод главных компонент часто использу- ется для представления многомерной выборки данных на двумерном графике. Для этого полагают m = 2 и полученные пары значений ??g1(xi), g2(xi), i = 1, . . . , ?, наносят как точки на график. Проекция на главные компоненты является наиме- нее искаженной из всех линейных проекций многомерной выборки на какую-либо пару осей. Как правило, в осях главных компонент удаётся увидеть наиболее суще- ственные особенности исходных данных, даже несмотря на неизбежные искажения. В частности, можно судить о наличии кластерных структур и выбросов. Две оси g1 и g2 отражают ?две основные тенденции? в данных. Иногда их удаётся интерпре- тировать, если внимательно изучить, какие точки на графике являются ?самыми левыми?, ?самыми правыми?, ?самыми верхними? и ?самыми нижними?. Этот вид анализа не позволяет делать точные количественные выводы и обычно используется с целью понимания данных. Аналогичную роль играют многомерное шкалирование (см. ??) и карты Кохонена (см. 7.2.2). :5.5 Нелинейные методы восстановления регрессии Предположение о том, что модель регрессии линейна по параметрам, удобно для построения численных методов, но не всегда хорошо согласуется со знаниями о предметной области. В этом параграфе рассматриваются случаи, когда модель регрессии нелинейна по параметрам, когда в линейную модель добавляются нели- нейные преобразования исходных признаков или целевого признака, а также когда вводится неквадратичная функция потерь. Общая идея во всех этих случаях одна: нелинейная задача сводится к решению последовательности более простых линейных задач. 5.5.1 Нелинейная модель регрессии Пусть задана нелинейная модель регрессии f(x, ?) и требуется минимизировать функционал качества по вектору параметров ? ? Rp: Q(?,X?) =X? i=1 ??f(xi, ?) ? yi2. Для выполнения численной минимизации функционала Q воспользуемся мето- дом Ньютона-Рафсона. Выберем начальное приближение ?0 = (?01, . . . , ?0p) и органи- зуем итерационный процесс ?t+1 := ?t ? ht??Q''(?t)?1Q'(?t),
94 К.В.Воронцов. Вычислительные методы обучения по прецедентам где Q'(?t)градиент функционала Q в точке ?t, Q''(?t)гессиан (матрица вто- рых производных) функционала Q в точке ?t, ht величина шага, который можно регулировать, а в простейшем варианте просто полагать равным единице. Запишем компоненты градиента: ? ??jQ(?) = 2X? i=1 ??f(xi, ?) ? yi?f ??j (xi, ?). Запишем компоненты гессиана: ?2 ??j??kQ(?) = 2 X? i=1 ?f ??j (xi, ?) ?f ??k (xi, ?) ? 2 X? i=1 ??f(xi, ?) ? yi?2f ??j??k (xi, ?) | {z } при линеаризации полагается равным 0 . Поскольку функция f задана, градиент и гессиан легко вычисляются численно. Основная сложность метода Ньютона-Рафсона заключается в обращении гессиана на каждой итерации. Более эффективной с вычислительной точки зрения является следующая мо- дификация этого метода. Если функция f достаточно гладкая (дважды непрерывно дифференцируема), то её можно линеаризовать в окрестности текущего значения вектора коэффициентов ?t: f(xi, ?) = f(xi, ?t) + Xp j=1 ?f ??j (xi, ?j)???j ? ?tj . Заменим в гессиане функцию f на её линеаризацию. Это всё равно, что поло- жить второе слагаемое в гессиане равным нулю. Тогда не нужно будет вычислять вторые производные ?2f ??j??k (xi, ?). Этот метод называют методом Ньютона-Гаусса. В остальном он ничем не отличается от метода Ньютона-Рафсона. Введём матричные обозначения: Ft = ?? ?f ??j (xi, ?t)j=1,p i=1,? матрица первых произ- водных размера ??p на t-й итерации; ft = ??f(xi, ?t)i=1,? вектор значений аппрокси- мирующей функции на t-й итерации. Тогда формула t-й итерации метода Ньютона- Гаусса в матричной записи примет вид: ?t+1 := ?t ? ht (Fт t Ft)?1Fт t (ft | {z ? y}) ? . В правой части записано решение стандартной задачи многомерной линейной регрессии kFt??(ft?y)k2 > min ? . Таким образом, в методе Ньютона-Гаусса нелиней- ная регрессия сводится к последовательности линейных регрессионных задач. Ско- рость сходимости у него практически такая же, как и у метода Ньютона-Рафсона (оба являются методами второго порядка), но вычисления несколько проще и вы- полняются стандартными методами линейной регрессии. 5.5.2 Нелинейные одномерные преобразования признаков На практике встречаются ситуации, когда линейная модель регрессии пред- ставляется необоснованной, но предложить адекватную нелинейную модель f(x, ?)
95 Алгоритм 5.2. Метод настройки с возвращениями (backfitting). Вход: F, y матрица ?объекты-признаки? и вектор ответов; Выход: ?j(x) функции преобразования признаков, в общем случае нелинейные. 1: нулевое приближение: ? := решение задачи МЛР с признаками fj(x); ?j(x) := ?jfj(x), j = 1, . . . , n; 2: повторять 3: для j = 1, . . . , n 4: zi := yi ? Pn k=1,k6=j ?k(fk(xi)), i = 1, . . . , ?; 5: ?j := argmin ? P? i=1???(fj(x)) ? zi2; 6: Qj := P? i=1???j(fj(x)) ? zi2; 7: пока значения Qj не стабилизируются также не удаётся. Тогда в качестве компромисса строится модель вида f(x, ?) = Xn j=1 ?j(fj(x)), где ?j : R > Rнекоторые преобразования исходных признаков, в общем случае нелинейные. Задача состоит в том, чтобы подобрать неизвестные одномерные преоб- разования ?j , при которых достигается минимум квадратичного функционала (5.1). Метод настройки с возвращениями предложен Хасти и Тибширани в 1986 го- ду [43]. Схема реализации показана в Алгоритме 5.2. Метод основан на итерационном уточнении функций ?j . На первом шаге они полагаются линейными, ?j(x) = ?jfj(x), и неизвестные коэффициенты ?j настраи- ваются методами многомерной линейной регрессии. На каждом последующем шаге выбирается одна из функций ?j , все остальные фиксируются, и выбранная функция строится заново. Для этого решается стандартная задача наименьших квадратов Q(?j ,X?) = X? i=1 ?j(fj(xi)) ? ??yi ?Pnk=1,k6=j ?k(fk(xi))| {z } zi=const(?j ) 2 > min ?j с обучающей выборкой Z?j = ??fj(xi), zi?i=1. Для решения данной задачи годятся лю- бые одномерные методы: ядерное сглаживание, сплайны, полиномиальная или Фу- рье-аппроксимация.
96 К.В.Воронцов. Вычислительные методы обучения по прецедентам 5.5.3 Обобщённые линейные модели Рассмотрим другую ситуацию, когда модель регрессии f(x, ?) линейна, но из- вестна нелинейная функция связи g(f) между выходом модели f и целевым призна- ком y. Задача аппроксимации ставится, исходя из принципа наименьших квадратов: Q(?,X?) =X? i=1 g??Pnj=1 ?jfj(xi) | {z } zi ? yi2 > min ??Rn, где g(f)заданная непрерывно дифференцируемая функция. Допустим, имеется некоторое приближение вектора коэффициентов ?. Линеа- ризуем функцию g(z) в окрестности каждого из ? значений zi: g(z) = g(zi) + g'(zi)(z ? zi). Тогда функционал Q аппроксимируется функционалом ?Q, квадратичным по вектору коэффициентов ?: ?Q(?,X?) = X? i=1 g(zi) + g'(zi)??Pnj=1 ?jfj(xi) ? zi? yi2 = = X? i=1 ??g'(zi)2 | {z } wi Pnj=1 ?jfj(xi) ? ??zi + yi?g(zi) g'(zi) | {z } ?yi 2 > min ??Rn . Линеаризованная задача сводится к стандартной многомерной линейной ре- грессии с весами объектов wi и модифицированным целевым признаком ?y. Решение этой задачи принимается за следующее приближение вектора коэффициентов ?. Ите- рации повторяются до тех пор, пока вектор коэффициентов ? или значение функци- онала Q(?) не перестанет существенно изменяться. 5.5.4 Неквадратичные функции потерь Функция потерь L(a, y) характеризует величину потери от ответа a ? Y при точном ответе y ? Y . Она задаётся априори, и благодаря ей задача обучения алго- ритма a(x) по выборке X? = (xi, yi)?i=1 сводится к минимизации суммарных потерь: Q(a,X?) = X? i=1 L??a(xi), y(xi)> min a: X>Y . Если функция потерь квадратична, L(a, y) = (a ? y)2, то минимизация Q со- ответствует методу наименьших квадратов, который был рассмотрен выше. При неквадратичных функциях потерь применяются численные методы оптимизации. Мы не будем подробно останавливаться на методах, а ограничимся перечислением ситуаций, в которых возникают функции потерь, отличные от квадратичных. Ненормальный шум. Как было показано в Примере 1.4, вид функции потерь свя- зан с априорными предположениями о распределении шума. В частности, квадра- тичная функция потерь соответствует гауссовскому шуму. Если распределение шума не гауссовское, то функция потерь окажется неквадратичной.
97 Проблемно-зависимые функции потерь. Во многих прикладных задачах мини- мизация ошибки предсказания |a ? y| или максимизация правдоподобия являются не самыми естественными критериями качества алгоритма. Пример 5.1. При планировании закупок в розничной сети решается регрессионная задача прогнозирования потребительского спроса. Строится алгоритм a(x), который отвечает на вопрос, сколько единиц данного товара купят в данном магазине в бли- жайшее время (скажем, в течение следующей недели). Квадрат отклонения (a ? y)2 прогноза a от реального спроса y экономического смысла не имеет. Гораздо удобнее измерять потери в рублях. Потери от заниженного прогноза a < y связаны с недо- полученной прибылью и прямо пропорциональны величине отклонения: L(a, y) = = c1|a?y|, где c1 коэффициент торговой наценки. Потери от завышенного прогно- за a > y связаны с замораживанием средств, затовариванием склада, а в худшем случаес истечением срока годности и списанием товара. В первом приближении эти потери также прямо пропорциональны отклонению, но с другим коэффициен- том: L(a, y) = c2|a ? y|. Коэффициенты c1 и c2 известны для каждого магазина и каждого товара. Таким образом, в данной задаче более обоснованной оказывается не квадратичная, а кусочно-линейная несимметричная функция потерь. Пример 5.2. При создании автоматических систем биржевой торговли строится алгоритм a(x), прогнозирующий в момент времени xi цену финансового инструмен- та на следующий момент xi+1. В данном случае квадрат отклонения (a?y)2 особого интереса не представляет. Экономический смысл имеет величина прибыли, которую можно получить, играя на бирже с применением алгоритма a(x). Допустим, мы по- купаем 1 акцию, если алгоритм предсказывает повышение, и продаём 1 акцию, если он предсказывает понижение. В следующий момент времени совершаем противопо- ложную операцию (на языке трейдеров ?закрываем позицию?), и тут же принимаем следующее решение согласно алгоритму a(x), и так далее. Суммарная прибыль, за- работанная в течение ? последовательных моментов времени x1, . . . , x?, равна Q(a) =X??1 i=1 sign??a(xi) ? y(xi)??y(xi+1) ? y(xi). Обучение алгоритма a сводится к максимизации функционала Q(a) на обуча- ющей последовательности цен y(x1), . . . , y(x?+1). Разности цен wi = |y(xi+1) ? y(xi)| играют роль весов объектовчем больше величина скачка wi, тем важнее правильно спрогнозировать направление скачка. Итак, в данной задаче содержательно обосно- ванной оказалась взвешенная кусочно-постоянная функция потерь. Робастная регрессия. Чтобы функционал Q(a,X?) был нечувствителен к выбро- сам, вводится ограниченная сверху функция потерь, например, функция Мешалки- на L(a, y) = 1 ? exp??? 1 2? (a ? y)2, где ? параметр, равный дисперсии ?обычно- го? шума, не связанного с большими выбросами. Задача минимизации функциона- ла Q(a,X?) с такой функцией потерь уже не может быть решена средствами ли- нейной алгебры; приходится применять численные методы оптимизации, например, метод сопряжённых градиентов.
98 К.В.Воронцов. Вычислительные методы обучения по прецедентам 5.5.5 Логистическая регрессия и итерационный взвешенный МНК Напомним, что неквадратичная функция потерь используется также в логи- стической регрессии, см. :4.4. Там минимизируемый функционал имеет вид Q(w) =X? i=1 ln1 + exp???wтxiyi= ? X? i=1 ln ???wтxiyi> min w , где ?(z) = (1 + e?z)?1 сигмоидная функция. Стандартная техника настройки параметров w заключается в применении ме- тода Ньютона-Рафсона для минимизации нелинейного функционала Q(w). В каче- стве нулевого приближения можно взять ?наивное? решение задачи классификации как задачи многомерной линейной регрессии, в которой ответы принимают только два значения, yi ? {?1,+1}. Затем начинается итерационный процесс, на t-м шаге которого уточняется вектор коэффициентов wt+1: wt+1 := wt ? ht??Q''(wt)?1Q'(wt), где Q'(wt)вектор первых производных (градиент) функционала Q(w) в точке wt, Q''(wt)матрица вторых производных (гессиан) функционала Q(w) в точке wt, ht величина шага, который можно положить равным 1, но более тщательный его подбор способен увеличить скорость сходимости. Найдём выражения для градиента и гессиана. Обозначим ?i = ?(yiwтxi) и заметим, что производная логистической функции есть ?'(z) = ?(z)(1 ? ?(z)). Элементы градиента (вектора первых производных) функционала Q(w): ?Q(w) ?wj = ? X? i=1 (1 ? ?i)yifj(xi), j = 1, . . . , n. Элементы гессиана (матрицы вторых производных) функционала Q(w): ?2Q(w) ?wj?wk = ? ? ?wk X? i=1 (1 ? ?i)yifj(xi) = = X? i=1 (1 ? ?i)?ifj(xi)fk(xi), j = 1, . . . , n, k = 1, . . . , n. Введём матричные обозначения: F??n = ??fj(xi)матрица признаковых описаний объектов; ????? = diag??p(1 ? ?i)?i диагональная матрица весов объектов; ? F = ??F взвешенная матрица признаковых описаний объектов; ?yi = yip(1 ? ?i)/?i, ?y = (?yi)?i=1 взвешенный вектор ответов. В этих обозначениях произведение матрицы, обратной к гессиану, на вектор градиента принимает следующий вид: ??Q''(w)?1Q'(w) = ?(Fт??2F)?1Fт???y = ?( ? Fт ? F)?1 ? Fт?y = ? ? F+?y.
99 Алгоритм 5.3. IRLS итерационный взвешенный метод наименьших квадратов Вход: F, y матрица ?объекты-признаки? и вектор ответов; Выход: w вектор коэффициентов линейной комбинации. 1: нулевое приближение обычный МНК: w := (FтF)?1Fтy; 2: для t := 1, 2, 3, . . . 3: z := Fw; 4: ?i := p(1 ? ?(zi))?(zi) для всех i = 1, . . . , ?; 5: ? F := diag(?1, . . . , ??)F; 6: ?yi := yip(1 ? ?(zi))/?(zi) для всех i = 1, . . . , ?; 7: выбрать градиентный шаг ht; 8: w := w + ht( ? Fт ? F)?1 ? Fт?y; 9: если ?(zi) мало изменились относительно предыдущей итерации то 10: прервать итерации, выйти из цикла; 11: конец цикла по t. Полученное выражение совпадает с решением задачи наименьших квадратов для многомерной линейной регрессии со взвешенными объектами и модифицирован- ными ответами: Q(w) = k ? Fw ? ?yk2 =X? i=1 (|1 ?{z?i)?}i ?i ??wтx ? yip| (1{?z ?i)/?}i ?yi 2 > min w . Таким образом, решение задачи классификации сводится к последовательности регрессионных задач, для каждой из которых веса объектов и ответы пересчитыва- ются заново. Отсюда и название метод наименьших квадратов с итерационным перевзвешиванием (iteratively reweighted least squares, IRLS) Понять смысл этого пересчёта совсем нетрудно. Во-первых, заметим, что вели- чина ?i равна вероятности правильного ответа алгоритма wt на объекте xi. Поэтому вес ?i максимален для пограничных объектов, у которых эта вероятность близка к 12 . Увеличение точности настройки на этих объектах способствует уменьшению неопре- делённости классификации. Во-вторых, по мере увеличения вероятности ошибки ал- горитма wt на объекте xi модифицированный ответ ?yi возрастает по модулю. Это приводит к повышению точности настройки алгоритма wt+1 на тех объектах, кото- рые оказались ?наиболее трудными? для алгоритма wt на предыдущей итерации. :5.6 Метод опорных векторов в задачах регрессии В главе 5 мы уже рассматривали задачи многомерной линейной регрессии, предполагая, что X = Rn, Y = R, алгоритм имеет вид a(x) = hw, xi ? w0, и для настройки параметров w ? Rn и w0 ? R минимизируется квадратичный функционал. В случае гребневой регрессии (см. раздел 5.3.3) вводится ещё и штрафное слагаемое,
100 К.В.Воронцов. Вычислительные методы обучения по прецедентам -3 -2 -1 0 1 2 3 0123 z Рис. 17. Функции потерь в задачах регрессии: кусочно-линейная |z|" при " = 1 и квадратичная z2. предотвращающее бесконтрольное увеличение коэффициентов w: Q(a,X?) =X? i=1 ??hw, xii ? w0 ? yi)2 + ?kwk2 > min w,w0, где ? параметр регуляризации. Выбор именно квадратичной функции потерь обу- словлен удобством решения задачи наименьших квадратов. Однако в некоторых случаях более естественно использовать кусочно-линейную функцию ?-чувствительности, показанную на Рис 17: |z|? = ??|z| ? ?+, которая не считает за ошибки отклонения a(xi) от yi, меньшие ?. Предполагается, что значе- ние параметра ? задаёт эксперт, исходя из априорных соображений. С этой функцией потерь функционал принимает вид Q?(a,X?) = X? i=1 hw, xii ? w0 ? yi? + ? hw,wi2 > min w,w0 . (5.12) Легко обнаруживается сходство данной задачи с задачей классификации (4.18). Покажем, что минимизация (5.12) эквивалентна некоторой задаче квадратичного программирования с линейными ограничениями типа неравенств. При этом так- же возникает двойственная задача, зависящая только от двойственных перемен- ных; также достаточно оставить в выборке только опорные объекты; также реше- ние выражается через скалярные произведения объектов, а не сами объекты; и так- же можно использовать ядра. Иными словами, SVM-регрессия отличается от SVM- классификации только в технических деталях, основные идеи остаются теми же. Положим C = 1 2? . Введём дополнительные переменные ?+i и ??i , значения кото- рых равны потере при завышенном и заниженном ответе a(xi) соответственно: ?+i = (a(xi) ? yi ? ?)+ , ??i = (?a(xi) + yi ? ?)+ , i = 1, . . . , ?. Тогда задача минимизации (5.12) может быть переписана в эквивалентной фор- ме как задача квадратичного программирования с линейными ограничениями-нера- венствами относительно переменных wi, w0, ?+i и ??i : ????? ???? 12 hw,wi + C P? i=1(?+i + ??i ) > min w,w0,?+,??; yi ? ? ? ??i 6 hw, xii ? w0 6 yi + ? + ?+i , i = 1, . . . , ?; ??i > 0, ?+i > 0, i = 1, . . . , ?. (5.13) Как и в предыдущих случаях, лагранжиан этой задачи выражается через двой- ственные переменные ?+i , ??i, i = 1, . . . , ?, а скалярные произведения hxi, xji можно
101 заменить ядром K(xi, xj). Опуская выкладки, представим результат: ??????????? ?????????? L(?+, ??) = ??P? i=1(??i+ ?+i ) + P? i=1(??i ? ?+i )yi ? ? 12 P? i,j=1(??i ? ?+i )(??j ? ?+j )K(xi, xj) > max ?+,??; 0 6 ?+i 6 C, 0 6 ??i6 C, i = 1, . . . , ?; P? i=1(??i+ ?+i ) = 0. Все объекты xi, i = 1, . . . , ? делятся на следующие пять типов: 1. |a(xi) ? yi| < ?; ?+i = ??i= ?+i = ??i = 0. Ответ алгоритма a(xi) находится внутри отрезка [yi ? ?, yi + ?] и считается верным. Объект xi не является опорным вектор весов w не изменился бы, если бы этого объекта изначально не было в выборке. 2. a(xi) = yi + ?; 0 < ?+i < C; ??i= 0; ?+i = ??i = 0. 3. a(xi) = yi ? ?; 0 < ??i< C; ?+i = 0; ?+i = ??i = 0. 4. a(xi) > yi + ?; ?+i = C; ??i= 0; ?+i = a(xi) ? yi ? ? > 0; ??i = 0. 5. a(xi) < yi ? ?; ??i= C; ?+i = 0; ??i = yi ? a(xi) ? ? > 0; ?+i = 0. Объекты типов 2-5 являются опорными и учитываются при определении век- тора весов. При этом только на объектах типов 4 и 5 возникает ненулевая ошибка. Уравнение регрессии также выражается через двойственные переменные: a(x) = X? i=1 (??i ? ?+i )K(xi, x) ? w0; где параметр w0 определяется из ограничений-неравенств, которые становятся ра- венствами на опорных объектах типа 2 и 3: hw, xii ? w0 = (yi + ?, если xi объект типа 2; yi ? ?, если xi объект типа 3. Как и раньше, чтобы избежать численной неустойчивости, имеет смысл взять меди- ану множества значений w0, вычисленных по всем опорным векторам. В этом методе есть два управляющих параметра. Параметр точности ? задаётся из априорных соображений. Параметр регуляризации C подбирается, как правило, по скользящему контролю, что является вычислительно трудоёмкой процедурой. Более обстоятельное изложение многочисленных особенностей SVM-регрессии можно найти в руководстве [61].
102 К.В.Воронцов. Вычислительные методы обучения по прецедентам 6 Искусственные нейронные сети Человеку и высшим животным буквально на каждом шагу приходится распо- знавать, принимать решения и обучаться. Нейросетевой подход возник из стремления понять, каким образом мозг решает столь сложные задачи, и реализовать эти прин- ципы в автоматических устройствах. Пока искусственные нейронные сети (artificial neural networks, ANN) являются лишь предельно упрощёнными аналогами естествен- ных нейронных сетей. Нервные системы животных и человека гораздо сложнее тех устройств, которые можно создать с помощью современных технологий. Однако для успешного решения многих практических задач оказалось вполне достаточно ?под- смотреть? лишь общие принципы функционирования нервной системы. Некоторые разновидности ANN представляют собой математические модели, имеющие лишь отдалённое сходство с нейрофизиологией, что отнюдь не препятствует их практиче- скому применению. :6.1 Проблема полноты Итак, отдельно взятый нейрон вида (??) позволяет реализовать линейный клас- сификатор или линейную регрессию. При решении практических задач линейность оказывается чрезмерно сильным ограничением. На ограниченность персептрона ука- зывали Минский и Пайперт в своей знаменитой книге ?Персептроны? [54]. Следу- ющий классический контрпример иллюстрирует невозможность нейронной реализа- ции даже очень простых функций. 6.1.1 Задача ?исключающего ИЛИ? Легко построить нейроны, реализующие логические функции И, ИЛИ, НЕ от бинарных переменных x1 и x2, см. Рис. 18: x1 ? x2 = x1 + x2 ? 12 > 0; x1 ? x2 = x1 + x2 ? 32 > 0; !x1 = ?x1 + 12 > 0; Однако функцию x1 ? x2 = [x1 6= x2]исключающее ИЛИ (exclusive or, XOR) принципиально невозможно реализовать одним нейроном с двумя входами x1 и x2, поскольку множества нулей и единиц этой функции линейно неразделимы. Возможны два пути решения этой проблемы, см. Рис 20. Первый путь пополнить состав признаков, подавая на вход нейрона нели- нейные преобразования исходных признаков. В частности, если разрешить образо- вывать всевозможные произведения исходных признаков, то нейрон будет строить уже не линейную, а полиномиальную разделяющую поверхность. В случае исклю- чающего ИЛИ достаточно добавить только один вход x1x2, чтобы в расширенном пространстве множества нулей и единиц оказались линейно разделимыми: x1 ? x2 = x1 + x2 ? 2x1x2 ? 12 > 0. Расширенные пространства признаков, в которых линейный классификатор безошибочно разделяет обучающую выборку, называют спрямляющими. Проблема
103 @GAFxBE1 CD @GAFxBE2 CD @G?AFBE1CD X (x1 ? x2) 1 LL LL &&LLL LL 1 // 1/2 rrr 88rrr r // Рис. 18. Однослойный персептрон, реализующий операцию ИЛИ. @GAFxBE1 CD @GAFxBE2 CD @G?AFBE1CD XX X @G?AFBE1CD (x1 ? x2) R1 RRR ((RRR R ll1 66lll lll 1 99 99 9 99 99 99 99 9 RR1 ((RRR RRR 1/2 BB 3/2 lll 66lll +1 RRR ((RRR ?1 lll 66lll 1/2PP // Рис. 19. Двухслойная сеть, реализующая опера- цию исключающего ИЛИ. 0.0 0.5 1.0 0.0 0.5 1.0 0.0 0.5 1.0 0.0 0.5 1.0 0.0 0.5 1.0 0.0 0.5 1.0 0.0 0.5 1.0 0.0 0.5 1.0 Рис. 20. Персептронная реализация элементарных логических функций. Слева направо: И, ИЛИ, XOR с помощью добавления признака x1x2, XOR с помощью двухслойной сети. заключается в том, что подбор нужных нелинейных преобразований является нетри- виальной задачей, которая для общего случая до сих пор остаётся нерешённой. Второй путь построить композицию из нескольких нейронов. Например, исключающее ИЛИ можно реализовать, подав выходы И-нейрона и ИЛИ-нейрона на вход ещё одному ИЛИ-нейрону, Рис 19: x1 ? x2 = (x1 ? x2) ? (x1 ? x2) ? 12 > 0. Дальнейшее обобщение этой идеи приводит к построению многослойных ней- ронных сетей, состоящих из огромного количества связанных нейронов и напомина- ющих естественные нейронные сети. Пример такой композиции показан на Рис. 21. Значения всех n признаков одновременно подаются на вход всех H нейронов первого слоя. Затем их выходные значения подаются на вход всех M нейронов следующего слоя. В данном случае этот слой является выходным такая сеть называется двух- слойной.6 В общем случае сеть может содержать произвольное число слоёв. Все слои, за исключением последнего, называются скрытыми (hidden layers). Вычисление выходных значений сети может осуществляться с высокой степе- нью параллелизма, за число тактов, равное числу слоёв. Существуют эффективные аппаратные реализации нейронных сетей, в которых вычисления действительно про- исходят параллельно. Но пока на практике чаще используются программные реали- зации, выполненные на обычных последовательных компьютерах. 6Существует терминологическая путаница с подсчётом числа слоёв. Иногда такую сеть (видимо, глядя на картинку) называют трёхслойной, считая входы x0, x1, . . . , xn особым, ?распределитель- ным? слоем. По делу, в счёт должны идти только слои, состоящие из суммирующих нейронов.
104 К.В.Воронцов. Вычислительные методы обучения по прецедентам 6.1.2 Вычислительные возможности нейронных сетей. Возникает вопрос: любую ли функцию можно представить (хотя бы прибли- жённо) с помощью нейронной сети? Следующие факты позволяют ответить на этот вопрос утвердительно. 1. Любая булева функция представима в виде двухслойной сети. Это тривиаль- ное следствие нейронной представимости функций И, ИЛИ, НЕ и представимости произвольной булевой функции в виде дизъюнктивной нормальной формы [29]. 2. Из простых геометрических соображений вытекает, что двухслойная сеть с пороговыми функциями активации позволяет выделить произвольный выпуклый многогранник в n-мерном пространстве признаков. Трёхслойная сеть позволяет вы- числить любую конечную линейную комбинацию характеристических функций вы- пуклых многогранников, следовательно, аппроксимировать любые области с непре- рывной границей, включая невыпуклые и даже неодносвязные, а также аппрокси- мировать любые непрерывные функции. 3. В 1900 году Гильберт предложил список из 23 нерешённых задач, которые, по его мнению, должны были стать вызовом для математиков XX века. Тринадца- тая проблема заключалась в следующем: возможно ли произвольную непрерывную функцию n аргументов представить в виде суперпозиции функций меньшего числа аргументов. Ответ был дан А.Н.Колмогоровым в [14]. Теорема 6.1 (Колмогоров, 1957). Любая непрерывная функция n аргументов на единичном кубе [0, 1]n представима в виде суперпозиции непрерывных функций одного аргумента и операции сложения: f(x1, x2, . . . , xn) = 2Xn+1 k=1 hkXn i=1 ?ik(xi), где hk, ?ik непрерывные функции, причём ?ik не зависят от выбора f. Нетрудно видеть, что записанное здесь выражение имеет структуру нейрон- ной сети с одним скрытым слоем из 2n+1 нейронов. Таким образом, двух слоёв уже достаточно, чтобы вычислять произвольные непрерывные функции, и не приближён- но, а точно. К сожалению, представление Колмогорова не является персептроном: функции ?ik не линейны, а функции hk зависят от f, и в общем случае не являются дифференцируемыми. 4. Известна классическая теорема Вейерштрасса о том, что любую непрерыв- ную функцию n переменных можно равномерно приблизить полиномом с любой сте- пенью точности. Более общая теорема Стоуна утверждает, что любую непрерывную функцию на произвольном компакте X можно приблизить не только многочленом от исходных переменных, но и многочленом от любого конечного набора функций F, разделяющих точки [62]. Опр. 6.1. Набор функций F называется разделяющим точки множества X, если для любых различных x, x' ? X существует функция f ? F такая, что f(x) 6= f(x'). Теорема 6.2 (Стоун, 1948). Пусть X компактное пространство, C(X) ал- гебра непрерывных на X вещественных функций, F кольцо в C(X), содержащее константу (1 ? F) и разделяющее точки множества X. Тогда F плотно в C(X).
105 На самом деле справедливо ещё более общее утверждение. Оказывается, вместо многочленов (суперпозиции операций сложения и умножения) можно пользоваться суперпозициями сложения и какой-нибудь (практически произвольной) непрерывной нелинейной функции одного аргумента [21]. Этот результат имеет прямое отноше- ние к нейронным сетям, поскольку они строятся из операций сложения, умножения и нелинейных функций активации. Опр. 6.2. Набор функций F ? C(X) называется замкнутым относительно функ- ции ? : R > R, если для любого f ? F выполнено ?(f) ? F. Теорема 6.3 (Горбань, 1998). Пусть X компактное пространство, C(X) ал- гебра непрерывных на X вещественных функций, F линейное подпространство в C(X), замкнутое относительно нелинейной непрерывной функции ?, содержащее константу (1 ? F) и разделяющее точки множества X. Тогда F плотно в C(X). Это интерпретируется как утверждение об универсальных аппроксимационных возможностях произвольной нелинейности: с помощью линейных операций и един- ственного нелинейного элемента ? можно получить устройство, вычисляющее любую непрерывную функцию с любой желаемой точностью. Однако данная теорема ничего не говорит о количестве слоёв нейронной сети (уровней вложенности суперпозиции) и о количестве нейронов, необходимых для аппроксимации произвольной функции. Таким образом, нейронные сети являются универсальными аппроксиматорами функций. Возможности сети возрастают с увеличением числа слоёв и числа нейро- нов в них. Двух-трёх слоёв, как правило, достаточно для решения подавляющего большинства практических задач классификации, регрессии и прогнозирования. :6.2 Многослойные нейронные сети Многослойные сети, так же, как и однослойный персептрон (линейный класси- фикатор), можно настраивать градиентными методами, несмотря на огромное коли- чество весовых коэффициентов. В середине 80-х одновременно несколькими исследо- вателями был предложен эффективный способ вычисления градиента, при котором каждый градиентный шаг выполняется за число операций, лишь немногим большее, чем при обычном вычислении сети на одном объекте. Это кажется удивительным ведь количество операций, необходимых для вычисления градиента, обычно возрас- тает пропорционально размерности, то есть числу весовых коэффициентов. Здесь этого удаётся избежать благодаря аналитическому дифференцированию суперпози- ции с сохранением необходимых промежуточных величин. Метод получил название обратного распространения ошибок (error back-propagation) [58]. 6.2.1 Метод обратного распространения ошибок Рассмотрим многослойную сеть, в который каждый нейрон предыдущего слоя связан со всеми нейронами последующего слоя, Рис. 21. Такая сеть называется пол- носвязной. Для большей общности положим X = Rn, Y = RM. Введём следующие обозначения. Пусть выходной слой состоит из M нейро- нов с функциями активации ?m и выходами am, m = 1, . . . ,M. Перед ним находится скрытый слой из H нейронов с функциями активации ?h и выходами uh, h = 1, . . . ,H.
106 К.В.Воронцов. Вычислительные методы обучения по прецедентам @GAFxBE1 CD @GAFxBEj CD @GAFxBEn CD @G?AFBE1CD . . . . . . XXX ?1 ?h ?H . . . . . . @G?AFBE1CD w11 // w1h RRR ))RRR RRR RRR RRR RRR RR w1H EE EE "" EEE EE EE EE EE EE EE EE EE EE wj1 lll 55lll lll lll lll lll lll wjh // wjH R R R ))RRR RRR RRR RRR RRR RR wn1 yy yy y <<y yy yy yy yy yy yy yy yy yy yy y wnh lll 55lll lll lll lll lll lll wnH // w01 FF w0h AA w0H :: XXX ?1 ?m ?M . . . . . . w11 // w1m RRR ))RRR RRR RRR RRR RRR RR w1M EE EE "" EEE EE EE EE EE EE EE EE EE EE wh1 lll 55lll lll lll lll lll lll whm // whM RRR ))RRR RRR RRR RRR RRR RR wH1 yy yy <<y yy yy yy yy yy yy yy yy yy yy y wHm lll 55lll lll lll lll lll lll wHM // w01 FF w0m AA w0M :: a1 am aM // // // z }| { входной слой, n признаков z }| { скрытый слой, H нейронов z }| { выходной слой, M нейронов Рис. 21. Многослойная сеть с одним скрытым слоем. Веса синаптических связей между h-м нейроном скрытого слоя и m-м нейроном вы- ходного слоя будем обозначать через whm. Перед этим слоем может находиться либо входной слой признаков (называемый также распределительным слоем), либо ещё один скрытый слой с выходами vj , j = 1, . . . , J и синаптическими весами wjh. В об- щем случае число слоёв может быть произвольным. Если сеть двухслойная, то vj есть просто j-й признак: vj(x) ? fj(x) ? xj , и J = n. Обозначим через w вектор всех си- наптических весов сети. Выходные значения сети на объекте xi вычисляются как суперпозиция: am(xi) = ?mXH h=0 whmuh(xi); uh(xi) = ?hXJ j=0 wjhvj(xi). (6.1) Зафиксируем объект xi и запишем функционал среднеквадратичной ошибки (для других функций потерь выкладки могут быть проделаны аналогично): Q(w) = 12 XM m=1??am(xi) ? ymi 2. (6.2) В дальнейшем нам понадобятся частные производные Q по выходам нейронов. Выпишем их сначала для выходного слоя: ?Q(w) ?am = am(xi) ? ymi = ?mi. Оказывается, частная производная Q по am равна величине ошибки ?miна объекте xi. Теперь выпишем частные производные по выходам скрытого слоя: ?Q(w) ?uh = XM m=1??am(xi) ? ymi ?'mwhm = XM m=1 ?mi?'mwhm = ?hi.
107 Эту величину, по аналогии с ?mi, будем называть ошибкой сети на скрытом слое и обозначать через ?hi. Через ?'mобозначена производная функции активации, вычисленная при том же значении аргумента, что и в (6.1). Если используется сиг- моидная функция активации, то для эффективного вычисления производной можно воспользоваться формулой ?'m= ?m(1 ? ?m) = am(xi)??1 ? am(xi). Заметим, что ?hiвычисляется по ?mi, если запустить сеть ?задом наперёд?, подав на выходы нейронов скрытого слоя значения ?mi?'m, а результат ?h получив на входе. При этом входной вектор скалярно умножается на вектор весов whm, находящих- ся справа от нейрона, а не слева, как при прямом вычислении (отсюда и название алгоритма обратное распространение ошибок): ?hi X ?1i?'1 ?Mi?'M . . . oottjwh1 jjj jjj jj whM TTTT TTT Имея частные производные по am и uh, легко выписать градиент Q по весам: ?Q(w) ?whm = ?Q(w) ?am ?am ?whm = ?mi?'muh(xi), m = 1, . . . ,M, h = 0, . . . ,H; (6.3) ?Q(w) ?wjh = ?Q(w) ?uh ?uh ?wjh = ?hi?'hvj(xi), h = 1, . . . ,H, j = 0, . . . , J; (6.4) и так далее для каждого слоя. Если слоёв больше двух, то остальные частные про- изводные вычисляются аналогично обратным ходом по слоям сети справа налево. Теперь мы обладаем всем необходимым, чтобы полностью выписать алгоритм обратного распространения, см. Алгоритм 6.1. Достоинства метода обратного распространения. : Достаточно высокая эффективность. В случае двухслойной сети прямой ход, обратный ход и вычисления градиента требуют порядка O(Hn+HM) операций. : Через каждый нейрон проходит информация только о связных с ним нейронах. Поэтому back-propagation легко реализуется на вычислительных устройствах с параллельной архитектурой. : Высокая степень общности. Алгоритм легко записать для произвольного числа слоёв, произвольной размерности выходов и выходов, произвольной функции потерь и произвольных функций активации, возможно, различных у разных нейронов. Кроме того, back-propagation можно применять совместно с различ- ными градиентными методами оптимизации: методом скорейшего спуска, со- пряженных градиентов, Ньютона-Рафсона и др. Недостатки метода обратного распространения. : Метод наследует известные недостатки градиентной настройки весов в одно- слойном персептроне. Здесь также возникают проблемы медленной сходимости
108 К.В.Воронцов. Вычислительные методы обучения по прецедентам Алгоритм 6.1. Обучение двухслойной сети методом back-propagation обратного распространения ошибки Вход: X? = (xi, yi)?i=1 обучающая выборка, xi ? Rn, yi ? RM; H число нейронов в скрытом слое; ? темп обучения; Выход: синаптические веса wjh, whm; 1: инициализировать веса небольшими случайными значениями: wjh := random??? 1 2n, 1 2n; whm := random??? 1 2H , 1 2H ; 2: повторять 3: выбрать прецедент (xi, yi) ? X? случайным образом; 4: прямой ход: uhi:= ?h??PJj=0 wjhxji , для всех h = 1, . . . ,H; ami:= ?m??PHh=0 whmuhi , для всех m = 1, . . . ,M; ?mi:= ami ? ymi , для всех m = 1, . . . ,M; Qi := PMm=1(?mi)2; 5: обратный ход: ?hi:= PMm=1 ?mi?'mwhm, для всех h = 1, . . . ,H; 6: градиентный шаг: whm := whm ? ??mi?'muhi, для всех h = 0, . . . ,H, m = 1, . . . ,M; wjh := wjh ? ??hi?'hxji , для всех j = 0, . . . , n, h = 1, . . . ,H; 7: Q := ??1 ? Q + 1?Qi; 8: пока Q не стабилизируется; или расходимости, ?застревания? в локальных минимумах функционала Q, пе- реобучения и паралича. Причём парализоваться могут отдельные связи, ней- роны, или вся сеть в целом. : Приходится заранее фиксировать число нейронов скрытого слоя H. В то же вре- мя, это критичный параметр сложности сети, от которого может существенно зависеть качество обучения и скорость сходимости. 6.2.2 Эвристики для улучшения сходимости Для улучшения сходимости и качества градиентного обучения применяются все те же приёмы, которые рекомендовались в 4.3.2 для обучения однослойного персеп- трона методом стохастического градиента. К ним добавляется ряд новых рекомен- даций, связанных с многослойностью. Выбор начального приближения. Для предотвращения паралича синаптические веса должны инициализироваться небольшими по модулю значениями. В Алго- ритме 6.1 на шаге 1 веса инициализируются случайными значениями из отрезка ? 1 2k , 1 2k , где k число нейронов в том слое, из которого выходит данный синапс.
109 В этом случае (и при условии, что все признаки нормализованы) значения скаляр- ных произведений гарантированно попадают в ?рабочую зону? функций активации, представленных на Рис. 9. Существует и более тонкий способ формирования начального приближения. Идея заключается в том, чтобы сначала настроить нейроны первого слоя по- отдельности, как H однослойных персептронов. Затем по-отдельности настраивают- ся нейроны второго слоя, которым на вход подаётся вектор выходных значений пер- вого слоя. Чтобы сеть не получилась вырожденной, нейроны первого слоя должны быть существенно различными. Ещё лучше, если они будут хоть как-то приближать целевую зависимость, тогда второму слою останется только усреднить результаты первого слоя, сгладив ошибки некоторых нейронов7. Добиться этого совсем неслож- но, если обучать нейроны первого слоя на различных случайных подвыборках, ли- бо подавать им на вход различные случайные подмножества признаков. Отметим, что при формировании начального приближения не требуется особая точность на- стройки, поэтому отдельные нейроны можно обучать простейшими градиентными методами. Выбор градиентного метода оптимизации. К сожалению, градиентные методы первого порядка сходятся довольно медленно, и потому редко применяются на прак- тике. Ньютоновские методы второго порядка также непрактичны, но по другой при- чине они требуют вычисления матрицы вторых производных функционала Q(w), имеющей слишком большой размер. Метод сопряжённых градиентов этого не требу- ет, однако применять его непосредственно нельзя, так как он существенно опирается на предположение неизменности функционал Q(w), а в методе стохастического гра- диента функционал меняется при предъявлении каждого нового объекта. Необходи- мы специальные ухищрения, чтобы приспособить стандартные методы оптимизации для настройки нейронных сетей. В обзоре [50] даются следующие рекомендации. 1. Если обучающая выборка имеет большой объём (порядка нескольких сотен объектов и более), или если решается задача классификации, то можно использовать метод стохастического градиента с адаптивным шагом. 2. Диагональный метод Левенберга-Марквардта сходится в несколько раз быст- рее. В этом методе величина шага вычисляется индивидуально для каждого весового коэффициента, при этом используется только один диагональный элемент матрицы вторых производных: ?jh = ? ?2Q ?w2jh + ?, где ? остаётся глобальным параметром темпа обучения, ? новый параметр, предот- вращающий обнуление знаменателя, и, соответственно, неограниченное увеличение шага. Отношение ?/? есть темп обучения на ровных участках функционала Q(w), где вторая производная обращается в нуль. Диагональный элемент матрицы вторых производных вычисляется с помощью специального варианта back-propagation. 7Фактически, такая двухслойная сеть является простейшей алгоритмической композицией. Ней- роны первого скрытого слоя играют роль базовых алгоритмов, нейроны второго слоя реализуют корректирующую операцию. Обучение первого слоя по случайным подвыборкам с последующим взвешенным усреднением во втором слое в точности соответствует методу бэггинга (bagging), см. раздел ??. Композиции общего вида рассматриваются в главе ??.
110 К.В.Воронцов. Вычислительные методы обучения по прецедентам 3. Если обучающая выборка имеет небольшой объём, или если решается задача регрессии, то лучше использовать адаптированные варианты метода сопряжённых градиентов. Адаптация заключается в том, что объекты предъявляются не по од- ному, а пакетами (batch learning). Состав пакета может формироваться случайным образом. Для каждого пакета минимизируемый функционал остаётся фиксирован- ным, что позволяет применить метод сопряжённых градиентов. 6.2.3 Оптимизация структуры сети Выбор структуры сети, то есть числа слоёв, числа нейронов и числа связей для каждого нейрона, является, пожалуй, наиболее сложной проблемой. Существу- ют различные стратегии поиска оптимальной структуры сети: постепенное наращи- вание, построение заведомо слишком сложной сети с последующим упрощением, по- очерёдное наращивание и упрощение. Проблема выбора структуры тесно связана с проблемами недообучения и пе- реобучения. Слишком простые сети не способны адекватно моделировать целевые зависимости в реальных задачах. Слишком сложные сети имеют избыточное чис- ло свободных параметров, которые в процессе обучения настраиваются не только на восстановление целевой зависимости, но и на воспроизведение шума. Выбор числа слоёв. Если в конкретной задаче гипотеза о линейной разделимости классов выглядит правдоподобно, то можно ограничиться однослойным персептро- ном. Двухслойные сети позволяют представлять извилистые нелинейные границы, и в большинстве случаев этого хватает. Трёхслойными сетями имеет смысл пользо- ваться для представления сложных многосвязных областей. Чем больше слоёв, тем более богатый класс функций реализует сеть, но тем хуже сходятся градиентные методы, и тем труднее её обучить. Выбор числа нейронов в скрытом слое H производят различными способами, но ни один из них не является лучшим. 1. Визуальный способ. Если граница классов (или кривая регрессии) слиш- ком сглажена, значит, сеть переупрощена, и необходимо увеличивать число нейронов в скрытом слое. Если граница классов (или кривая регрессии) испытывает слишком резкие колебания, на тестовых данных наблюдаются большие выбросы, веса сети принимают большие по модулю значения, то сеть переусложнена, и скрытый слой следует сократить. Недостаток этого способа в том, что он подходит только для задач с низкой размерностью пространства (небольшим числом признаков). 2. Оптимизация H по внешнему критерию, например, по критерию скользя- щего контроля или средней ошибки на независимой контрольной выборке Q(Xk). Зависимость внешних критериев от параметра сложности, каким является H, обыч- но имеет характерный оптимум. Недостаток этого способа в том, что приходится много раз заново строить сеть при различных значениях параметра H, а в случае скользящего контроля ещё и при различных разбиениях выборки на обучающую и контрольную части. Динамическое добавление нейронов. Сначала сеть обучается при заведомо недо- статочной мощности среднего слоя H ? ?. Обучение происходит до тех пор, пока
111 ошибка не перестанет убывать. Тогда добавляется один или несколько новых ней- ронов. Веса новых связей инициализируются небольшими случайными числами, ли- бо добавленные нейроны обучаются по-отдельности как однослойные персептроны. Во втором случае можно рекомендовать обучать новый персептрон на случайной под- выборке, возможно, добавив в неё те объекты, на которых текущая сеть допустила наибольшие ошибки. Веса старых связей не меняются. Затем проводится настройка сети методом обратного распространения. После добавления новых нейронов ошибка, как правило, сначала резко воз- растает, затем быстро сходится к меньшему значению. Интересно, что общее время обучения обычно оказывается лишь в 1.5-2 раза больше, чем если бы в сети сра- зу было нужное количество нейронов. Это означает, что информация, накопленная в сети, является полезной и не теряется при добавлении новых нейронов. При постепенном наращивании сети целесообразно наблюдать за динамикой какого-нибудь внешнего критерия. Прохождение значения Q(Xk) через минимум яв- ляется надёжным критерием останова, так как свидетельствует о переобученности, вызванной чрезмерным усложнением сети. Удаление избыточных связей. Метод оптимального прореживания сети (optimal brain damage, OBD) [51, 42] удаляет те связи, к изменению которых функционал Q наименее чувствителен. Уменьшение числа весов снижает склонность сети к пере- обучению. Метод OBD основан на предположении, что после стабилизации функционала ошибки Q вектор весов w находится в локальном минимуме, где функционал может быть аппроксимирован квадратичной формой: Q(w + ?) = Q(w) + 12?тH(w)? + o(k?k2), где H(w) = ?? ?2Q(w) ?wjh?wj'h' гессиан, матрица вторых производных. Как и в диагональ- ном методе Левенберга-Марквардта, предполагается, что диагональные элементы доминируют в гессиане, а остальными частными производными можно пренебречь, положив их равными нулю. Это предположение носит эвристический характер и вво- дится для того, чтобы избежать трудоёмкого вычисления всего гессиана. Если гессиан H(w) диагонален, то ?тH(w)? =XJ j=0 XH h=1 ?2jh ?2Q(w) ?w2jh . Обнуление веса wjh эквивалентно выполнению условия wjh + ?jh = 0. Введём величину значимости (salience) синаптической связи, равную изменению функцио- нала Q(w) при обнулении веса: Sjh = w2jh ?2Q(w) ?w2jh . Эвристика OBD заключается в том, чтобы удалить из сети d синапсов, соот- ветствующих наименьшим значениям Sjh. Здесь d это ещё один параметр метода настройки. После удаления производится цикл итераций до следующей стабилизации функционала Q. При относительно небольших значениях d градиентный алгоритм довольно быстро находит новый локальный минимум Q. Процесс упрощения сети останавливается, когда внутренний критерий стабилизируется, либо когда задан- ный внешний критерий начинает возрастать.
112 К.В.Воронцов. Вычислительные методы обучения по прецедентам Обнуление веса wjh между входным и скрытым слоями означает, что h-й ней- рон скрытого слоя не будет учитывать j-й признак. Тем самым происходит отбор информативных признаков для h-го нейрона скрытого слоя. Метод OBD легко приспособить и для настоящего отбора признаков. Вводит- ся суммарная значимость признака Sj = PHh=1 Sjh, и из сети удаляется один или несколько признаков с наименьшим значением Sj . Обнуление веса whm между скрытым и выходным слоями означает, что m-е вы- ходное значение не зависит от h-го нейрона скрытого слоя. Если выход одномерный (M = 1), то h-й нейрон можно удалить. В случае многомерного выхода для удаления нейронов скрытого слоя вычисляется суммарная значимость Sh = PMm=1 Shm.
113 7 Кластеризация и визуализация Во многих прикладных задачах измерять степень сходства объектов существен- но проще, чем формировать признаковые описания. Например, две строки с описа- нием молекул ДНК или протеинов гораздо легче сравнить непосредственно друг с другом, чем преобразовывать каждый из них в вектор признаков, и затем срав- нивать эти векторы. То же самое можно сказать про тексты, временные ряды или растровые изображения. Задача классификации объектов на основе их сходства друг с другом, когда принадлежность обучающих объектов каким-либо классам не задаётся, называет- ся задачей кластеризации. В :7.1 рассматриваются статистические, иерархические и графовые алгоритмы кластеризации. В :7.3 рассматриваются методы многомер- ного шкалирования, позволяющие восстанавливать признаковые описания объектов по матрице попарных расстояний между ними. :7.1 Алгоритмы кластеризации Задача кластеризации (или обучения без учителя) заключается в следующем. Имеется обучающая выборка X? = {x1, . . . , x?} ? X и функция расстояния между объектами ?(x, x'). Требуется разбить выборку на непересекающиеся подмножества, называемые кластерами, так, чтобы каждый кластер состоял из объектов, близких по метрике ?, а объекты разных кластеров существенно отличались. При этом каж- дому объекту xi ? X? приписывается метка (номер) кластера yi. Алгоритм кластеризации это функция a: X > Y , которая любому объек- ту x ? X ставит в соответствие метку кластера y ? Y . Множество меток Y в некото- рых случаях известно заранее, однако чаще ставится задача определить оптимальное число кластеров, с точки зрения того или иного критерия качества кластеризации. Решение задачи кластеризации принципиально неоднозначно, и тому есть несколько причин. Во-первых, не существует однозначно наилучшего критерия ка- чества кластеризации. Известен целый ряд достаточно разумных критериев, а также ряд алгоритмов, не имеющих чётко выраженного критерия, но осуществляющих до- статочно разумную кластеризацию ?по построению?. Все они могут давать разные результаты. Во-вторых, число кластеров, как правило, неизвестно заранее и устанав- ливается в соответствии с некоторым субъективным критерием. В-третьих, резуль- тат кластеризации существенно зависит от метрики ?, выбор которой, как правило, также субъективен и определяется экспертом. Кластеризация (обучение без учителя) отличается от классификации (обучения с учителем) тем, что метки исходных объектов yi изначально не заданы, и даже может быть неизвестно само множество Y . В этом смысле задача кластеризации ещё в большей степени некорректно поставленная, чем задача классификации. Цели кластеризации могут быть различными в зависимости от особенностей кон- кретной прикладной задачи: : Упростить дальнейшую обработку данных, разбить множество X? на группы схожих объектов чтобы работать с каждой группой в отдельности (задачи клас- сификации, регрессии, прогнозирования).
114 К.В.Воронцов. Вычислительные методы обучения по прецедентам : Сократить объём хранимых данных, оставив по одному представителю от каж- дого кластера (задачи сжатия данных). : Выделить нетипичные объекты, которые не подходят ни к одному из кластеров (задачи одноклассовой классификации). : Построить иерархию множества объектов (задачи таксономии). В первом случае число кластеров стараются сделать поменьше. Во втором слу- чае важнее обеспечить высокую степень сходства объектов внутри каждого класте- ра, а кластеров может быть сколько угодно. В третьем случае наибольший интерес представляют отдельные объекты, не вписывающиеся ни в один из кластеров. Во всех этих случаях может применяться иерархическая кластеризация, когда крупные кластеры дробятся на более мелкие, те в свою очередь дробятся ещё мельче, и т. д. Такие задачи называются задачами таксономии (taxonomy). Результатом так- сономии является не простое разбиение множества объектов на кластеры, а древооб- разная иерархическая структура. Вместо номера кластера объект характеризуется перечислением всех кластеров, которым он принадлежит, от крупного к мелкому. Классическим примером таксономии на основе сходства является систематизация живых существ, предложенная Карлом Линнеем в середине XVIII века. В совре- менном представлении биологическая иерархия имеет около 30 уровней, 7 из них считаются основными: царство, тип, класс, отряд, семейство, род, вид. Таксономии строятся во многих областях знания, чтобы упорядочить информацию о большом количестве объектов. Мы будем рассматривать алгоритмы иерархической кластери- зации, позволяющие автоматизировать процесс построения таксономий. Типы кластерных структур. Попытаемся составить реестр различных типов кла- стерных структур, которые могут возникать в практических задачах. Сгущения: внутрикластерные расстояния, как правило, мень- ше межкластерных. Ленты: для любого объекта найдётся близкий к нему объект того же кластера, в то же время существуют объекты одного кластера, которые не являются близкими. Кластеры с центром: в каждом кластере найдётся объект, такой, что почти все объекты кластера лежат внутри шара с центром в этом объекте. Кластеры могут соединяться перемычками, что затрудняет работу многих алгоритмов кластеризации.
115 Кластеры могут накладываться на разреженный фон из ред- ких нетипичных объектов. Кластеры могут перекрываться. Кластеры могут образовываться не по принципу сходства, а по каким-либо иным, заранее неизвестным, свойствам объ- ектов. Стандартные методы кластеризации здесь бессильны. Кластеры могут вообще отсутствовать. В этом случае надо применять не кластеризацию, а иные методы анализа данных. Различные алгоритмы кластеризации могут быть более или менее успешны в этих ситуациях. Простые алгоритмы, как правило, узко специализированы и да- ют адекватные результаты только в одной-двух ситуациях. Более сложные алгорит- мы, такие как FOREL или агломеративная процедура Ланса-Вильямса, справляются с несколькими типами ситуаций. Однако создание алгоритма, успешно работающего во всех ситуациях без исключения, представляется трудной и едва ли разрешимой задачей [18]. Неплохой обзор по методам кластеризации можно найти также в [46]. 7.1.1 Эвристические графовые алгоритмы Обширный класс алгоритмов кластеризации основан на представлении выбор- ки в виде графа. Вершинам графа соответствуют объекты выборки, а рёбрам попарные расстояния между объектами ?ij = ?(xi, xj). Достоинством графовых алгоритмов кластеризации является наглядность, от- носительная простота реализации, возможность вносить различные усовершенство- вания, опираясь на простые геометрические соображения. Алгоритм выделения связных компонент. Задаётся параметр R и в графе удаля- ются все рёбра (i, j), для которых ?ij > R. Соединёнными остаются только наиболее близкие пары объектов. Идея алгоритма заключается в том, чтобы подобрать такое значение R ? [min ?ij ,max ?ij ], при котором граф развалится на несколько связных компонент. Найденные связные компоненты и есть кластеры. Связной компонентой графа называется подмножество его вершин, в котором любые две вершины можно соединить путём, целиком лежащим в этом подмноже- стве. Для поиска связных компонент можно использовать стандартные алгоритмы поиска в ширину (алгоритм Дейкстры) или поиска в глубину.
116 К.В.Воронцов. Вычислительные методы обучения по прецедентам Алгоритм 7.1. Алгоритм кратчайшего незамкнутого пути (КНП) 1: Найти пару точек (i, j) с наименьшим ?ij и соединить их ребром; 2: пока в выборке остаются изолированные точки 3: найти изолированную точку, ближайшую к некоторой неизолированной; 4: соединить эти две точки ребром; 5: удалить K ? 1 самых длинных рёбер; Для подбора параметра R обычно рекомендуется построить гистограмму рас- пределения попарных расстояний ?ij . В задачах с выраженной кластерной струк- турой эта гистограмма имеет два чётких пика: зона небольших внутриклассовых расстояний и зона больших межклассовых расстояний. Параметр R задаётся как расстояние, соответствующее точке минимума между этими пиками [16]. Отметим два недостатка этого алгоритма. : Ограниченная применимость. Алгоритм выделения связных компонент наибо- лее подходит для выделения кластеров типа сгущений или лент. Наличие раз- реженного фона или ?узких перемычек? между кластерами приводит к неадек- ватной кластеризации. : Плохая управляемость числом кластеров. Для многих приложений удобнее за- давать не параметр R, а число кластеров или некоторый порог ?чёткости кла- стеризации?. Управлять числом кластеров с помощью параметра R довольно затруднительно. Приходится многократно решать задачу при разных R, что отрицательно сказывается на временных затратах. Алгоритм кратчайшего незамкнутого пути строит граф из ??1 рёбер так, чтобы они соединяли все ? точек и обладали минимальной суммарной длиной. Такой граф называется кратчайшим незамкнутым путём (КНП), минимальным покрывающим деревом или каркасом. Доказано, что этот граф строится с помощью несложной процедуры, соответствующей шагам 1-4 Алгоритма 7.1. На шаге 5 удаляются K ? 1 самых длинных рёбер, и связный граф распадается на K кластеров. В отличие от предыдущего алгоритма, число кластеров K задаётся как входной параметр. Его можно также определять графически, если упорядочить все рассто- яния, образующие каркас, в порядке убывания и отложить их на графике. Резкий скачок вниз где-то на начальном (левом) участке графика покажет количество наи- более чётко выделяемых кластеров. Этот алгоритм, как и предыдущий, очень прост и также имеет ограниченную применимость. Наличие разреженного фона или перемычек приводит к неадекватной кластеризации. Другим недостатком КНП является высокая трудоёмкость для построения кратчайшего незамкнутого пути требуется O(?3) операций. Алгоритм FOREL (ФОРмальный ЭЛемент) предложен Загоруйко и Ёлкиной в 1967 году при решении одной прикладной задачи в области палеонтологии. Алгоритм имеет многочисленные вариации, подробно описанные в [12, 11]. В основе всех этих вариаций лежит следующая базовая процедура.
117 Пусть задана некоторая точка x0 ? X и параметр R. Выделяются все точки выборки xi ? X?, попадающие внутрь сферы ?(xi, x0) 6 R, и точка x0 переносится в центр тяжести выделенных точек. Эта процедура повторяется до тех пор, пока состав выделенных точек, а значит и положение центра, не перестанет меняться. Доказано, что эта процедура сходится за конечное число шагов. При этом сфера перемещается в место локального сгущения точек. Центр сферы x0 в общем случае не является объектом выборки, потому и называется формальным элементом. Для вычисления центра необходимо, чтобы множество объектов X было не только метрическим, но и линейным векторным пространством. Это требование естественным образом выполняется, когда объекты описываются числовыми при- знаками. Однако существуют задачи, в которых изначально задана только метрика, а сложение и умножение на число не определены на X. Тогда в качестве центра сфе- ры можно взять тот объект обучающей выборки, для которого среднее расстояние до других объектов кластера минимально. Соответственно, шаг 6 заменяется на x0 := argmin x?K0 Xx'?K0 ?(x, x'). При этом заметно увеличивается трудоёмкость алгоритма. Если в линейном про- странстве для вычисления центра требуется O(?) операций, то в метрическом O(?2), где ? чисто точек в кластере. Алгоритм можно несколько ускорить, ес- ли заметить, что пересчёт центра при добавлении или удалении отдельной точки кластера требует лишь O(?) операций, а в линейном пространстве O(1). Различные варианты алгоритма FOREL отличаются способами объединения сфер в кластеры, способами варьирования параметра R, способами выбора началь- ного приближения для точек x0. В Алгоритме 7.2 представлен один из вариантов, в котором сферы строятся последовательно. На шаге 9 к центрам этих сфер применя- ется алгоритм КНП. С одной стороны, это решает проблему низкой эффективности КНП, так как сфер гораздо меньше, чем исходных объектов. С другой стороны, мы получаем более тонкую, двухуровневую, структуру кластеров: каждый кластер верхнего уровня распадается на более мелкие подкластеры нижнего уровня. Другое преимущество этого алгоритма возможность описывать кластеры произвольной геометрической формы. Варьируя параметр R, можно получать кла- стеризации различной степени детальности. Если кластеры близки по форме к ша- рам, можно сделать R достаточно большим. Для описания кластеров более сложной формы следует уменьшать R. Алгоритм 7.2 довольно чувствителен к выбору начального положения точки x0 для каждого нового кластера. Для устранения этого недостатка в [11] предлагается генерировать несколько (порядка 10..20) кластеризаций. Поскольку начальное поло- жение центров выбирается случайным образом, эти кластеризации будут довольно сильно отличаться. Окончательно выбирается та кластеризация, которая доставляет наилучшее значение заданному функционалу качества. Различные виды функционалов качества рассматриваются далее. 7.1.2 Функционалы качества кластеризации Задачу кластеризации можно ставить как задачу дискретной оптимизации: необходимо так приписать номера кластеров yi объектам xi, чтобы значение вы- бранного функционала качества приняло наилучшее значение. Существует много
118 К.В.Воронцов. Вычислительные методы обучения по прецедентам Алгоритм 7.2. Алгоритм FOREL 1: Инициализировать множество некластеризованных точек: U := X?; 2: пока в выборке есть некластеризованные точки, U 6= ?: 3: взять произвольную точку x0 ? U случайным образом; 4: повторять 5: образовать кластер сферу с центром в x0 и радиусом R: K0 := {xi ? U | ?(xi, x0) 6 R}; 6: поместить центр сферы в центр масс кластера: x0 := 1 |K0| Pxi?K0 xi; 7: пока центр x0 не стабилизируется; 8: пометить все точки K0 как кластеризованные: U := U \ K0; 9: применить алгоритм КНП к множеству центров всех найденных кластеров; 10: каждый объект xi ? X? приписать кластеру с ближайшим центром; разновидностей функционалов качества кластеризации, но нет ?самого правильно- го? функционала. По сути дела, каждый метод кластеризации можно рассматривать как точный или приближённый алгоритм поиска оптимума некоторого функционала. Среднее внутрикластерное расстояние должно быть как можно меньше: F0 = Pi<j [yi = yj ]?(xi, xj) Pi<j [yi = yj ] > min . Среднее межкластерное расстояние должно быть как можно больше: F1 = Pi<j [yi 6= yj ]?(xi, xj) Pi<j [yi 6= yj ] > max . Если алгоритм кластеризации вычисляет центры кластеров ?y, y ? Y , то можно определить функционалы, вычислительно более эффективные. Сумма средних внутрикластерных расстояний должна быть как можно меньше: 0 =Xy?Y 1 |Ky| X i : yi=y ?2(xi, ?y) > min, где Ky = {xi ? X? | yi = y} кластер с номером y. В этой формуле можно было бы взять не квадраты расстояний, а сами расстояния. Однако, если ? евклидова мет- рика, то внутренняя сумма в 0 приобретает физический смысл момента инерции кластера Ky относительно его центра масс, если рассматривать кластер как матери- альное тело, состоящее из |Ky| точек одинаковой массы. Сумма межкластерных расстояний должна быть как можно больше: 1 =Xy?Y ?2(?y, ?) > max, где ? центр масс всей выборки. На практике вычисляют отношение пары функционалов, чтобы учесть как межкластерные, так и внутрикластерные расстояния: F0/F1 > min, либо 0/1 > min .
119 Алгоритм 7.3. Кластеризация с помощью EM-алгоритма 1: начальное приближение для всех кластеров y ? Y : wy := 1/|Y |; ?y := случайный объект выборки; ?2yj := 1 ?|Y | P?i=1(fj(xi) ? ?yj)2, j = 1, . . . , n; 2: повторять 3: E-шаг (expectation): giy := Pwypy(xi) z?Y wzpz(xi) , y ? Y , i = 1, . . . , ?; 4: M-шаг (maximization): wy := 1? P? i=1 giy, y ? Y ; ?yj := 1 ?wy P? i=1 giyfj(xi), y ? Y , j = 1, . . . , n; ?2yj := 1 ?wy P? i=1 giy(fj(xi) ? ?yj)2, y ? Y , j = 1, . . . , n; 5: Отнести объекты к кластерам по байесовскому решающему правилу: yi := argmax y?Y giy, i = 1, . . . , ?; 6: пока yi не перестанут изменяться; 7.1.3 Статистические алгоритмы Статистические алгоритмы основаны на предположении, что кластеры непло- хо описываются некоторым семейством вероятностных распределений. Тогда задача кластеризации сводится к разделению смеси распределений по конечной выборке. Снова EM-алгоритм. Напомним основные гипотезы байесовского подхода к разде- лению смесей вероятностных распределений, см. также :2.4. Гипотеза 7.1 (о вероятностной природе данных). Объекты выборки X? по- являются случайно и независимо согласно вероятностному распределению, представ- ляющему собой смесь распределений p(x) =Xy?Y wypy(x), Xy?Y wy = 1, где py(x) функция плотности распределения кластера y, wy неизвестная апри- орная вероятность появления объектов из кластера y. Конкретизируя вид распределений py(x), чаще всего берут сферические гаус- совские плотности. Мы будем считать, что кластеры похожи скорее не на шары, а на эллипсоиды, оси которых направлены вдоль осей координат. Преимущество эл- липтических гауссианов в том, что они обходят проблему выбора нормировки при- знаков. Нормировать можно немного по-разному, причём результат кластеризации существенно зависит от нормировки. Пока не произведена кластеризация, трудно по- нять, какая нормировка лучше. При использовании эллиптических гауссианов опти- мальная нормировка подбирается самим алгоритмом кластеризации, индивидуально для каждого кластера.
120 К.В.Воронцов. Вычислительные методы обучения по прецедентам Гипотеза 7.2 (о пространстве объектов и форме кластеров). Каждый объ- ект x из X = Rn описывается n числовыми признаками: x ? ??f1(x), . . . , fn(x). Каждый кластер y ? Y описывается n-мерной гауссовской плотностью py(x) с цен- тром ?y = (?y1, . . . , ?yn) и диагональной матрицей ковариаций y = diag(?2y1, . . . , ?2yn): py(x) = (2?)?n2 (?y1 - - - ?yn)?1 exp ???12?2y(x, ?y), где ?2y(x, x') = Pn j=1 ??2 yj |fj(x)?fj(x')|2 взвешенное евклидово расстояние с весами ??2 yj . При этих предположениях задача кластеризации совпадает с задачей разделе- ния смеси вероятностных распределений, и для её решения можно применить EM- алгоритм 2.3. Для оценивания параметров кластеров воспользуемся формулами, по- лученными в Теореме 2.7 как раз для случая эллиптических гауссианов. Реализация этой идеи представлена в Алгоритме 7.3. Напомним, что EM-алгоритм заключается в итерационном повторении двух шагов. На E-шаге по формуле Байеса вычисляются скрытые переменные giy. Зна- чение giy равно апостериорной вероятности того, что объект xi ? X? принадлежит кластеру y ? Y . На M-шаге уточняются параметры каждого кластера (?y,y), при этом существенно используются скрытые переменные giy. В Алгоритме 7.3 для простоты предполагается, что число кластеров известно заранее. Однако в большинстве практических случаев его лучше определять авто- матически, как это было сделано в Алгоритме 2.3. Метод k-средних, представленный в Алгоритме 7.4, является упрощением EM-ал- горитма. Главное отличие в том, что в EM-алгоритме каждый объект xi распреде- ляется по всем кластерам с вероятностями giy = P{yi = y}. В алгоритме k-средних (k-means) каждый объект жёстко приписывается только к одному кластеру. Второе отличие в том, что в k-means форма кластеров не настраивается. Однако это отличие не столь принципиально. Можно предложить упрощённый вариант EM, в котором форма кластеров также не будет настраиваться для этого достаточно взять сферические гауссианы с ковариационными матрицами y = ?yIn. С другой стороны, возможен и обобщённый вариант k-means, в котором будут определяться размеры кластеров вдоль координатных осей. Для этого в Алгоритме 7.3 достаточно убрать шаг 5 и заменить E-шаг жёстким приписыванием объектов кластерам: yi := argmin y?Y ?y(xi, ?y), j = 1, . . . , n; giy := [yi = y], j = 1, . . . , n, y ? Y. Таким образом, EM и k-means довольно плавно ?перетекают? друг в друга, позволяя строить различные ?промежуточные? варианты этих двух алгоритмов. Заметим, что k-means похож также на поиск центра кластера в алгоритме FOREL. Отличие в том, что в FOREL кластер это шар заданного радиуса R, тогда как в k-means объекты относятся к кластерам по принципу ближайшего соседа. Существует два ?канонических? варианта алгоритма k-means. Вариант Болла- Холла [18, стр. 110] представлен в Алгоритме 7.4. Вариант МакКина [18, стр. 98] отличается тем, что всякий раз, когда некоторый объект xi переходит из одного
121 Алгоритм 7.4. Кластеризация с помощью алгоритма k-средних 1: сформировать начальное приближение центров всех кластеров y ? Y : ?y наиболее удалённые друг от друга объекты выборки; 2: повторять 3: отнести каждый объект к ближайшему центру (аналог E-шага): yi := argmin y?Y ?(xi, ?y), i = 1, . . . , ?; 4: вычислить новое положение центров (аналог M-шага): ?yj := P?i=1[yi = y]fj(xi) P?i=1[yi = y] , y ? Y , j = 1, . . . , n; 5: пока yi не перестанут изменяться; кластера в другой, центры обоих кластеров пересчитываются. Для этого шаг 4 надо перенести внутрь цикла по i, выполняемого на шаге 3. МакКин показал в 1967 году, что этот вариант алгоритма приводит к локальному минимуму функционала 0. Алгоритм k-means крайне чувствителен к выбору начальных приближений цен- тров. Случайная инициализация центров на шаге 1 может приводить к плохим кла- стеризациям. Для формирования начального приближения можно выделить k наи- более удалённых точек выборки: первые две точки выделяются по максимуму всех попарных расстояний; каждая следующая точка выбирается так, чтобы расстояние от неё до ближайшей уже выделенной было максимально. Другая рекомендация выполнить кластеризацию несколько раз, из различ- ных случайных начальных приближений и выбрать кластеризацию с наилучшим значением заданного функционала качества. Кластеризация может оказаться неадекватной и в том случае, если число кла- стеров будет изначально неверно угадано. Стандартная рекомендация провести кластеризацию при различных значениях k и выбрать то, при котором достигается резкое улучшение качества кластеризации по заданному функционалу. Кластеризация с частичным обучением. Алгоритмы EM и k-means легко приспо- собить для решения задач кластеризации с частичным обучением (semi-supervised learning), когда для некоторых объектов xi известны правильные классифика- ции y?(xi). Обозначим через U подмножество таких объектов, U ? X?. Примером такой задачи является рубрикация текстовых документов, в частно- сти, страниц в Интернете. Типична ситуация, когда имеется относительно небольшое множество документов, вручную классифицированных по тематике. Требуется опре- делить тематику большого числа неклассифицированных документов. Сходство до- кументов ?(x, x') может оцениваться по-разному в зависимости от целей рубрикации и специфики самих документов: по частоте встречаемости ключевых слов, по ча- стоте посещаемости заданным множеством пользователей, по количеству взаимных гипертекстовых ссылок, или другими способами. Модификация обоих алгоритмов довольно проста: на E-шаге (шаг 3) для всех xi ? U полагаем giy := [y = y?(xi)], для всех остальных xi ? X? \ U скрытые пере- менные giy вычисляются как прежде. На практике частичная классификация даже небольшого количества объектов существенно улучшает качество кластеризации.
122 К.В.Воронцов. Вычислительные методы обучения по прецедентам 7.1.4 Иерархическая кластеризация Иерархические алгоритмы кластеризации, называемые также алгоритмами таксономии, строят не одно разбиение выборки на непересекающиеся классы, а си- стему вложенных разбиений. Результат таксономии обычно представляется в виде таксономического дерева дендрограммы. Классическим примером такого дерева является иерархическая классификация животных и растений. Среди алгоритмов иерархической кластеризации различаются два основных ти- па. Дивизимные или нисходящие алгоритмы разбивают выборку на всё более и более мелкие кластеры. Более распространены агломеративные или восходящие алгорит- мы, в которых объекты объединяются во всё более и более крупные кластеры. Реа- лизация этой идеи представлена в Алгоритме 7.5. Сначала каждый объект считается отдельным кластером. Для одноэлементных кластеров естественным образом определяется функция расстояния R({x}, {x'}) = ?(x, x'). Затем запускается процесс слияний. На каждой итерации вместо пары самых близких кластеров U и V образуется новый кластер W = U ?V . Расстояние от нового кластера W до любого другого кластера S вычисляется по расстояниям R(U, V ), R(U, S) и R(V, S), которые к этому моменту уже должны быть известны: R(U ? V, S) = ?UR(U, S) + ?V R(V, S) + ?R(U, V ) + ?|R(U, S) ? R(V, S)|, где ?U, ?U, ?, ? числовые параметры. Эта универсальная формула обобщает прак- тически все разумные способы определить расстояние между кластерами. Она была предложена Лансом и Уильямсом в 1967 году [49, 24]. На практике используются следующие способы вычисления расстояний R(W, S) между кластерами W и S. Для каждого из них доказано соответствие формуле Ланса-Вильямса при определённых сочетаниях параметров [18]: Расстояние ближнего соседа: ?U = ?V = 12 , ? = 0, ? = ?12 ; Rб(W, S) = min w?W,s?S ?(w, s); Расстояние дальнего соседа: ?U = ?V = 12 , ? = 0, ? = 12 ; Rд(W, S) = max w?W,s?S ?(w, s); Среднее расстояние: ?U = |U| |W| , ?V = |V | |W| , ? = ? = 0; Rс(W, S) = 1 |W||S| P w?W Ps?S ?(w, s); Расстояние между центрами: ?U = |U| |W| , ?V = |V | |W| , ? = ??U?V , ? = 0; Rц(W, S) = ?2P w?W w |W| , Ps?S s |S|; Расстояние Уорда: ?U = |S|+|U| |S|+|W| , ?V = |S|+|V | |S|+|W| , Rу(W, S) = |S||W| |S|+|W|?2P w?W w |W| , Ps?S s |S|; ? = ?|S| |S|+|W| , ? = 0. Возможных вариантов слишком много, и на первый взгляд все они кажутся достаточно разумными. Возникает вопрос: какой из них предпочесть? Рассмотрим несколько дополнительных свойств, характеризующих качество кластеризации.
123 Алгоритм 7.5. Агломеративная кластеризация Ланса-Уильямса 1: инициализировать множество кластеров C1: t := 1; Ct = {x1}, . . . , {x?}; 2: для всех t = 2, . . . , ? (t номер итерации): 3: найти в Ct?1 два ближайших кластера: (U, V ) := argmin U6=V R(U, V ); Rt := R(U, V ); 4: изъять кластеры U и V , добавить слитый кластер W = U ? V : Ct := Ct?1 ? {W} \ {U, V }; 5: для всех S ? Ct 6: вычислить расстояние R(W, S) по формуле Ланса-Уильямса; Свойство монотонности. Обозначим через Rt расстояние между ближайшими кла- стерами, выбранными на t-м шаге для слияния. Говорят, что функция расстояния R обладает свойством монотонности, если при каждом слиянии расстояние между объединяемыми кластерами только увеличивается: R2 6 R3 6 . . . 6 R?. Свойство монотонности позволяет изобразить процесс кластеризации в виде специального графика, называемого дендрограммой. По вертикальной оси отклады- ваются объекты, по горизонтальной расстояния Rt. Нетрудно доказать, что если кластеризация обладает свойством монотонности, то дендрограмму можно построить так, чтобы она не имела самопересечений. При этом любой кластер из множества Ct представляется сплошной последовательностью точек на вертикальной оси. Если же процесс кластеризации идёт не монотонно, то вместо дендрограммы получается за- путанный клубок линий, на котором трудно что-либо разобрать. Дендрограмма позволяет представить кластерную структуру в виде плоско- го графика независимо от того, какова размерность исходного пространства. Суще- ствуют и другие способы двумерной визуализации многомерных данных, такие как многомерное шкалирование или карты Кохонена, но они привносят в картину искус- ственные искажения, влияние которых довольно трудно оценить. Оказывается, не любое сочетание коэффициентов в формуле Ланса-Вильямса приводит к монотонной кластеризации. Теорема 7.1 (Миллиган, 1979). Если выполняются следующие три условия, то кластеризация является монотонной: 1) ?U > 0, ?V > 0; 2) ?U + ?V + ? > 1; 3) min{?U, ?V } + ? > 0. Из перечисленных выше расстояний только Rц не является монотонным. Рас- стояние Уорда отличается от него мультипликативной поправкой, которая и делает его монотонным. Свойства растяжения и сжатия. Некоторые расстояния обладают свойством рас- тяжения. По мере того, как кластер укрупняется, расстояния от него до других кластеров увеличиваются, как будто пространство вокруг кластера растягивается.
124 К.В.Воронцов. Вычислительные методы обучения по прецедентам На дендрограмме растягивающие расстояния характеризуются повышением плотно- сти линий слева, в области наименьших значений Rt. Свойство растяжения считается желательным, так как оно способствует более чёткому отделению кластеров. С дру- гой стороны, при слишком сильном растяжении возможно найти кластеры там, где их изначально не было. Растягивающими являются расстояния Rд и Rу. Некоторые расстояния, наоборот, обладают свойством сжатия. По мере ро- ста кластера расстояния от него до других кластеров уменьшается, и кажется, что пространство вокруг кластера сжимается. Естественная кластеризация при этом мо- жет исчезнуть. Для сжимающих расстояний характерно уплотнение дендрограммы справа, в области наибольших значений Rt. Расстояние ближнего соседа Rб является сильно сжимающим. Свойства сжатия и растяжения определяются через отношение Rt/?(?U, ?V ), где Rt = R(U, V ) расстояние между ближайшими кластерами, объединяемыми на t-м шаге, ?U и ?V центры этих кластеров. Если это отношение на каждом шаге больше единицы, то расстояние R является растягивающим; если оно всегда меньше единицы, то сжимающим. Есть и такие расстояния, которые не являются ни сжимающими, ни растягивающими, например, Rс и Rц. О них говорят, что они сохраняют метрику пространства. На практике часто применяют гибкое расстояние, которое представляет собой компромисс между методами ближнего соседа, дальнего соседа и среднего расстоя- ния. Оно определяется одним параметром ? вместо четырёх: ?U = ?V = (1 ? ?)/2, ? = 0, ? < 1. Гибкое расстояние является сжимающим при ? > 0 и растягивающим при ? < 0. Стандартная рекомендация: ? = ?0,25 [24]. Свойство редуктивности. Самой трудоёмкой операцией в Алгоритме 7.5 являет- ся поиск пары ближайших кластеров на шаге 3. Он требует O(?2) операций внутри основного цикла. Соответственно, построение всего таксономического дерева требу- ет O(?3) операций. Это ограничивает применимость алгоритма выборками длины в несколько сотен объектов. Идея ускорения алгоритма заключается в том, чтобы перебирать лишь наи- более близкие пары. Задаётся параметр ?, и перебор ограничивается сокращённым множеством пар (U, V ) : R(U, V ) 6 ?. Когда все такие пары будут исчерпаны, па- раметр ? увеличивается, и формируется новое сокращённое множество пар. И так далее, до полного слияния всех объектов в один кластер. Реализация представлена в Алгоритме 7.6. Доказано, что этот алгоритм приводит к той же кластеризации, что и Алго- ритм 7.5, если расстояние R обладает свойством редуктивности: Опр. 7.1 (Брюинош, 1978). Расстояние R называется редуктивным, если для любого ? > 0 и любых ?-близких кластеров U и V объединение ?-окрестностей U и V содержит в себе ?-окрестность кластера W = U ? V : S R(U?V, S) < ?, R(U, V ) 6 ?? S R(S, U) < ? или R(S, V ) < ?.
125 Алгоритм 7.6. Быстрая агломеративная кластеризация на основе редуктивности 1: инициализировать множество кластеров C1: t := 1; Ct = {x1}, . . . , {x?}; 2: выбрать начальное значение параметра ?; 3: P(?) := (U, V )U, V ? Ct, R(U, V ) 6 ?; 4: для всех t = 2, . . . , ? (t номер итерации): 5: если P(?) = ? то 6: увеличить ? так, чтобы P(?) 6= ?; 7: найти в P(?) пару ближайших кластеров: (U, V ) := argmin (U,V )?P(?)R(U, V ); Rt := R(U, V ); 8: изъять кластеры U и V , добавить слитый кластер W = U ? V : Ct := Ct?1 ? {W} \ {U, V }; 9: для всех S ? Ct 10: вычислить расстояние R(W, S) по формуле Ланса-Уильямса; 11: если R(W, S) 6 ? то 12: P(?) := P(?) ? (W, S); Теорема 7.2 (Диде и Моро, 1984). Если выполняются следующие три условия, то расстояние R является редуктивным: 1) ?U > 0, ?V > 0; 2) ?U + ?V + min{?, 0} > 1; 3) min{?U, ?V } + ? > 0. Сравнение условий теорем 7.2 и 7.1, показывает, что всякое редуктивное рас- стояние является монотонным, следовательно, позволяет отобразить процесс кла- стеризации в виде дендрограммы. Из перечисленных выше расстояний только Rц не является редуктивным. В Алгоритме 7.6 возможны различные эвристические стратегии выбора пара- метра ? на шагах 2 и 6. Общие соображения таковы: если ? настолько велико, что P(?) содержит практически все пары кластеров, то мы фактически возвращаемся к неэф- фективному Алгоритму 7.5; если же ? мал?о, то приходится слишком часто форми- ровать множество P(?). На практике поступают следующим образом. Если число кластеров в Ct не превышает порог n1, то в качестве P(?) берут множество всех возможных пар (U, V ) из Ct. В противном случае выбирается случайным образом n2 расстояний R(U, V ), и ? полагается равным наименьшему из них. В случае редуктив- ности параметры алгоритма n1 и n2 влияют только на время выполнения алгоритма, но не на результат кластеризации. Оптимальные значения для них подбираются с по- мощью калибровочных тестов и, вообще говоря, зависят от компьютера. В качестве начального выбора можно предложить n1 = n2 = 20. Определение числа кластеров проще всего производить путём отсечения правого участка дендрограммы. На горизонтальной оси находится интервал максимальной длины |Rt+1 ?Rt|, и в качестве результирующей кластеризации выдаётся множество
126 К.В.Воронцов. Вычислительные методы обучения по прецедентам кластеров Ct. Число кластеров равно K = ? ? t + 1. При необходимости можно задать ограничение на минимальное и максимальное число кластеров K0 6 K 6 K1 и выбирать t, удовлетворяющие ограничениям ? ? K1 + 1 6 t 6 ? ? K0 + 1. Во многих прикладных задачах интерес представляет таксономическое дерево целиком, и определять оптимальное число кластеров не имеет особого смысла. Достоинства и недостатки агломеративной кластеризации. Точного ответа на во- прос, какой алгоритм кластеризации лучше, не существует. Каждое из расстояний, перечисленных выше, имеет свои недостатки и подходит не для всех задач. Метод ближнего соседа обладает цепочечным эффектом, когда независимо от формы кластера к нему присоединяются ближайшие к границе объекты. В неко- торых случаях это приводит к тому, что кластеры ?отращивают щупальца?. В зави- симости от задачи это свойство может быть как полезным, так и мешающим. Метод ближнего соседа хорошо подходит для выделения кластеров ленточной формы. Метод дальнего соседа цепочечного эффекта не имеет, но на раннем этапе мо- жет объединять довольно несхожие группы. Расстояние между центрами масс не монотонно и не редуктивно, поэтому редко используется на практике, хотя интуитивно кажется ?золотой серединой?. Метод Уорда оказался наилучшим по результатам экспериментального срав- нения на представительном наборе модельных задач [18]. Он чаще других методов строит интуитивно лучшую таксономию. :7.2 Сети Кохонена До сих пор мы рассматривали нейронные сети, предназначенные для обучения с учителем, когда для каждого объекта xi задан соответствующий ему ответ yi. Сети Кохонена решают задачи обучения без учителя, когда задаются только сами объек- ты xi, и требуется выделить обособленные ?плотные сгустки? объектов кластеры, и научиться относить новые объекты к этим кластерам. Кластеризация основывается на предположении, что в пространстве X введена метрика ?: X ?X > R, адекватно оценивающая степень сходства любой пары объектов. 7.2.1 Модели конкурентного обучения Пусть X = Rn пространство объектов, Y = {1, . . . ,M} множество кла- стеров, число M фиксировано. Задана обучающая выборка объектов X? = {xi}?i=1. Требуется выработать правило отнесения объектов к кластерам a: X > Y . Правило жёсткой конкуренции WTA. Наиболее очевидный подход заключается в том, чтобы ввести векторы wm ? Rn, m = 1, . . . ,M, описывающие центры класте- ров, и относить произвольный объект x ? X к ближайшему кластеру: a(x) = argmin m?Y ?(x,wm). (7.1) Образно говоря, кластеры соревнуются за право присоединить к себе объект x. Кластер, ближайший к x, называется кластером-победителем, а выражение (7.1) правилом WTA (winner takes all).
127 @GAFxBE1 CD - - - @GAFxBEn CD ?(x,w1) - - - ?(x,wM) arg min a(x) w11 // w1M ?? ? ??? ?? ?? ?? ? wn1   ??      wnM // &&LL LL LL 88rr rr rr // Рис. 22. Представление алгоритма кла- стеризации (7.1) в виде двухслойной ней- ронной сети. Настройка алгоритма кластеризации a(x) сводится к оптимизации расположе- ния центров wm. Для этого минимизируется функционал качества кластеризации, равный среднему квадрату расстояния между объектами и центрами кластеров: Q(w1, . . . ,wM) = 12 X? i=1 ?2(xi,wa(xi)) > min {wm} . Допустим, что метрика евклидова: ?(x,w) = kx?wk. Тогда можно выписать градиент функционала Q по вектору wm: ?Q ?wm = X? i=1 (wm ? xi)a(xi) = m. Для поиска центров кластеров wm можно применить метод стохастического градиента Алгоритм 4.1, практически без модификаций. Единственное отличие заключается в том, что теперь правило обновления весов на шаге 6 будет иметь вид wm := wm + ?(xi ? wm)a(xi) = m, (7.2) где xi ? X? случайным образом выбранный обучающий объект, ? градиентный шаг, он же темп обучения. Смысл данного правила очевиден: если объект xi отно- сится к кластеру m, то центр этого кластера wm немного сдвигается в направлении объекта xi, остальные центры не изменяются. Формальное сходство формулы (7.2) с персептронным правилом наводит на мысль, что кластеризация осуществляется алгоритмом, аналогичным нейронной сети. Выражение (7.1) и в самом деле представимо в виде двухслойной суперпозиции, только вместо привычных скалярных произведений hx,wmi вычисляются функции расстояния ?(x,wm), а на выходе вместо суммирования применяется операция мини- мума, см. Рис. 22. При этом центры кластеров wm взаимно однозначно соответствуют нейронам скрытого стоя, которые называются нейронами Кохонена. Нейрон, выход которого минимален, называется нейроном-победителем. Рассмотренная разновидность нейронных сетей называется сетью с конкурент- ным обучением. Исходно она была предложена как чисто математическая модель. Позже нейрофизиологам удалось найти некоторые её аналоги в биологических ней- ронных сетях [40]. Альтернативное названиеобучающееся векторное квантование (learning vector quantization, LVQ)связано с тем, что по исходной выборке из ? объектов xi строятся M новых объектов wm, похожих на исходные,это центры ячеек, по кото- рым распределяются (?квантуются?) исходные объекты. Как правило, M ? ?, по- этому замена объектов на ближайшие к ним центры позволяет эффективно сжимать данные при незначительной потере информации. Объём сохраняемой информации регулируется единственным параметром M, что достаточно удобно в приложениях.
128 К.В.Воронцов. Вычислительные методы обучения по прецедентам Правило справедливой конкуренции CWTA. Недостаток конкурентного обуче- ния по правилу WTA заключается в том, что при случайной инициализации весов нейрон Кохонена может попасть в такую область, где он никогда не станет победи- телем. В результате появится неинформативный пустой кластер. Для преодоления этого недостатка алгоритм (7.1) немного модифицируется. Вводится ?механизм утомления? победителей правило CWTA (conscience WTA): a(x) = argmin m?Y Cm?(x,wm), (7.3) где Cm количество побед m-го нейрона в ходе обучения. Таким образом, кластеры штрафуются за слишком частое присоединение объектов. Правило мягкой конкуренции WTM. Другим недостатком правила WTA являет- ся медленная скорость сходимости, связанная с тем, что на каждой итерации моди- фицируется только один нейрон-победитель wm. Для ускорения сходимости, особен- но на начальных итерациях, можно подстраивать сразу несколько нейронов, близких к объекту xi. Для этого вводится ядронеотрицательная монотонно убывающая на [0,+?) функция расстояния K(?). Иногда накладывается дополнительное требова- ние нормировки K(0) = 1. Часто берут гауссовское ядро K(?) = exp(???2) при некотором ? > 0. Вместо правила жёсткой конкуренции WTA вводится мягкая кон- куренция правило WTM (winner takes most): wm := wm + ?(xi ? wm)K???(xi,wm), m = 1, . . . ,M. (7.4) Теперь на каждой итерации центры всех кластеров смещаются в сторону xi, но чем дальше центр находится от xi, тем меньше величина смещения. Заметим, что (7.2) является частным случаем (7.4), если положить K???(xi,wm)= [a(xi) = m]. На начальных итерациях имеет смысл выбрать небольшое значение коэффици- ента ?, чтобы все весовые векторы успели переместиться ближе к области входных векторов. Затем ? можно увеличивать, делая конкуренцию всё более жёсткой, и по- степенно переходя к коррекции только одного нейрона-победителя. Благодаря способности к сглаживанию, правило WTM имеет многочисленные применения. Одно из важнейших самоорганизующиеся карты Кохонена. 7.2.2 Самоорганизующиеся карты Кохонена Самоорганизующиеся карты Кохонена (self-organizing maps, SOM) применяют- ся для визуализации многомерных данных. Они дают лишь общую картину, довольно размытую и подверженную искажениям, поскольку спроецировать многомерную вы- борку на плоскость без искажений в общем случае невозможно. Тем не менее, карты Кохонена позволяют увидеть ключевые особенности кластерной структуры выбор- ки. Они используются на стадии разведочного анализа данных, скорее для общего понимания задачи, чем для получения каких-либо точных результатов. Идея заключается в том, чтобы спроецировать все объекты выборки на плоскую карту, точнее, на множество узлов прямоугольной сетки заранее заданного размера M ? H. На практике M и H имеют порядок десятков или сотен. Каждому узлу сетки приписывается нейрон Кохонена с вектором весов wmh ? Rn, m = 1, . . . ,M,
129 Алгоритм 7.7. Обучение карты Кохонена методом стохастического градиента Вход: X? обучающая выборка; ? темп обучения; Выход: Векторы синаптических весов wmh, m = 1, . . . ,M, h = 1, . . . ,H; 1: инициализировать веса: wmh := random??? 1 2MH , 1 2MH ; 2: повторять 3: выбрать объект xi из X? случайным образом; 4: WTA: вычислить координаты узла, в который проецируется объект xi: (mi, hi) := a(xi) ? argmin (m,h)?Y ?(xi,wmh); 5: для всех (m, h) ? Y , достаточно близких к (mi, hi) 6: WTM: сделать шаг градиентного спуска: wmh := wmh + ?(xi ? wmh)K??r((mi, hi), (m, h)); 7: пока размещение всех объектов в узлах сетки не стабилизируется; h = 1, . . . ,H. Таким образом, множество Y совпадает с множеством узлов сетки, Y = {1, . . . ,M} ? {1, . . . ,H}. Алгоритм кластеризации a(x) выдаёт пару индексов (m, h) ? Y , показываю- щих, в какой узел сетки проецируется объект x. Чтобы карта отражала кластерную структуру выборки, близкие объекты должны попадать в близкие узлы сетки. Обучение нейронов производится методом стохастического градиента, см. Ал- горитм 7.7. После случайного выбора объекта xi на шаге 3 определяется нейрон- победитель согласно правилу WTA. Соответствующий ему узел сетки обозначается в алгоритме через (mi, hi). Затем, согласно правилу WTM, этот нейрон и нейроны, расположенные в ближайших узлах сетки, сдвигаются в сторону вектора xi. Правило обучения, применяемое на шаге 6, схоже с (7.4), только вместо метрики ?(x, x'), опре- делённой на пространстве объектов, используется евклидова метрика на множестве узлов сетки Y : r??(mi, hi), (m, h)= p(m ? mi)2 + (h ? hi)2. По прежнему, K(?) ядро сглаживания, например, K(?) = exp(???2). Пара- метр ? задаёт степень сглаженности карты: чем меньше ?, тем мягче конкуренция нейронов, и тем более сглаженными будут выглядеть границы кластеров на кар- те. Имеет смысл увеличивать значение параметра ? от итерации к итерации, чтобы сеть Кохонена сначала обучилась кластерной структуре ?в общих чертах?, а затем сосредоточилась на деталях. Алгоритм останавливается, когда проекции всех, или хотя бы большинства, объектов выборки (mi, hi) = a(xi) перестанут меняться от итерации к итерации. Искусство интерпретации карт Кохонена. Если через настроенную карту Кохо- нена (алгоритм a(x)) пропустить все объекты обучающей выборки X?, то кластеры исходного пространства отобразятся в сгустки точек на карте. При этом векторы
130 К.В.Воронцов. Вычислительные методы обучения по прецедентам Рис. 23. Карты Кохонена для задачи UCI.house-votes (объекты конгрессмены, признаки резуль- таты голосования по 17 вопросам). Первые три графика в верхнем ряду: (1) разделение выборки на два кластера, (2) двухцветная полутоновая карта, (3) цветная карта по признаку ?партия? {де- мократ, республиканец}. Голосование по большинству вопросов хорошо согласуется с партийной принадлежностью конгрессменов. весов в узлах-сгустках должны быть одновременно похожи на все объекты соответ- ствующих кластеров. Обычно для каждой точки карты вычисляют среднее расстояние до k ближай- ших точек выборки, и полученное распределение средних расстояний отображают в виде двухцветной полутоновой карты. Чем меньше среднее расстояние, тем выше локальная плотность точек на карте. На той же карте отмечают и сами точки обуча- ющей выборки. На карте хорошо видно, сколько кластеров выделено, в каких местах они расположились, и какие объекты выборки в них попадают, Рис. 23. Следующий шаг поиск интерпретации кластеров. Для этого строятся ещё n карт, по одной карте на каждый признак. Теперь цвет узла (m, h) соответству- ет значению j-й компоненты вектора весов wm,h. Обычно эти карты раскрашивают в геодезические цвета от синего до коричневого. Синие участки карты соответству- ют наименьшим значениям j-го признака, красные наибольшим. Сравнивая карты
131 признаков с общей картой кластеров, можно найти кластеры, которым свойственны повышенные или пониженные значения отдельных признаков. В результате содержательная интерпретация кластеров формулируется путём перечисления всех признаков, имеющих либо повышенные, либо пониженные значе- ния в каждом из кластеров. Ещё один способ интерпретации выделение на карте всех узлов, в которые по- падает выбранное подмножество объектов. Если объекты сгруппировались в одном месте, значит мы имеем дело с кластером или его частью. Выделяя различные под- множества объектов, имеющие заведомо известную содержательную интерпретацию, можно находить интерпретации различных зон на карте. Недостатки карт Кохонена. : Субъективность. Не всегда ясно, какие особенности карты обусловлены кла- стерной структурой данных, а какие свойствами сглаживающего ядра. От выбора параметра ? существенно зависит сглаженность границ кластеров и степень детализации карты. : Наличие искажений. Близкие объекты исходного пространства могут перехо- дить в далёкие точки на карте. В частности, объективно существующие класте- ры могут разрываться на фрагменты [44]. И наоборот, далёкие объекты могут случайно оказаться на карте рядом, особенно, если они были одинаково дале- ки от всех кластеров. Искажения неизбежны при проецировании многомерной выборки на плоскость. Распределение точек на карте позволяет судить лишь о локальной структуре многомерных данных, и то не всегда. : Зависимость от инициализации. Начальное распределение весов существенно влияет на процесс обучения и может сказываться не только на расположении кластеров, но даже на их количестве. Иногда рекомендуется построить несколь- ко карт и выбрать из них наиболее ?удачную?. Не секрет, что популярность карт Кохонена обусловлена в значительной сте- пени их эстетической привлекательностью и впечатлением наукообразной загадоч- ности, которое они производят на неискушённого пользователя. На практике они применяются в основном как вспомогательное средство для предварительного визу- ального анализа и выявления неочевидных закономерностей в многомерных данных. 7.2.3 Гибридные сети встречного распространения Ещё одно важное применение нейронов Кохонена с их способностью кластери- зовать исходные векторыкусочная аппроксимация функций. Рассмотрим задачу восстановления регрессии, когда на элементах обучающей выборки X? = {xi}?i=1 заданы вещественные ответы yi = y?(xi). Идея заключается в том, чтобы сначала разбить обучающие объекты (и всё пространство X) на класте- ры, не пользуясь ответами yi, затем для каждого кластера построить свою локаль- ную аппроксимацию целевой зависимости y?. При использовании жёсткой конку- ренции WTA эти аппроксимации образуют кусочно-непрерывную функцию. Мягкая конкуренция WTM ?склеивает? из локальных кусков гладкую аппроксимацию.
132 К.В.Воронцов. Вычислительные методы обучения по прецедентам Кусочно-постоянная аппроксимация. Чтобы алгоритм кластеризации (7.1) пре- вратить в алгоритм кусочной аппроксимации, к нему добавляется ещё один нейрон с линейной функцией активации, образующий третий слой с весами v1, . . . , vM: a(x) = vm?(x) =XM m=1 vmm?(x) = m; (7.5) m?(x) = argmin m=1,...,M ?(x,wm); где m?(x)номер нейрона-победителя на объекте x, вычисляемый по правилу WTA. При квадратичной функции потерь задача настройки весов vm легко решается аналитически: Q(v) = 12 X? i=1 ??a(xi) ? yi2 > min v ; ?Q ?vm = X? i=1 ??a(xi) ? yim?(xi) = m= 0. Подставляя сюда выражение для a(xi) из (7.5), получаем vm = P?i=1 yim?(xi) = mP?i=1m?(xi) = m. Проще говоря, оптимальное значение весового коэффициента vm есть среднее yi по всем объектам xi, попавшим в m-й кластер. Ответ алгоритма a(x) для всех объек- тов, попадающих в m-й кластер, будет одинаков и равен vm. Это означает, что a(x) реализует кусочно-постоянную функцию. Гладкая аппроксимация строится с помощью правила мягкой конкуренции WTM при выбранном гладком ядре K(?). Алгоритм a(x) представляет собой формулу На- дарая-Ватсона для сглаживания ответов vm по M точкам центрам кластеров: a(x) = XM m=1 vm K???(x,wm)PMs=1 K???(x,ws). В этом случае задача минимизации Q(v) сводится к решению системы линейных уравнений размера M?M. Вместо явного решения системы можно снова воспользо- ваться методом стохастического градиента. На каждой итерации обновляются и веса слоя Кохонена wm, и веса третьего (выходного) слоя vm: ??? ?? wm := wm ? ?(wm ? xi)K???(xi,wm); vm := vm ? ?(a(xi) ? yi) K???(xi,wm)PMs=1 K???(xi,ws); Заметим, что обновление весов wm влияет на веса vm, а обратного влияния нет. Данный метод получил название встречного распространения ошибки, по- скольку второй слой настраивается по правилу Кохонена, а третий слойтак же, как в методе back-propagation.
133 :7.3 Многомерное шкалирование Визуализация кластерной структуры заданной выборки объектов X? непро- стая проблема, особенно если выборка содержит тысячи объектов, а пространство объектов существенно многомерно. Задача многомерного шкалирования (multidimensional scaling, MDS) заключа- ется в следующем. Имеется обучающая выборка объектов X? = {x1, . . . , x?} ? X. Заданы расстояния Rij = ?(xi, xj) для некоторых пар обучающих объектов (i, j) ? D. Требуется для каждого объекта xi ? X? построить его признаковое описание век- тор xi = (x1i, . . . , xni) в евклидовом пространстве Rn так, чтобы евклидовы расстояния dij между объектами xi и xj d2ij =Xn d=1(xdi ? xdj)2 как можно точнее приближали исходные расстояния Rij для всех (i, j) ? D. Данное требование можно формализовать по-разному; один из наиболее распространённых способовчерез минимизацию функционала, называемого стрессом: S(X?) = X (i,j)?D wij(dij ? Rij)2 > min, где минимум берётся по совокупности ?n переменных (xdi)d=1,n i=1,? . Размерность n обычно задаётся небольшая. В частности, при n = 2 многомерное шкалирование позволяет отобразить выборку в виде множества точек на плоскости (scatter plot). Плоское представление, как правило, искажено (S > 0), но в целом отражает основные структурные особенности многомерной выборки, в частности, её кластерную структуру. Поэтому двумерное шкалирование часто используют как инструмент предварительного анализа и понимания данных. На практике расстояния чаще бывают известны для всех пар объектов, но мы будем рассматривать более общий случай, когда D произвольное заданное множе- ство пар индексов объектов. Веса wij задаются исходя из целей шкалирования. Обычно берут wij = (Rij)?. При ? < 0 приоритет отдаётся более точному приближению малых расстояний; при ? > 0больших расстояний. Наиболее адекватным считается значение ? = ?2, когда функционал стресса приобретает физический смысл потенциальной энергии системы ? материальных точек, связанных упругими связями; требуется найти рав- новесное состояние системы, в котором потенциальная энергия минимальна. Функционал стресса S(X?) сложным образом зависит от ?n переменных, имеет огромное количество локальных минимумов, и его вычисление довольно трудоёмко. Поэтому многие алгоритмы многомерного шкалирования основаны на итерационном размещении объектов по одному. На каждой итерации оптимизируются евклидовы координаты только одного из объектов при фиксированных остальных объектах. Размещение одного объекта методом Ньютона-Рафсона. Рассмотрим адди- тивную составляющую функционала стресса, зависящую только от одного объекта x ? X? с координатами x ? (x1, . . . , xn), которые и требуется найти: S(x) = Xxi?U wi??di(x) ? Ri2 > min x ,
134 К.В.Воронцов. Вычислительные методы обучения по прецедентам где U ? X? все объекты с известными расстояниями Ri = ?(x, xi); di(x)евкли- дово расстояние между векторами x ? (x1, . . . , xn) и xi ? (x1i, . . . , xni). Применим метод Ньютона-Рафсона для минимизации S(x). Поскольку функционал многоэкстремальный, очень важно выбрать удачное на- чальное приближение x(0). Вектор x должен быть похож на те векторы xi ? U, для которых расстояния Ri малы. Неплохая эвристикавзять в качестве x(0) взвешенное среднее всех векторов из U, например, с весами ci = R?2 i : x(0) = Pxi?U cixi Pxi?U ci . Затем запускается итерационный процесс x(t+1) := x(t) ? ht??S''(x(t))?1S'(x(t)), где S'(x(t))вектор первых производных (градиент) функционала S(x) в точке x(t), S''(x(t))матрица вторых производных (гессиан) функционала S(x) в точке x(t), ht величина шага, который можно положить равным 1, но более тщательный его подбор способен увеличить скорость сходимости. Найдём выражения для градиента и гессиана. ?di ?xa = xa ? xai di ; ?S ?xa = 2Xxi?U wi 1 ? Ri di ??xa ? xai ; ?2S ?xa?xa = 2Xxi?U wi  Ri di xa ? xai di 2 ? Ri di + 1!; ?2S ?xa?xb = 2Xxi?U wiRi di xa ? xai di xb ? xbi di . Заметим, что в пространствах малой размерности n 6 3 обращение гессианадовольно простая операция, однако с ростом размерности вычислительные затраты растут как O(n3). Итерации Ньютона-Рафсона прекращаются, когда значение стресса S(x) стаби- лизируется или вектор x перестаёт существенно изменяться, то есть стабилизируется норма разности kx(t+1) ? x(t)k. Будем полагать, что размещение объекта x относительно множества уже раз- мещённых объектов U ? X? реализуется процедурой НьютонРафсон(x, U). Субквадратичный алгоритм многомерного шкалирования. Алгоритм 7.8 на- чинает с того, что находит две самые удалённые точки выборки xi, xj . Достаточно решить эту задачу приближённо. В частности, можно взять произвольную точку, найти самую удалённую от неё, затем для этой точки найти самую удалённую, и так далее. Обычно 3-4 итераций хватает, чтобы найти пару достаточно далёких точек. Найденным точкам приписываются (в двумерном случае) евклидовы координаты (0, 0) и (0,Rij). Затем находится третья точка xk, наиболее удалённая от первых
135 Алгоритм 7.8. Субквадратичный алгоритм многомерного шкалирования Вход: Rij матрица попарных расстояний между объектами, возможно, разреженная; K размер скелета; Выход: евклидовы координаты всех объектов выборки xi ? (x1i, . . . , xni), i = 1, . . . , ?; 1: Инициализировать скелет: U := три достаточно далёкие друг от друга точки; 2: пока |U| < K наращивать скелет: 3: x := argmax xi?X?\U ??min xj?U Rij; 4: НьютонРафсон(x, U); 5: U := U ? {x}; 6: пока координаты точек скелета не стабилизируются: 7: найти наиболее напряжённую точку в скелете: x := argmax xi?U S(x); 8: НьютонРафсон(x, U \ {x}); 9: для x ? X? \ U 10: НьютонРафсон(x, U); двух, то есть для которой значение min{Rki,Rkj} максимально. Евклидовы коорди- наты xk определяются (в двумерном случае) исходя из того, что треугольник *ijk жёстко задан длинами своих сторон. Затем начинается поочерёдное добавление точек и их размещение относительно уже имеющихся. После размещения первых K точек их положение уточняется друг относительно друга. Эти точки, размещённые с особой тщательностью, становятся ?скелетом?, относительно которого размещаются все остальные точки. Расстояния между ?не-скелетными? точками в алгоритме вообще не задействуются. Если K = ?, то все точки будут ?скелетными?; в этом случае размещение яв- ляется наиболее точным, но и наиболее долгим, требуя O(?2) операций. В общем случае число операций алгоритма O(K2) + O(K?). Выбирая размер ?скелета? K, можно находить компромисс между точностью и временем построения решения. Карта сходства отображает результат многомерного шкалирования при n = 2 в ви- де плоского точечного графика. Евклидова метрика и функционал стресса инвари- антны относительно произвольных ортогональных преобразований карты сходствасдвигов, поворотов и зеркальных отражений. Поэтому оси на карте не имеют интер- претации. Для понимания карты на ней обозначают ориентиры те объекты выбор- ки, интерпретации которых хорошо известны. Если искажения расстояний на карте не велики, то объекты, близкие к ориентирам, должны иметь схожие интерпретации. Карта сходства даёт лишь общее представление о взаимном расположении объ- ектов выборки. Делать на её основе какие-либо количественные выводы, как правило, нельзя.
136 К.В.Воронцов. Вычислительные методы обучения по прецедентам Диаграмма Шепарда позволяет сказать, насколько сильно искажены расстояния на карте сходства. Это точечный график; по горизонтальной оси откладываются исходные расстояния Rij ; по вертикальной оси откладываются евклидовы расстоя- ния dij ; каждая точка на графике соответствует некоторой паре объектов (i, j) ? D. Если число пар превышает несколько тысяч, отображается случайное подмножество пар. Иногда на диаграмме изображается сглаженная зависимость dij(Rij), а также сглаженные границы верхних и нижних доверительных интервалов, в которых dij(R) находится с высокой вероятностью (например, 90%) при каждом значении R. Идеальной диаграммой Шепарда является наклонная прямаябиссектриса первой четверти. Чем ?толще? облако точек, представленное на диаграмме, тем силь- нее искажения, и тем меньшего доверия заслуживает карта сходства. Пример 7.1. Один из надёжных способов тестирования методов многомерного шкалирования, предложенный в [15]размещение изначально двумерных (или близ- ких к двумерным) выборок. Например, можно взять множество городов Российской Федерации, и задать Rij как евклидовы расстояния между их географическими ко- ординатами (долгота, широта). Хороший алгоритм шкалирования должен построить карту сходства, похожую на географическую карту (с точностью до поворотов и от- ражений), а диаграмма Шепарда должна оказаться практически диагональной. Список литературы [1] Айвазян С. А., Бухштабер В. М., Енюков И. С., Мешалкин Л. Д. Прикладная статистика: классификация и снижение размерности. М.: Финансы и стати- стика, 1989. [2] Айвазян С. А., Енюков И. С., Мешалкин Л. Д. Прикладная статистика: иссле- дование зависимостей.М.: Финансы и статистика, 1985. [3] Айзерман М. А., Браверман Э. М., Розоноэр Л. И. Метод потенциальных функ- ций в теории обучения машин.М.: Наука, 1970.320 pp. [4] Вапник В. Н. Восстановление зависимостей по эмпирическим данным.М.: На- ука, 1979. [5] Вапник В. Н., Червоненкис А. Я. О равномерной сходимости частот появления событий к их вероятностям //ДАН СССР.1968.Т. 181, № 4.С. 781-784. [6] Вапник В. Н., Червоненкис А. Я. О равномерной сходимости частот появления событий к их вероятностям //Теория вероятностей и ее применения. 1971.Т. 16, № 2.С. 264-280. [7] Вапник В. Н., Червоненкис А. Я. Теория распознавания образов.М.: Наука, 1974. [8] Головко В. А. Нейронные сети: обучение, организация и применение. М.: ИПР- ЖР, 2001.
137 [9] Епанечников В. А. Непараметрическая оценка многомерной плотности вероят- ности //Теория вероятностей и её применения. 1969.Т. 14, № 1.С. 156- 161. [10] Ермаков С. М., Михайлов Г. А. Курс статистического моделирования. М.: На- ука, 1976. [11] Загоруйко Н. Г. Прикладные методы анализа данных и знаний.Новосибирск: ИМ СО РАН, 1999. [12] Загоруйко Н. Г., Ёлкина В. Н., Лбов Г. С. Алгоритмы обнаружения эмпириче- ских закономерностей.Новосибирск: Наука, 1985. [13] Закс Ш. Теория статистических выводов.М.: Мир, 1975. [14] Колмогоров А. Н. О представлении непрерывных функций нескольких перемен- ных в виде суперпозиции непрерывных функций одного переменного //Докл. АН СССР.1958.Т. 114, № 5.С. 953-956. [15] Кулаичев А. П.Методы и средства комплексного анализа данных.М: ИНФРА- М, 2006. [16] Лагутин М. Б. Наглядная математическая статистика.М.: П-центр, 2003. [17] Лапко А. В., Ченцов С. В., Крохов С. И., Фельдман Л. А. Обучающиеся систе- мы обработки информации и принятия решений. Непараметрический подход.Новосибирск: Наука, 1996. [18] Мандель И. Д. Кластерный анализ.М.: Финансы и Статистика, 1988. [19] Мерков А. Б. Основные методы, применяемые для распознавания рукописного текста.Лаборатория распознавания образов МЦНМО.2005. http://www.recognition.mccme.ru/pub/RecognitionLab.html/methods.html. [20] Мерков А. Б. О статистическом обучении. Лаборатория распознавания обра- зов МЦНМО.2006. http://www.recognition.mccme.ru/pub/RecognitionLab.html/slt.pdf. [21] Нейроинформатика /А. Н. Горбань, В. Л. Дунин-Барковский, А. Н. Кирдин, Е. М. Миркес, А. Ю. Новоходько, Д. А. Россиев, С. А. Терехов и др.Новоси- бирск: Наука, 1998.296 с. [22] Орлов А. И. Нечисловая статистика.М.: МЗ-Пресс, 2004. [23] Тихонов А. Н., Арсенин В. Я. Методы решения некорректных задач.М.: На- ука, 1986. [24] Уиллиамс У. Т., Ланс Д. Н. Методы иерархической классификации //Стати- стические методы для ЭВМ /Под ред. М. Б. Малютов.М.: Наука, 1986.С. 269-301. [25] Хардле В. Прикладная непараметрическая регрессия.М.: Мир, 1993.
138 К.В.Воронцов. Вычислительные методы обучения по прецедентам [26] Шлезингер М., Главач В. Десять лекций по статистическому и структурному распознаванию. Киев: Наукова думка, 2004. [27] Шлезингер М. И. О самопроизвольном различении образов //Читающие авто- маты.Киев, Наукова думка, 1965.Pp. 38-45. [28] Шурыгин А. М. Прикладная стохастика: робастность, оценивание, прогноз.М.: Финансы и статистика, 2000. [29] Яблонский С. В. Введение в дискретную математику.М.: Наука, 1986. [30] Asuncion A., Newman D. UCI machine learning repository: Tech. rep.: University of California, Irvine, School of Information and Computer Sciences, 2007. http://www.ics.uci.edu/?mlearn/MLRepository.html. [31] Bartlett P. The sample complexity of pattern classification with neural networks: the size of the weights is more important than the size of the network //IEEE Transactions on Information Theory.1998.Vol. 44, no. 2.Pp. 525-536. http://discus.anu.edu.au/?bartlett. [32] Bartlett P., Shawe-Taylor J. Generalization performance of support vector machines and other pattern classifiers //Advances in Kernel Methods.MIT Press, Cambridge, USA, 1999.Pp. 43-54. http://citeseer.ist.psu.edu/bartlett98generalization.html. [33] Bishop C. M. Pattern Recognition and Machine Learning.Springer, Series: Information Science and Statistics, 2006.740 pp. [34] Boucheron S., Bousquet O., Lugosi G. Theory of classification: A survey of some recent advances //ESAIM: Probability and Statistics.2005.no. 9.Pp. 323- 375. http://www.econ.upf.edu/?lugosi/esaimsurvey.pdf. [35] Burges C. J. C. A tutorial on support vector machines for pattern recognition //Data Mining and Knowledge Discovery.1998.Vol. 2, no. 2.Pp. 121-167. http://citeseer.ist.psu.edu/burges98tutorial.html. [36] Burges C. J. C. Geometry and invariance in kernel based methods //Advances in Kernel Methods /Ed. by B. Scholkopf, C. C. Burges, A. J. Smola.MIT Press, 1999.Pp. 89 - 116. [37] Cleveland W. S. Robust locally weighted regression and smoothing scatter plots //Journal of the American Statistical Association.1979.Vol. 74, no. 368.Pp. 829-836. [38] Cortes C., Vapnik V. Support-vector networks //Machine Learning.1995.Vol. 20, no. 3.Pp. 273-297. http://citeseer.ist.psu.edu/cortes95supportvector.html. [39] Dempster A. P., Laird N. M., Rubin D. B. Maximum likelihood from incomplete data via the EM algorithm //J. of the Royal Statistical Society, Series B.1977.no. 34.Pp. 1-38.
139 [40] Durbin R., Rummelhart D. E. Product units: A computationally powerful and biologically plausible extension to backpropagation networks //Neural Computation.1989.Vol. 1, no. 4.Pp. 133-142. [41] Fisher R. A. The use of multiple measurements in taxonomic problem //Ann. Eugen.1936.no. 7.Pp. 179-188. [42] Hassibi B., Stork D. G. Second order derivatives for network pruning: Optimal brain surgeon //Advances in Neural Information Processing Systems /Ed. by S. J. Hanson, J. D. Cowan, C. L. Giles.Vol. 5.Morgan Kaufmann, San Mateo, CA, 1993.Pp. 164-171. http://citeseer.ist.psu.edu/hassibi93second.html. [43] Hastie T., Tibshirani R. Generalized additive models //Statistical Science.1986.Vol. 1.Pp. 297-318. http://citeseer.ist.psu.edu/hastie95generalized.html. [44] Hastie T., Tibshirani R., Friedman J. The Elements of Statistical Learning.Springer, 2001.533 pp. http://http://www-stat.stanford.edu/?tibs/ElemStatLearn. [45] Hebb D. The organization of behavior.New York: Wiley, 1949. [46] Jain A., Murty M., Flynn P. Data clustering: A review //ACM Computing Surveys.1999.Vol. 31, no. 3.Pp. 264-323. http://citeseer.ifi.unizh.ch/jain99data.html. [47] Jordan M. I., Xu L. Convergence results for the EM algorithm to mixtures of experts architectures: Tech. Rep. A.I. Memo No. 1458: MIT, Cambridge, MA, 1993. [48] Kohavi R. A study of cross-validation and bootstrap for accuracy estimation and model selection //14th International Joint Conference on Artificial Intelligence, Palais de Congres Montreal, Quebec, Canada.1995.Pp. 1137-1145. http://citeseer.ist.psu.edu/kohavi95study.html. [49] Lance G. N., Willams W. T. A general theory of classification sorting strategies. 1. hierarchical systems //Comp. J.1967.no. 9.Pp. 373-380. [50] LeCun Y., Bottou L., Orr G. B., Muller K.-R. Efficient BackProp //Neural Networks: tricks of the trade.Springer, 1998. [51] LeCun Y., Denker J., Solla S., Howard R. E., Jackel L. D. Optimal brain damage //Advances in Neural Information Processing Systems II /Ed. by D. S. Touretzky.San Mateo, CA: Morgan Kauffman, 1990. http://citeseer.ist.psu.edu/lecun90optimal.html. [52] McCulloch W. S., Pitts W. A logical calculus of ideas immanent in nervous activity //Bulletin of Mathematical Biophysics.1943.no. 5.Pp. 115-133. [53] Mercer J. Functions of positive and negative type and their connection with the theory of integral equations //Philos. Trans. Roy. Soc. London.1909.Vol. A, no. 209.Pp. 415-446.
140 К.В.Воронцов. Вычислительные методы обучения по прецедентам [54] Minsky M., Papert S. Perceptrons: an Introduction to Computational Geometry.MIT Press, 1968. [55] Novikoff A. B. J. On convergence proofs on perceptrons //Proceedings of the Symposium on the Mathematical Theory of Automata.Vol. 12.Polytechnic Institute of Brooklyn, 1962.Pp. 615-622. [56] Parzen E. On the estimation of a probability density function and mode //Annals of Mathematical Statistics.1962.Vol. 33.Pp. 1065-1076. http://citeseer.ist.psu.edu/parzen62estimation.html. [57] Rosenblatt M. Remarks on some nonparametric estimates of a density function //Annals of Mathematical Statistics.1956.Vol. 27, no. 3.Pp. 832-837. [58] Rummelhart D. E., Hinton G. E., Williams R. J. Learning internal representations by error propagation //Vol. 1 of Computational models of cognition and perception, chap. 8.Cambridge, MA: MIT Press, 1986.Pp. 319-362. [59] Shawe-Taylor J., Cristianini N. Robust bounds on generalization from the margin distribution: Tech. Rep. NC2-TR-1998-029: Royal Holloway, University of London, 1998. http://citeseer.ist.psu.edu/shawe-taylor98robust.html. [60] Smola A., Bartlett P., Scholkopf B., Schuurmans D. Advances in large margin classifiers.MIT Press, Cambridge, MA.2000. http://citeseer.ist.psu.edu/article/smola00advances.html. [61] Smola A., Schoelkopf B. A tutorial on support vector regression: Tech. Rep. NeuroCOLT2 NC2-TR-1998-030: Royal Holloway College, London, UK, 1998. http://citeseer.ist.psu.edu/smola98tutorial.html. [62] Stone M. N. The generalized Weierstrass approximation theorem //Math. Mag.1948.Vol. 21.Pp. 167-183, 237-254. [63] Tibshirani R. J. Regression shrinkage and selection via the lasso //Journal of the Royal Statistical Society. Series B (Methodological).1996.Vol. 58, no. 1.Pp. 267-288. http://citeseer.ist.psu.edu/tibshirani94regression.html. [64] Tipping M. The relevance vector machine //Advances in Neural Information Processing Systems, San Mateo, CA.Morgan Kaufmann, 2000. http://citeseer.ist.psu.edu/tipping00relevance.html. [65] Vapnik V., Chapelle O. Bounds on error expectation for support vector machines //Neural Computation.2000.Vol. 12, no. 9.Pp. 2013-2036. http://citeseer.ist.psu.edu/vapnik99bounds.html. [66] Widrow B., Hoff M. E. Adaptive switching circuits //IRE WESCON Convention Record.DUNNO, 1960.Pp. 96-104.
141 [67] Wu C. F. G. On the convergence properties of the EM algorithm //The Annals of Statistics.1983.no. 11.Pp. 95-103. http://citeseer.ist.psu.edu/78906.html.